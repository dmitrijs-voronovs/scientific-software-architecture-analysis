id,quality_attribute,keyword,matched_word,match_idx,sentence,source,author,repo,version,wiki,url
https://github.com/root-project/root/pull/11252:2346,safety,Test,Test,2346,leFunc-auto ........ Passed 0.40 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 34.53 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 3.28 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.26 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 4.26 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.89 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.54 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 12.81 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 7.55 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.58 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 1.02 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 19.49 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 8.65 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeform,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:2484,safety,Test,Test,2484,est-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 34.53 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 3.28 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.26 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 4.26 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.89 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.54 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 12.81 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 7.55 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.58 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 1.02 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 19.49 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 8.65 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 7.18 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:2623,safety,Test,Test,2623,-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 3.28 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.26 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 4.26 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.89 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.54 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 12.81 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 7.55 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.58 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 1.02 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 19.49 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 8.65 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 7.18 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.24 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-tree,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:2760,safety,Test,Test,2760,-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.26 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 4.26 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.89 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.54 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 12.81 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 7.55 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.58 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 1.02 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 19.49 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 8.65 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 7.18 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.24 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 8.48 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treefor,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:2899,safety,Test,Test,2899,ot-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.26 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 4.26 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.89 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.54 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 12.81 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 7.55 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.58 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 1.02 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 19.49 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 8.65 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 7.18 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.24 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 8.48 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 9.25 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformu,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3035,safety,Test,Test,3035,t-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 4.26 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.89 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.54 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 12.81 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 7.55 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.58 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 1.02 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 19.49 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 8.65 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 7.18 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.24 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 8.48 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 9.25 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.42 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformul,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3177,safety,Test,Test,3177,ormula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.89 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.54 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 12.81 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 7.55 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.58 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 1.02 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 19.49 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 8.65 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 7.18 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.24 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 8.48 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 9.25 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.42 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 52.53 sec. ```. </details>. <summary>This PR</summary>. <details>. ```. ctest -R .*callfunc.* . Test proje,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3314,safety,Test,Test,3314,eformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.54 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 12.81 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 7.55 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.58 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 1.02 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 19.49 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 8.65 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 7.18 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.24 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 8.48 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 9.25 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.42 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 52.53 sec. ```. </details>. <summary>This PR</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-release-master. Start 1825: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1825: roottest-root-meta-ca,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3449,safety,Test,Test,3449,-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 12.81 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 7.55 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.58 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 1.02 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 19.49 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 8.65 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 7.18 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.24 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 8.48 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 9.25 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.42 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 52.53 sec. ```. </details>. <summary>This PR</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-release-master. Start 1825: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1825: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.30 sec. Start 1826: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1826: ro,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3595,safety,Test,Test,3595,rmula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 7.55 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.58 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 1.02 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 19.49 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 8.65 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 7.18 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.24 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 8.48 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 9.25 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.42 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 52.53 sec. ```. </details>. <summary>This PR</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-release-master. Start 1825: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1825: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.30 sec. Start 1826: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1826: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.18 sec. Start 1827: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1827:,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3729,safety,Test,Test,3729,eeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.58 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 1.02 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 19.49 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 8.65 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 7.18 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.24 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 8.48 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 9.25 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.42 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 52.53 sec. ```. </details>. <summary>This PR</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-release-master. Start 1825: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1825: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.30 sec. Start 1826: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1826: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.18 sec. Start 1827: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1827: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.41 sec. Start 1828: roottest-root-meta-callfunc-runmemberFunc-auto. ,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3866,safety,Test,Test,3866,eeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 1.02 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 19.49 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 8.65 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 7.18 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.24 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 8.48 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 9.25 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.42 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 52.53 sec. ```. </details>. <summary>This PR</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-release-master. Start 1825: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1825: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.30 sec. Start 1826: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1826: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.18 sec. Start 1827: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1827: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.41 sec. Start 1828: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1828: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.38 sec. Start 1829: roottest-root-meta-callfunc-runsimpl,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4001,safety,Test,Test,4001,t-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 19.49 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 8.65 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 7.18 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.24 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 8.48 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 9.25 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.42 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 52.53 sec. ```. </details>. <summary>This PR</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-release-master. Start 1825: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1825: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.30 sec. Start 1826: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1826: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.18 sec. Start 1827: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1827: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.41 sec. Start 1828: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1828: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.38 sec. Start 1829: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1829: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.43 sec. ctest -R .*treefor.* . Test projec,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4169,safety,Test,Test,4169,13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 8.65 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 7.18 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.24 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 8.48 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 9.25 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.42 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 52.53 sec. ```. </details>. <summary>This PR</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-release-master. Start 1825: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1825: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.30 sec. Start 1826: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1826: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.18 sec. Start 1827: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1827: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.41 sec. Start 1828: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1828: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.38 sec. Start 1829: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1829: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.43 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 29.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4283,safety,Test,Test,4283,eeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 7.18 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.24 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 8.48 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 9.25 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.42 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 52.53 sec. ```. </details>. <summary>This PR</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-release-master. Start 1825: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1825: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.30 sec. Start 1826: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1826: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.18 sec. Start 1827: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1827: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.41 sec. Start 1828: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1828: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.38 sec. Start 1829: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1829: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.43 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 29.43 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-mak,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4437,safety,Test,Test,4437,ke. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.24 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 8.48 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 9.25 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.42 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 52.53 sec. ```. </details>. <summary>This PR</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-release-master. Start 1825: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1825: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.30 sec. Start 1826: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1826: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.18 sec. Start 1827: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1827: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.41 sec. Start 1828: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1828: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.38 sec. Start 1829: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1829: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.43 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 29.43 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 3.40 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Pass,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4586,safety,Test,Test,4586, 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 8.48 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 9.25 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.42 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 52.53 sec. ```. </details>. <summary>This PR</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-release-master. Start 1825: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1825: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.30 sec. Start 1826: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1826: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.18 sec. Start 1827: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1827: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.41 sec. Start 1828: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1828: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.38 sec. Start 1829: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1829: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.43 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 29.43 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 3.40 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.95 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.28 sec. S,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4735,safety,Test,Test,4735,33: roottest-root-treeformula-stl-make ............... Passed 9.25 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.42 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 52.53 sec. ```. </details>. <summary>This PR</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-release-master. Start 1825: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1825: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.30 sec. Start 1826: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1826: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.18 sec. Start 1827: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1827: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.41 sec. Start 1828: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1828: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.38 sec. Start 1829: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1829: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.43 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 29.43 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 3.40 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.95 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.28 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 4.29 sec. Start 2221: roo,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4884,safety,Test,Test,4884,-root-treeformula-string-make ............ Passed 8.42 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 52.53 sec. ```. </details>. <summary>This PR</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-release-master. Start 1825: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1825: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.30 sec. Start 1826: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1826: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.18 sec. Start 1827: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1827: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.41 sec. Start 1828: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1828: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.38 sec. Start 1829: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1829: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.43 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 29.43 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 3.40 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.95 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.28 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 4.29 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 6.01 sec. Start 2222: roottest-root,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4992,safety,Test,Test,4992, 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 52.53 sec. ```. </details>. <summary>This PR</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-release-master. Start 1825: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1825: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.30 sec. Start 1826: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1826: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.18 sec. Start 1827: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1827: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.41 sec. Start 1828: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1828: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.38 sec. Start 1829: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1829: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.43 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 29.43 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 3.40 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.95 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.28 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 4.29 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 6.01 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.56,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5098,safety,Test,Test,5098, <summary>This PR</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-release-master. Start 1825: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1825: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.30 sec. Start 1826: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1826: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.18 sec. Start 1827: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1827: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.41 sec. Start 1828: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1828: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.38 sec. Start 1829: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1829: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.43 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 29.43 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 3.40 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.95 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.28 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 4.29 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 6.01 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.56 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-func,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5236,safety,Test,Test,5236,st-root-meta-callfunc-assertUnload-auto. 1/5 Test #1825: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.30 sec. Start 1826: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1826: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.18 sec. Start 1827: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1827: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.41 sec. Start 1828: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1828: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.38 sec. Start 1829: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1829: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.43 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 29.43 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 3.40 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.95 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.28 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 4.29 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 6.01 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.56 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 13.24 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-mor,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5372,safety,Test,Test,5372,1826: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1826: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.18 sec. Start 1827: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1827: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.41 sec. Start 1828: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1828: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.38 sec. Start 1829: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1829: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.43 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 29.43 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 3.40 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.95 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.28 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 4.29 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 6.01 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.56 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 13.24 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 7.61 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-nt,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5507,safety,Test,Test,5507,ed 0.18 sec. Start 1827: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1827: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.41 sec. Start 1828: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1828: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.38 sec. Start 1829: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1829: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.43 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 29.43 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 3.40 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.95 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.28 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 4.29 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 6.01 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.56 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 13.24 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 7.61 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.61 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformul,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5642,safety,Test,Test,5642, ........ Passed 0.41 sec. Start 1828: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1828: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.38 sec. Start 1829: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1829: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.43 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 29.43 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 3.40 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.95 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.28 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 4.29 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 6.01 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.56 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 13.24 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 7.61 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.61 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformu,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5781,safety,Test,Test,5781,rFunc-auto ........ Passed 0.38 sec. Start 1829: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1829: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.43 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 29.43 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 3.40 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.95 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.28 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 4.29 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 6.01 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.56 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 13.24 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 7.61 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.61 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 20.18 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treefo,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5920,safety,Test,Test,5920,c-runsimpleFunc-auto ........ Passed 0.43 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 29.43 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 3.40 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.95 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.28 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 4.29 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 6.01 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.56 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 13.24 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 7.61 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.61 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 20.18 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 8.88 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeform,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6058,safety,Test,Test,6058,est-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 29.43 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 3.40 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.95 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.28 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 4.29 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 6.01 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.56 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 13.24 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 7.61 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.61 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 20.18 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 8.88 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 7.35 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6197,safety,Test,Test,6197,-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 3.40 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.95 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.28 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 4.29 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 6.01 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.56 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 13.24 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 7.61 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.61 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 20.18 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 8.88 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 7.35 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.31 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-tree,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6334,safety,Test,Test,6334,-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.95 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.28 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 4.29 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 6.01 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.56 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 13.24 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 7.61 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.61 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 20.18 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 8.88 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 7.35 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.31 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 8.64 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treefor,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6473,safety,Test,Test,6473,ot-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.28 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 4.29 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 6.01 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.56 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 13.24 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 7.61 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.61 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 20.18 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 8.88 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 7.35 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.31 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 8.64 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 9.53 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformu,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6609,safety,Test,Test,6609,t-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 4.29 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 6.01 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.56 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 13.24 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 7.61 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.61 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 20.18 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 8.88 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 7.35 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.31 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 8.64 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 9.53 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.62 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformul,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6751,safety,Test,Test,6751,"ormula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 6.01 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.56 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 13.24 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 7.61 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.61 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 20.18 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 8.88 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 7.35 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.31 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 8.64 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 9.53 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.62 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 51.12 sec. ```. </details>. The enum-based optimization which I introduced in commit [""Improve performance",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6888,safety,Test,Test,6888,"eformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.56 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 13.24 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 7.61 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.61 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 20.18 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 8.88 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 7.35 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.31 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 8.64 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 9.53 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.62 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 51.12 sec. ```. </details>. The enum-based optimization which I introduced in commit [""Improve performance by allowing most of cling::Value to inline""](https://github.com/root-project/root/pull/11252/commits/fa74b5419c3120ab4b5130e53a1844c54dc",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:7023,safety,Test,Test,7023,"-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 13.24 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 7.61 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.61 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 20.18 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 8.88 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 7.35 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.31 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 8.64 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 9.53 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.62 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 51.12 sec. ```. </details>. The enum-based optimization which I introduced in commit [""Improve performance by allowing most of cling::Value to inline""](https://github.com/root-project/root/pull/11252/commits/fa74b5419c3120ab4b5130e53a1844c54dc467c4). Unfortunately it did not show any improvement for callfunc. It helps with inlining the `castAs` operation but that does not bri",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:7169,safety,Test,Test,7169,"rmula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 7.61 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.61 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 20.18 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 8.88 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 7.35 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.31 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 8.64 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 9.53 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.62 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 51.12 sec. ```. </details>. The enum-based optimization which I introduced in commit [""Improve performance by allowing most of cling::Value to inline""](https://github.com/root-project/root/pull/11252/commits/fa74b5419c3120ab4b5130e53a1844c54dc467c4). Unfortunately it did not show any improvement for callfunc. It helps with inlining the `castAs` operation but that does not bring benefits. That's why I decided to revert it but keep it in the history if we want to apply it. I can further spend time in trying to optimize t",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:7303,safety,Test,Test,7303,"eeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.61 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 20.18 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 8.88 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 7.35 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.31 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 8.64 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 9.53 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.62 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 51.12 sec. ```. </details>. The enum-based optimization which I introduced in commit [""Improve performance by allowing most of cling::Value to inline""](https://github.com/root-project/root/pull/11252/commits/fa74b5419c3120ab4b5130e53a1844c54dc467c4). Unfortunately it did not show any improvement for callfunc. It helps with inlining the `castAs` operation but that does not bring benefits. That's why I decided to revert it but keep it in the history if we want to apply it. I can further spend time in trying to optimize this but that might be at the cost of making it harder to understand and maintain. If that performance info is acceptable, I will play ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:7440,safety,Test,Test,7440,"eeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 20.18 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 8.88 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 7.35 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.31 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 8.64 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 9.53 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.62 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 51.12 sec. ```. </details>. The enum-based optimization which I introduced in commit [""Improve performance by allowing most of cling::Value to inline""](https://github.com/root-project/root/pull/11252/commits/fa74b5419c3120ab4b5130e53a1844c54dc467c4). Unfortunately it did not show any improvement for callfunc. It helps with inlining the `castAs` operation but that does not bring benefits. That's why I decided to revert it but keep it in the history if we want to apply it. I can further spend time in trying to optimize this but that might be at the cost of making it harder to understand and maintain. If that performance info is acceptable, I will play a bit with a couple of ideas I have and move forward as that's blocking lowering parts of CallFunc to cling standalone. fyi @Axel-Naumann",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:7575,safety,Test,Test,7575,"eeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 20.18 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 8.88 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 7.35 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.31 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 8.64 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 9.53 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.62 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 51.12 sec. ```. </details>. The enum-based optimization which I introduced in commit [""Improve performance by allowing most of cling::Value to inline""](https://github.com/root-project/root/pull/11252/commits/fa74b5419c3120ab4b5130e53a1844c54dc467c4). Unfortunately it did not show any improvement for callfunc. It helps with inlining the `castAs` operation but that does not bring benefits. That's why I decided to revert it but keep it in the history if we want to apply it. I can further spend time in trying to optimize this but that might be at the cost of making it harder to understand and maintain. If that performance info is acceptable, I will play a bit with a couple of ideas I have and move forward as that's blocking lowering parts of CallFunc to cling standalone. fyi @Axel-Naumann",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:8243,safety,maintain,maintain,8243,"eeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 20.18 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 8.88 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 7.35 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.31 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 8.64 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 9.53 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.62 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 51.12 sec. ```. </details>. The enum-based optimization which I introduced in commit [""Improve performance by allowing most of cling::Value to inline""](https://github.com/root-project/root/pull/11252/commits/fa74b5419c3120ab4b5130e53a1844c54dc467c4). Unfortunately it did not show any improvement for callfunc. It helps with inlining the `castAs` operation but that does not bring benefits. That's why I decided to revert it but keep it in the history if we want to apply it. I can further spend time in trying to optimize this but that might be at the cost of making it harder to understand and maintain. If that performance info is acceptable, I will play a bit with a couple of ideas I have and move forward as that's blocking lowering parts of CallFunc to cling standalone. fyi @Axel-Naumann",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:123,security,sign,significant,123,"@pcanal, my performance quest did not bring a lot of fruit unfortunately. The good news is that this PR does not introduce significant performance regression. There is 2-5% slowdown on some tests but I think the improvement of type consistency is worth it. The tests were primarily focused at the TClingCallFunc performance I have not excessively tested the performance of other `cling::Value`-related code as we do not really have an idiom which is widely used. Here are some performance benchmarks details:. <summary>master</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-callfunc-master/release. Start 1829: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1829: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.25 sec. Start 1830: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1830: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.16 sec. Start 1831: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1831: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.43 sec. Start 1832: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1832: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.34 sec. Start 1833: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1833: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.40 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 34.53 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 3.28 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Pass",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:147,testability,regress,regression,147,"@pcanal, my performance quest did not bring a lot of fruit unfortunately. The good news is that this PR does not introduce significant performance regression. There is 2-5% slowdown on some tests but I think the improvement of type consistency is worth it. The tests were primarily focused at the TClingCallFunc performance I have not excessively tested the performance of other `cling::Value`-related code as we do not really have an idiom which is widely used. Here are some performance benchmarks details:. <summary>master</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-callfunc-master/release. Start 1829: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1829: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.25 sec. Start 1830: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1830: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.16 sec. Start 1831: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1831: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.43 sec. Start 1832: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1832: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.34 sec. Start 1833: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1833: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.40 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 34.53 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 3.28 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Pass",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:190,testability,test,tests,190,"@pcanal, my performance quest did not bring a lot of fruit unfortunately. The good news is that this PR does not introduce significant performance regression. There is 2-5% slowdown on some tests but I think the improvement of type consistency is worth it. The tests were primarily focused at the TClingCallFunc performance I have not excessively tested the performance of other `cling::Value`-related code as we do not really have an idiom which is widely used. Here are some performance benchmarks details:. <summary>master</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-callfunc-master/release. Start 1829: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1829: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.25 sec. Start 1830: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1830: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.16 sec. Start 1831: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1831: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.43 sec. Start 1832: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1832: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.34 sec. Start 1833: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1833: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.40 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 34.53 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 3.28 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Pass",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:261,testability,test,tests,261,"@pcanal, my performance quest did not bring a lot of fruit unfortunately. The good news is that this PR does not introduce significant performance regression. There is 2-5% slowdown on some tests but I think the improvement of type consistency is worth it. The tests were primarily focused at the TClingCallFunc performance I have not excessively tested the performance of other `cling::Value`-related code as we do not really have an idiom which is widely used. Here are some performance benchmarks details:. <summary>master</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-callfunc-master/release. Start 1829: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1829: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.25 sec. Start 1830: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1830: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.16 sec. Start 1831: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1831: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.43 sec. Start 1832: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1832: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.34 sec. Start 1833: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1833: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.40 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 34.53 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 3.28 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Pass",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:347,testability,test,tested,347,"@pcanal, my performance quest did not bring a lot of fruit unfortunately. The good news is that this PR does not introduce significant performance regression. There is 2-5% slowdown on some tests but I think the improvement of type consistency is worth it. The tests were primarily focused at the TClingCallFunc performance I have not excessively tested the performance of other `cling::Value`-related code as we do not really have an idiom which is widely used. Here are some performance benchmarks details:. <summary>master</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-callfunc-master/release. Start 1829: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1829: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.25 sec. Start 1830: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1830: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.16 sec. Start 1831: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1831: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.43 sec. Start 1832: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1832: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.34 sec. Start 1833: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1833: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.40 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 34.53 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 3.28 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Pass",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:577,testability,Test,Test,577,"@pcanal, my performance quest did not bring a lot of fruit unfortunately. The good news is that this PR does not introduce significant performance regression. There is 2-5% slowdown on some tests but I think the improvement of type consistency is worth it. The tests were primarily focused at the TClingCallFunc performance I have not excessively tested the performance of other `cling::Value`-related code as we do not really have an idiom which is widely used. Here are some performance benchmarks details:. <summary>master</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-callfunc-master/release. Start 1829: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1829: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.25 sec. Start 1830: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1830: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.16 sec. Start 1831: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1831: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.43 sec. Start 1832: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1832: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.34 sec. Start 1833: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1833: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.40 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 34.53 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 3.28 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Pass",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:677,testability,assert,assertUnload-auto,677,"@pcanal, my performance quest did not bring a lot of fruit unfortunately. The good news is that this PR does not introduce significant performance regression. There is 2-5% slowdown on some tests but I think the improvement of type consistency is worth it. The tests were primarily focused at the TClingCallFunc performance I have not excessively tested the performance of other `cling::Value`-related code as we do not really have an idiom which is widely used. Here are some performance benchmarks details:. <summary>master</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-callfunc-master/release. Start 1829: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1829: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.25 sec. Start 1830: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1830: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.16 sec. Start 1831: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1831: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.43 sec. Start 1832: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1832: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.34 sec. Start 1833: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1833: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.40 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 34.53 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 3.28 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Pass",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:700,testability,Test,Test,700,"@pcanal, my performance quest did not bring a lot of fruit unfortunately. The good news is that this PR does not introduce significant performance regression. There is 2-5% slowdown on some tests but I think the improvement of type consistency is worth it. The tests were primarily focused at the TClingCallFunc performance I have not excessively tested the performance of other `cling::Value`-related code as we do not really have an idiom which is widely used. Here are some performance benchmarks details:. <summary>master</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-callfunc-master/release. Start 1829: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1829: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.25 sec. Start 1830: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1830: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.16 sec. Start 1831: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1831: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.43 sec. Start 1832: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1832: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.34 sec. Start 1833: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1833: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.40 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 34.53 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 3.28 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Pass",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:740,testability,assert,assertUnload-auto,740,"@pcanal, my performance quest did not bring a lot of fruit unfortunately. The good news is that this PR does not introduce significant performance regression. There is 2-5% slowdown on some tests but I think the improvement of type consistency is worth it. The tests were primarily focused at the TClingCallFunc performance I have not excessively tested the performance of other `cling::Value`-related code as we do not really have an idiom which is widely used. Here are some performance benchmarks details:. <summary>master</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-callfunc-master/release. Start 1829: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1829: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.25 sec. Start 1830: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1830: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.16 sec. Start 1831: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1831: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.43 sec. Start 1832: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1832: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.34 sec. Start 1833: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1833: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.40 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 34.53 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 3.28 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Pass",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:825,testability,assert,assertUnloadHelper-auto,825,"@pcanal, my performance quest did not bring a lot of fruit unfortunately. The good news is that this PR does not introduce significant performance regression. There is 2-5% slowdown on some tests but I think the improvement of type consistency is worth it. The tests were primarily focused at the TClingCallFunc performance I have not excessively tested the performance of other `cling::Value`-related code as we do not really have an idiom which is widely used. Here are some performance benchmarks details:. <summary>master</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-callfunc-master/release. Start 1829: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1829: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.25 sec. Start 1830: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1830: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.16 sec. Start 1831: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1831: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.43 sec. Start 1832: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1832: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.34 sec. Start 1833: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1833: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.40 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 34.53 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 3.28 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Pass",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:854,testability,Test,Test,854,"@pcanal, my performance quest did not bring a lot of fruit unfortunately. The good news is that this PR does not introduce significant performance regression. There is 2-5% slowdown on some tests but I think the improvement of type consistency is worth it. The tests were primarily focused at the TClingCallFunc performance I have not excessively tested the performance of other `cling::Value`-related code as we do not really have an idiom which is widely used. Here are some performance benchmarks details:. <summary>master</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-callfunc-master/release. Start 1829: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1829: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.25 sec. Start 1830: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1830: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.16 sec. Start 1831: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1831: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.43 sec. Start 1832: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1832: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.34 sec. Start 1833: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1833: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.40 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 34.53 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 3.28 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Pass",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:894,testability,assert,assertUnloadHelper-auto,894,"@pcanal, my performance quest did not bring a lot of fruit unfortunately. The good news is that this PR does not introduce significant performance regression. There is 2-5% slowdown on some tests but I think the improvement of type consistency is worth it. The tests were primarily focused at the TClingCallFunc performance I have not excessively tested the performance of other `cling::Value`-related code as we do not really have an idiom which is widely used. Here are some performance benchmarks details:. <summary>master</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-callfunc-master/release. Start 1829: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1829: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.25 sec. Start 1830: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1830: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.16 sec. Start 1831: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1831: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.43 sec. Start 1832: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1832: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.34 sec. Start 1833: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1833: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.40 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 34.53 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 3.28 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Pass",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:1003,testability,Test,Test,1003,"al, my performance quest did not bring a lot of fruit unfortunately. The good news is that this PR does not introduce significant performance regression. There is 2-5% slowdown on some tests but I think the improvement of type consistency is worth it. The tests were primarily focused at the TClingCallFunc performance I have not excessively tested the performance of other `cling::Value`-related code as we do not really have an idiom which is widely used. Here are some performance benchmarks details:. <summary>master</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-callfunc-master/release. Start 1829: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1829: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.25 sec. Start 1830: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1830: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.16 sec. Start 1831: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1831: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.43 sec. Start 1832: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1832: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.34 sec. Start 1833: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1833: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.40 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 34.53 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 3.28 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:1152,testability,Test,Test,1152,ion. There is 2-5% slowdown on some tests but I think the improvement of type consistency is worth it. The tests were primarily focused at the TClingCallFunc performance I have not excessively tested the performance of other `cling::Value`-related code as we do not really have an idiom which is widely used. Here are some performance benchmarks details:. <summary>master</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-callfunc-master/release. Start 1829: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1829: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.25 sec. Start 1830: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1830: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.16 sec. Start 1831: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1831: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.43 sec. Start 1832: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1832: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.34 sec. Start 1833: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1833: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.40 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 34.53 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 3.28 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.26 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 4.26 sec. Start ,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:1301,testability,Test,Test,1301,CallFunc performance I have not excessively tested the performance of other `cling::Value`-related code as we do not really have an idiom which is widely used. Here are some performance benchmarks details:. <summary>master</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-callfunc-master/release. Start 1829: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1829: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.25 sec. Start 1830: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1830: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.16 sec. Start 1831: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1831: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.43 sec. Start 1832: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1832: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.34 sec. Start 1833: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1833: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.40 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 34.53 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 3.28 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.26 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 4.26 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.89 sec. Start 2223: root,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:1409,testability,Test,Test,1409,e do not really have an idiom which is widely used. Here are some performance benchmarks details:. <summary>master</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-callfunc-master/release. Start 1829: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1829: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.25 sec. Start 1830: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1830: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.16 sec. Start 1831: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1831: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.43 sec. Start 1832: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1832: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.34 sec. Start 1833: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1833: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.40 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 34.53 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 3.28 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.26 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 4.26 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.89 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Pa,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:1524,testability,Test,Test,1524,/summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-callfunc-master/release. Start 1829: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1829: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.25 sec. Start 1830: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1830: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.16 sec. Start 1831: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1831: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.43 sec. Start 1832: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1832: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.34 sec. Start 1833: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1833: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.40 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 34.53 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 3.28 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.26 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 4.26 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.89 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.54 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-func,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:1662,testability,Test,Test,1662,eta-callfunc-assertUnload-auto. 1/5 Test #1829: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.25 sec. Start 1830: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1830: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.16 sec. Start 1831: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1831: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.43 sec. Start 1832: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1832: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.34 sec. Start 1833: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1833: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.40 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 34.53 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 3.28 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.26 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 4.26 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.89 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.54 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 12.81 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-mor,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:1798,testability,Test,Test,1798,ttest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1830: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.16 sec. Start 1831: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1831: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.43 sec. Start 1832: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1832: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.34 sec. Start 1833: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1833: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.40 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 34.53 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 3.28 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.26 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 4.26 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.89 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.54 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 12.81 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 7.55 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-nt,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:1933,testability,Test,Test,1933,ec. Start 1831: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1831: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.43 sec. Start 1832: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1832: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.34 sec. Start 1833: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1833: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.40 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 34.53 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 3.28 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.26 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 4.26 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.89 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.54 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 12.81 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 7.55 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.58 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformul,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:2068,testability,Test,Test,2068, Passed 0.43 sec. Start 1832: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1832: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.34 sec. Start 1833: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1833: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.40 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 34.53 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 3.28 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.26 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 4.26 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.89 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.54 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 12.81 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 7.55 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.58 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 1.02 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformu,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:2207,testability,Test,Test,2207,o ........ Passed 0.34 sec. Start 1833: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1833: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.40 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 34.53 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 3.28 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.26 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 4.26 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.89 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.54 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 12.81 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 7.55 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.58 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 1.02 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 19.49 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treefo,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:2346,testability,Test,Test,2346,leFunc-auto ........ Passed 0.40 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 34.53 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 3.28 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.26 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 4.26 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.89 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.54 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 12.81 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 7.55 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.58 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 1.02 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 19.49 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 8.65 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeform,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:2484,testability,Test,Test,2484,est-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 34.53 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 3.28 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.26 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 4.26 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.89 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.54 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 12.81 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 7.55 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.58 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 1.02 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 19.49 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 8.65 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 7.18 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:2623,testability,Test,Test,2623,-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 3.28 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.26 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 4.26 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.89 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.54 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 12.81 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 7.55 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.58 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 1.02 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 19.49 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 8.65 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 7.18 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.24 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-tree,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:2760,testability,Test,Test,2760,-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.26 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 4.26 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.89 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.54 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 12.81 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 7.55 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.58 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 1.02 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 19.49 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 8.65 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 7.18 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.24 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 8.48 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treefor,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:2899,testability,Test,Test,2899,ot-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.26 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 4.26 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.89 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.54 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 12.81 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 7.55 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.58 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 1.02 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 19.49 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 8.65 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 7.18 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.24 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 8.48 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 9.25 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformu,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3035,testability,Test,Test,3035,t-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 4.26 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.89 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.54 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 12.81 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 7.55 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.58 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 1.02 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 19.49 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 8.65 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 7.18 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.24 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 8.48 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 9.25 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.42 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformul,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3177,testability,Test,Test,3177,ormula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.89 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.54 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 12.81 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 7.55 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.58 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 1.02 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 19.49 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 8.65 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 7.18 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.24 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 8.48 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 9.25 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.42 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 52.53 sec. ```. </details>. <summary>This PR</summary>. <details>. ```. ctest -R .*callfunc.* . Test proje,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3314,testability,Test,Test,3314,eformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.54 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 12.81 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 7.55 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.58 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 1.02 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 19.49 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 8.65 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 7.18 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.24 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 8.48 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 9.25 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.42 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 52.53 sec. ```. </details>. <summary>This PR</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-release-master. Start 1825: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1825: roottest-root-meta-ca,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3449,testability,Test,Test,3449,-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 12.81 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 7.55 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.58 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 1.02 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 19.49 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 8.65 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 7.18 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.24 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 8.48 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 9.25 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.42 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 52.53 sec. ```. </details>. <summary>This PR</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-release-master. Start 1825: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1825: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.30 sec. Start 1826: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1826: ro,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3595,testability,Test,Test,3595,rmula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 7.55 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.58 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 1.02 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 19.49 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 8.65 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 7.18 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.24 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 8.48 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 9.25 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.42 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 52.53 sec. ```. </details>. <summary>This PR</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-release-master. Start 1825: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1825: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.30 sec. Start 1826: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1826: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.18 sec. Start 1827: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1827:,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3729,testability,Test,Test,3729,eeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.58 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 1.02 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 19.49 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 8.65 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 7.18 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.24 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 8.48 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 9.25 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.42 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 52.53 sec. ```. </details>. <summary>This PR</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-release-master. Start 1825: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1825: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.30 sec. Start 1826: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1826: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.18 sec. Start 1827: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1827: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.41 sec. Start 1828: roottest-root-meta-callfunc-runmemberFunc-auto. ,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3866,testability,Test,Test,3866,eeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 1.02 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 19.49 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 8.65 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 7.18 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.24 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 8.48 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 9.25 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.42 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 52.53 sec. ```. </details>. <summary>This PR</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-release-master. Start 1825: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1825: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.30 sec. Start 1826: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1826: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.18 sec. Start 1827: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1827: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.41 sec. Start 1828: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1828: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.38 sec. Start 1829: roottest-root-meta-callfunc-runsimpl,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4001,testability,Test,Test,4001,t-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 19.49 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 8.65 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 7.18 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.24 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 8.48 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 9.25 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.42 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 52.53 sec. ```. </details>. <summary>This PR</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-release-master. Start 1825: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1825: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.30 sec. Start 1826: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1826: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.18 sec. Start 1827: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1827: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.41 sec. Start 1828: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1828: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.38 sec. Start 1829: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1829: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.43 sec. ctest -R .*treefor.* . Test projec,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4169,testability,Test,Test,4169,13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 8.65 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 7.18 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.24 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 8.48 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 9.25 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.42 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 52.53 sec. ```. </details>. <summary>This PR</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-release-master. Start 1825: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1825: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.30 sec. Start 1826: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1826: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.18 sec. Start 1827: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1827: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.41 sec. Start 1828: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1828: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.38 sec. Start 1829: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1829: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.43 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 29.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4260,testability,assert,assertUnload-auto,4260,roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 7.18 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.24 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 8.48 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 9.25 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.42 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 52.53 sec. ```. </details>. <summary>This PR</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-release-master. Start 1825: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1825: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.30 sec. Start 1826: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1826: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.18 sec. Start 1827: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1827: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.41 sec. Start 1828: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1828: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.38 sec. Start 1829: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1829: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.43 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 29.43 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treefor,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4283,testability,Test,Test,4283,eeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 7.18 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.24 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 8.48 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 9.25 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.42 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 52.53 sec. ```. </details>. <summary>This PR</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-release-master. Start 1825: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1825: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.30 sec. Start 1826: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1826: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.18 sec. Start 1827: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1827: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.41 sec. Start 1828: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1828: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.38 sec. Start 1829: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1829: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.43 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 29.43 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-mak,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4323,testability,assert,assertUnload-auto,4323,st-root-treeformula-retobj-make ............ Passed 7.18 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.24 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 8.48 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 9.25 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.42 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 52.53 sec. ```. </details>. <summary>This PR</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-release-master. Start 1825: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1825: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.30 sec. Start 1826: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1826: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.18 sec. Start 1827: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1827: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.41 sec. Start 1828: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1828: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.38 sec. Start 1829: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1829: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.43 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 29.43 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 3.40 sec. Start 2218: root,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4408,testability,assert,assertUnloadHelper-auto,4408,treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.24 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 8.48 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 9.25 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.42 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 52.53 sec. ```. </details>. <summary>This PR</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-release-master. Start 1825: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1825: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.30 sec. Start 1826: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1826: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.18 sec. Start 1827: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1827: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.41 sec. Start 1828: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1828: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.38 sec. Start 1829: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1829: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.43 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 29.43 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 3.40 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-mak,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4437,testability,Test,Test,4437,ke. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.24 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 8.48 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 9.25 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.42 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 52.53 sec. ```. </details>. <summary>This PR</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-release-master. Start 1825: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1825: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.30 sec. Start 1826: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1826: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.18 sec. Start 1827: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1827: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.41 sec. Start 1828: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1828: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.38 sec. Start 1829: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1829: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.43 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 29.43 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 3.40 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Pass,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4477,testability,assert,assertUnloadHelper-auto,4477,an-make .............. Passed 1.24 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 8.48 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 9.25 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.42 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 52.53 sec. ```. </details>. <summary>This PR</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-release-master. Start 1825: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1825: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.30 sec. Start 1826: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1826: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.18 sec. Start 1827: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1827: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.41 sec. Start 1828: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1828: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.38 sec. Start 1829: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1829: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.43 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 29.43 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 3.40 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.95 sec. Start 2219: roottest-root-treeformula,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4586,testability,Test,Test,4586, 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 8.48 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 9.25 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.42 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 52.53 sec. ```. </details>. <summary>This PR</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-release-master. Start 1825: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1825: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.30 sec. Start 1826: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1826: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.18 sec. Start 1827: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1827: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.41 sec. Start 1828: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1828: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.38 sec. Start 1829: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1829: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.43 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 29.43 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 3.40 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.95 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.28 sec. S,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4735,testability,Test,Test,4735,33: roottest-root-treeformula-stl-make ............... Passed 9.25 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.42 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 52.53 sec. ```. </details>. <summary>This PR</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-release-master. Start 1825: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1825: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.30 sec. Start 1826: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1826: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.18 sec. Start 1827: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1827: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.41 sec. Start 1828: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1828: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.38 sec. Start 1829: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1829: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.43 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 29.43 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 3.40 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.95 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.28 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 4.29 sec. Start 2221: roo,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4884,testability,Test,Test,4884,-root-treeformula-string-make ............ Passed 8.42 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 52.53 sec. ```. </details>. <summary>This PR</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-release-master. Start 1825: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1825: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.30 sec. Start 1826: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1826: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.18 sec. Start 1827: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1827: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.41 sec. Start 1828: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1828: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.38 sec. Start 1829: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1829: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.43 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 29.43 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 3.40 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.95 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.28 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 4.29 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 6.01 sec. Start 2222: roottest-root,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4992,testability,Test,Test,4992, 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 52.53 sec. ```. </details>. <summary>This PR</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-release-master. Start 1825: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1825: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.30 sec. Start 1826: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1826: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.18 sec. Start 1827: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1827: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.41 sec. Start 1828: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1828: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.38 sec. Start 1829: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1829: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.43 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 29.43 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 3.40 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.95 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.28 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 4.29 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 6.01 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.56,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5098,testability,Test,Test,5098, <summary>This PR</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-release-master. Start 1825: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1825: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.30 sec. Start 1826: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1826: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.18 sec. Start 1827: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1827: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.41 sec. Start 1828: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1828: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.38 sec. Start 1829: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1829: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.43 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 29.43 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 3.40 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.95 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.28 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 4.29 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 6.01 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.56 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-func,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5236,testability,Test,Test,5236,st-root-meta-callfunc-assertUnload-auto. 1/5 Test #1825: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.30 sec. Start 1826: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1826: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.18 sec. Start 1827: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1827: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.41 sec. Start 1828: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1828: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.38 sec. Start 1829: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1829: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.43 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 29.43 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 3.40 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.95 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.28 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 4.29 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 6.01 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.56 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 13.24 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-mor,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5372,testability,Test,Test,5372,1826: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1826: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.18 sec. Start 1827: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1827: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.41 sec. Start 1828: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1828: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.38 sec. Start 1829: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1829: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.43 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 29.43 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 3.40 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.95 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.28 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 4.29 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 6.01 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.56 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 13.24 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 7.61 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-nt,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5507,testability,Test,Test,5507,ed 0.18 sec. Start 1827: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1827: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.41 sec. Start 1828: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1828: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.38 sec. Start 1829: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1829: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.43 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 29.43 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 3.40 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.95 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.28 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 4.29 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 6.01 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.56 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 13.24 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 7.61 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.61 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformul,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5642,testability,Test,Test,5642, ........ Passed 0.41 sec. Start 1828: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1828: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.38 sec. Start 1829: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1829: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.43 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 29.43 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 3.40 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.95 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.28 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 4.29 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 6.01 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.56 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 13.24 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 7.61 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.61 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformu,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5781,testability,Test,Test,5781,rFunc-auto ........ Passed 0.38 sec. Start 1829: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1829: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.43 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 29.43 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 3.40 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.95 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.28 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 4.29 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 6.01 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.56 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 13.24 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 7.61 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.61 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 20.18 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treefo,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5920,testability,Test,Test,5920,c-runsimpleFunc-auto ........ Passed 0.43 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 29.43 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 3.40 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.95 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.28 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 4.29 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 6.01 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.56 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 13.24 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 7.61 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.61 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 20.18 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 8.88 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeform,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6058,testability,Test,Test,6058,est-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 29.43 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 3.40 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.95 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.28 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 4.29 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 6.01 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.56 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 13.24 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 7.61 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.61 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 20.18 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 8.88 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 7.35 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6197,testability,Test,Test,6197,-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 3.40 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.95 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.28 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 4.29 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 6.01 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.56 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 13.24 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 7.61 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.61 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 20.18 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 8.88 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 7.35 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.31 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-tree,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6334,testability,Test,Test,6334,-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.95 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.28 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 4.29 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 6.01 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.56 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 13.24 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 7.61 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.61 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 20.18 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 8.88 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 7.35 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.31 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 8.64 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treefor,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6473,testability,Test,Test,6473,ot-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.28 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 4.29 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 6.01 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.56 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 13.24 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 7.61 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.61 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 20.18 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 8.88 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 7.35 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.31 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 8.64 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 9.53 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformu,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6609,testability,Test,Test,6609,t-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 4.29 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 6.01 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.56 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 13.24 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 7.61 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.61 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 20.18 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 8.88 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 7.35 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.31 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 8.64 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 9.53 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.62 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformul,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6751,testability,Test,Test,6751,"ormula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 6.01 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.56 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 13.24 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 7.61 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.61 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 20.18 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 8.88 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 7.35 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.31 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 8.64 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 9.53 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.62 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 51.12 sec. ```. </details>. The enum-based optimization which I introduced in commit [""Improve performance",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6888,testability,Test,Test,6888,"eformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.56 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 13.24 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 7.61 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.61 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 20.18 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 8.88 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 7.35 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.31 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 8.64 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 9.53 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.62 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 51.12 sec. ```. </details>. The enum-based optimization which I introduced in commit [""Improve performance by allowing most of cling::Value to inline""](https://github.com/root-project/root/pull/11252/commits/fa74b5419c3120ab4b5130e53a1844c54dc",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:7023,testability,Test,Test,7023,"-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 13.24 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 7.61 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.61 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 20.18 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 8.88 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 7.35 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.31 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 8.64 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 9.53 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.62 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 51.12 sec. ```. </details>. The enum-based optimization which I introduced in commit [""Improve performance by allowing most of cling::Value to inline""](https://github.com/root-project/root/pull/11252/commits/fa74b5419c3120ab4b5130e53a1844c54dc467c4). Unfortunately it did not show any improvement for callfunc. It helps with inlining the `castAs` operation but that does not bri",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:7169,testability,Test,Test,7169,"rmula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 7.61 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.61 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 20.18 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 8.88 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 7.35 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.31 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 8.64 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 9.53 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.62 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 51.12 sec. ```. </details>. The enum-based optimization which I introduced in commit [""Improve performance by allowing most of cling::Value to inline""](https://github.com/root-project/root/pull/11252/commits/fa74b5419c3120ab4b5130e53a1844c54dc467c4). Unfortunately it did not show any improvement for callfunc. It helps with inlining the `castAs` operation but that does not bring benefits. That's why I decided to revert it but keep it in the history if we want to apply it. I can further spend time in trying to optimize t",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:7303,testability,Test,Test,7303,"eeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.61 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 20.18 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 8.88 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 7.35 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.31 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 8.64 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 9.53 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.62 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 51.12 sec. ```. </details>. The enum-based optimization which I introduced in commit [""Improve performance by allowing most of cling::Value to inline""](https://github.com/root-project/root/pull/11252/commits/fa74b5419c3120ab4b5130e53a1844c54dc467c4). Unfortunately it did not show any improvement for callfunc. It helps with inlining the `castAs` operation but that does not bring benefits. That's why I decided to revert it but keep it in the history if we want to apply it. I can further spend time in trying to optimize this but that might be at the cost of making it harder to understand and maintain. If that performance info is acceptable, I will play ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:7440,testability,Test,Test,7440,"eeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 20.18 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 8.88 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 7.35 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.31 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 8.64 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 9.53 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.62 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 51.12 sec. ```. </details>. The enum-based optimization which I introduced in commit [""Improve performance by allowing most of cling::Value to inline""](https://github.com/root-project/root/pull/11252/commits/fa74b5419c3120ab4b5130e53a1844c54dc467c4). Unfortunately it did not show any improvement for callfunc. It helps with inlining the `castAs` operation but that does not bring benefits. That's why I decided to revert it but keep it in the history if we want to apply it. I can further spend time in trying to optimize this but that might be at the cost of making it harder to understand and maintain. If that performance info is acceptable, I will play a bit with a couple of ideas I have and move forward as that's blocking lowering parts of CallFunc to cling standalone. fyi @Axel-Naumann",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:7575,testability,Test,Test,7575,"eeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 20.18 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 8.88 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 7.35 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.31 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 8.64 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 9.53 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.62 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 51.12 sec. ```. </details>. The enum-based optimization which I introduced in commit [""Improve performance by allowing most of cling::Value to inline""](https://github.com/root-project/root/pull/11252/commits/fa74b5419c3120ab4b5130e53a1844c54dc467c4). Unfortunately it did not show any improvement for callfunc. It helps with inlining the `castAs` operation but that does not bring benefits. That's why I decided to revert it but keep it in the history if we want to apply it. I can further spend time in trying to optimize this but that might be at the cost of making it harder to understand and maintain. If that performance info is acceptable, I will play a bit with a couple of ideas I have and move forward as that's blocking lowering parts of CallFunc to cling standalone. fyi @Axel-Naumann",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:8228,testability,understand,understand,8228,"eeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 20.18 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 8.88 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 7.35 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.31 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 8.64 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 9.53 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.62 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 51.12 sec. ```. </details>. The enum-based optimization which I introduced in commit [""Improve performance by allowing most of cling::Value to inline""](https://github.com/root-project/root/pull/11252/commits/fa74b5419c3120ab4b5130e53a1844c54dc467c4). Unfortunately it did not show any improvement for callfunc. It helps with inlining the `castAs` operation but that does not bring benefits. That's why I decided to revert it but keep it in the history if we want to apply it. I can further spend time in trying to optimize this but that might be at the cost of making it harder to understand and maintain. If that performance info is acceptable, I will play a bit with a couple of ideas I have and move forward as that's blocking lowering parts of CallFunc to cling standalone. fyi @Axel-Naumann",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:8318,testability,coupl,couple,8318,"eeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 20.18 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 8.88 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 7.35 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.31 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 8.64 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 9.53 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.62 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 51.12 sec. ```. </details>. The enum-based optimization which I introduced in commit [""Improve performance by allowing most of cling::Value to inline""](https://github.com/root-project/root/pull/11252/commits/fa74b5419c3120ab4b5130e53a1844c54dc467c4). Unfortunately it did not show any improvement for callfunc. It helps with inlining the `castAs` operation but that does not bring benefits. That's why I decided to revert it but keep it in the history if we want to apply it. I can further spend time in trying to optimize this but that might be at the cost of making it harder to understand and maintain. If that performance info is acceptable, I will play a bit with a couple of ideas I have and move forward as that's blocking lowering parts of CallFunc to cling standalone. fyi @Axel-Naumann",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:12,usability,perform,performance,12,"@pcanal, my performance quest did not bring a lot of fruit unfortunately. The good news is that this PR does not introduce significant performance regression. There is 2-5% slowdown on some tests but I think the improvement of type consistency is worth it. The tests were primarily focused at the TClingCallFunc performance I have not excessively tested the performance of other `cling::Value`-related code as we do not really have an idiom which is widely used. Here are some performance benchmarks details:. <summary>master</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-callfunc-master/release. Start 1829: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1829: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.25 sec. Start 1830: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1830: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.16 sec. Start 1831: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1831: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.43 sec. Start 1832: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1832: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.34 sec. Start 1833: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1833: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.40 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 34.53 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 3.28 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Pass",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:135,usability,perform,performance,135,"@pcanal, my performance quest did not bring a lot of fruit unfortunately. The good news is that this PR does not introduce significant performance regression. There is 2-5% slowdown on some tests but I think the improvement of type consistency is worth it. The tests were primarily focused at the TClingCallFunc performance I have not excessively tested the performance of other `cling::Value`-related code as we do not really have an idiom which is widely used. Here are some performance benchmarks details:. <summary>master</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-callfunc-master/release. Start 1829: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1829: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.25 sec. Start 1830: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1830: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.16 sec. Start 1831: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1831: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.43 sec. Start 1832: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1832: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.34 sec. Start 1833: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1833: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.40 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 34.53 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 3.28 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Pass",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:232,usability,consist,consistency,232,"@pcanal, my performance quest did not bring a lot of fruit unfortunately. The good news is that this PR does not introduce significant performance regression. There is 2-5% slowdown on some tests but I think the improvement of type consistency is worth it. The tests were primarily focused at the TClingCallFunc performance I have not excessively tested the performance of other `cling::Value`-related code as we do not really have an idiom which is widely used. Here are some performance benchmarks details:. <summary>master</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-callfunc-master/release. Start 1829: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1829: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.25 sec. Start 1830: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1830: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.16 sec. Start 1831: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1831: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.43 sec. Start 1832: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1832: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.34 sec. Start 1833: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1833: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.40 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 34.53 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 3.28 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Pass",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:312,usability,perform,performance,312,"@pcanal, my performance quest did not bring a lot of fruit unfortunately. The good news is that this PR does not introduce significant performance regression. There is 2-5% slowdown on some tests but I think the improvement of type consistency is worth it. The tests were primarily focused at the TClingCallFunc performance I have not excessively tested the performance of other `cling::Value`-related code as we do not really have an idiom which is widely used. Here are some performance benchmarks details:. <summary>master</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-callfunc-master/release. Start 1829: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1829: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.25 sec. Start 1830: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1830: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.16 sec. Start 1831: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1831: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.43 sec. Start 1832: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1832: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.34 sec. Start 1833: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1833: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.40 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 34.53 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 3.28 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Pass",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:358,usability,perform,performance,358,"@pcanal, my performance quest did not bring a lot of fruit unfortunately. The good news is that this PR does not introduce significant performance regression. There is 2-5% slowdown on some tests but I think the improvement of type consistency is worth it. The tests were primarily focused at the TClingCallFunc performance I have not excessively tested the performance of other `cling::Value`-related code as we do not really have an idiom which is widely used. Here are some performance benchmarks details:. <summary>master</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-callfunc-master/release. Start 1829: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1829: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.25 sec. Start 1830: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1830: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.16 sec. Start 1831: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1831: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.43 sec. Start 1832: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1832: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.34 sec. Start 1833: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1833: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.40 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 34.53 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 3.28 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Pass",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:477,usability,perform,performance,477,"@pcanal, my performance quest did not bring a lot of fruit unfortunately. The good news is that this PR does not introduce significant performance regression. There is 2-5% slowdown on some tests but I think the improvement of type consistency is worth it. The tests were primarily focused at the TClingCallFunc performance I have not excessively tested the performance of other `cling::Value`-related code as we do not really have an idiom which is widely used. Here are some performance benchmarks details:. <summary>master</summary>. <details>. ```. ctest -R .*callfunc.* . Test project /build/vvassilev/root-callfunc-master/release. Start 1829: roottest-root-meta-callfunc-assertUnload-auto. 1/5 Test #1829: roottest-root-meta-callfunc-assertUnload-auto ......... Passed 0.25 sec. Start 1830: roottest-root-meta-callfunc-assertUnloadHelper-auto. 2/5 Test #1830: roottest-root-meta-callfunc-assertUnloadHelper-auto ... Passed 0.16 sec. Start 1831: roottest-root-meta-callfunc-execResolveAt-auto. 3/5 Test #1831: roottest-root-meta-callfunc-execResolveAt-auto ........ Passed 0.43 sec. Start 1832: roottest-root-meta-callfunc-runmemberFunc-auto. 4/5 Test #1832: roottest-root-meta-callfunc-runmemberFunc-auto ........ Passed 0.34 sec. Start 1833: roottest-root-meta-callfunc-runsimpleFunc-auto. 5/5 Test #1833: roottest-root-meta-callfunc-runsimpleFunc-auto ........ Passed 0.40 sec. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 34.53 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 3.28 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.91 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Pass",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:7742,usability,perform,performance,7742,"eeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 20.18 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 8.88 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 7.35 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.31 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 8.64 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 9.53 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.62 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 51.12 sec. ```. </details>. The enum-based optimization which I introduced in commit [""Improve performance by allowing most of cling::Value to inline""](https://github.com/root-project/root/pull/11252/commits/fa74b5419c3120ab4b5130e53a1844c54dc467c4). Unfortunately it did not show any improvement for callfunc. It helps with inlining the `castAs` operation but that does not bring benefits. That's why I decided to revert it but keep it in the history if we want to apply it. I can further spend time in trying to optimize this but that might be at the cost of making it harder to understand and maintain. If that performance info is acceptable, I will play a bit with a couple of ideas I have and move forward as that's blocking lowering parts of CallFunc to cling standalone. fyi @Axel-Naumann",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:7961,usability,help,helps,7961,"eeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 20.18 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 8.88 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 7.35 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.31 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 8.64 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 9.53 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.62 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 51.12 sec. ```. </details>. The enum-based optimization which I introduced in commit [""Improve performance by allowing most of cling::Value to inline""](https://github.com/root-project/root/pull/11252/commits/fa74b5419c3120ab4b5130e53a1844c54dc467c4). Unfortunately it did not show any improvement for callfunc. It helps with inlining the `castAs` operation but that does not bring benefits. That's why I decided to revert it but keep it in the history if we want to apply it. I can further spend time in trying to optimize this but that might be at the cost of making it harder to understand and maintain. If that performance info is acceptable, I will play a bit with a couple of ideas I have and move forward as that's blocking lowering parts of CallFunc to cling standalone. fyi @Axel-Naumann",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:8261,usability,perform,performance,8261,"eeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 1.09 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 20.18 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 8.88 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 7.35 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.31 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 8.64 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 9.53 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.62 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 51.12 sec. ```. </details>. The enum-based optimization which I introduced in commit [""Improve performance by allowing most of cling::Value to inline""](https://github.com/root-project/root/pull/11252/commits/fa74b5419c3120ab4b5130e53a1844c54dc467c4). Unfortunately it did not show any improvement for callfunc. It helps with inlining the `castAs` operation but that does not bring benefits. That's why I decided to revert it but keep it in the history if we want to apply it. I can further spend time in trying to optimize this but that might be at the cost of making it harder to understand and maintain. If that performance info is acceptable, I will play a bit with a couple of ideas I have and move forward as that's blocking lowering parts of CallFunc to cling standalone. fyi @Axel-Naumann",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:16,energy efficiency,Draw,Draw,16,"For the `TTree::Draw` based benchmark, you noted:. ```. That benchmark runs more or less for the same time (0.16 +-2):. ```. which is pretty large relative increase. Since you machine is fast could you increase the number of iteration by 200 or so (i.e unless it run for at least 30 seconds)? It might also be instructive to profile that example and see where the cost comes from.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:325,energy efficiency,profil,profile,325,"For the `TTree::Draw` based benchmark, you noted:. ```. That benchmark runs more or less for the same time (0.16 +-2):. ```. which is pretty large relative increase. Since you machine is fast could you increase the number of iteration by 200 or so (i.e unless it run for at least 30 seconds)? It might also be instructive to profile that example and see where the cost comes from.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:102,performance,time,time,102,"For the `TTree::Draw` based benchmark, you noted:. ```. That benchmark runs more or less for the same time (0.16 +-2):. ```. which is pretty large relative increase. Since you machine is fast could you increase the number of iteration by 200 or so (i.e unless it run for at least 30 seconds)? It might also be instructive to profile that example and see where the cost comes from.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:325,performance,profil,profile,325,"For the `TTree::Draw` based benchmark, you noted:. ```. That benchmark runs more or less for the same time (0.16 +-2):. ```. which is pretty large relative increase. Since you machine is fast could you increase the number of iteration by 200 or so (i.e unless it run for at least 30 seconds)? It might also be instructive to profile that example and see where the cost comes from.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:436,deployability,build,build,436,"> For the `TTree::Draw` based benchmark, you noted:. > . > ```. > That benchmark runs more or less for the same time (0.16 +-2):. > ```. > . > which is pretty large relative increase. Since you machine is fast could you increase the number of iteration by 200 or so (i.e unless it run for at least 30 seconds)? It might also be instructive to profile that example and see where the cost comes from. `/usr/bin/time -v root.exe -l -b -q /build/vvassilev/root-release-master/callfuncbench.C\(1000000000\)` yields 6.12 for master and 6.45 for this PR. The results are over 3 runs and seem pretty stable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:457,deployability,releas,release-master,457,"> For the `TTree::Draw` based benchmark, you noted:. > . > ```. > That benchmark runs more or less for the same time (0.16 +-2):. > ```. > . > which is pretty large relative increase. Since you machine is fast could you increase the number of iteration by 200 or so (i.e unless it run for at least 30 seconds)? It might also be instructive to profile that example and see where the cost comes from. `/usr/bin/time -v root.exe -l -b -q /build/vvassilev/root-release-master/callfuncbench.C\(1000000000\)` yields 6.12 for master and 6.45 for this PR. The results are over 3 runs and seem pretty stable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:18,energy efficiency,Draw,Draw,18,"> For the `TTree::Draw` based benchmark, you noted:. > . > ```. > That benchmark runs more or less for the same time (0.16 +-2):. > ```. > . > which is pretty large relative increase. Since you machine is fast could you increase the number of iteration by 200 or so (i.e unless it run for at least 30 seconds)? It might also be instructive to profile that example and see where the cost comes from. `/usr/bin/time -v root.exe -l -b -q /build/vvassilev/root-release-master/callfuncbench.C\(1000000000\)` yields 6.12 for master and 6.45 for this PR. The results are over 3 runs and seem pretty stable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:343,energy efficiency,profil,profile,343,"> For the `TTree::Draw` based benchmark, you noted:. > . > ```. > That benchmark runs more or less for the same time (0.16 +-2):. > ```. > . > which is pretty large relative increase. Since you machine is fast could you increase the number of iteration by 200 or so (i.e unless it run for at least 30 seconds)? It might also be instructive to profile that example and see where the cost comes from. `/usr/bin/time -v root.exe -l -b -q /build/vvassilev/root-release-master/callfuncbench.C\(1000000000\)` yields 6.12 for master and 6.45 for this PR. The results are over 3 runs and seem pretty stable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:112,performance,time,time,112,"> For the `TTree::Draw` based benchmark, you noted:. > . > ```. > That benchmark runs more or less for the same time (0.16 +-2):. > ```. > . > which is pretty large relative increase. Since you machine is fast could you increase the number of iteration by 200 or so (i.e unless it run for at least 30 seconds)? It might also be instructive to profile that example and see where the cost comes from. `/usr/bin/time -v root.exe -l -b -q /build/vvassilev/root-release-master/callfuncbench.C\(1000000000\)` yields 6.12 for master and 6.45 for this PR. The results are over 3 runs and seem pretty stable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:343,performance,profil,profile,343,"> For the `TTree::Draw` based benchmark, you noted:. > . > ```. > That benchmark runs more or less for the same time (0.16 +-2):. > ```. > . > which is pretty large relative increase. Since you machine is fast could you increase the number of iteration by 200 or so (i.e unless it run for at least 30 seconds)? It might also be instructive to profile that example and see where the cost comes from. `/usr/bin/time -v root.exe -l -b -q /build/vvassilev/root-release-master/callfuncbench.C\(1000000000\)` yields 6.12 for master and 6.45 for this PR. The results are over 3 runs and seem pretty stable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:409,performance,time,time,409,"> For the `TTree::Draw` based benchmark, you noted:. > . > ```. > That benchmark runs more or less for the same time (0.16 +-2):. > ```. > . > which is pretty large relative increase. Since you machine is fast could you increase the number of iteration by 200 or so (i.e unless it run for at least 30 seconds)? It might also be instructive to profile that example and see where the cost comes from. `/usr/bin/time -v root.exe -l -b -q /build/vvassilev/root-release-master/callfuncbench.C\(1000000000\)` yields 6.12 for master and 6.45 for this PR. The results are over 3 runs and seem pretty stable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:14,energy efficiency,profil,profiler,14,Can you run a profiler and/or callgrind on the benchmark?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:14,performance,profil,profiler,14,Can you run a profiler and/or callgrind on the benchmark?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:426,availability,sli,slight,426,"> Can you run a profiler and/or callgrind on the benchmark? I found nothing interesting there. However, I rebuilt my master and PR in both Release (not RelWithDebInfo) and now I see the speedup of my patch in your example. Average of 3 runs of `root.exe -l -b -q /build/vvassilev/callfuncbench.C\(2000000000\)` master 13.05s and this PR (with the enum what-i-thought optimization) 11.16s and 11.16s. The ctest benchmarks show slight effect towards the enum optimization but it is really negligible. I thought the RelWithDebInfo is almost the same but for LLVM Release means -O3 and RelWithDebInfo means -O2. . Things are looking good for the ctest examples, too:. <summary>Master Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morr",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:2213,availability,operat,operator-make,2213,219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 6.46 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.51 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 0.89 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 17.06 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottes,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:2272,availability,operat,operator-make,2272, roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 6.46 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.51 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 0.89 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 17.06 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5005,availability,operat,operator-make,5005,220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.57 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.51 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.90 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.19 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottes,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5064,availability,operat,operator-make,5064, roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.57 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.51 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.90 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.19 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:7768,availability,operat,operator-make,7768,220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.25 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.44 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.12 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottes,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:7827,availability,operat,operator-make,7827, roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.25 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.44 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.12 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.25 sec,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:139,deployability,Releas,Release,139,"> Can you run a profiler and/or callgrind on the benchmark? I found nothing interesting there. However, I rebuilt my master and PR in both Release (not RelWithDebInfo) and now I see the speedup of my patch in your example. Average of 3 runs of `root.exe -l -b -q /build/vvassilev/callfuncbench.C\(2000000000\)` master 13.05s and this PR (with the enum what-i-thought optimization) 11.16s and 11.16s. The ctest benchmarks show slight effect towards the enum optimization but it is really negligible. I thought the RelWithDebInfo is almost the same but for LLVM Release means -O3 and RelWithDebInfo means -O2. . Things are looking good for the ctest examples, too:. <summary>Master Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morr",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:200,deployability,patch,patch,200,"> Can you run a profiler and/or callgrind on the benchmark? I found nothing interesting there. However, I rebuilt my master and PR in both Release (not RelWithDebInfo) and now I see the speedup of my patch in your example. Average of 3 runs of `root.exe -l -b -q /build/vvassilev/callfuncbench.C\(2000000000\)` master 13.05s and this PR (with the enum what-i-thought optimization) 11.16s and 11.16s. The ctest benchmarks show slight effect towards the enum optimization but it is really negligible. I thought the RelWithDebInfo is almost the same but for LLVM Release means -O3 and RelWithDebInfo means -O2. . Things are looking good for the ctest examples, too:. <summary>Master Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morr",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:264,deployability,build,build,264,"> Can you run a profiler and/or callgrind on the benchmark? I found nothing interesting there. However, I rebuilt my master and PR in both Release (not RelWithDebInfo) and now I see the speedup of my patch in your example. Average of 3 runs of `root.exe -l -b -q /build/vvassilev/callfuncbench.C\(2000000000\)` master 13.05s and this PR (with the enum what-i-thought optimization) 11.16s and 11.16s. The ctest benchmarks show slight effect towards the enum optimization but it is really negligible. I thought the RelWithDebInfo is almost the same but for LLVM Release means -O3 and RelWithDebInfo means -O2. . Things are looking good for the ctest examples, too:. <summary>Master Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morr",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:560,deployability,Releas,Release,560,"> Can you run a profiler and/or callgrind on the benchmark? I found nothing interesting there. However, I rebuilt my master and PR in both Release (not RelWithDebInfo) and now I see the speedup of my patch in your example. Average of 3 runs of `root.exe -l -b -q /build/vvassilev/callfuncbench.C\(2000000000\)` master 13.05s and this PR (with the enum what-i-thought optimization) 11.16s and 11.16s. The ctest benchmarks show slight effect towards the enum optimization but it is really negligible. I thought the RelWithDebInfo is almost the same but for LLVM Release means -O3 and RelWithDebInfo means -O2. . Things are looking good for the ctest examples, too:. <summary>Master Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morr",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:680,deployability,Releas,Release,680,"> Can you run a profiler and/or callgrind on the benchmark? I found nothing interesting there. However, I rebuilt my master and PR in both Release (not RelWithDebInfo) and now I see the speedup of my patch in your example. Average of 3 runs of `root.exe -l -b -q /build/vvassilev/callfuncbench.C\(2000000000\)` master 13.05s and this PR (with the enum what-i-thought optimization) 11.16s and 11.16s. The ctest benchmarks show slight effect towards the enum optimization but it is really negligible. I thought the RelWithDebInfo is almost the same but for LLVM Release means -O3 and RelWithDebInfo means -O2. . Things are looking good for the ctest examples, too:. <summary>Master Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morr",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:758,deployability,build,build,758,"> Can you run a profiler and/or callgrind on the benchmark? I found nothing interesting there. However, I rebuilt my master and PR in both Release (not RelWithDebInfo) and now I see the speedup of my patch in your example. Average of 3 runs of `root.exe -l -b -q /build/vvassilev/callfuncbench.C\(2000000000\)` master 13.05s and this PR (with the enum what-i-thought optimization) 11.16s and 11.16s. The ctest benchmarks show slight effect towards the enum optimization but it is really negligible. I thought the RelWithDebInfo is almost the same but for LLVM Release means -O3 and RelWithDebInfo means -O2. . Things are looking good for the ctest examples, too:. <summary>Master Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morr",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:795,deployability,releas,release,795,"> Can you run a profiler and/or callgrind on the benchmark? I found nothing interesting there. However, I rebuilt my master and PR in both Release (not RelWithDebInfo) and now I see the speedup of my patch in your example. Average of 3 runs of `root.exe -l -b -q /build/vvassilev/callfuncbench.C\(2000000000\)` master 13.05s and this PR (with the enum what-i-thought optimization) 11.16s and 11.16s. The ctest benchmarks show slight effect towards the enum optimization but it is really negligible. I thought the RelWithDebInfo is almost the same but for LLVM Release means -O3 and RelWithDebInfo means -O2. . Things are looking good for the ctest examples, too:. <summary>Master Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morr",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3401,deployability,Fail,Failed,3401,ula-parse-make ............. Passed 17.06 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed ,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3452,deployability,Releas,Release,3452, 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-form,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3559,deployability,build,build,3559,ake ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 222,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3580,deployability,releas,release-master,3580,sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeform,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6193,deployability,Fail,Failed,6193,ula-parse-make ............. Passed 17.19 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottes,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6244,deployability,Releas,Release,6244, 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: ,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6322,deployability,build,build,6322,root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 222,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6343,deployability,releas,release-master,6343,es-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeform,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:8956,deployability,Fail,Failed,8956,"..... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.25 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.44 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.12 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.25 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.13 sec. ```. </details>. That being said, it seems that performance-wise we are good. . PS: Let me know if I should re-introduce the enum optimization as it is currently reverted in the PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:16,energy efficiency,profil,profiler,16,"> Can you run a profiler and/or callgrind on the benchmark? I found nothing interesting there. However, I rebuilt my master and PR in both Release (not RelWithDebInfo) and now I see the speedup of my patch in your example. Average of 3 runs of `root.exe -l -b -q /build/vvassilev/callfuncbench.C\(2000000000\)` master 13.05s and this PR (with the enum what-i-thought optimization) 11.16s and 11.16s. The ctest benchmarks show slight effect towards the enum optimization but it is really negligible. I thought the RelWithDebInfo is almost the same but for LLVM Release means -O3 and RelWithDebInfo means -O2. . Things are looking good for the ctest examples, too:. <summary>Master Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morr",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:367,energy efficiency,optim,optimization,367,"> Can you run a profiler and/or callgrind on the benchmark? I found nothing interesting there. However, I rebuilt my master and PR in both Release (not RelWithDebInfo) and now I see the speedup of my patch in your example. Average of 3 runs of `root.exe -l -b -q /build/vvassilev/callfuncbench.C\(2000000000\)` master 13.05s and this PR (with the enum what-i-thought optimization) 11.16s and 11.16s. The ctest benchmarks show slight effect towards the enum optimization but it is really negligible. I thought the RelWithDebInfo is almost the same but for LLVM Release means -O3 and RelWithDebInfo means -O2. . Things are looking good for the ctest examples, too:. <summary>Master Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morr",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:457,energy efficiency,optim,optimization,457,"> Can you run a profiler and/or callgrind on the benchmark? I found nothing interesting there. However, I rebuilt my master and PR in both Release (not RelWithDebInfo) and now I see the speedup of my patch in your example. Average of 3 runs of `root.exe -l -b -q /build/vvassilev/callfuncbench.C\(2000000000\)` master 13.05s and this PR (with the enum what-i-thought optimization) 11.16s and 11.16s. The ctest benchmarks show slight effect towards the enum optimization but it is really negligible. I thought the RelWithDebInfo is almost the same but for LLVM Release means -O3 and RelWithDebInfo means -O2. . Things are looking good for the ctest examples, too:. <summary>Master Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morr",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3482,energy efficiency,optim,optimization,3482,-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roo,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:9103,energy efficiency,optim,optimization,9103,"..... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.25 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.44 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.12 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.25 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.13 sec. ```. </details>. That being said, it seems that performance-wise we are good. . PS: Let me know if I should re-introduce the enum optimization as it is currently reverted in the PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:9125,energy efficiency,current,currently,9125,"..... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.25 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.44 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.12 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.25 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.13 sec. ```. </details>. That being said, it seems that performance-wise we are good. . PS: Let me know if I should re-introduce the enum optimization as it is currently reverted in the PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:1386,integrability,event,event-make,1386," 11.16s. The ctest benchmarks show slight effect towards the enum optimization but it is really negligible. I thought the RelWithDebInfo is almost the same but for LLVM Release means -O3 and RelWithDebInfo means -O2. . Things are looking good for the ctest examples, too:. <summary>Master Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 6.46 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.51 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 0.89 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:1441,integrability,event,event-make,1441,"s the enum optimization but it is really negligible. I thought the RelWithDebInfo is almost the same but for LLVM Release means -O3 and RelWithDebInfo means -O2. . Things are looking good for the ctest examples, too:. <summary>Master Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 6.46 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.51 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 0.89 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 17.06 ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:2902,integrability,schema,schemaEvolution-make,2902,roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 6.46 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.51 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 0.89 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 17.06 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clone,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:2968,integrability,schema,schemaEvolution-make,2968,-root-treeformula-morrison-make .......... Passed 6.46 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.51 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 0.89 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 17.06 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ...,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4178,integrability,event,event-make,4178,tring-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.57 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.51 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.90 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4233,integrability,event,event-make,4233,-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.57 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.51 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.90 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.19 ,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5694,integrability,schema,schemaEvolution-make,5694,roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.51 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.90 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.19 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: root,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5760,integrability,schema,schemaEvolution-make,5760,-root-treeformula-morrison-make .......... Passed 6.51 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.90 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.19 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. St,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6941,integrability,event,event-make,6941,: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6996,integrability,event,event-make,6996,34: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 ,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:8457,integrability,schema,schemaEvolution-make,8457,"..... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.25 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.44 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.12 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.25 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.13 sec. ```. </details>. That being said, it seems that performance-wise we are good. . PS: Let me know if I should re-introduce the enum optimization as it is currently reverted in the PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:8523,integrability,schema,schemaEvolution-make,8523,"..... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.25 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.44 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.12 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.25 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.13 sec. ```. </details>. That being said, it seems that performance-wise we are good. . PS: Let me know if I should re-introduce the enum optimization as it is currently reverted in the PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:16,performance,profil,profiler,16,"> Can you run a profiler and/or callgrind on the benchmark? I found nothing interesting there. However, I rebuilt my master and PR in both Release (not RelWithDebInfo) and now I see the speedup of my patch in your example. Average of 3 runs of `root.exe -l -b -q /build/vvassilev/callfuncbench.C\(2000000000\)` master 13.05s and this PR (with the enum what-i-thought optimization) 11.16s and 11.16s. The ctest benchmarks show slight effect towards the enum optimization but it is really negligible. I thought the RelWithDebInfo is almost the same but for LLVM Release means -O3 and RelWithDebInfo means -O2. . Things are looking good for the ctest examples, too:. <summary>Master Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morr",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:367,performance,optimiz,optimization,367,"> Can you run a profiler and/or callgrind on the benchmark? I found nothing interesting there. However, I rebuilt my master and PR in both Release (not RelWithDebInfo) and now I see the speedup of my patch in your example. Average of 3 runs of `root.exe -l -b -q /build/vvassilev/callfuncbench.C\(2000000000\)` master 13.05s and this PR (with the enum what-i-thought optimization) 11.16s and 11.16s. The ctest benchmarks show slight effect towards the enum optimization but it is really negligible. I thought the RelWithDebInfo is almost the same but for LLVM Release means -O3 and RelWithDebInfo means -O2. . Things are looking good for the ctest examples, too:. <summary>Master Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morr",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:457,performance,optimiz,optimization,457,"> Can you run a profiler and/or callgrind on the benchmark? I found nothing interesting there. However, I rebuilt my master and PR in both Release (not RelWithDebInfo) and now I see the speedup of my patch in your example. Average of 3 runs of `root.exe -l -b -q /build/vvassilev/callfuncbench.C\(2000000000\)` master 13.05s and this PR (with the enum what-i-thought optimization) 11.16s and 11.16s. The ctest benchmarks show slight effect towards the enum optimization but it is really negligible. I thought the RelWithDebInfo is almost the same but for LLVM Release means -O3 and RelWithDebInfo means -O2. . Things are looking good for the ctest examples, too:. <summary>Master Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morr",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3482,performance,optimiz,optimization,3482,-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roo,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:9021,performance,perform,performance-wise,9021,"..... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.25 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.44 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.12 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.25 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.13 sec. ```. </details>. That being said, it seems that performance-wise we are good. . PS: Let me know if I should re-introduce the enum optimization as it is currently reverted in the PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:9103,performance,optimiz,optimization,9103,"..... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.25 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.44 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.12 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.25 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.13 sec. ```. </details>. That being said, it seems that performance-wise we are good. . PS: Let me know if I should re-introduce the enum optimization as it is currently reverted in the PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:426,reliability,sli,slight,426,"> Can you run a profiler and/or callgrind on the benchmark? I found nothing interesting there. However, I rebuilt my master and PR in both Release (not RelWithDebInfo) and now I see the speedup of my patch in your example. Average of 3 runs of `root.exe -l -b -q /build/vvassilev/callfuncbench.C\(2000000000\)` master 13.05s and this PR (with the enum what-i-thought optimization) 11.16s and 11.16s. The ctest benchmarks show slight effect towards the enum optimization but it is really negligible. I thought the RelWithDebInfo is almost the same but for LLVM Release means -O3 and RelWithDebInfo means -O2. . Things are looking good for the ctest examples, too:. <summary>Master Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morr",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3401,reliability,Fail,Failed,3401,ula-parse-make ............. Passed 17.06 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed ,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6193,reliability,Fail,Failed,6193,ula-parse-make ............. Passed 17.19 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottes,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:8956,reliability,Fail,Failed,8956,"..... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.25 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.44 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.12 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.25 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.13 sec. ```. </details>. That being said, it seems that performance-wise we are good. . PS: Let me know if I should re-introduce the enum optimization as it is currently reverted in the PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:200,safety,patch,patch,200,"> Can you run a profiler and/or callgrind on the benchmark? I found nothing interesting there. However, I rebuilt my master and PR in both Release (not RelWithDebInfo) and now I see the speedup of my patch in your example. Average of 3 runs of `root.exe -l -b -q /build/vvassilev/callfuncbench.C\(2000000000\)` master 13.05s and this PR (with the enum what-i-thought optimization) 11.16s and 11.16s. The ctest benchmarks show slight effect towards the enum optimization but it is really negligible. I thought the RelWithDebInfo is almost the same but for LLVM Release means -O3 and RelWithDebInfo means -O2. . Things are looking good for the ctest examples, too:. <summary>Master Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morr",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:744,safety,Test,Test,744,"> Can you run a profiler and/or callgrind on the benchmark? I found nothing interesting there. However, I rebuilt my master and PR in both Release (not RelWithDebInfo) and now I see the speedup of my patch in your example. Average of 3 runs of `root.exe -l -b -q /build/vvassilev/callfuncbench.C\(2000000000\)` master 13.05s and this PR (with the enum what-i-thought optimization) 11.16s and 11.16s. The ctest benchmarks show slight effect towards the enum optimization but it is really negligible. I thought the RelWithDebInfo is almost the same but for LLVM Release means -O3 and RelWithDebInfo means -O2. . Things are looking good for the ctest examples, too:. <summary>Master Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morr",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:859,safety,Test,Test,859,"> Can you run a profiler and/or callgrind on the benchmark? I found nothing interesting there. However, I rebuilt my master and PR in both Release (not RelWithDebInfo) and now I see the speedup of my patch in your example. Average of 3 runs of `root.exe -l -b -q /build/vvassilev/callfuncbench.C\(2000000000\)` master 13.05s and this PR (with the enum what-i-thought optimization) 11.16s and 11.16s. The ctest benchmarks show slight effect towards the enum optimization but it is really negligible. I thought the RelWithDebInfo is almost the same but for LLVM Release means -O3 and RelWithDebInfo means -O2. . Things are looking good for the ctest examples, too:. <summary>Master Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morr",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:997,safety,Test,Test,997,"> Can you run a profiler and/or callgrind on the benchmark? I found nothing interesting there. However, I rebuilt my master and PR in both Release (not RelWithDebInfo) and now I see the speedup of my patch in your example. Average of 3 runs of `root.exe -l -b -q /build/vvassilev/callfuncbench.C\(2000000000\)` master 13.05s and this PR (with the enum what-i-thought optimization) 11.16s and 11.16s. The ctest benchmarks show slight effect towards the enum optimization but it is really negligible. I thought the RelWithDebInfo is almost the same but for LLVM Release means -O3 and RelWithDebInfo means -O2. . Things are looking good for the ctest examples, too:. <summary>Master Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morr",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:1133,safety,Test,Test,1133,"oth Release (not RelWithDebInfo) and now I see the speedup of my patch in your example. Average of 3 runs of `root.exe -l -b -q /build/vvassilev/callfuncbench.C\(2000000000\)` master 13.05s and this PR (with the enum what-i-thought optimization) 11.16s and 11.16s. The ctest benchmarks show slight effect towards the enum optimization but it is really negligible. I thought the RelWithDebInfo is almost the same but for LLVM Release means -O3 and RelWithDebInfo means -O2. . Things are looking good for the ctest examples, too:. <summary>Master Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 6.46 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-nt",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:1268,safety,Test,Test,1268,"vvassilev/callfuncbench.C\(2000000000\)` master 13.05s and this PR (with the enum what-i-thought optimization) 11.16s and 11.16s. The ctest benchmarks show slight effect towards the enum optimization but it is really negligible. I thought the RelWithDebInfo is almost the same but for LLVM Release means -O3 and RelWithDebInfo means -O2. . Things are looking good for the ctest examples, too:. <summary>Master Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 6.46 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.51 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformul",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:1403,safety,Test,Test,1403,"test benchmarks show slight effect towards the enum optimization but it is really negligible. I thought the RelWithDebInfo is almost the same but for LLVM Release means -O3 and RelWithDebInfo means -O2. . Things are looking good for the ctest examples, too:. <summary>Master Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 6.46 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.51 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 0.89 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformu",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:1542,safety,Test,Test,1542,"me but for LLVM Release means -O3 and RelWithDebInfo means -O2. . Things are looking good for the ctest examples, too:. <summary>Master Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 6.46 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.51 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 0.89 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 17.06 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treefo",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:1681,safety,Test,Test,1681,ease Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 6.46 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.51 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 0.89 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 17.06 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeform,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:1819,safety,Test,Test,1819,est-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 6.46 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.51 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 0.89 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 17.06 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:1958,safety,Test,Test,1958,-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 6.46 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.51 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 0.89 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 17.06 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-tree,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:2095,safety,Test,Test,2095,-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 6.46 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.51 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 0.89 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 17.06 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treefor,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:2234,safety,Test,Test,2234,ot-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 6.46 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.51 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 0.89 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 17.06 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformu,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:2370,safety,Test,Test,2370,t-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 6.46 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.51 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 0.89 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 17.06 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformul,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:2512,safety,Test,Test,2512,ormula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 6.46 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.51 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 0.89 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 17.06 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:2649,safety,Test,Test,2649,eformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 6.46 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.51 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 0.89 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 17.06 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 ,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:2784,safety,Test,Test,2784,-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 6.46 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.51 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 0.89 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 17.06 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:2930,safety,Test,Test,2930,rmula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 6.46 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.51 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 0.89 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 17.06 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3064,safety,Test,Test,3064,eeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.51 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 0.89 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 17.06 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3201,safety,Test,Test,3201,eeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 0.89 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 17.06 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #22,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3336,safety,Test,Test,3336,t-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 17.06 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3545,safety,Test,Test,3545,la-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3651,safety,Test,Test,3651, #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-func,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3789,safety,Test,Test,3789,230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.57 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-mor,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3925,safety,Test,Test,3925,19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.57 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.51 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-nt,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4060,safety,Test,Test,4060,9 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.57 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.51 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformul,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4195,safety,Test,Test,4195,/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.57 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.51 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.90 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformu,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4334,safety,Test,Test,4334,Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.57 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.51 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.90 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.19 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treefo,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4473,safety,Test,Test,4473,e enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.57 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.51 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.90 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.19 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeform,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4611,safety,Test,Test,4611,est-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.57 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.51 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.90 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.19 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4750,safety,Test,Test,4750,-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.57 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.51 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.90 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.19 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-tree,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4887,safety,Test,Test,4887,-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.57 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.51 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.90 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.19 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treefor,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5026,safety,Test,Test,5026,ot-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.57 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.51 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.90 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.19 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformu,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5162,safety,Test,Test,5162,t-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.57 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.51 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.90 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.19 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformul,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5304,safety,Test,Test,5304,ormula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.57 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.51 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.90 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.19 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* ,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5441,safety,Test,Test,5441,eformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.57 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.51 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.90 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.19 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-tre,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5576,safety,Test,Test,5576,-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.57 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.51 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.90 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.19 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5722,safety,Test,Test,5722,rmula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.51 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.90 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.19 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformul,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5856,safety,Test,Test,5856,eeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.90 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.19 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformu,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5993,safety,Test,Test,5993,eeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.90 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.19 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6128,safety,Test,Test,6128,t-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.19 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treefor,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6308,safety,Test,Test,6308,2229: roottest-root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6414,safety,Test,Test,6414,rmula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-func,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6552,safety,Test,Test,6552,mula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-mor,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6688,safety,Test,Test,6688,ula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-nt,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6823,safety,Test,Test,6823,ot-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformul,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6958,safety,Test,Test,6958,t-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformu,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:7097,safety,Test,Test,7097,treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treefo,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:7236,safety,Test,Test,7236,is PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeform,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:7374,safety,Test,Test,7374,est-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.25 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:7513,safety,Test,Test,7513,-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.25 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-tree,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:7650,safety,Test,Test,7650,-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.25 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.44 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treefor,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:7789,safety,Test,Test,7789,ot-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.25 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.44 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.12 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformu,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:7925,safety,Test,Test,7925,t-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.25 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.44 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.12 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.25 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformul,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:8067,safety,Test,Test,8067,"ormula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.25 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.44 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.12 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.25 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.13 sec. ```. </details>. That being said, it seems that performance-wise we are good. . PS: Let me know ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:8204,safety,Test,Test,8204,"..... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.25 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.44 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.12 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.25 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.13 sec. ```. </details>. That being said, it seems that performance-wise we are good. . PS: Let me know if I should re-introduce the enum optimization as it is currently reverted in the PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:8339,safety,Test,Test,8339,"..... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.25 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.44 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.12 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.25 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.13 sec. ```. </details>. That being said, it seems that performance-wise we are good. . PS: Let me know if I should re-introduce the enum optimization as it is currently reverted in the PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:8485,safety,Test,Test,8485,"..... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.25 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.44 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.12 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.25 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.13 sec. ```. </details>. That being said, it seems that performance-wise we are good. . PS: Let me know if I should re-introduce the enum optimization as it is currently reverted in the PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:8619,safety,Test,Test,8619,"..... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.25 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.44 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.12 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.25 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.13 sec. ```. </details>. That being said, it seems that performance-wise we are good. . PS: Let me know if I should re-introduce the enum optimization as it is currently reverted in the PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:8756,safety,Test,Test,8756,"..... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.25 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.44 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.12 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.25 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.13 sec. ```. </details>. That being said, it seems that performance-wise we are good. . PS: Let me know if I should re-introduce the enum optimization as it is currently reverted in the PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:8891,safety,Test,Test,8891,"..... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.25 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.44 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.12 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.25 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.13 sec. ```. </details>. That being said, it seems that performance-wise we are good. . PS: Let me know if I should re-introduce the enum optimization as it is currently reverted in the PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:200,security,patch,patch,200,"> Can you run a profiler and/or callgrind on the benchmark? I found nothing interesting there. However, I rebuilt my master and PR in both Release (not RelWithDebInfo) and now I see the speedup of my patch in your example. Average of 3 runs of `root.exe -l -b -q /build/vvassilev/callfuncbench.C\(2000000000\)` master 13.05s and this PR (with the enum what-i-thought optimization) 11.16s and 11.16s. The ctest benchmarks show slight effect towards the enum optimization but it is really negligible. I thought the RelWithDebInfo is almost the same but for LLVM Release means -O3 and RelWithDebInfo means -O2. . Things are looking good for the ctest examples, too:. <summary>Master Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morr",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:744,testability,Test,Test,744,"> Can you run a profiler and/or callgrind on the benchmark? I found nothing interesting there. However, I rebuilt my master and PR in both Release (not RelWithDebInfo) and now I see the speedup of my patch in your example. Average of 3 runs of `root.exe -l -b -q /build/vvassilev/callfuncbench.C\(2000000000\)` master 13.05s and this PR (with the enum what-i-thought optimization) 11.16s and 11.16s. The ctest benchmarks show slight effect towards the enum optimization but it is really negligible. I thought the RelWithDebInfo is almost the same but for LLVM Release means -O3 and RelWithDebInfo means -O2. . Things are looking good for the ctest examples, too:. <summary>Master Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morr",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:859,testability,Test,Test,859,"> Can you run a profiler and/or callgrind on the benchmark? I found nothing interesting there. However, I rebuilt my master and PR in both Release (not RelWithDebInfo) and now I see the speedup of my patch in your example. Average of 3 runs of `root.exe -l -b -q /build/vvassilev/callfuncbench.C\(2000000000\)` master 13.05s and this PR (with the enum what-i-thought optimization) 11.16s and 11.16s. The ctest benchmarks show slight effect towards the enum optimization but it is really negligible. I thought the RelWithDebInfo is almost the same but for LLVM Release means -O3 and RelWithDebInfo means -O2. . Things are looking good for the ctest examples, too:. <summary>Master Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morr",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:997,testability,Test,Test,997,"> Can you run a profiler and/or callgrind on the benchmark? I found nothing interesting there. However, I rebuilt my master and PR in both Release (not RelWithDebInfo) and now I see the speedup of my patch in your example. Average of 3 runs of `root.exe -l -b -q /build/vvassilev/callfuncbench.C\(2000000000\)` master 13.05s and this PR (with the enum what-i-thought optimization) 11.16s and 11.16s. The ctest benchmarks show slight effect towards the enum optimization but it is really negligible. I thought the RelWithDebInfo is almost the same but for LLVM Release means -O3 and RelWithDebInfo means -O2. . Things are looking good for the ctest examples, too:. <summary>Master Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morr",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:1133,testability,Test,Test,1133,"oth Release (not RelWithDebInfo) and now I see the speedup of my patch in your example. Average of 3 runs of `root.exe -l -b -q /build/vvassilev/callfuncbench.C\(2000000000\)` master 13.05s and this PR (with the enum what-i-thought optimization) 11.16s and 11.16s. The ctest benchmarks show slight effect towards the enum optimization but it is really negligible. I thought the RelWithDebInfo is almost the same but for LLVM Release means -O3 and RelWithDebInfo means -O2. . Things are looking good for the ctest examples, too:. <summary>Master Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 6.46 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-nt",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:1268,testability,Test,Test,1268,"vvassilev/callfuncbench.C\(2000000000\)` master 13.05s and this PR (with the enum what-i-thought optimization) 11.16s and 11.16s. The ctest benchmarks show slight effect towards the enum optimization but it is really negligible. I thought the RelWithDebInfo is almost the same but for LLVM Release means -O3 and RelWithDebInfo means -O2. . Things are looking good for the ctest examples, too:. <summary>Master Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 6.46 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.51 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformul",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:1403,testability,Test,Test,1403,"test benchmarks show slight effect towards the enum optimization but it is really negligible. I thought the RelWithDebInfo is almost the same but for LLVM Release means -O3 and RelWithDebInfo means -O2. . Things are looking good for the ctest examples, too:. <summary>Master Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 6.46 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.51 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 0.89 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformu",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:1542,testability,Test,Test,1542,"me but for LLVM Release means -O3 and RelWithDebInfo means -O2. . Things are looking good for the ctest examples, too:. <summary>Master Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 6.46 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.51 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 0.89 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 17.06 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treefo",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:1681,testability,Test,Test,1681,ease Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-callfunc-master/release. Start 2216: roottest-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 6.46 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.51 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 0.89 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 17.06 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeform,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:1819,testability,Test,Test,1819,est-root-treeformula-array-make. 1/19 Test #2216: roottest-root-treeformula-array-make ............. Passed 26.16 sec. Start 2217: roottest-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 6.46 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.51 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 0.89 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 17.06 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:1958,testability,Test,Test,1958,-root-treeformula-casting-make. 2/19 Test #2217: roottest-root-treeformula-casting-make ........... Passed 2.84 sec. Start 2218: roottest-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 6.46 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.51 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 0.89 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 17.06 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-tree,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:2095,testability,Test,Test,2095,-root-treeformula-clones-make. 3/19 Test #2218: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2219: roottest-root-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 6.46 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.51 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 0.89 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 17.06 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treefor,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:2234,testability,Test,Test,2234,ot-treeformula-depth-make. 4/19 Test #2219: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2220: roottest-root-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 6.46 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.51 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 0.89 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 17.06 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformu,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:2370,testability,Test,Test,2370,t-treeformula-event-make. 5/19 Test #2220: roottest-root-treeformula-event-make ............. Passed 3.82 sec. Start 2221: roottest-root-treeformula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 6.46 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.51 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 0.89 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 17.06 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformul,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:2512,testability,Test,Test,2512,ormula-evolution-make. 6/19 Test #2221: roottest-root-treeformula-evolution-make ......... Passed 5.06 sec. Start 2222: roottest-root-treeformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 6.46 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.51 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 0.89 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 17.06 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:2649,testability,Test,Test,2649,eformula-formulaio-make. 7/19 Test #2222: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2223: roottest-root-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 6.46 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.51 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 0.89 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 17.06 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 ,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:2784,testability,Test,Test,2784,-treeformula-function-make. 8/19 Test #2223: roottest-root-treeformula-function-make .......... Passed 11.50 sec. Start 2224: roottest-root-treeformula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 6.46 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.51 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 0.89 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 17.06 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:2930,testability,Test,Test,2930,rmula-morrison-make. 9/19 Test #2224: roottest-root-treeformula-morrison-make .......... Passed 6.46 sec. Start 2225: roottest-root-treeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.51 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 0.89 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 17.06 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3064,testability,Test,Test,3064,eeformula-ntuple-make. 10/19 Test #2225: roottest-root-treeformula-ntuple-make ............ Passed 0.51 sec. Start 2226: roottest-root-treeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 0.89 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 17.06 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3201,testability,Test,Test,3201,eeformula-operator-make. 11/19 Test #2226: roottest-root-treeformula-operator-make .......... Passed 0.89 sec. Start 2227: roottest-root-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 17.06 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #22,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3336,testability,Test,Test,3336,t-treeformula-parse-make. 12/19 Test #2227: roottest-root-treeformula-parse-make ............. Passed 17.06 sec. Start 2228: roottest-root-treeformula-references-make. 13/19 Test #2228: roottest-root-treeformula-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3545,testability,Test,Test,3545,la-references-make ........ Passed 7.83 sec. Start 2229: roottest-root-treeformula-retobj-make. 14/19 Test #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3651,testability,Test,Test,3651, #2229: roottest-root-treeformula-retobj-make ............ Passed 6.23 sec. Start 2230: roottest-root-treeformula-scan-make. 15/19 Test #2230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-func,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3789,testability,Test,Test,3789,230: roottest-root-treeformula-scan-make .............. Passed 1.07 sec. Start 2231: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.57 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-mor,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3925,testability,Test,Test,3925,19 Test #2231: roottest-root-treeformula-schemaEvolution-make ... Passed 7.40 sec. Start 2232: roottest-root-treeformula-stl-make. 17/19 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.57 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.51 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-nt,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4060,testability,Test,Test,4060,9 Test #2232: roottest-root-treeformula-stl-make ............... Passed 8.08 sec. Start 2233: roottest-root-treeformula-string-make. 18/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.57 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.51 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformul,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4195,testability,Test,Test,4195,/19 Test #2233: roottest-root-treeformula-string-make ............ Passed 8.22 sec. Start 2234: roottest-root-treeformula-sync-make. 19/19 Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.57 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.51 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.90 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformu,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4334,testability,Test,Test,4334,Test #2234: roottest-root-treeformula-sync-make ..............***Failed 4.11 sec. ```. </details>. <summary>This PR Release Mode without the enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.57 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.51 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.90 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.19 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treefo,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4473,testability,Test,Test,4473,e enum optimization</summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.57 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.51 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.90 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.19 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeform,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4611,testability,Test,Test,4611,est-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.27 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.57 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.51 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.90 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.19 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4750,testability,Test,Test,4750,-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.85 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.57 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.51 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.90 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.19 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-tree,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4887,testability,Test,Test,4887,-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.57 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.51 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.90 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.19 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treefor,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5026,testability,Test,Test,5026,ot-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.57 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.51 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.90 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.19 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformu,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5162,testability,Test,Test,5162,t-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.57 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.51 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.90 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.19 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformul,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5304,testability,Test,Test,5304,ormula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.10 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.57 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.51 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.90 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.19 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* ,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5441,testability,Test,Test,5441,eformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.57 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.51 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.90 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.19 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-tre,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5576,testability,Test,Test,5576,-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.57 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.51 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.90 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.19 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5722,testability,Test,Test,5722,rmula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.51 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.90 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.19 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformul,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5856,testability,Test,Test,5856,eeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.90 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.19 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformu,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5993,testability,Test,Test,5993,eeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.90 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.19 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6128,testability,Test,Test,6128,t-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.19 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treefor,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6308,testability,Test,Test,6308,2229: roottest-root-treeformula-references-make ........ Passed 7.88 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6414,testability,Test,Test,6414,rmula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.26 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-func,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6552,testability,Test,Test,6552,mula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-mor,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6688,testability,Test,Test,6688,ula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.45 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-nt,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6823,testability,Test,Test,6823,ot-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.17 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformul,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6958,testability,Test,Test,6958,t-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.24 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformu,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:7097,testability,Test,Test,7097,treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.12 sec. ```. </details>. <summary>This PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treefo,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:7236,testability,Test,Test,7236,is PR Release Mode </summary>. <details>. ```. ctest -R .*treefor.* . Test project /build/vvassilev/root-release-master. Start 2217: roottest-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeform,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:7374,testability,Test,Test,7374,est-root-treeformula-array-make. 1/19 Test #2217: roottest-root-treeformula-array-make ............. Passed 26.23 sec. Start 2218: roottest-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.25 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:7513,testability,Test,Test,7513,-root-treeformula-casting-make. 2/19 Test #2218: roottest-root-treeformula-casting-make ........... Passed 2.86 sec. Start 2219: roottest-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.25 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-tree,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:7650,testability,Test,Test,7650,-root-treeformula-clones-make. 3/19 Test #2219: roottest-root-treeformula-clones-make ............ Passed 0.79 sec. Start 2220: roottest-root-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.25 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.44 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treefor,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:7789,testability,Test,Test,7789,ot-treeformula-depth-make. 4/19 Test #2220: roottest-root-treeformula-depth-make ............. Passed 0.23 sec. Start 2221: roottest-root-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.25 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.44 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.12 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformu,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:7925,testability,Test,Test,7925,t-treeformula-event-make. 5/19 Test #2221: roottest-root-treeformula-event-make ............. Passed 3.84 sec. Start 2222: roottest-root-treeformula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.25 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.44 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.12 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.25 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformul,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:8067,testability,Test,Test,8067,"ormula-evolution-make. 6/19 Test #2222: roottest-root-treeformula-evolution-make ......... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.25 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.44 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.12 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.25 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.13 sec. ```. </details>. That being said, it seems that performance-wise we are good. . PS: Let me know ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:8204,testability,Test,Test,8204,"..... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.25 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.44 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.12 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.25 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.13 sec. ```. </details>. That being said, it seems that performance-wise we are good. . PS: Let me know if I should re-introduce the enum optimization as it is currently reverted in the PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:8339,testability,Test,Test,8339,"..... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.25 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.44 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.12 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.25 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.13 sec. ```. </details>. That being said, it seems that performance-wise we are good. . PS: Let me know if I should re-introduce the enum optimization as it is currently reverted in the PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:8485,testability,Test,Test,8485,"..... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.25 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.44 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.12 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.25 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.13 sec. ```. </details>. That being said, it seems that performance-wise we are good. . PS: Let me know if I should re-introduce the enum optimization as it is currently reverted in the PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:8619,testability,Test,Test,8619,"..... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.25 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.44 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.12 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.25 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.13 sec. ```. </details>. That being said, it seems that performance-wise we are good. . PS: Let me know if I should re-introduce the enum optimization as it is currently reverted in the PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:8756,testability,Test,Test,8756,"..... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.25 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.44 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.12 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.25 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.13 sec. ```. </details>. That being said, it seems that performance-wise we are good. . PS: Let me know if I should re-introduce the enum optimization as it is currently reverted in the PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:8891,testability,Test,Test,8891,"..... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.25 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.44 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.12 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.25 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.13 sec. ```. </details>. That being said, it seems that performance-wise we are good. . PS: Let me know if I should re-introduce the enum optimization as it is currently reverted in the PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:9021,usability,perform,performance-wise,9021,"..... Passed 5.07 sec. Start 2223: roottest-root-treeformula-formulaio-make. 7/19 Test #2223: roottest-root-treeformula-formulaio-make ......... Passed 0.47 sec. Start 2224: roottest-root-treeformula-function-make. 8/19 Test #2224: roottest-root-treeformula-function-make .......... Passed 11.54 sec. Start 2225: roottest-root-treeformula-morrison-make. 9/19 Test #2225: roottest-root-treeformula-morrison-make .......... Passed 6.49 sec. Start 2226: roottest-root-treeformula-ntuple-make. 10/19 Test #2226: roottest-root-treeformula-ntuple-make ............ Passed 0.52 sec. Start 2227: roottest-root-treeformula-operator-make. 11/19 Test #2227: roottest-root-treeformula-operator-make .......... Passed 0.88 sec. Start 2228: roottest-root-treeformula-parse-make. 12/19 Test #2228: roottest-root-treeformula-parse-make ............. Passed 17.10 sec. Start 2229: roottest-root-treeformula-references-make. 13/19 Test #2229: roottest-root-treeformula-references-make ........ Passed 7.84 sec. Start 2230: roottest-root-treeformula-retobj-make. 14/19 Test #2230: roottest-root-treeformula-retobj-make ............ Passed 6.25 sec. Start 2231: roottest-root-treeformula-scan-make. 15/19 Test #2231: roottest-root-treeformula-scan-make .............. Passed 1.08 sec. Start 2232: roottest-root-treeformula-schemaEvolution-make. 16/19 Test #2232: roottest-root-treeformula-schemaEvolution-make ... Passed 7.44 sec. Start 2233: roottest-root-treeformula-stl-make. 17/19 Test #2233: roottest-root-treeformula-stl-make ............... Passed 8.12 sec. Start 2234: roottest-root-treeformula-string-make. 18/19 Test #2234: roottest-root-treeformula-string-make ............ Passed 8.25 sec. Start 2235: roottest-root-treeformula-sync-make. 19/19 Test #2235: roottest-root-treeformula-sync-make ..............***Failed 4.13 sec. ```. </details>. That being said, it seems that performance-wise we are good. . PS: Let me know if I should re-introduce the enum optimization as it is currently reverted in the PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:78,deployability,build,build,78,@pcanal attaching the output of `valgrind --tool=callgrind root.exe -l -b -q /build/vvassilev/callfuncbench.C\(1000000000\)`; `callgrind_annotate callgrind.out.23230`. [callgrind.out.zip](https://github.com/root-project/root/files/9629316/callgrind.out.zip).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:44,usability,tool,tool,44,@pcanal attaching the output of `valgrind --tool=callgrind root.exe -l -b -q /build/vvassilev/callfuncbench.C\(1000000000\)`; `callgrind_annotate callgrind.out.23230`. [callgrind.out.zip](https://github.com/root-project/root/files/9629316/callgrind.out.zip).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:80,deployability,build,build,80,> @pcanal attaching the output of `valgrind --tool=callgrind root.exe -l -b -q /build/vvassilev/callfuncbench.C\(1000000000\)`; `callgrind_annotate callgrind.out.23230` [callgrind.out.zip](https://github.com/root-project/root/files/9629316/callgrind.out.zip). @pcanal here is the profile ran on `RelWithDebInfo`. [callgrind.out.10120.zip](https://github.com/root-project/root/files/9635004/callgrind.out.10120.zip).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:280,energy efficiency,profil,profile,280,> @pcanal attaching the output of `valgrind --tool=callgrind root.exe -l -b -q /build/vvassilev/callfuncbench.C\(1000000000\)`; `callgrind_annotate callgrind.out.23230` [callgrind.out.zip](https://github.com/root-project/root/files/9629316/callgrind.out.zip). @pcanal here is the profile ran on `RelWithDebInfo`. [callgrind.out.10120.zip](https://github.com/root-project/root/files/9635004/callgrind.out.10120.zip).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:280,performance,profil,profile,280,> @pcanal attaching the output of `valgrind --tool=callgrind root.exe -l -b -q /build/vvassilev/callfuncbench.C\(1000000000\)`; `callgrind_annotate callgrind.out.23230` [callgrind.out.zip](https://github.com/root-project/root/files/9629316/callgrind.out.zip). @pcanal here is the profile ran on `RelWithDebInfo`. [callgrind.out.10120.zip](https://github.com/root-project/root/files/9635004/callgrind.out.10120.zip).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:46,usability,tool,tool,46,> @pcanal attaching the output of `valgrind --tool=callgrind root.exe -l -b -q /build/vvassilev/callfuncbench.C\(1000000000\)`; `callgrind_annotate callgrind.out.23230` [callgrind.out.zip](https://github.com/root-project/root/files/9629316/callgrind.out.zip). @pcanal here is the profile ran on `RelWithDebInfo`. [callgrind.out.10120.zip](https://github.com/root-project/root/files/9635004/callgrind.out.10120.zip).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:11,deployability,build,build,11,@phsft-bot build just on ROOT-performance-centos8-multicore/cxx17,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:30,performance,perform,performance-,30,@phsft-bot build just on ROOT-performance-centos8-multicore/cxx17,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:30,usability,perform,performance-,30,@phsft-bot build just on ROOT-performance-centos8-multicore/cxx17,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:646,deployability,build,build,646,> here is the profile ran on RelWithDebInfo. [callgrind.out.10120.zip](https://github.com/root-project/root/files/9635004/callgrind.out.10120.zip). The result of callgrind_annotate on my machine complains it can find some of the source file and thus it can not aggregate the result. When I used KCacheGrind I get a little further but the result is still odd and all the calls under `TTree::Draw` I do not see any of the C++ calls I would expect (including calls to function in `TSelectorDraw` and `TFormLeafInfo`. (Maybe `libTreePlayer` was not recompiling in RelWithDebInfo). Also maybe compiling the script might help:. ```. root.exe -l -b -q /build/vvassilev/callfuncbench.C+(1000000000). ```,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:14,energy efficiency,profil,profile,14,> here is the profile ran on RelWithDebInfo. [callgrind.out.10120.zip](https://github.com/root-project/root/files/9635004/callgrind.out.10120.zip). The result of callgrind_annotate on my machine complains it can find some of the source file and thus it can not aggregate the result. When I used KCacheGrind I get a little further but the result is still odd and all the calls under `TTree::Draw` I do not see any of the C++ calls I would expect (including calls to function in `TSelectorDraw` and `TFormLeafInfo`. (Maybe `libTreePlayer` was not recompiling in RelWithDebInfo). Also maybe compiling the script might help:. ```. root.exe -l -b -q /build/vvassilev/callfuncbench.C+(1000000000). ```,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:390,energy efficiency,Draw,Draw,390,> here is the profile ran on RelWithDebInfo. [callgrind.out.10120.zip](https://github.com/root-project/root/files/9635004/callgrind.out.10120.zip). The result of callgrind_annotate on my machine complains it can find some of the source file and thus it can not aggregate the result. When I used KCacheGrind I get a little further but the result is still odd and all the calls under `TTree::Draw` I do not see any of the C++ calls I would expect (including calls to function in `TSelectorDraw` and `TFormLeafInfo`. (Maybe `libTreePlayer` was not recompiling in RelWithDebInfo). Also maybe compiling the script might help:. ```. root.exe -l -b -q /build/vvassilev/callfuncbench.C+(1000000000). ```,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:14,performance,profil,profile,14,> here is the profile ran on RelWithDebInfo. [callgrind.out.10120.zip](https://github.com/root-project/root/files/9635004/callgrind.out.10120.zip). The result of callgrind_annotate on my machine complains it can find some of the source file and thus it can not aggregate the result. When I used KCacheGrind I get a little further but the result is still odd and all the calls under `TTree::Draw` I do not see any of the C++ calls I would expect (including calls to function in `TSelectorDraw` and `TFormLeafInfo`. (Maybe `libTreePlayer` was not recompiling in RelWithDebInfo). Also maybe compiling the script might help:. ```. root.exe -l -b -q /build/vvassilev/callfuncbench.C+(1000000000). ```,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:195,safety,compl,complains,195,> here is the profile ran on RelWithDebInfo. [callgrind.out.10120.zip](https://github.com/root-project/root/files/9635004/callgrind.out.10120.zip). The result of callgrind_annotate on my machine complains it can find some of the source file and thus it can not aggregate the result. When I used KCacheGrind I get a little further but the result is still odd and all the calls under `TTree::Draw` I do not see any of the C++ calls I would expect (including calls to function in `TSelectorDraw` and `TFormLeafInfo`. (Maybe `libTreePlayer` was not recompiling in RelWithDebInfo). Also maybe compiling the script might help:. ```. root.exe -l -b -q /build/vvassilev/callfuncbench.C+(1000000000). ```,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:195,security,compl,complains,195,> here is the profile ran on RelWithDebInfo. [callgrind.out.10120.zip](https://github.com/root-project/root/files/9635004/callgrind.out.10120.zip). The result of callgrind_annotate on my machine complains it can find some of the source file and thus it can not aggregate the result. When I used KCacheGrind I get a little further but the result is still odd and all the calls under `TTree::Draw` I do not see any of the C++ calls I would expect (including calls to function in `TSelectorDraw` and `TFormLeafInfo`. (Maybe `libTreePlayer` was not recompiling in RelWithDebInfo). Also maybe compiling the script might help:. ```. root.exe -l -b -q /build/vvassilev/callfuncbench.C+(1000000000). ```,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:615,usability,help,help,615,> here is the profile ran on RelWithDebInfo. [callgrind.out.10120.zip](https://github.com/root-project/root/files/9635004/callgrind.out.10120.zip). The result of callgrind_annotate on my machine complains it can find some of the source file and thus it can not aggregate the result. When I used KCacheGrind I get a little further but the result is still odd and all the calls under `TTree::Draw` I do not see any of the C++ calls I would expect (including calls to function in `TSelectorDraw` and `TFormLeafInfo`. (Maybe `libTreePlayer` was not recompiling in RelWithDebInfo). Also maybe compiling the script might help:. ```. root.exe -l -b -q /build/vvassilev/callfuncbench.C+(1000000000). ```,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:668,deployability,build,build,668,> > here is the profile ran on RelWithDebInfo. [callgrind.out.10120.zip](https://github.com/root-project/root/files/9635004/callgrind.out.10120.zip). > . > The result of callgrind_annotate on my machine complains it can find some of the source file and thus it can not aggregate the result. When I used KCacheGrind I get a little further but the result is still odd and all the calls under `TTree::Draw` I do not see any of the C++ calls I would expect (including calls to function in `TSelectorDraw` and `TFormLeafInfo`. (Maybe `libTreePlayer` was not recompiling in RelWithDebInfo). > . > Also maybe compiling the script might help:. > . > ```. > root.exe -l -b -q /build/vvassilev/callfuncbench.C+(1000000000). > ```. Does not seem to produce anything different. I am attaching some flamegraphs but they don't really show anything either. The first one is from ACLiC (eg `root.exe -l -b -q /build/vvassilev/callfuncbench.C+(1000000000)`). ![callfunc_aclic](https://user-images.githubusercontent.com/6516307/192096191-20816795-219d-4aa0-96fe-5a4eddf25ef3.svg). ![callfunc](https://user-images.githubusercontent.com/6516307/192096193-079fa1db-4d0f-4f4a-8de9-8122a341788c.svg).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:894,deployability,build,build,894,> > here is the profile ran on RelWithDebInfo. [callgrind.out.10120.zip](https://github.com/root-project/root/files/9635004/callgrind.out.10120.zip). > . > The result of callgrind_annotate on my machine complains it can find some of the source file and thus it can not aggregate the result. When I used KCacheGrind I get a little further but the result is still odd and all the calls under `TTree::Draw` I do not see any of the C++ calls I would expect (including calls to function in `TSelectorDraw` and `TFormLeafInfo`. (Maybe `libTreePlayer` was not recompiling in RelWithDebInfo). > . > Also maybe compiling the script might help:. > . > ```. > root.exe -l -b -q /build/vvassilev/callfuncbench.C+(1000000000). > ```. Does not seem to produce anything different. I am attaching some flamegraphs but they don't really show anything either. The first one is from ACLiC (eg `root.exe -l -b -q /build/vvassilev/callfuncbench.C+(1000000000)`). ![callfunc_aclic](https://user-images.githubusercontent.com/6516307/192096191-20816795-219d-4aa0-96fe-5a4eddf25ef3.svg). ![callfunc](https://user-images.githubusercontent.com/6516307/192096193-079fa1db-4d0f-4f4a-8de9-8122a341788c.svg).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:16,energy efficiency,profil,profile,16,> > here is the profile ran on RelWithDebInfo. [callgrind.out.10120.zip](https://github.com/root-project/root/files/9635004/callgrind.out.10120.zip). > . > The result of callgrind_annotate on my machine complains it can find some of the source file and thus it can not aggregate the result. When I used KCacheGrind I get a little further but the result is still odd and all the calls under `TTree::Draw` I do not see any of the C++ calls I would expect (including calls to function in `TSelectorDraw` and `TFormLeafInfo`. (Maybe `libTreePlayer` was not recompiling in RelWithDebInfo). > . > Also maybe compiling the script might help:. > . > ```. > root.exe -l -b -q /build/vvassilev/callfuncbench.C+(1000000000). > ```. Does not seem to produce anything different. I am attaching some flamegraphs but they don't really show anything either. The first one is from ACLiC (eg `root.exe -l -b -q /build/vvassilev/callfuncbench.C+(1000000000)`). ![callfunc_aclic](https://user-images.githubusercontent.com/6516307/192096191-20816795-219d-4aa0-96fe-5a4eddf25ef3.svg). ![callfunc](https://user-images.githubusercontent.com/6516307/192096193-079fa1db-4d0f-4f4a-8de9-8122a341788c.svg).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:398,energy efficiency,Draw,Draw,398,> > here is the profile ran on RelWithDebInfo. [callgrind.out.10120.zip](https://github.com/root-project/root/files/9635004/callgrind.out.10120.zip). > . > The result of callgrind_annotate on my machine complains it can find some of the source file and thus it can not aggregate the result. When I used KCacheGrind I get a little further but the result is still odd and all the calls under `TTree::Draw` I do not see any of the C++ calls I would expect (including calls to function in `TSelectorDraw` and `TFormLeafInfo`. (Maybe `libTreePlayer` was not recompiling in RelWithDebInfo). > . > Also maybe compiling the script might help:. > . > ```. > root.exe -l -b -q /build/vvassilev/callfuncbench.C+(1000000000). > ```. Does not seem to produce anything different. I am attaching some flamegraphs but they don't really show anything either. The first one is from ACLiC (eg `root.exe -l -b -q /build/vvassilev/callfuncbench.C+(1000000000)`). ![callfunc_aclic](https://user-images.githubusercontent.com/6516307/192096191-20816795-219d-4aa0-96fe-5a4eddf25ef3.svg). ![callfunc](https://user-images.githubusercontent.com/6516307/192096193-079fa1db-4d0f-4f4a-8de9-8122a341788c.svg).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:16,performance,profil,profile,16,> > here is the profile ran on RelWithDebInfo. [callgrind.out.10120.zip](https://github.com/root-project/root/files/9635004/callgrind.out.10120.zip). > . > The result of callgrind_annotate on my machine complains it can find some of the source file and thus it can not aggregate the result. When I used KCacheGrind I get a little further but the result is still odd and all the calls under `TTree::Draw` I do not see any of the C++ calls I would expect (including calls to function in `TSelectorDraw` and `TFormLeafInfo`. (Maybe `libTreePlayer` was not recompiling in RelWithDebInfo). > . > Also maybe compiling the script might help:. > . > ```. > root.exe -l -b -q /build/vvassilev/callfuncbench.C+(1000000000). > ```. Does not seem to produce anything different. I am attaching some flamegraphs but they don't really show anything either. The first one is from ACLiC (eg `root.exe -l -b -q /build/vvassilev/callfuncbench.C+(1000000000)`). ![callfunc_aclic](https://user-images.githubusercontent.com/6516307/192096191-20816795-219d-4aa0-96fe-5a4eddf25ef3.svg). ![callfunc](https://user-images.githubusercontent.com/6516307/192096193-079fa1db-4d0f-4f4a-8de9-8122a341788c.svg).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:721,reliability,Doe,Does,721,> > here is the profile ran on RelWithDebInfo. [callgrind.out.10120.zip](https://github.com/root-project/root/files/9635004/callgrind.out.10120.zip). > . > The result of callgrind_annotate on my machine complains it can find some of the source file and thus it can not aggregate the result. When I used KCacheGrind I get a little further but the result is still odd and all the calls under `TTree::Draw` I do not see any of the C++ calls I would expect (including calls to function in `TSelectorDraw` and `TFormLeafInfo`. (Maybe `libTreePlayer` was not recompiling in RelWithDebInfo). > . > Also maybe compiling the script might help:. > . > ```. > root.exe -l -b -q /build/vvassilev/callfuncbench.C+(1000000000). > ```. Does not seem to produce anything different. I am attaching some flamegraphs but they don't really show anything either. The first one is from ACLiC (eg `root.exe -l -b -q /build/vvassilev/callfuncbench.C+(1000000000)`). ![callfunc_aclic](https://user-images.githubusercontent.com/6516307/192096191-20816795-219d-4aa0-96fe-5a4eddf25ef3.svg). ![callfunc](https://user-images.githubusercontent.com/6516307/192096193-079fa1db-4d0f-4f4a-8de9-8122a341788c.svg).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:203,safety,compl,complains,203,> > here is the profile ran on RelWithDebInfo. [callgrind.out.10120.zip](https://github.com/root-project/root/files/9635004/callgrind.out.10120.zip). > . > The result of callgrind_annotate on my machine complains it can find some of the source file and thus it can not aggregate the result. When I used KCacheGrind I get a little further but the result is still odd and all the calls under `TTree::Draw` I do not see any of the C++ calls I would expect (including calls to function in `TSelectorDraw` and `TFormLeafInfo`. (Maybe `libTreePlayer` was not recompiling in RelWithDebInfo). > . > Also maybe compiling the script might help:. > . > ```. > root.exe -l -b -q /build/vvassilev/callfuncbench.C+(1000000000). > ```. Does not seem to produce anything different. I am attaching some flamegraphs but they don't really show anything either. The first one is from ACLiC (eg `root.exe -l -b -q /build/vvassilev/callfuncbench.C+(1000000000)`). ![callfunc_aclic](https://user-images.githubusercontent.com/6516307/192096191-20816795-219d-4aa0-96fe-5a4eddf25ef3.svg). ![callfunc](https://user-images.githubusercontent.com/6516307/192096193-079fa1db-4d0f-4f4a-8de9-8122a341788c.svg).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:203,security,compl,complains,203,> > here is the profile ran on RelWithDebInfo. [callgrind.out.10120.zip](https://github.com/root-project/root/files/9635004/callgrind.out.10120.zip). > . > The result of callgrind_annotate on my machine complains it can find some of the source file and thus it can not aggregate the result. When I used KCacheGrind I get a little further but the result is still odd and all the calls under `TTree::Draw` I do not see any of the C++ calls I would expect (including calls to function in `TSelectorDraw` and `TFormLeafInfo`. (Maybe `libTreePlayer` was not recompiling in RelWithDebInfo). > . > Also maybe compiling the script might help:. > . > ```. > root.exe -l -b -q /build/vvassilev/callfuncbench.C+(1000000000). > ```. Does not seem to produce anything different. I am attaching some flamegraphs but they don't really show anything either. The first one is from ACLiC (eg `root.exe -l -b -q /build/vvassilev/callfuncbench.C+(1000000000)`). ![callfunc_aclic](https://user-images.githubusercontent.com/6516307/192096191-20816795-219d-4aa0-96fe-5a4eddf25ef3.svg). ![callfunc](https://user-images.githubusercontent.com/6516307/192096193-079fa1db-4d0f-4f4a-8de9-8122a341788c.svg).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:629,usability,help,help,629,> > here is the profile ran on RelWithDebInfo. [callgrind.out.10120.zip](https://github.com/root-project/root/files/9635004/callgrind.out.10120.zip). > . > The result of callgrind_annotate on my machine complains it can find some of the source file and thus it can not aggregate the result. When I used KCacheGrind I get a little further but the result is still odd and all the calls under `TTree::Draw` I do not see any of the C++ calls I would expect (including calls to function in `TSelectorDraw` and `TFormLeafInfo`. (Maybe `libTreePlayer` was not recompiling in RelWithDebInfo). > . > Also maybe compiling the script might help:. > . > ```. > root.exe -l -b -q /build/vvassilev/callfuncbench.C+(1000000000). > ```. Does not seem to produce anything different. I am attaching some flamegraphs but they don't really show anything either. The first one is from ACLiC (eg `root.exe -l -b -q /build/vvassilev/callfuncbench.C+(1000000000)`). ![callfunc_aclic](https://user-images.githubusercontent.com/6516307/192096191-20816795-219d-4aa0-96fe-5a4eddf25ef3.svg). ![callfunc](https://user-images.githubusercontent.com/6516307/192096193-079fa1db-4d0f-4f4a-8de9-8122a341788c.svg).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:968,usability,user,user-images,968,> > here is the profile ran on RelWithDebInfo. [callgrind.out.10120.zip](https://github.com/root-project/root/files/9635004/callgrind.out.10120.zip). > . > The result of callgrind_annotate on my machine complains it can find some of the source file and thus it can not aggregate the result. When I used KCacheGrind I get a little further but the result is still odd and all the calls under `TTree::Draw` I do not see any of the C++ calls I would expect (including calls to function in `TSelectorDraw` and `TFormLeafInfo`. (Maybe `libTreePlayer` was not recompiling in RelWithDebInfo). > . > Also maybe compiling the script might help:. > . > ```. > root.exe -l -b -q /build/vvassilev/callfuncbench.C+(1000000000). > ```. Does not seem to produce anything different. I am attaching some flamegraphs but they don't really show anything either. The first one is from ACLiC (eg `root.exe -l -b -q /build/vvassilev/callfuncbench.C+(1000000000)`). ![callfunc_aclic](https://user-images.githubusercontent.com/6516307/192096191-20816795-219d-4aa0-96fe-5a4eddf25ef3.svg). ![callfunc](https://user-images.githubusercontent.com/6516307/192096193-079fa1db-4d0f-4f4a-8de9-8122a341788c.svg).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:1083,usability,user,user-images,1083,> > here is the profile ran on RelWithDebInfo. [callgrind.out.10120.zip](https://github.com/root-project/root/files/9635004/callgrind.out.10120.zip). > . > The result of callgrind_annotate on my machine complains it can find some of the source file and thus it can not aggregate the result. When I used KCacheGrind I get a little further but the result is still odd and all the calls under `TTree::Draw` I do not see any of the C++ calls I would expect (including calls to function in `TSelectorDraw` and `TFormLeafInfo`. (Maybe `libTreePlayer` was not recompiling in RelWithDebInfo). > . > Also maybe compiling the script might help:. > . > ```. > root.exe -l -b -q /build/vvassilev/callfuncbench.C+(1000000000). > ```. Does not seem to produce anything different. I am attaching some flamegraphs but they don't really show anything either. The first one is from ACLiC (eg `root.exe -l -b -q /build/vvassilev/callfuncbench.C+(1000000000)`). ![callfunc_aclic](https://user-images.githubusercontent.com/6516307/192096191-20816795-219d-4aa0-96fe-5a4eddf25ef3.svg). ![callfunc](https://user-images.githubusercontent.com/6516307/192096193-079fa1db-4d0f-4f4a-8de9-8122a341788c.svg).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:71,deployability,version,version,71,So there is something odd with you combination of OS/compiler/valgrind version ... let me see if I can get more information locally.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:71,integrability,version,version,71,So there is something odd with you combination of OS/compiler/valgrind version ... let me see if I can get more information locally.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:71,modifiability,version,version,71,So there is something odd with you combination of OS/compiler/valgrind version ... let me see if I can get more information locally.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:353,availability,down,down,353,"My version of os/compiler/valgrind seems to work better and I got some useful information. For `root.exe -b -l -q callfuncbench.cxx+(1000)`. The new code is a big faster: `42,696,463,692` instead of `45,892,859,389`. Some of the calculation are shifted to `Value::Value`: `5,000,000,988` vs `3,100,001,703` (it grows by 2 billions when the overall goes down by 3 billions). The gains comes from the disappearance of `TClingCallFunc::InitRefAndExec` (minus 3.8 billions) and the simplifications of `std::function_handler (removed) and TClingCallFunc::exec` (minus 1.2 billions). So it is getting better and `Value::Value` is a potential source of further optimization (see related comment). [callgrind-callfund.tar.gz](https://github.com/root-project/root/files/9665974/callgrind-callfund.tar.gz).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3,deployability,version,version,3,"My version of os/compiler/valgrind seems to work better and I got some useful information. For `root.exe -b -l -q callfuncbench.cxx+(1000)`. The new code is a big faster: `42,696,463,692` instead of `45,892,859,389`. Some of the calculation are shifted to `Value::Value`: `5,000,000,988` vs `3,100,001,703` (it grows by 2 billions when the overall goes down by 3 billions). The gains comes from the disappearance of `TClingCallFunc::InitRefAndExec` (minus 3.8 billions) and the simplifications of `std::function_handler (removed) and TClingCallFunc::exec` (minus 1.2 billions). So it is getting better and `Value::Value` is a potential source of further optimization (see related comment). [callgrind-callfund.tar.gz](https://github.com/root-project/root/files/9665974/callgrind-callfund.tar.gz).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:654,energy efficiency,optim,optimization,654,"My version of os/compiler/valgrind seems to work better and I got some useful information. For `root.exe -b -l -q callfuncbench.cxx+(1000)`. The new code is a big faster: `42,696,463,692` instead of `45,892,859,389`. Some of the calculation are shifted to `Value::Value`: `5,000,000,988` vs `3,100,001,703` (it grows by 2 billions when the overall goes down by 3 billions). The gains comes from the disappearance of `TClingCallFunc::InitRefAndExec` (minus 3.8 billions) and the simplifications of `std::function_handler (removed) and TClingCallFunc::exec` (minus 1.2 billions). So it is getting better and `Value::Value` is a potential source of further optimization (see related comment). [callgrind-callfund.tar.gz](https://github.com/root-project/root/files/9665974/callgrind-callfund.tar.gz).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3,integrability,version,version,3,"My version of os/compiler/valgrind seems to work better and I got some useful information. For `root.exe -b -l -q callfuncbench.cxx+(1000)`. The new code is a big faster: `42,696,463,692` instead of `45,892,859,389`. Some of the calculation are shifted to `Value::Value`: `5,000,000,988` vs `3,100,001,703` (it grows by 2 billions when the overall goes down by 3 billions). The gains comes from the disappearance of `TClingCallFunc::InitRefAndExec` (minus 3.8 billions) and the simplifications of `std::function_handler (removed) and TClingCallFunc::exec` (minus 1.2 billions). So it is getting better and `Value::Value` is a potential source of further optimization (see related comment). [callgrind-callfund.tar.gz](https://github.com/root-project/root/files/9665974/callgrind-callfund.tar.gz).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:3,modifiability,version,version,3,"My version of os/compiler/valgrind seems to work better and I got some useful information. For `root.exe -b -l -q callfuncbench.cxx+(1000)`. The new code is a big faster: `42,696,463,692` instead of `45,892,859,389`. Some of the calculation are shifted to `Value::Value`: `5,000,000,988` vs `3,100,001,703` (it grows by 2 billions when the overall goes down by 3 billions). The gains comes from the disappearance of `TClingCallFunc::InitRefAndExec` (minus 3.8 billions) and the simplifications of `std::function_handler (removed) and TClingCallFunc::exec` (minus 1.2 billions). So it is getting better and `Value::Value` is a potential source of further optimization (see related comment). [callgrind-callfund.tar.gz](https://github.com/root-project/root/files/9665974/callgrind-callfund.tar.gz).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:654,performance,optimiz,optimization,654,"My version of os/compiler/valgrind seems to work better and I got some useful information. For `root.exe -b -l -q callfuncbench.cxx+(1000)`. The new code is a big faster: `42,696,463,692` instead of `45,892,859,389`. Some of the calculation are shifted to `Value::Value`: `5,000,000,988` vs `3,100,001,703` (it grows by 2 billions when the overall goes down by 3 billions). The gains comes from the disappearance of `TClingCallFunc::InitRefAndExec` (minus 3.8 billions) and the simplifications of `std::function_handler (removed) and TClingCallFunc::exec` (minus 1.2 billions). So it is getting better and `Value::Value` is a potential source of further optimization (see related comment). [callgrind-callfund.tar.gz](https://github.com/root-project/root/files/9665974/callgrind-callfund.tar.gz).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:478,testability,simpl,simplifications,478,"My version of os/compiler/valgrind seems to work better and I got some useful information. For `root.exe -b -l -q callfuncbench.cxx+(1000)`. The new code is a big faster: `42,696,463,692` instead of `45,892,859,389`. Some of the calculation are shifted to `Value::Value`: `5,000,000,988` vs `3,100,001,703` (it grows by 2 billions when the overall goes down by 3 billions). The gains comes from the disappearance of `TClingCallFunc::InitRefAndExec` (minus 3.8 billions) and the simplifications of `std::function_handler (removed) and TClingCallFunc::exec` (minus 1.2 billions). So it is getting better and `Value::Value` is a potential source of further optimization (see related comment). [callgrind-callfund.tar.gz](https://github.com/root-project/root/files/9665974/callgrind-callfund.tar.gz).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:478,usability,simpl,simplifications,478,"My version of os/compiler/valgrind seems to work better and I got some useful information. For `root.exe -b -l -q callfuncbench.cxx+(1000)`. The new code is a big faster: `42,696,463,692` instead of `45,892,859,389`. Some of the calculation are shifted to `Value::Value`: `5,000,000,988` vs `3,100,001,703` (it grows by 2 billions when the overall goes down by 3 billions). The gains comes from the disappearance of `TClingCallFunc::InitRefAndExec` (minus 3.8 billions) and the simplifications of `std::function_handler (removed) and TClingCallFunc::exec` (minus 1.2 billions). So it is getting better and `Value::Value` is a potential source of further optimization (see related comment). [callgrind-callfund.tar.gz](https://github.com/root-project/root/files/9665974/callgrind-callfund.tar.gz).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:373,availability,down,down,373,"> My version of os/compiler/valgrind seems to work better and I got some useful information. > . > For `root.exe -b -l -q callfuncbench.cxx+(1000)`. > . > The new code is a big faster: `42,696,463,692` instead of `45,892,859,389`. > . > Some of the calculation are shifted to `Value::Value`: `5,000,000,988` vs `3,100,001,703` (it grows by 2 billions when the overall goes down by 3 billions). > . > The gains comes from the disappearance of `TClingCallFunc::InitRefAndExec` (minus 3.8 billions) and the simplifications of `std::function_handler (removed) and TClingCallFunc::exec` (minus 1.2 billions). > . > So it is getting better and `Value::Value` is a potential source of further optimization (see related comment). > . > [callgrind-callfund.tar.gz](https://github.com/root-project/root/files/9665974/callgrind-callfund.tar.gz). Thanks for the details. I've pushed the further optimization of `Value::Value`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5,deployability,version,version,5,"> My version of os/compiler/valgrind seems to work better and I got some useful information. > . > For `root.exe -b -l -q callfuncbench.cxx+(1000)`. > . > The new code is a big faster: `42,696,463,692` instead of `45,892,859,389`. > . > Some of the calculation are shifted to `Value::Value`: `5,000,000,988` vs `3,100,001,703` (it grows by 2 billions when the overall goes down by 3 billions). > . > The gains comes from the disappearance of `TClingCallFunc::InitRefAndExec` (minus 3.8 billions) and the simplifications of `std::function_handler (removed) and TClingCallFunc::exec` (minus 1.2 billions). > . > So it is getting better and `Value::Value` is a potential source of further optimization (see related comment). > . > [callgrind-callfund.tar.gz](https://github.com/root-project/root/files/9665974/callgrind-callfund.tar.gz). Thanks for the details. I've pushed the further optimization of `Value::Value`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:686,energy efficiency,optim,optimization,686,"> My version of os/compiler/valgrind seems to work better and I got some useful information. > . > For `root.exe -b -l -q callfuncbench.cxx+(1000)`. > . > The new code is a big faster: `42,696,463,692` instead of `45,892,859,389`. > . > Some of the calculation are shifted to `Value::Value`: `5,000,000,988` vs `3,100,001,703` (it grows by 2 billions when the overall goes down by 3 billions). > . > The gains comes from the disappearance of `TClingCallFunc::InitRefAndExec` (minus 3.8 billions) and the simplifications of `std::function_handler (removed) and TClingCallFunc::exec` (minus 1.2 billions). > . > So it is getting better and `Value::Value` is a potential source of further optimization (see related comment). > . > [callgrind-callfund.tar.gz](https://github.com/root-project/root/files/9665974/callgrind-callfund.tar.gz). Thanks for the details. I've pushed the further optimization of `Value::Value`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:883,energy efficiency,optim,optimization,883,"> My version of os/compiler/valgrind seems to work better and I got some useful information. > . > For `root.exe -b -l -q callfuncbench.cxx+(1000)`. > . > The new code is a big faster: `42,696,463,692` instead of `45,892,859,389`. > . > Some of the calculation are shifted to `Value::Value`: `5,000,000,988` vs `3,100,001,703` (it grows by 2 billions when the overall goes down by 3 billions). > . > The gains comes from the disappearance of `TClingCallFunc::InitRefAndExec` (minus 3.8 billions) and the simplifications of `std::function_handler (removed) and TClingCallFunc::exec` (minus 1.2 billions). > . > So it is getting better and `Value::Value` is a potential source of further optimization (see related comment). > . > [callgrind-callfund.tar.gz](https://github.com/root-project/root/files/9665974/callgrind-callfund.tar.gz). Thanks for the details. I've pushed the further optimization of `Value::Value`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5,integrability,version,version,5,"> My version of os/compiler/valgrind seems to work better and I got some useful information. > . > For `root.exe -b -l -q callfuncbench.cxx+(1000)`. > . > The new code is a big faster: `42,696,463,692` instead of `45,892,859,389`. > . > Some of the calculation are shifted to `Value::Value`: `5,000,000,988` vs `3,100,001,703` (it grows by 2 billions when the overall goes down by 3 billions). > . > The gains comes from the disappearance of `TClingCallFunc::InitRefAndExec` (minus 3.8 billions) and the simplifications of `std::function_handler (removed) and TClingCallFunc::exec` (minus 1.2 billions). > . > So it is getting better and `Value::Value` is a potential source of further optimization (see related comment). > . > [callgrind-callfund.tar.gz](https://github.com/root-project/root/files/9665974/callgrind-callfund.tar.gz). Thanks for the details. I've pushed the further optimization of `Value::Value`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:5,modifiability,version,version,5,"> My version of os/compiler/valgrind seems to work better and I got some useful information. > . > For `root.exe -b -l -q callfuncbench.cxx+(1000)`. > . > The new code is a big faster: `42,696,463,692` instead of `45,892,859,389`. > . > Some of the calculation are shifted to `Value::Value`: `5,000,000,988` vs `3,100,001,703` (it grows by 2 billions when the overall goes down by 3 billions). > . > The gains comes from the disappearance of `TClingCallFunc::InitRefAndExec` (minus 3.8 billions) and the simplifications of `std::function_handler (removed) and TClingCallFunc::exec` (minus 1.2 billions). > . > So it is getting better and `Value::Value` is a potential source of further optimization (see related comment). > . > [callgrind-callfund.tar.gz](https://github.com/root-project/root/files/9665974/callgrind-callfund.tar.gz). Thanks for the details. I've pushed the further optimization of `Value::Value`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:686,performance,optimiz,optimization,686,"> My version of os/compiler/valgrind seems to work better and I got some useful information. > . > For `root.exe -b -l -q callfuncbench.cxx+(1000)`. > . > The new code is a big faster: `42,696,463,692` instead of `45,892,859,389`. > . > Some of the calculation are shifted to `Value::Value`: `5,000,000,988` vs `3,100,001,703` (it grows by 2 billions when the overall goes down by 3 billions). > . > The gains comes from the disappearance of `TClingCallFunc::InitRefAndExec` (minus 3.8 billions) and the simplifications of `std::function_handler (removed) and TClingCallFunc::exec` (minus 1.2 billions). > . > So it is getting better and `Value::Value` is a potential source of further optimization (see related comment). > . > [callgrind-callfund.tar.gz](https://github.com/root-project/root/files/9665974/callgrind-callfund.tar.gz). Thanks for the details. I've pushed the further optimization of `Value::Value`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:883,performance,optimiz,optimization,883,"> My version of os/compiler/valgrind seems to work better and I got some useful information. > . > For `root.exe -b -l -q callfuncbench.cxx+(1000)`. > . > The new code is a big faster: `42,696,463,692` instead of `45,892,859,389`. > . > Some of the calculation are shifted to `Value::Value`: `5,000,000,988` vs `3,100,001,703` (it grows by 2 billions when the overall goes down by 3 billions). > . > The gains comes from the disappearance of `TClingCallFunc::InitRefAndExec` (minus 3.8 billions) and the simplifications of `std::function_handler (removed) and TClingCallFunc::exec` (minus 1.2 billions). > . > So it is getting better and `Value::Value` is a potential source of further optimization (see related comment). > . > [callgrind-callfund.tar.gz](https://github.com/root-project/root/files/9665974/callgrind-callfund.tar.gz). Thanks for the details. I've pushed the further optimization of `Value::Value`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:504,testability,simpl,simplifications,504,"> My version of os/compiler/valgrind seems to work better and I got some useful information. > . > For `root.exe -b -l -q callfuncbench.cxx+(1000)`. > . > The new code is a big faster: `42,696,463,692` instead of `45,892,859,389`. > . > Some of the calculation are shifted to `Value::Value`: `5,000,000,988` vs `3,100,001,703` (it grows by 2 billions when the overall goes down by 3 billions). > . > The gains comes from the disappearance of `TClingCallFunc::InitRefAndExec` (minus 3.8 billions) and the simplifications of `std::function_handler (removed) and TClingCallFunc::exec` (minus 1.2 billions). > . > So it is getting better and `Value::Value` is a potential source of further optimization (see related comment). > . > [callgrind-callfund.tar.gz](https://github.com/root-project/root/files/9665974/callgrind-callfund.tar.gz). Thanks for the details. I've pushed the further optimization of `Value::Value`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:504,usability,simpl,simplifications,504,"> My version of os/compiler/valgrind seems to work better and I got some useful information. > . > For `root.exe -b -l -q callfuncbench.cxx+(1000)`. > . > The new code is a big faster: `42,696,463,692` instead of `45,892,859,389`. > . > Some of the calculation are shifted to `Value::Value`: `5,000,000,988` vs `3,100,001,703` (it grows by 2 billions when the overall goes down by 3 billions). > . > The gains comes from the disappearance of `TClingCallFunc::InitRefAndExec` (minus 3.8 billions) and the simplifications of `std::function_handler (removed) and TClingCallFunc::exec` (minus 1.2 billions). > . > So it is getting better and `Value::Value` is a potential source of further optimization (see related comment). > . > [callgrind-callfund.tar.gz](https://github.com/root-project/root/files/9665974/callgrind-callfund.tar.gz). Thanks for the details. I've pushed the further optimization of `Value::Value`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:369,availability,down,down,369,"> > My version of os/compiler/valgrind seems to work better and I got some useful information. > > For `root.exe -b -l -q callfuncbench.cxx+(1000)`. > > The new code is a big faster: `42,696,463,692` instead of `45,892,859,389`. > > Some of the calculation are shifted to `Value::Value`: `5,000,000,988` vs `3,100,001,703` (it grows by 2 billions when the overall goes down by 3 billions). > > The gains comes from the disappearance of `TClingCallFunc::InitRefAndExec` (minus 3.8 billions) and the simplifications of `std::function_handler (removed) and TClingCallFunc::exec` (minus 1.2 billions). > > So it is getting better and `Value::Value` is a potential source of further optimization (see related comment). > > [callgrind-callfund.tar.gz](https://github.com/root-project/root/files/9665974/callgrind-callfund.tar.gz). > . > Thanks for the details. I've pushed the further optimization of `Value::Value`. Can you remeasure?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:7,deployability,version,version,7,"> > My version of os/compiler/valgrind seems to work better and I got some useful information. > > For `root.exe -b -l -q callfuncbench.cxx+(1000)`. > > The new code is a big faster: `42,696,463,692` instead of `45,892,859,389`. > > Some of the calculation are shifted to `Value::Value`: `5,000,000,988` vs `3,100,001,703` (it grows by 2 billions when the overall goes down by 3 billions). > > The gains comes from the disappearance of `TClingCallFunc::InitRefAndExec` (minus 3.8 billions) and the simplifications of `std::function_handler (removed) and TClingCallFunc::exec` (minus 1.2 billions). > > So it is getting better and `Value::Value` is a potential source of further optimization (see related comment). > > [callgrind-callfund.tar.gz](https://github.com/root-project/root/files/9665974/callgrind-callfund.tar.gz). > . > Thanks for the details. I've pushed the further optimization of `Value::Value`. Can you remeasure?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:678,energy efficiency,optim,optimization,678,"> > My version of os/compiler/valgrind seems to work better and I got some useful information. > > For `root.exe -b -l -q callfuncbench.cxx+(1000)`. > > The new code is a big faster: `42,696,463,692` instead of `45,892,859,389`. > > Some of the calculation are shifted to `Value::Value`: `5,000,000,988` vs `3,100,001,703` (it grows by 2 billions when the overall goes down by 3 billions). > > The gains comes from the disappearance of `TClingCallFunc::InitRefAndExec` (minus 3.8 billions) and the simplifications of `std::function_handler (removed) and TClingCallFunc::exec` (minus 1.2 billions). > > So it is getting better and `Value::Value` is a potential source of further optimization (see related comment). > > [callgrind-callfund.tar.gz](https://github.com/root-project/root/files/9665974/callgrind-callfund.tar.gz). > . > Thanks for the details. I've pushed the further optimization of `Value::Value`. Can you remeasure?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:879,energy efficiency,optim,optimization,879,"> > My version of os/compiler/valgrind seems to work better and I got some useful information. > > For `root.exe -b -l -q callfuncbench.cxx+(1000)`. > > The new code is a big faster: `42,696,463,692` instead of `45,892,859,389`. > > Some of the calculation are shifted to `Value::Value`: `5,000,000,988` vs `3,100,001,703` (it grows by 2 billions when the overall goes down by 3 billions). > > The gains comes from the disappearance of `TClingCallFunc::InitRefAndExec` (minus 3.8 billions) and the simplifications of `std::function_handler (removed) and TClingCallFunc::exec` (minus 1.2 billions). > > So it is getting better and `Value::Value` is a potential source of further optimization (see related comment). > > [callgrind-callfund.tar.gz](https://github.com/root-project/root/files/9665974/callgrind-callfund.tar.gz). > . > Thanks for the details. I've pushed the further optimization of `Value::Value`. Can you remeasure?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:7,integrability,version,version,7,"> > My version of os/compiler/valgrind seems to work better and I got some useful information. > > For `root.exe -b -l -q callfuncbench.cxx+(1000)`. > > The new code is a big faster: `42,696,463,692` instead of `45,892,859,389`. > > Some of the calculation are shifted to `Value::Value`: `5,000,000,988` vs `3,100,001,703` (it grows by 2 billions when the overall goes down by 3 billions). > > The gains comes from the disappearance of `TClingCallFunc::InitRefAndExec` (minus 3.8 billions) and the simplifications of `std::function_handler (removed) and TClingCallFunc::exec` (minus 1.2 billions). > > So it is getting better and `Value::Value` is a potential source of further optimization (see related comment). > > [callgrind-callfund.tar.gz](https://github.com/root-project/root/files/9665974/callgrind-callfund.tar.gz). > . > Thanks for the details. I've pushed the further optimization of `Value::Value`. Can you remeasure?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:7,modifiability,version,version,7,"> > My version of os/compiler/valgrind seems to work better and I got some useful information. > > For `root.exe -b -l -q callfuncbench.cxx+(1000)`. > > The new code is a big faster: `42,696,463,692` instead of `45,892,859,389`. > > Some of the calculation are shifted to `Value::Value`: `5,000,000,988` vs `3,100,001,703` (it grows by 2 billions when the overall goes down by 3 billions). > > The gains comes from the disappearance of `TClingCallFunc::InitRefAndExec` (minus 3.8 billions) and the simplifications of `std::function_handler (removed) and TClingCallFunc::exec` (minus 1.2 billions). > > So it is getting better and `Value::Value` is a potential source of further optimization (see related comment). > > [callgrind-callfund.tar.gz](https://github.com/root-project/root/files/9665974/callgrind-callfund.tar.gz). > . > Thanks for the details. I've pushed the further optimization of `Value::Value`. Can you remeasure?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:678,performance,optimiz,optimization,678,"> > My version of os/compiler/valgrind seems to work better and I got some useful information. > > For `root.exe -b -l -q callfuncbench.cxx+(1000)`. > > The new code is a big faster: `42,696,463,692` instead of `45,892,859,389`. > > Some of the calculation are shifted to `Value::Value`: `5,000,000,988` vs `3,100,001,703` (it grows by 2 billions when the overall goes down by 3 billions). > > The gains comes from the disappearance of `TClingCallFunc::InitRefAndExec` (minus 3.8 billions) and the simplifications of `std::function_handler (removed) and TClingCallFunc::exec` (minus 1.2 billions). > > So it is getting better and `Value::Value` is a potential source of further optimization (see related comment). > > [callgrind-callfund.tar.gz](https://github.com/root-project/root/files/9665974/callgrind-callfund.tar.gz). > . > Thanks for the details. I've pushed the further optimization of `Value::Value`. Can you remeasure?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:879,performance,optimiz,optimization,879,"> > My version of os/compiler/valgrind seems to work better and I got some useful information. > > For `root.exe -b -l -q callfuncbench.cxx+(1000)`. > > The new code is a big faster: `42,696,463,692` instead of `45,892,859,389`. > > Some of the calculation are shifted to `Value::Value`: `5,000,000,988` vs `3,100,001,703` (it grows by 2 billions when the overall goes down by 3 billions). > > The gains comes from the disappearance of `TClingCallFunc::InitRefAndExec` (minus 3.8 billions) and the simplifications of `std::function_handler (removed) and TClingCallFunc::exec` (minus 1.2 billions). > > So it is getting better and `Value::Value` is a potential source of further optimization (see related comment). > > [callgrind-callfund.tar.gz](https://github.com/root-project/root/files/9665974/callgrind-callfund.tar.gz). > . > Thanks for the details. I've pushed the further optimization of `Value::Value`. Can you remeasure?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:919,safety,reme,remeasure,919,"> > My version of os/compiler/valgrind seems to work better and I got some useful information. > > For `root.exe -b -l -q callfuncbench.cxx+(1000)`. > > The new code is a big faster: `42,696,463,692` instead of `45,892,859,389`. > > Some of the calculation are shifted to `Value::Value`: `5,000,000,988` vs `3,100,001,703` (it grows by 2 billions when the overall goes down by 3 billions). > > The gains comes from the disappearance of `TClingCallFunc::InitRefAndExec` (minus 3.8 billions) and the simplifications of `std::function_handler (removed) and TClingCallFunc::exec` (minus 1.2 billions). > > So it is getting better and `Value::Value` is a potential source of further optimization (see related comment). > > [callgrind-callfund.tar.gz](https://github.com/root-project/root/files/9665974/callgrind-callfund.tar.gz). > . > Thanks for the details. I've pushed the further optimization of `Value::Value`. Can you remeasure?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:498,testability,simpl,simplifications,498,"> > My version of os/compiler/valgrind seems to work better and I got some useful information. > > For `root.exe -b -l -q callfuncbench.cxx+(1000)`. > > The new code is a big faster: `42,696,463,692` instead of `45,892,859,389`. > > Some of the calculation are shifted to `Value::Value`: `5,000,000,988` vs `3,100,001,703` (it grows by 2 billions when the overall goes down by 3 billions). > > The gains comes from the disappearance of `TClingCallFunc::InitRefAndExec` (minus 3.8 billions) and the simplifications of `std::function_handler (removed) and TClingCallFunc::exec` (minus 1.2 billions). > > So it is getting better and `Value::Value` is a potential source of further optimization (see related comment). > > [callgrind-callfund.tar.gz](https://github.com/root-project/root/files/9665974/callgrind-callfund.tar.gz). > . > Thanks for the details. I've pushed the further optimization of `Value::Value`. Can you remeasure?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:498,usability,simpl,simplifications,498,"> > My version of os/compiler/valgrind seems to work better and I got some useful information. > > For `root.exe -b -l -q callfuncbench.cxx+(1000)`. > > The new code is a big faster: `42,696,463,692` instead of `45,892,859,389`. > > Some of the calculation are shifted to `Value::Value`: `5,000,000,988` vs `3,100,001,703` (it grows by 2 billions when the overall goes down by 3 billions). > > The gains comes from the disappearance of `TClingCallFunc::InitRefAndExec` (minus 3.8 billions) and the simplifications of `std::function_handler (removed) and TClingCallFunc::exec` (minus 1.2 billions). > > So it is getting better and `Value::Value` is a potential source of further optimization (see related comment). > > [callgrind-callfund.tar.gz](https://github.com/root-project/root/files/9665974/callgrind-callfund.tar.gz). > . > Thanks for the details. I've pushed the further optimization of `Value::Value`. Can you remeasure?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4,deployability,fail,failing,4,The failing tests seem to fail on other PRs as well.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:26,deployability,fail,fail,26,The failing tests seem to fail on other PRs as well.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4,reliability,fail,failing,4,The failing tests seem to fail on other PRs as well.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:26,reliability,fail,fail,26,The failing tests seem to fail on other PRs as well.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:12,safety,test,tests,12,The failing tests seem to fail on other PRs as well.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:12,testability,test,tests,12,The failing tests seem to fail on other PRs as well.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:8,performance,perform,performance,8,Lastest performance results indicates an addition 2.5%. [callgrind-callfunc-v2.tar.gz](https://github.com/root-project/root/files/9687253/callgrind-callfunc-v2.tar.gz).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:8,usability,perform,performance,8,Lastest performance results indicates an addition 2.5%. [callgrind-callfunc-v2.tar.gz](https://github.com/root-project/root/files/9687253/callgrind-callfunc-v2.tar.gz).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:28,usability,indicat,indicates,28,Lastest performance results indicates an addition 2.5%. [callgrind-callfunc-v2.tar.gz](https://github.com/root-project/root/files/9687253/callgrind-callfunc-v2.tar.gz).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:190,availability,slo,slower,190,> Lastest performance results indicates an addition 2.5%. > [callgrind-callfunc-v2.tar.gz](https://github.com/root-project/root/files/9687253/callgrind-callfunc-v2.tar.gz). Do you mean 2.5% slower than master?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:10,performance,perform,performance,10,> Lastest performance results indicates an addition 2.5%. > [callgrind-callfunc-v2.tar.gz](https://github.com/root-project/root/files/9687253/callgrind-callfunc-v2.tar.gz). Do you mean 2.5% slower than master?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:190,reliability,slo,slower,190,> Lastest performance results indicates an addition 2.5%. > [callgrind-callfunc-v2.tar.gz](https://github.com/root-project/root/files/9687253/callgrind-callfunc-v2.tar.gz). Do you mean 2.5% slower than master?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:10,usability,perform,performance,10,> Lastest performance results indicates an addition 2.5%. > [callgrind-callfunc-v2.tar.gz](https://github.com/root-project/root/files/9687253/callgrind-callfunc-v2.tar.gz). Do you mean 2.5% slower than master?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:30,usability,indicat,indicates,30,> Lastest performance results indicates an addition 2.5%. > [callgrind-callfunc-v2.tar.gz](https://github.com/root-project/root/files/9687253/callgrind-callfunc-v2.tar.gz). Do you mean 2.5% slower than master?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:23,performance,lock,lock,23,"Beside reinstating the lock, this is a long PR review and we ought to revisit all the comments and finalize them (@Axel-Naumann also need to look at some of the answers) by marking them as ""resolved"" once there is a satisfactory conclusion (for each individually).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:47,safety,review,review,47,"Beside reinstating the lock, this is a long PR review and we ought to revisit all the comments and finalize them (@Axel-Naumann also need to look at some of the answers) by marking them as ""resolved"" once there is a satisfactory conclusion (for each individually).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:23,security,lock,lock,23,"Beside reinstating the lock, this is a long PR review and we ought to revisit all the comments and finalize them (@Axel-Naumann also need to look at some of the answers) by marking them as ""resolved"" once there is a satisfactory conclusion (for each individually).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:47,testability,review,review,47,"Beside reinstating the lock, this is a long PR review and we ought to revisit all the comments and finalize them (@Axel-Naumann also need to look at some of the answers) by marking them as ""resolved"" once there is a satisfactory conclusion (for each individually).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:216,usability,satisfa,satisfactory,216,"Beside reinstating the lock, this is a long PR review and we ought to revisit all the comments and finalize them (@Axel-Naumann also need to look at some of the answers) by marking them as ""resolved"" once there is a satisfactory conclusion (for each individually).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:25,performance,lock,lock,25,"> Beside reinstating the lock, this is a long PR review and we ought to revisit all the comments and finalize them (@Axel-Naumann also need to look at some of the answers) by marking them as ""resolved"" once there is a satisfactory conclusion (for each individually). The lock is re-instated in `GetDecl`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:271,performance,lock,lock,271,"> Beside reinstating the lock, this is a long PR review and we ought to revisit all the comments and finalize them (@Axel-Naumann also need to look at some of the answers) by marking them as ""resolved"" once there is a satisfactory conclusion (for each individually). The lock is re-instated in `GetDecl`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:49,safety,review,review,49,"> Beside reinstating the lock, this is a long PR review and we ought to revisit all the comments and finalize them (@Axel-Naumann also need to look at some of the answers) by marking them as ""resolved"" once there is a satisfactory conclusion (for each individually). The lock is re-instated in `GetDecl`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:25,security,lock,lock,25,"> Beside reinstating the lock, this is a long PR review and we ought to revisit all the comments and finalize them (@Axel-Naumann also need to look at some of the answers) by marking them as ""resolved"" once there is a satisfactory conclusion (for each individually). The lock is re-instated in `GetDecl`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:271,security,lock,lock,271,"> Beside reinstating the lock, this is a long PR review and we ought to revisit all the comments and finalize them (@Axel-Naumann also need to look at some of the answers) by marking them as ""resolved"" once there is a satisfactory conclusion (for each individually). The lock is re-instated in `GetDecl`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:49,testability,review,review,49,"> Beside reinstating the lock, this is a long PR review and we ought to revisit all the comments and finalize them (@Axel-Naumann also need to look at some of the answers) by marking them as ""resolved"" once there is a satisfactory conclusion (for each individually). The lock is re-instated in `GetDecl`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:218,usability,satisfa,satisfactory,218,"> Beside reinstating the lock, this is a long PR review and we ought to revisit all the comments and finalize them (@Axel-Naumann also need to look at some of the answers) by marking them as ""resolved"" once there is a satisfactory conclusion (for each individually). The lock is re-instated in `GetDecl`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:290,availability,ping,ping,290,"> Beside reinstating the lock, this is a long PR review and we ought to revisit all the comments and finalize them (@Axel-Naumann also need to look at some of the answers) by marking them as ""resolved"" once there is a satisfactory conclusion (for each individually). @pcanal, @Axel-Naumann ping…",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:25,performance,lock,lock,25,"> Beside reinstating the lock, this is a long PR review and we ought to revisit all the comments and finalize them (@Axel-Naumann also need to look at some of the answers) by marking them as ""resolved"" once there is a satisfactory conclusion (for each individually). @pcanal, @Axel-Naumann ping…",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:49,safety,review,review,49,"> Beside reinstating the lock, this is a long PR review and we ought to revisit all the comments and finalize them (@Axel-Naumann also need to look at some of the answers) by marking them as ""resolved"" once there is a satisfactory conclusion (for each individually). @pcanal, @Axel-Naumann ping…",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:25,security,lock,lock,25,"> Beside reinstating the lock, this is a long PR review and we ought to revisit all the comments and finalize them (@Axel-Naumann also need to look at some of the answers) by marking them as ""resolved"" once there is a satisfactory conclusion (for each individually). @pcanal, @Axel-Naumann ping…",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:49,testability,review,review,49,"> Beside reinstating the lock, this is a long PR review and we ought to revisit all the comments and finalize them (@Axel-Naumann also need to look at some of the answers) by marking them as ""resolved"" once there is a satisfactory conclusion (for each individually). @pcanal, @Axel-Naumann ping…",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:218,usability,satisfa,satisfactory,218,"> Beside reinstating the lock, this is a long PR review and we ought to revisit all the comments and finalize them (@Axel-Naumann also need to look at some of the answers) by marking them as ""resolved"" once there is a satisfactory conclusion (for each individually). @pcanal, @Axel-Naumann ping…",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4,availability,failur,failures,4,The failures are present in other PRs and seem unrelated to this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4,deployability,fail,failures,4,The failures are present in other PRs and seem unrelated to this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4,performance,failur,failures,4,The failures are present in other PRs and seem unrelated to this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:4,reliability,fail,failures,4,The failures are present in other PRs and seem unrelated to this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:11,deployability,build,build,11,@phsft-bot build just on windows10/cxx14,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:11,deployability,build,build,11,@phsft-bot build just on windows10/cxx14,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6,availability,failur,failures,6,These failures seem unrelated. We have run successfully the test suite on windows last time. After that the changes were squashing the review comments into the relevant commit to keep good history.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6,deployability,fail,failures,6,These failures seem unrelated. We have run successfully the test suite on windows last time. After that the changes were squashing the review comments into the relevant commit to keep good history.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6,performance,failur,failures,6,These failures seem unrelated. We have run successfully the test suite on windows last time. After that the changes were squashing the review comments into the relevant commit to keep good history.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:87,performance,time,time,87,These failures seem unrelated. We have run successfully the test suite on windows last time. After that the changes were squashing the review comments into the relevant commit to keep good history.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:6,reliability,fail,failures,6,These failures seem unrelated. We have run successfully the test suite on windows last time. After that the changes were squashing the review comments into the relevant commit to keep good history.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:60,safety,test,test,60,These failures seem unrelated. We have run successfully the test suite on windows last time. After that the changes were squashing the review comments into the relevant commit to keep good history.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:135,safety,review,review,135,These failures seem unrelated. We have run successfully the test suite on windows last time. After that the changes were squashing the review comments into the relevant commit to keep good history.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:60,testability,test,test,60,These failures seem unrelated. We have run successfully the test suite on windows last time. After that the changes were squashing the review comments into the relevant commit to keep good history.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11252:135,testability,review,review,135,These failures seem unrelated. We have run successfully the test suite on windows last time. After that the changes were squashing the review comments into the relevant commit to keep good history.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11252
https://github.com/root-project/root/pull/11253:11,deployability,build,build,11,@phsft-bot build with flags -Dimt=OFF,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11253
https://github.com/root-project/root/pull/11254:781,availability,operat,operations,781,"Reverted the changes to the help text of `O` option. Kept other formatting changes, this is the current look of the help output. ```. OPTIONS:. -a Append to the output. -k Skip corrupt or non-existent files, do not exit. -T Do not merge Trees. -O Re-optimize basket size when merging TTree. -v Explicitly set the verbosity level: 0 request no output, 99 is the. default. -j Parallelize the execution in multiple processes. -dbg Parallelize the execution in multiple processes in debug mode (Does. not delete partial files stored inside working directory). -d Carry out the partial multiprocess execution in the specified. directory. -n Open at most 'maxopenedfiles' at once (use 0 to request to use the. system maximum). -cachesize Resize the prefetching cache use to speed up I/O operations(use 0 to. disable). -experimental-io-features Used with an argument provided, enables the corresponding experimental. feature for output trees. -f Gives the ability to specify the compression level of the target file. (by default 4). -fk Sets the target file to contain the baskets with the same compression. as the input files (unless -O is specified). Compresses the meta data. using the compression level specified in the first input or the. compression setting after fk (for example 206 when using -fk206). -ff The compression level use is the one specified in the first input. -f0 Do not compress the target file. -f6 Use compression level 6 (see TFile::SetCompressionSettings for the. supported range of values). TARGET Target file. SOURCES Source files. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11254
https://github.com/root-project/root/pull/11254:1054,deployability,contain,contain,1054,"Reverted the changes to the help text of `O` option. Kept other formatting changes, this is the current look of the help output. ```. OPTIONS:. -a Append to the output. -k Skip corrupt or non-existent files, do not exit. -T Do not merge Trees. -O Re-optimize basket size when merging TTree. -v Explicitly set the verbosity level: 0 request no output, 99 is the. default. -j Parallelize the execution in multiple processes. -dbg Parallelize the execution in multiple processes in debug mode (Does. not delete partial files stored inside working directory). -d Carry out the partial multiprocess execution in the specified. directory. -n Open at most 'maxopenedfiles' at once (use 0 to request to use the. system maximum). -cachesize Resize the prefetching cache use to speed up I/O operations(use 0 to. disable). -experimental-io-features Used with an argument provided, enables the corresponding experimental. feature for output trees. -f Gives the ability to specify the compression level of the target file. (by default 4). -fk Sets the target file to contain the baskets with the same compression. as the input files (unless -O is specified). Compresses the meta data. using the compression level specified in the first input or the. compression setting after fk (for example 206 when using -fk206). -ff The compression level use is the one specified in the first input. -f0 Do not compress the target file. -f6 Use compression level 6 (see TFile::SetCompressionSettings for the. supported range of values). TARGET Target file. SOURCES Source files. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11254
https://github.com/root-project/root/pull/11254:96,energy efficiency,current,current,96,"Reverted the changes to the help text of `O` option. Kept other formatting changes, this is the current look of the help output. ```. OPTIONS:. -a Append to the output. -k Skip corrupt or non-existent files, do not exit. -T Do not merge Trees. -O Re-optimize basket size when merging TTree. -v Explicitly set the verbosity level: 0 request no output, 99 is the. default. -j Parallelize the execution in multiple processes. -dbg Parallelize the execution in multiple processes in debug mode (Does. not delete partial files stored inside working directory). -d Carry out the partial multiprocess execution in the specified. directory. -n Open at most 'maxopenedfiles' at once (use 0 to request to use the. system maximum). -cachesize Resize the prefetching cache use to speed up I/O operations(use 0 to. disable). -experimental-io-features Used with an argument provided, enables the corresponding experimental. feature for output trees. -f Gives the ability to specify the compression level of the target file. (by default 4). -fk Sets the target file to contain the baskets with the same compression. as the input files (unless -O is specified). Compresses the meta data. using the compression level specified in the first input or the. compression setting after fk (for example 206 when using -fk206). -ff The compression level use is the one specified in the first input. -f0 Do not compress the target file. -f6 Use compression level 6 (see TFile::SetCompressionSettings for the. supported range of values). TARGET Target file. SOURCES Source files. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11254
https://github.com/root-project/root/pull/11254:250,energy efficiency,optim,optimize,250,"Reverted the changes to the help text of `O` option. Kept other formatting changes, this is the current look of the help output. ```. OPTIONS:. -a Append to the output. -k Skip corrupt or non-existent files, do not exit. -T Do not merge Trees. -O Re-optimize basket size when merging TTree. -v Explicitly set the verbosity level: 0 request no output, 99 is the. default. -j Parallelize the execution in multiple processes. -dbg Parallelize the execution in multiple processes in debug mode (Does. not delete partial files stored inside working directory). -d Carry out the partial multiprocess execution in the specified. directory. -n Open at most 'maxopenedfiles' at once (use 0 to request to use the. system maximum). -cachesize Resize the prefetching cache use to speed up I/O operations(use 0 to. disable). -experimental-io-features Used with an argument provided, enables the corresponding experimental. feature for output trees. -f Gives the ability to specify the compression level of the target file. (by default 4). -fk Sets the target file to contain the baskets with the same compression. as the input files (unless -O is specified). Compresses the meta data. using the compression level specified in the first input or the. compression setting after fk (for example 206 when using -fk206). -ff The compression level use is the one specified in the first input. -f0 Do not compress the target file. -f6 Use compression level 6 (see TFile::SetCompressionSettings for the. supported range of values). TARGET Target file. SOURCES Source files. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11254
https://github.com/root-project/root/pull/11254:64,interoperability,format,formatting,64,"Reverted the changes to the help text of `O` option. Kept other formatting changes, this is the current look of the help output. ```. OPTIONS:. -a Append to the output. -k Skip corrupt or non-existent files, do not exit. -T Do not merge Trees. -O Re-optimize basket size when merging TTree. -v Explicitly set the verbosity level: 0 request no output, 99 is the. default. -j Parallelize the execution in multiple processes. -dbg Parallelize the execution in multiple processes in debug mode (Does. not delete partial files stored inside working directory). -d Carry out the partial multiprocess execution in the specified. directory. -n Open at most 'maxopenedfiles' at once (use 0 to request to use the. system maximum). -cachesize Resize the prefetching cache use to speed up I/O operations(use 0 to. disable). -experimental-io-features Used with an argument provided, enables the corresponding experimental. feature for output trees. -f Gives the ability to specify the compression level of the target file. (by default 4). -fk Sets the target file to contain the baskets with the same compression. as the input files (unless -O is specified). Compresses the meta data. using the compression level specified in the first input or the. compression setting after fk (for example 206 when using -fk206). -ff The compression level use is the one specified in the first input. -f0 Do not compress the target file. -f6 Use compression level 6 (see TFile::SetCompressionSettings for the. supported range of values). TARGET Target file. SOURCES Source files. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11254
https://github.com/root-project/root/pull/11254:611,interoperability,specif,specified,611,"Reverted the changes to the help text of `O` option. Kept other formatting changes, this is the current look of the help output. ```. OPTIONS:. -a Append to the output. -k Skip corrupt or non-existent files, do not exit. -T Do not merge Trees. -O Re-optimize basket size when merging TTree. -v Explicitly set the verbosity level: 0 request no output, 99 is the. default. -j Parallelize the execution in multiple processes. -dbg Parallelize the execution in multiple processes in debug mode (Does. not delete partial files stored inside working directory). -d Carry out the partial multiprocess execution in the specified. directory. -n Open at most 'maxopenedfiles' at once (use 0 to request to use the. system maximum). -cachesize Resize the prefetching cache use to speed up I/O operations(use 0 to. disable). -experimental-io-features Used with an argument provided, enables the corresponding experimental. feature for output trees. -f Gives the ability to specify the compression level of the target file. (by default 4). -fk Sets the target file to contain the baskets with the same compression. as the input files (unless -O is specified). Compresses the meta data. using the compression level specified in the first input or the. compression setting after fk (for example 206 when using -fk206). -ff The compression level use is the one specified in the first input. -f0 Do not compress the target file. -f6 Use compression level 6 (see TFile::SetCompressionSettings for the. supported range of values). TARGET Target file. SOURCES Source files. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11254
https://github.com/root-project/root/pull/11254:960,interoperability,specif,specify,960,"Reverted the changes to the help text of `O` option. Kept other formatting changes, this is the current look of the help output. ```. OPTIONS:. -a Append to the output. -k Skip corrupt or non-existent files, do not exit. -T Do not merge Trees. -O Re-optimize basket size when merging TTree. -v Explicitly set the verbosity level: 0 request no output, 99 is the. default. -j Parallelize the execution in multiple processes. -dbg Parallelize the execution in multiple processes in debug mode (Does. not delete partial files stored inside working directory). -d Carry out the partial multiprocess execution in the specified. directory. -n Open at most 'maxopenedfiles' at once (use 0 to request to use the. system maximum). -cachesize Resize the prefetching cache use to speed up I/O operations(use 0 to. disable). -experimental-io-features Used with an argument provided, enables the corresponding experimental. feature for output trees. -f Gives the ability to specify the compression level of the target file. (by default 4). -fk Sets the target file to contain the baskets with the same compression. as the input files (unless -O is specified). Compresses the meta data. using the compression level specified in the first input or the. compression setting after fk (for example 206 when using -fk206). -ff The compression level use is the one specified in the first input. -f0 Do not compress the target file. -f6 Use compression level 6 (see TFile::SetCompressionSettings for the. supported range of values). TARGET Target file. SOURCES Source files. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11254
https://github.com/root-project/root/pull/11254:1134,interoperability,specif,specified,1134,"Reverted the changes to the help text of `O` option. Kept other formatting changes, this is the current look of the help output. ```. OPTIONS:. -a Append to the output. -k Skip corrupt or non-existent files, do not exit. -T Do not merge Trees. -O Re-optimize basket size when merging TTree. -v Explicitly set the verbosity level: 0 request no output, 99 is the. default. -j Parallelize the execution in multiple processes. -dbg Parallelize the execution in multiple processes in debug mode (Does. not delete partial files stored inside working directory). -d Carry out the partial multiprocess execution in the specified. directory. -n Open at most 'maxopenedfiles' at once (use 0 to request to use the. system maximum). -cachesize Resize the prefetching cache use to speed up I/O operations(use 0 to. disable). -experimental-io-features Used with an argument provided, enables the corresponding experimental. feature for output trees. -f Gives the ability to specify the compression level of the target file. (by default 4). -fk Sets the target file to contain the baskets with the same compression. as the input files (unless -O is specified). Compresses the meta data. using the compression level specified in the first input or the. compression setting after fk (for example 206 when using -fk206). -ff The compression level use is the one specified in the first input. -f0 Do not compress the target file. -f6 Use compression level 6 (see TFile::SetCompressionSettings for the. supported range of values). TARGET Target file. SOURCES Source files. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11254
https://github.com/root-project/root/pull/11254:1200,interoperability,specif,specified,1200,"Reverted the changes to the help text of `O` option. Kept other formatting changes, this is the current look of the help output. ```. OPTIONS:. -a Append to the output. -k Skip corrupt or non-existent files, do not exit. -T Do not merge Trees. -O Re-optimize basket size when merging TTree. -v Explicitly set the verbosity level: 0 request no output, 99 is the. default. -j Parallelize the execution in multiple processes. -dbg Parallelize the execution in multiple processes in debug mode (Does. not delete partial files stored inside working directory). -d Carry out the partial multiprocess execution in the specified. directory. -n Open at most 'maxopenedfiles' at once (use 0 to request to use the. system maximum). -cachesize Resize the prefetching cache use to speed up I/O operations(use 0 to. disable). -experimental-io-features Used with an argument provided, enables the corresponding experimental. feature for output trees. -f Gives the ability to specify the compression level of the target file. (by default 4). -fk Sets the target file to contain the baskets with the same compression. as the input files (unless -O is specified). Compresses the meta data. using the compression level specified in the first input or the. compression setting after fk (for example 206 when using -fk206). -ff The compression level use is the one specified in the first input. -f0 Do not compress the target file. -f6 Use compression level 6 (see TFile::SetCompressionSettings for the. supported range of values). TARGET Target file. SOURCES Source files. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11254
https://github.com/root-project/root/pull/11254:1344,interoperability,specif,specified,1344,"Reverted the changes to the help text of `O` option. Kept other formatting changes, this is the current look of the help output. ```. OPTIONS:. -a Append to the output. -k Skip corrupt or non-existent files, do not exit. -T Do not merge Trees. -O Re-optimize basket size when merging TTree. -v Explicitly set the verbosity level: 0 request no output, 99 is the. default. -j Parallelize the execution in multiple processes. -dbg Parallelize the execution in multiple processes in debug mode (Does. not delete partial files stored inside working directory). -d Carry out the partial multiprocess execution in the specified. directory. -n Open at most 'maxopenedfiles' at once (use 0 to request to use the. system maximum). -cachesize Resize the prefetching cache use to speed up I/O operations(use 0 to. disable). -experimental-io-features Used with an argument provided, enables the corresponding experimental. feature for output trees. -f Gives the ability to specify the compression level of the target file. (by default 4). -fk Sets the target file to contain the baskets with the same compression. as the input files (unless -O is specified). Compresses the meta data. using the compression level specified in the first input or the. compression setting after fk (for example 206 when using -fk206). -ff The compression level use is the one specified in the first input. -f0 Do not compress the target file. -f6 Use compression level 6 (see TFile::SetCompressionSettings for the. supported range of values). TARGET Target file. SOURCES Source files. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11254
https://github.com/root-project/root/pull/11254:250,performance,optimiz,optimize,250,"Reverted the changes to the help text of `O` option. Kept other formatting changes, this is the current look of the help output. ```. OPTIONS:. -a Append to the output. -k Skip corrupt or non-existent files, do not exit. -T Do not merge Trees. -O Re-optimize basket size when merging TTree. -v Explicitly set the verbosity level: 0 request no output, 99 is the. default. -j Parallelize the execution in multiple processes. -dbg Parallelize the execution in multiple processes in debug mode (Does. not delete partial files stored inside working directory). -d Carry out the partial multiprocess execution in the specified. directory. -n Open at most 'maxopenedfiles' at once (use 0 to request to use the. system maximum). -cachesize Resize the prefetching cache use to speed up I/O operations(use 0 to. disable). -experimental-io-features Used with an argument provided, enables the corresponding experimental. feature for output trees. -f Gives the ability to specify the compression level of the target file. (by default 4). -fk Sets the target file to contain the baskets with the same compression. as the input files (unless -O is specified). Compresses the meta data. using the compression level specified in the first input or the. compression setting after fk (for example 206 when using -fk206). -ff The compression level use is the one specified in the first input. -f0 Do not compress the target file. -f6 Use compression level 6 (see TFile::SetCompressionSettings for the. supported range of values). TARGET Target file. SOURCES Source files. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11254
https://github.com/root-project/root/pull/11254:374,performance,Parallel,Parallelize,374,"Reverted the changes to the help text of `O` option. Kept other formatting changes, this is the current look of the help output. ```. OPTIONS:. -a Append to the output. -k Skip corrupt or non-existent files, do not exit. -T Do not merge Trees. -O Re-optimize basket size when merging TTree. -v Explicitly set the verbosity level: 0 request no output, 99 is the. default. -j Parallelize the execution in multiple processes. -dbg Parallelize the execution in multiple processes in debug mode (Does. not delete partial files stored inside working directory). -d Carry out the partial multiprocess execution in the specified. directory. -n Open at most 'maxopenedfiles' at once (use 0 to request to use the. system maximum). -cachesize Resize the prefetching cache use to speed up I/O operations(use 0 to. disable). -experimental-io-features Used with an argument provided, enables the corresponding experimental. feature for output trees. -f Gives the ability to specify the compression level of the target file. (by default 4). -fk Sets the target file to contain the baskets with the same compression. as the input files (unless -O is specified). Compresses the meta data. using the compression level specified in the first input or the. compression setting after fk (for example 206 when using -fk206). -ff The compression level use is the one specified in the first input. -f0 Do not compress the target file. -f6 Use compression level 6 (see TFile::SetCompressionSettings for the. supported range of values). TARGET Target file. SOURCES Source files. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11254
https://github.com/root-project/root/pull/11254:428,performance,Parallel,Parallelize,428,"Reverted the changes to the help text of `O` option. Kept other formatting changes, this is the current look of the help output. ```. OPTIONS:. -a Append to the output. -k Skip corrupt or non-existent files, do not exit. -T Do not merge Trees. -O Re-optimize basket size when merging TTree. -v Explicitly set the verbosity level: 0 request no output, 99 is the. default. -j Parallelize the execution in multiple processes. -dbg Parallelize the execution in multiple processes in debug mode (Does. not delete partial files stored inside working directory). -d Carry out the partial multiprocess execution in the specified. directory. -n Open at most 'maxopenedfiles' at once (use 0 to request to use the. system maximum). -cachesize Resize the prefetching cache use to speed up I/O operations(use 0 to. disable). -experimental-io-features Used with an argument provided, enables the corresponding experimental. feature for output trees. -f Gives the ability to specify the compression level of the target file. (by default 4). -fk Sets the target file to contain the baskets with the same compression. as the input files (unless -O is specified). Compresses the meta data. using the compression level specified in the first input or the. compression setting after fk (for example 206 when using -fk206). -ff The compression level use is the one specified in the first input. -f0 Do not compress the target file. -f6 Use compression level 6 (see TFile::SetCompressionSettings for the. supported range of values). TARGET Target file. SOURCES Source files. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11254
https://github.com/root-project/root/pull/11254:722,performance,cach,cachesize,722,"Reverted the changes to the help text of `O` option. Kept other formatting changes, this is the current look of the help output. ```. OPTIONS:. -a Append to the output. -k Skip corrupt or non-existent files, do not exit. -T Do not merge Trees. -O Re-optimize basket size when merging TTree. -v Explicitly set the verbosity level: 0 request no output, 99 is the. default. -j Parallelize the execution in multiple processes. -dbg Parallelize the execution in multiple processes in debug mode (Does. not delete partial files stored inside working directory). -d Carry out the partial multiprocess execution in the specified. directory. -n Open at most 'maxopenedfiles' at once (use 0 to request to use the. system maximum). -cachesize Resize the prefetching cache use to speed up I/O operations(use 0 to. disable). -experimental-io-features Used with an argument provided, enables the corresponding experimental. feature for output trees. -f Gives the ability to specify the compression level of the target file. (by default 4). -fk Sets the target file to contain the baskets with the same compression. as the input files (unless -O is specified). Compresses the meta data. using the compression level specified in the first input or the. compression setting after fk (for example 206 when using -fk206). -ff The compression level use is the one specified in the first input. -f0 Do not compress the target file. -f6 Use compression level 6 (see TFile::SetCompressionSettings for the. supported range of values). TARGET Target file. SOURCES Source files. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11254
https://github.com/root-project/root/pull/11254:755,performance,cach,cache,755,"Reverted the changes to the help text of `O` option. Kept other formatting changes, this is the current look of the help output. ```. OPTIONS:. -a Append to the output. -k Skip corrupt or non-existent files, do not exit. -T Do not merge Trees. -O Re-optimize basket size when merging TTree. -v Explicitly set the verbosity level: 0 request no output, 99 is the. default. -j Parallelize the execution in multiple processes. -dbg Parallelize the execution in multiple processes in debug mode (Does. not delete partial files stored inside working directory). -d Carry out the partial multiprocess execution in the specified. directory. -n Open at most 'maxopenedfiles' at once (use 0 to request to use the. system maximum). -cachesize Resize the prefetching cache use to speed up I/O operations(use 0 to. disable). -experimental-io-features Used with an argument provided, enables the corresponding experimental. feature for output trees. -f Gives the ability to specify the compression level of the target file. (by default 4). -fk Sets the target file to contain the baskets with the same compression. as the input files (unless -O is specified). Compresses the meta data. using the compression level specified in the first input or the. compression setting after fk (for example 206 when using -fk206). -ff The compression level use is the one specified in the first input. -f0 Do not compress the target file. -f6 Use compression level 6 (see TFile::SetCompressionSettings for the. supported range of values). TARGET Target file. SOURCES Source files. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11254
https://github.com/root-project/root/pull/11254:777,performance,I/O,I/O,777,"Reverted the changes to the help text of `O` option. Kept other formatting changes, this is the current look of the help output. ```. OPTIONS:. -a Append to the output. -k Skip corrupt or non-existent files, do not exit. -T Do not merge Trees. -O Re-optimize basket size when merging TTree. -v Explicitly set the verbosity level: 0 request no output, 99 is the. default. -j Parallelize the execution in multiple processes. -dbg Parallelize the execution in multiple processes in debug mode (Does. not delete partial files stored inside working directory). -d Carry out the partial multiprocess execution in the specified. directory. -n Open at most 'maxopenedfiles' at once (use 0 to request to use the. system maximum). -cachesize Resize the prefetching cache use to speed up I/O operations(use 0 to. disable). -experimental-io-features Used with an argument provided, enables the corresponding experimental. feature for output trees. -f Gives the ability to specify the compression level of the target file. (by default 4). -fk Sets the target file to contain the baskets with the same compression. as the input files (unless -O is specified). Compresses the meta data. using the compression level specified in the first input or the. compression setting after fk (for example 206 when using -fk206). -ff The compression level use is the one specified in the first input. -f0 Do not compress the target file. -f6 Use compression level 6 (see TFile::SetCompressionSettings for the. supported range of values). TARGET Target file. SOURCES Source files. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11254
https://github.com/root-project/root/pull/11254:491,reliability,Doe,Does,491,"Reverted the changes to the help text of `O` option. Kept other formatting changes, this is the current look of the help output. ```. OPTIONS:. -a Append to the output. -k Skip corrupt or non-existent files, do not exit. -T Do not merge Trees. -O Re-optimize basket size when merging TTree. -v Explicitly set the verbosity level: 0 request no output, 99 is the. default. -j Parallelize the execution in multiple processes. -dbg Parallelize the execution in multiple processes in debug mode (Does. not delete partial files stored inside working directory). -d Carry out the partial multiprocess execution in the specified. directory. -n Open at most 'maxopenedfiles' at once (use 0 to request to use the. system maximum). -cachesize Resize the prefetching cache use to speed up I/O operations(use 0 to. disable). -experimental-io-features Used with an argument provided, enables the corresponding experimental. feature for output trees. -f Gives the ability to specify the compression level of the target file. (by default 4). -fk Sets the target file to contain the baskets with the same compression. as the input files (unless -O is specified). Compresses the meta data. using the compression level specified in the first input or the. compression setting after fk (for example 206 when using -fk206). -ff The compression level use is the one specified in the first input. -f0 Do not compress the target file. -f6 Use compression level 6 (see TFile::SetCompressionSettings for the. supported range of values). TARGET Target file. SOURCES Source files. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11254
https://github.com/root-project/root/pull/11254:1108,safety,input,input,1108,"Reverted the changes to the help text of `O` option. Kept other formatting changes, this is the current look of the help output. ```. OPTIONS:. -a Append to the output. -k Skip corrupt or non-existent files, do not exit. -T Do not merge Trees. -O Re-optimize basket size when merging TTree. -v Explicitly set the verbosity level: 0 request no output, 99 is the. default. -j Parallelize the execution in multiple processes. -dbg Parallelize the execution in multiple processes in debug mode (Does. not delete partial files stored inside working directory). -d Carry out the partial multiprocess execution in the specified. directory. -n Open at most 'maxopenedfiles' at once (use 0 to request to use the. system maximum). -cachesize Resize the prefetching cache use to speed up I/O operations(use 0 to. disable). -experimental-io-features Used with an argument provided, enables the corresponding experimental. feature for output trees. -f Gives the ability to specify the compression level of the target file. (by default 4). -fk Sets the target file to contain the baskets with the same compression. as the input files (unless -O is specified). Compresses the meta data. using the compression level specified in the first input or the. compression setting after fk (for example 206 when using -fk206). -ff The compression level use is the one specified in the first input. -f0 Do not compress the target file. -f6 Use compression level 6 (see TFile::SetCompressionSettings for the. supported range of values). TARGET Target file. SOURCES Source files. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11254
https://github.com/root-project/root/pull/11254:1223,safety,input,input,1223,"Reverted the changes to the help text of `O` option. Kept other formatting changes, this is the current look of the help output. ```. OPTIONS:. -a Append to the output. -k Skip corrupt or non-existent files, do not exit. -T Do not merge Trees. -O Re-optimize basket size when merging TTree. -v Explicitly set the verbosity level: 0 request no output, 99 is the. default. -j Parallelize the execution in multiple processes. -dbg Parallelize the execution in multiple processes in debug mode (Does. not delete partial files stored inside working directory). -d Carry out the partial multiprocess execution in the specified. directory. -n Open at most 'maxopenedfiles' at once (use 0 to request to use the. system maximum). -cachesize Resize the prefetching cache use to speed up I/O operations(use 0 to. disable). -experimental-io-features Used with an argument provided, enables the corresponding experimental. feature for output trees. -f Gives the ability to specify the compression level of the target file. (by default 4). -fk Sets the target file to contain the baskets with the same compression. as the input files (unless -O is specified). Compresses the meta data. using the compression level specified in the first input or the. compression setting after fk (for example 206 when using -fk206). -ff The compression level use is the one specified in the first input. -f0 Do not compress the target file. -f6 Use compression level 6 (see TFile::SetCompressionSettings for the. supported range of values). TARGET Target file. SOURCES Source files. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11254
https://github.com/root-project/root/pull/11254:1367,safety,input,input,1367,"Reverted the changes to the help text of `O` option. Kept other formatting changes, this is the current look of the help output. ```. OPTIONS:. -a Append to the output. -k Skip corrupt or non-existent files, do not exit. -T Do not merge Trees. -O Re-optimize basket size when merging TTree. -v Explicitly set the verbosity level: 0 request no output, 99 is the. default. -j Parallelize the execution in multiple processes. -dbg Parallelize the execution in multiple processes in debug mode (Does. not delete partial files stored inside working directory). -d Carry out the partial multiprocess execution in the specified. directory. -n Open at most 'maxopenedfiles' at once (use 0 to request to use the. system maximum). -cachesize Resize the prefetching cache use to speed up I/O operations(use 0 to. disable). -experimental-io-features Used with an argument provided, enables the corresponding experimental. feature for output trees. -f Gives the ability to specify the compression level of the target file. (by default 4). -fk Sets the target file to contain the baskets with the same compression. as the input files (unless -O is specified). Compresses the meta data. using the compression level specified in the first input or the. compression setting after fk (for example 206 when using -fk206). -ff The compression level use is the one specified in the first input. -f0 Do not compress the target file. -f6 Use compression level 6 (see TFile::SetCompressionSettings for the. supported range of values). TARGET Target file. SOURCES Source files. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11254
https://github.com/root-project/root/pull/11254:28,usability,help,help,28,"Reverted the changes to the help text of `O` option. Kept other formatting changes, this is the current look of the help output. ```. OPTIONS:. -a Append to the output. -k Skip corrupt or non-existent files, do not exit. -T Do not merge Trees. -O Re-optimize basket size when merging TTree. -v Explicitly set the verbosity level: 0 request no output, 99 is the. default. -j Parallelize the execution in multiple processes. -dbg Parallelize the execution in multiple processes in debug mode (Does. not delete partial files stored inside working directory). -d Carry out the partial multiprocess execution in the specified. directory. -n Open at most 'maxopenedfiles' at once (use 0 to request to use the. system maximum). -cachesize Resize the prefetching cache use to speed up I/O operations(use 0 to. disable). -experimental-io-features Used with an argument provided, enables the corresponding experimental. feature for output trees. -f Gives the ability to specify the compression level of the target file. (by default 4). -fk Sets the target file to contain the baskets with the same compression. as the input files (unless -O is specified). Compresses the meta data. using the compression level specified in the first input or the. compression setting after fk (for example 206 when using -fk206). -ff The compression level use is the one specified in the first input. -f0 Do not compress the target file. -f6 Use compression level 6 (see TFile::SetCompressionSettings for the. supported range of values). TARGET Target file. SOURCES Source files. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11254
https://github.com/root-project/root/pull/11254:116,usability,help,help,116,"Reverted the changes to the help text of `O` option. Kept other formatting changes, this is the current look of the help output. ```. OPTIONS:. -a Append to the output. -k Skip corrupt or non-existent files, do not exit. -T Do not merge Trees. -O Re-optimize basket size when merging TTree. -v Explicitly set the verbosity level: 0 request no output, 99 is the. default. -j Parallelize the execution in multiple processes. -dbg Parallelize the execution in multiple processes in debug mode (Does. not delete partial files stored inside working directory). -d Carry out the partial multiprocess execution in the specified. directory. -n Open at most 'maxopenedfiles' at once (use 0 to request to use the. system maximum). -cachesize Resize the prefetching cache use to speed up I/O operations(use 0 to. disable). -experimental-io-features Used with an argument provided, enables the corresponding experimental. feature for output trees. -f Gives the ability to specify the compression level of the target file. (by default 4). -fk Sets the target file to contain the baskets with the same compression. as the input files (unless -O is specified). Compresses the meta data. using the compression level specified in the first input or the. compression setting after fk (for example 206 when using -fk206). -ff The compression level use is the one specified in the first input. -f0 Do not compress the target file. -f6 Use compression level 6 (see TFile::SetCompressionSettings for the. supported range of values). TARGET Target file. SOURCES Source files. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11254
https://github.com/root-project/root/pull/11254:1108,usability,input,input,1108,"Reverted the changes to the help text of `O` option. Kept other formatting changes, this is the current look of the help output. ```. OPTIONS:. -a Append to the output. -k Skip corrupt or non-existent files, do not exit. -T Do not merge Trees. -O Re-optimize basket size when merging TTree. -v Explicitly set the verbosity level: 0 request no output, 99 is the. default. -j Parallelize the execution in multiple processes. -dbg Parallelize the execution in multiple processes in debug mode (Does. not delete partial files stored inside working directory). -d Carry out the partial multiprocess execution in the specified. directory. -n Open at most 'maxopenedfiles' at once (use 0 to request to use the. system maximum). -cachesize Resize the prefetching cache use to speed up I/O operations(use 0 to. disable). -experimental-io-features Used with an argument provided, enables the corresponding experimental. feature for output trees. -f Gives the ability to specify the compression level of the target file. (by default 4). -fk Sets the target file to contain the baskets with the same compression. as the input files (unless -O is specified). Compresses the meta data. using the compression level specified in the first input or the. compression setting after fk (for example 206 when using -fk206). -ff The compression level use is the one specified in the first input. -f0 Do not compress the target file. -f6 Use compression level 6 (see TFile::SetCompressionSettings for the. supported range of values). TARGET Target file. SOURCES Source files. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11254
https://github.com/root-project/root/pull/11254:1223,usability,input,input,1223,"Reverted the changes to the help text of `O` option. Kept other formatting changes, this is the current look of the help output. ```. OPTIONS:. -a Append to the output. -k Skip corrupt or non-existent files, do not exit. -T Do not merge Trees. -O Re-optimize basket size when merging TTree. -v Explicitly set the verbosity level: 0 request no output, 99 is the. default. -j Parallelize the execution in multiple processes. -dbg Parallelize the execution in multiple processes in debug mode (Does. not delete partial files stored inside working directory). -d Carry out the partial multiprocess execution in the specified. directory. -n Open at most 'maxopenedfiles' at once (use 0 to request to use the. system maximum). -cachesize Resize the prefetching cache use to speed up I/O operations(use 0 to. disable). -experimental-io-features Used with an argument provided, enables the corresponding experimental. feature for output trees. -f Gives the ability to specify the compression level of the target file. (by default 4). -fk Sets the target file to contain the baskets with the same compression. as the input files (unless -O is specified). Compresses the meta data. using the compression level specified in the first input or the. compression setting after fk (for example 206 when using -fk206). -ff The compression level use is the one specified in the first input. -f0 Do not compress the target file. -f6 Use compression level 6 (see TFile::SetCompressionSettings for the. supported range of values). TARGET Target file. SOURCES Source files. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11254
https://github.com/root-project/root/pull/11254:1367,usability,input,input,1367,"Reverted the changes to the help text of `O` option. Kept other formatting changes, this is the current look of the help output. ```. OPTIONS:. -a Append to the output. -k Skip corrupt or non-existent files, do not exit. -T Do not merge Trees. -O Re-optimize basket size when merging TTree. -v Explicitly set the verbosity level: 0 request no output, 99 is the. default. -j Parallelize the execution in multiple processes. -dbg Parallelize the execution in multiple processes in debug mode (Does. not delete partial files stored inside working directory). -d Carry out the partial multiprocess execution in the specified. directory. -n Open at most 'maxopenedfiles' at once (use 0 to request to use the. system maximum). -cachesize Resize the prefetching cache use to speed up I/O operations(use 0 to. disable). -experimental-io-features Used with an argument provided, enables the corresponding experimental. feature for output trees. -f Gives the ability to specify the compression level of the target file. (by default 4). -fk Sets the target file to contain the baskets with the same compression. as the input files (unless -O is specified). Compresses the meta data. using the compression level specified in the first input or the. compression setting after fk (for example 206 when using -fk206). -ff The compression level use is the one specified in the first input. -f0 Do not compress the target file. -f6 Use compression level 6 (see TFile::SetCompressionSettings for the. supported range of values). TARGET Target file. SOURCES Source files. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11254
https://github.com/root-project/root/pull/11254:1483,usability,support,supported,1483,"Reverted the changes to the help text of `O` option. Kept other formatting changes, this is the current look of the help output. ```. OPTIONS:. -a Append to the output. -k Skip corrupt or non-existent files, do not exit. -T Do not merge Trees. -O Re-optimize basket size when merging TTree. -v Explicitly set the verbosity level: 0 request no output, 99 is the. default. -j Parallelize the execution in multiple processes. -dbg Parallelize the execution in multiple processes in debug mode (Does. not delete partial files stored inside working directory). -d Carry out the partial multiprocess execution in the specified. directory. -n Open at most 'maxopenedfiles' at once (use 0 to request to use the. system maximum). -cachesize Resize the prefetching cache use to speed up I/O operations(use 0 to. disable). -experimental-io-features Used with an argument provided, enables the corresponding experimental. feature for output trees. -f Gives the ability to specify the compression level of the target file. (by default 4). -fk Sets the target file to contain the baskets with the same compression. as the input files (unless -O is specified). Compresses the meta data. using the compression level specified in the first input or the. compression setting after fk (for example 206 when using -fk206). -ff The compression level use is the one specified in the first input. -f0 Do not compress the target file. -f6 Use compression level 6 (see TFile::SetCompressionSettings for the. supported range of values). TARGET Target file. SOURCES Source files. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11254
https://github.com/root-project/root/pull/11254:39,deployability,contain,contains,39,@pcanal can we merge this? Now it only contains formatting changes and fixes a couple of typos. My previous comment shows the new output after this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11254
https://github.com/root-project/root/pull/11254:79,integrability,coupl,couple,79,@pcanal can we merge this? Now it only contains formatting changes and fixes a couple of typos. My previous comment shows the new output after this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11254
https://github.com/root-project/root/pull/11254:48,interoperability,format,formatting,48,@pcanal can we merge this? Now it only contains formatting changes and fixes a couple of typos. My previous comment shows the new output after this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11254
https://github.com/root-project/root/pull/11254:79,modifiability,coupl,couple,79,@pcanal can we merge this? Now it only contains formatting changes and fixes a couple of typos. My previous comment shows the new output after this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11254
https://github.com/root-project/root/pull/11254:79,testability,coupl,couple,79,@pcanal can we merge this? Now it only contains formatting changes and fixes a couple of typos. My previous comment shows the new output after this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11254
https://github.com/root-project/root/pull/11256:11,deployability,build,build,11,@phsft-bot build just on windows10/cxx14,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11256
https://github.com/root-project/root/pull/11258:11,deployability,build,build,11,"@phsft-bot build just on ROOT-ubuntu2204/default, ROOT-ubuntu2004/default, ROOT-ubuntu18.04/default with flags -Dtmva-sofie=On",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11258
https://github.com/root-project/root/pull/11258:11,deployability,build,build,11,"@phsft-bot build just on ROOT-ubuntu2204/default, ROOT-ubuntu2004/default, ROOT-ubuntu18.04/default with flags -Dtmva-sofie=On",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11258
https://github.com/root-project/root/pull/11258:11,deployability,build,build,11,"@phsft-bot build just on ROOT-ubuntu2204/default, ROOT-ubuntu2004/default, ROOT-ubuntu18.04/default with flags -Dtmva-sofie=On",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11258
https://github.com/root-project/root/issues/11259:264,performance,tune,tuned,264,"I can reproduce the problem but still to assert if the proposed solution cover the intent. In the meantime, a genuine question. What is the intent of:. ```. <class pattern=""*iterator<*pair<const*,const*""/>. ```. i.e. maybe it is no longer necessary or can be fine tuned (eg. this request the dictionary for classes like `""__and_<is_constructible<_Rb_tree_iterator<pair<const unsigned int,string> >,const _Rb_tree_iterator<pair<const unsigned int,string> >&>,is_constructible<bool,const bool&> >""`",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11259
https://github.com/root-project/root/issues/11259:41,testability,assert,assert,41,"I can reproduce the problem but still to assert if the proposed solution cover the intent. In the meantime, a genuine question. What is the intent of:. ```. <class pattern=""*iterator<*pair<const*,const*""/>. ```. i.e. maybe it is no longer necessary or can be fine tuned (eg. this request the dictionary for classes like `""__and_<is_constructible<_Rb_tree_iterator<pair<const unsigned int,string> >,const _Rb_tree_iterator<pair<const unsigned int,string> >&>,is_constructible<bool,const bool&> >""`",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11259
https://github.com/root-project/root/pull/11261:4,safety,test,test,4,The test shows a regression (i.e. need fixing in the code),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11261
https://github.com/root-project/root/pull/11261:4,testability,test,test,4,The test shows a regression (i.e. need fixing in the code),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11261
https://github.com/root-project/root/pull/11261:17,testability,regress,regression,17,The test shows a regression (i.e. need fixing in the code),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11261
https://github.com/root-project/root/pull/11261:11,deployability,build,build,11,@phsft-bot build just on windows10/cxx14,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11261
https://github.com/root-project/root/pull/11261:22,availability,error,error,22,The transient Windows error is a known race condition in the roottest build system.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11261
https://github.com/root-project/root/pull/11261:70,deployability,build,build,70,The transient Windows error is a known race condition in the roottest build system.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11261
https://github.com/root-project/root/pull/11261:22,performance,error,error,22,The transient Windows error is a known race condition in the roottest build system.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11261
https://github.com/root-project/root/pull/11261:22,safety,error,error,22,The transient Windows error is a known race condition in the roottest build system.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11261
https://github.com/root-project/root/pull/11261:22,usability,error,error,22,The transient Windows error is a known race condition in the roottest build system.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11261
https://github.com/root-project/root/pull/11262:881,reliability,doe,does,881,"cling startup scripts are different from rootlogon.C and rootrc . rootrc is a config file while .clingrc is a regular cling script. cling startup scripts are executed also in invocation of standalone cling binary (not from root interpreter). Question:. 1. Renaming `.cling_profile` and `.clingrc` with suffix `.C` ? 2. Rename `.clingrc` to something else so that `.clingrc` can be reserved for cling config file in the future (if any)? Making it a config file instead of a cling script aligns with rootrc but not with bashrc, zshrc. 3. Drop `.clingrc` for now and keep `.cling_profile` only ? If a cling script can easily tell if it is in interactive mode then keeping only 1 script makes sense. Otherwise it is better to keep both to align with bash and other interpreter inspired by bash design. By easily telling I mean a macro like `CLING_INTERACTIVE` or something simple that does not access `gCling`. .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:890,security,access,access,890,"cling startup scripts are different from rootlogon.C and rootrc . rootrc is a config file while .clingrc is a regular cling script. cling startup scripts are executed also in invocation of standalone cling binary (not from root interpreter). Question:. 1. Renaming `.cling_profile` and `.clingrc` with suffix `.C` ? 2. Rename `.clingrc` to something else so that `.clingrc` can be reserved for cling config file in the future (if any)? Making it a config file instead of a cling script aligns with rootrc but not with bashrc, zshrc. 3. Drop `.clingrc` for now and keep `.cling_profile` only ? If a cling script can easily tell if it is in interactive mode then keeping only 1 script makes sense. Otherwise it is better to keep both to align with bash and other interpreter inspired by bash design. By easily telling I mean a macro like `CLING_INTERACTIVE` or something simple that does not access `gCling`. .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:869,testability,simpl,simple,869,"cling startup scripts are different from rootlogon.C and rootrc . rootrc is a config file while .clingrc is a regular cling script. cling startup scripts are executed also in invocation of standalone cling binary (not from root interpreter). Question:. 1. Renaming `.cling_profile` and `.clingrc` with suffix `.C` ? 2. Rename `.clingrc` to something else so that `.clingrc` can be reserved for cling config file in the future (if any)? Making it a config file instead of a cling script aligns with rootrc but not with bashrc, zshrc. 3. Drop `.clingrc` for now and keep `.cling_profile` only ? If a cling script can easily tell if it is in interactive mode then keeping only 1 script makes sense. Otherwise it is better to keep both to align with bash and other interpreter inspired by bash design. By easily telling I mean a macro like `CLING_INTERACTIVE` or something simple that does not access `gCling`. .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:639,usability,interact,interactive,639,"cling startup scripts are different from rootlogon.C and rootrc . rootrc is a config file while .clingrc is a regular cling script. cling startup scripts are executed also in invocation of standalone cling binary (not from root interpreter). Question:. 1. Renaming `.cling_profile` and `.clingrc` with suffix `.C` ? 2. Rename `.clingrc` to something else so that `.clingrc` can be reserved for cling config file in the future (if any)? Making it a config file instead of a cling script aligns with rootrc but not with bashrc, zshrc. 3. Drop `.clingrc` for now and keep `.cling_profile` only ? If a cling script can easily tell if it is in interactive mode then keeping only 1 script makes sense. Otherwise it is better to keep both to align with bash and other interpreter inspired by bash design. By easily telling I mean a macro like `CLING_INTERACTIVE` or something simple that does not access `gCling`. .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:869,usability,simpl,simple,869,"cling startup scripts are different from rootlogon.C and rootrc . rootrc is a config file while .clingrc is a regular cling script. cling startup scripts are executed also in invocation of standalone cling binary (not from root interpreter). Question:. 1. Renaming `.cling_profile` and `.clingrc` with suffix `.C` ? 2. Rename `.clingrc` to something else so that `.clingrc` can be reserved for cling config file in the future (if any)? Making it a config file instead of a cling script aligns with rootrc but not with bashrc, zshrc. 3. Drop `.clingrc` for now and keep `.cling_profile` only ? If a cling script can easily tell if it is in interactive mode then keeping only 1 script makes sense. Otherwise it is better to keep both to align with bash and other interpreter inspired by bash design. By easily telling I mean a macro like `CLING_INTERACTIVE` or something simple that does not access `gCling`. .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:11,deployability,build,build,11,"@phsft-bot build! @jiangyilism, thanks for you PR, can you add some tests for the new functionality under `cling/test`?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:68,safety,test,tests,68,"@phsft-bot build! @jiangyilism, thanks for you PR, can you add some tests for the new functionality under `cling/test`?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:113,safety,test,test,113,"@phsft-bot build! @jiangyilism, thanks for you PR, can you add some tests for the new functionality under `cling/test`?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:68,testability,test,tests,68,"@phsft-bot build! @jiangyilism, thanks for you PR, can you add some tests for the new functionality under `cling/test`?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:113,testability,test,test,113,"@phsft-bot build! @jiangyilism, thanks for you PR, can you add some tests for the new functionality under `cling/test`?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:23,safety,test,test,23,"Hi @vgvassilev, `cling/test/StratupFile.C` is added. However it only covers usage of `.cling_profile.C`. To proceed further, I would like to clerify the above decisions first. Let me summarize again here:. 1. Should we .x execute the startup file(s) or execute it in shebang `#!` way? @eguiraud, @vgvassilev, @Axel-Naumann, what is the designed/documented difference between the 2? Will it effect project root (which I have not tried out myself. I am experimenting standalone cling only). As far as I read from the web, `rootlogon.C` and `.rootrc` are executed in shebang way. Their filename-functions `rootlogon()`, `rootrc()` are not executed. My proposal: Execute startup files in .x way . 2. How should the startup files be named? `.cling_profile`, `.cling_login`, `.cling_logon` like bash and root? https://www.gnu.org/software/bash/manual/html_node/Bash-Startup-Files.html. Should we adopt file suffix `.C` ? My proposal: `.cling_profile.C` to align with rootlogon.C (to be honest I just want the editor syntax highlighting...). 3. Do we need `.cling_profile` and `.clingrc` as the original draft implementation? If inside the script we can tell if cling is in interactive mode by a macro like `CLING_INTERACTIVE` then. only 1 file is needed. My proposal: keep `.cling_profile.C` as the only startup file. Forget about `#define CLING_INTERACTIVE 1` for now. I mentioned this support just because bash and other shells/interpreters have it. But unless someone wants this feature right now, I prefer not to implement it and. reserve `CLING_INTERACTIVE` and `.clingrc`/`.clingrc.C` for future design.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:23,testability,test,test,23,"Hi @vgvassilev, `cling/test/StratupFile.C` is added. However it only covers usage of `.cling_profile.C`. To proceed further, I would like to clerify the above decisions first. Let me summarize again here:. 1. Should we .x execute the startup file(s) or execute it in shebang `#!` way? @eguiraud, @vgvassilev, @Axel-Naumann, what is the designed/documented difference between the 2? Will it effect project root (which I have not tried out myself. I am experimenting standalone cling only). As far as I read from the web, `rootlogon.C` and `.rootrc` are executed in shebang way. Their filename-functions `rootlogon()`, `rootrc()` are not executed. My proposal: Execute startup files in .x way . 2. How should the startup files be named? `.cling_profile`, `.cling_login`, `.cling_logon` like bash and root? https://www.gnu.org/software/bash/manual/html_node/Bash-Startup-Files.html. Should we adopt file suffix `.C` ? My proposal: `.cling_profile.C` to align with rootlogon.C (to be honest I just want the editor syntax highlighting...). 3. Do we need `.cling_profile` and `.clingrc` as the original draft implementation? If inside the script we can tell if cling is in interactive mode by a macro like `CLING_INTERACTIVE` then. only 1 file is needed. My proposal: keep `.cling_profile.C` as the only startup file. Forget about `#define CLING_INTERACTIVE 1` for now. I mentioned this support just because bash and other shells/interpreters have it. But unless someone wants this feature right now, I prefer not to implement it and. reserve `CLING_INTERACTIVE` and `.clingrc`/`.clingrc.C` for future design.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:345,usability,document,documented,345,"Hi @vgvassilev, `cling/test/StratupFile.C` is added. However it only covers usage of `.cling_profile.C`. To proceed further, I would like to clerify the above decisions first. Let me summarize again here:. 1. Should we .x execute the startup file(s) or execute it in shebang `#!` way? @eguiraud, @vgvassilev, @Axel-Naumann, what is the designed/documented difference between the 2? Will it effect project root (which I have not tried out myself. I am experimenting standalone cling only). As far as I read from the web, `rootlogon.C` and `.rootrc` are executed in shebang way. Their filename-functions `rootlogon()`, `rootrc()` are not executed. My proposal: Execute startup files in .x way . 2. How should the startup files be named? `.cling_profile`, `.cling_login`, `.cling_logon` like bash and root? https://www.gnu.org/software/bash/manual/html_node/Bash-Startup-Files.html. Should we adopt file suffix `.C` ? My proposal: `.cling_profile.C` to align with rootlogon.C (to be honest I just want the editor syntax highlighting...). 3. Do we need `.cling_profile` and `.clingrc` as the original draft implementation? If inside the script we can tell if cling is in interactive mode by a macro like `CLING_INTERACTIVE` then. only 1 file is needed. My proposal: keep `.cling_profile.C` as the only startup file. Forget about `#define CLING_INTERACTIVE 1` for now. I mentioned this support just because bash and other shells/interpreters have it. But unless someone wants this feature right now, I prefer not to implement it and. reserve `CLING_INTERACTIVE` and `.clingrc`/`.clingrc.C` for future design.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:1167,usability,interact,interactive,1167,"Hi @vgvassilev, `cling/test/StratupFile.C` is added. However it only covers usage of `.cling_profile.C`. To proceed further, I would like to clerify the above decisions first. Let me summarize again here:. 1. Should we .x execute the startup file(s) or execute it in shebang `#!` way? @eguiraud, @vgvassilev, @Axel-Naumann, what is the designed/documented difference between the 2? Will it effect project root (which I have not tried out myself. I am experimenting standalone cling only). As far as I read from the web, `rootlogon.C` and `.rootrc` are executed in shebang way. Their filename-functions `rootlogon()`, `rootrc()` are not executed. My proposal: Execute startup files in .x way . 2. How should the startup files be named? `.cling_profile`, `.cling_login`, `.cling_logon` like bash and root? https://www.gnu.org/software/bash/manual/html_node/Bash-Startup-Files.html. Should we adopt file suffix `.C` ? My proposal: `.cling_profile.C` to align with rootlogon.C (to be honest I just want the editor syntax highlighting...). 3. Do we need `.cling_profile` and `.clingrc` as the original draft implementation? If inside the script we can tell if cling is in interactive mode by a macro like `CLING_INTERACTIVE` then. only 1 file is needed. My proposal: keep `.cling_profile.C` as the only startup file. Forget about `#define CLING_INTERACTIVE 1` for now. I mentioned this support just because bash and other shells/interpreters have it. But unless someone wants this feature right now, I prefer not to implement it and. reserve `CLING_INTERACTIVE` and `.clingrc`/`.clingrc.C` for future design.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:1381,usability,support,support,1381,"Hi @vgvassilev, `cling/test/StratupFile.C` is added. However it only covers usage of `.cling_profile.C`. To proceed further, I would like to clerify the above decisions first. Let me summarize again here:. 1. Should we .x execute the startup file(s) or execute it in shebang `#!` way? @eguiraud, @vgvassilev, @Axel-Naumann, what is the designed/documented difference between the 2? Will it effect project root (which I have not tried out myself. I am experimenting standalone cling only). As far as I read from the web, `rootlogon.C` and `.rootrc` are executed in shebang way. Their filename-functions `rootlogon()`, `rootrc()` are not executed. My proposal: Execute startup files in .x way . 2. How should the startup files be named? `.cling_profile`, `.cling_login`, `.cling_logon` like bash and root? https://www.gnu.org/software/bash/manual/html_node/Bash-Startup-Files.html. Should we adopt file suffix `.C` ? My proposal: `.cling_profile.C` to align with rootlogon.C (to be honest I just want the editor syntax highlighting...). 3. Do we need `.cling_profile` and `.clingrc` as the original draft implementation? If inside the script we can tell if cling is in interactive mode by a macro like `CLING_INTERACTIVE` then. only 1 file is needed. My proposal: keep `.cling_profile.C` as the only startup file. Forget about `#define CLING_INTERACTIVE 1` for now. I mentioned this support just because bash and other shells/interpreters have it. But unless someone wants this feature right now, I prefer not to implement it and. reserve `CLING_INTERACTIVE` and `.clingrc`/`.clingrc.C` for future design.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:1497,usability,prefer,prefer,1497,"Hi @vgvassilev, `cling/test/StratupFile.C` is added. However it only covers usage of `.cling_profile.C`. To proceed further, I would like to clerify the above decisions first. Let me summarize again here:. 1. Should we .x execute the startup file(s) or execute it in shebang `#!` way? @eguiraud, @vgvassilev, @Axel-Naumann, what is the designed/documented difference between the 2? Will it effect project root (which I have not tried out myself. I am experimenting standalone cling only). As far as I read from the web, `rootlogon.C` and `.rootrc` are executed in shebang way. Their filename-functions `rootlogon()`, `rootrc()` are not executed. My proposal: Execute startup files in .x way . 2. How should the startup files be named? `.cling_profile`, `.cling_login`, `.cling_logon` like bash and root? https://www.gnu.org/software/bash/manual/html_node/Bash-Startup-Files.html. Should we adopt file suffix `.C` ? My proposal: `.cling_profile.C` to align with rootlogon.C (to be honest I just want the editor syntax highlighting...). 3. Do we need `.cling_profile` and `.clingrc` as the original draft implementation? If inside the script we can tell if cling is in interactive mode by a macro like `CLING_INTERACTIVE` then. only 1 file is needed. My proposal: keep `.cling_profile.C` as the only startup file. Forget about `#define CLING_INTERACTIVE 1` for now. I mentioned this support just because bash and other shells/interpreters have it. But unless someone wants this feature right now, I prefer not to implement it and. reserve `CLING_INTERACTIVE` and `.clingrc`/`.clingrc.C` for future design.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:51,usability,feedback,feedback,51,"@Axel-Naumann , @vgvassilev Could you provide some feedback?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:30,deployability,patch,patch,30,"@jiangyilism, thanks for your patch. I am a bit worried about the fact that upon startup cling will execute ""random"" code. Can you elaborate a little more about your usecase? I suspect python does something similar, can we model the feature following their approach?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:223,energy efficiency,model,model,223,"@jiangyilism, thanks for your patch. I am a bit worried about the fact that upon startup cling will execute ""random"" code. Can you elaborate a little more about your usecase? I suspect python does something similar, can we model the feature following their approach?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:192,reliability,doe,does,192,"@jiangyilism, thanks for your patch. I am a bit worried about the fact that upon startup cling will execute ""random"" code. Can you elaborate a little more about your usecase? I suspect python does something similar, can we model the feature following their approach?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:30,safety,patch,patch,30,"@jiangyilism, thanks for your patch. I am a bit worried about the fact that upon startup cling will execute ""random"" code. Can you elaborate a little more about your usecase? I suspect python does something similar, can we model the feature following their approach?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:30,security,patch,patch,30,"@jiangyilism, thanks for your patch. I am a bit worried about the fact that upon startup cling will execute ""random"" code. Can you elaborate a little more about your usecase? I suspect python does something similar, can we model the feature following their approach?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:223,security,model,model,223,"@jiangyilism, thanks for your patch. I am a bit worried about the fact that upon startup cling will execute ""random"" code. Can you elaborate a little more about your usecase? I suspect python does something similar, can we model the feature following their approach?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:40,interoperability,standard,standard,40,"My use case is to `#include <...>` some standard headers I often use. e.g. filesystem and thread. I will also put `namespace fs = std::filesystem;` in my startup file. cling already implicitly includes some standard headers so I think letting users to customize it makes sense. About ""execute random code"", is there risk if the executed code/script is in user's home directory or `XDG_CONFIG_HOME` ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:207,interoperability,standard,standard,207,"My use case is to `#include <...>` some standard headers I often use. e.g. filesystem and thread. I will also put `namespace fs = std::filesystem;` in my startup file. cling already implicitly includes some standard headers so I think letting users to customize it makes sense. About ""execute random code"", is there risk if the executed code/script is in user's home directory or `XDG_CONFIG_HOME` ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:316,safety,risk,risk,316,"My use case is to `#include <...>` some standard headers I often use. e.g. filesystem and thread. I will also put `namespace fs = std::filesystem;` in my startup file. cling already implicitly includes some standard headers so I think letting users to customize it makes sense. About ""execute random code"", is there risk if the executed code/script is in user's home directory or `XDG_CONFIG_HOME` ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:316,security,risk,risk,316,"My use case is to `#include <...>` some standard headers I often use. e.g. filesystem and thread. I will also put `namespace fs = std::filesystem;` in my startup file. cling already implicitly includes some standard headers so I think letting users to customize it makes sense. About ""execute random code"", is there risk if the executed code/script is in user's home directory or `XDG_CONFIG_HOME` ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:243,usability,user,users,243,"My use case is to `#include <...>` some standard headers I often use. e.g. filesystem and thread. I will also put `namespace fs = std::filesystem;` in my startup file. cling already implicitly includes some standard headers so I think letting users to customize it makes sense. About ""execute random code"", is there risk if the executed code/script is in user's home directory or `XDG_CONFIG_HOME` ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:252,usability,custom,customize,252,"My use case is to `#include <...>` some standard headers I often use. e.g. filesystem and thread. I will also put `namespace fs = std::filesystem;` in my startup file. cling already implicitly includes some standard headers so I think letting users to customize it makes sense. About ""execute random code"", is there risk if the executed code/script is in user's home directory or `XDG_CONFIG_HOME` ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:355,usability,user,user,355,"My use case is to `#include <...>` some standard headers I often use. e.g. filesystem and thread. I will also put `namespace fs = std::filesystem;` in my startup file. cling already implicitly includes some standard headers so I think letting users to customize it makes sense. About ""execute random code"", is there risk if the executed code/script is in user's home directory or `XDG_CONFIG_HOME` ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:523,availability,consist,consistent,523,"> My use case is to `#include <...>` some standard headers I often use. e.g. filesystem and thread. I will also put `namespace fs = std::filesystem;` in my startup file. cling already implicitly includes some standard headers so I think letting users to customize it makes sense. Thanks for explaining. It all makes sense. > About ""execute random code"", is there risk if the executed code/script is in user's home directory or `XDG_CONFIG_HOME` ? Well, I guess bash and python suffer from the same issue. As long as we are consistent to their practices it should be no issue.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:42,interoperability,standard,standard,42,"> My use case is to `#include <...>` some standard headers I often use. e.g. filesystem and thread. I will also put `namespace fs = std::filesystem;` in my startup file. cling already implicitly includes some standard headers so I think letting users to customize it makes sense. Thanks for explaining. It all makes sense. > About ""execute random code"", is there risk if the executed code/script is in user's home directory or `XDG_CONFIG_HOME` ? Well, I guess bash and python suffer from the same issue. As long as we are consistent to their practices it should be no issue.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:209,interoperability,standard,standard,209,"> My use case is to `#include <...>` some standard headers I often use. e.g. filesystem and thread. I will also put `namespace fs = std::filesystem;` in my startup file. cling already implicitly includes some standard headers so I think letting users to customize it makes sense. Thanks for explaining. It all makes sense. > About ""execute random code"", is there risk if the executed code/script is in user's home directory or `XDG_CONFIG_HOME` ? Well, I guess bash and python suffer from the same issue. As long as we are consistent to their practices it should be no issue.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:543,reliability,pra,practices,543,"> My use case is to `#include <...>` some standard headers I often use. e.g. filesystem and thread. I will also put `namespace fs = std::filesystem;` in my startup file. cling already implicitly includes some standard headers so I think letting users to customize it makes sense. Thanks for explaining. It all makes sense. > About ""execute random code"", is there risk if the executed code/script is in user's home directory or `XDG_CONFIG_HOME` ? Well, I guess bash and python suffer from the same issue. As long as we are consistent to their practices it should be no issue.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:363,safety,risk,risk,363,"> My use case is to `#include <...>` some standard headers I often use. e.g. filesystem and thread. I will also put `namespace fs = std::filesystem;` in my startup file. cling already implicitly includes some standard headers so I think letting users to customize it makes sense. Thanks for explaining. It all makes sense. > About ""execute random code"", is there risk if the executed code/script is in user's home directory or `XDG_CONFIG_HOME` ? Well, I guess bash and python suffer from the same issue. As long as we are consistent to their practices it should be no issue.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:363,security,risk,risk,363,"> My use case is to `#include <...>` some standard headers I often use. e.g. filesystem and thread. I will also put `namespace fs = std::filesystem;` in my startup file. cling already implicitly includes some standard headers so I think letting users to customize it makes sense. Thanks for explaining. It all makes sense. > About ""execute random code"", is there risk if the executed code/script is in user's home directory or `XDG_CONFIG_HOME` ? Well, I guess bash and python suffer from the same issue. As long as we are consistent to their practices it should be no issue.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:245,usability,user,users,245,"> My use case is to `#include <...>` some standard headers I often use. e.g. filesystem and thread. I will also put `namespace fs = std::filesystem;` in my startup file. cling already implicitly includes some standard headers so I think letting users to customize it makes sense. Thanks for explaining. It all makes sense. > About ""execute random code"", is there risk if the executed code/script is in user's home directory or `XDG_CONFIG_HOME` ? Well, I guess bash and python suffer from the same issue. As long as we are consistent to their practices it should be no issue.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:254,usability,custom,customize,254,"> My use case is to `#include <...>` some standard headers I often use. e.g. filesystem and thread. I will also put `namespace fs = std::filesystem;` in my startup file. cling already implicitly includes some standard headers so I think letting users to customize it makes sense. Thanks for explaining. It all makes sense. > About ""execute random code"", is there risk if the executed code/script is in user's home directory or `XDG_CONFIG_HOME` ? Well, I guess bash and python suffer from the same issue. As long as we are consistent to their practices it should be no issue.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:402,usability,user,user,402,"> My use case is to `#include <...>` some standard headers I often use. e.g. filesystem and thread. I will also put `namespace fs = std::filesystem;` in my startup file. cling already implicitly includes some standard headers so I think letting users to customize it makes sense. Thanks for explaining. It all makes sense. > About ""execute random code"", is there risk if the executed code/script is in user's home directory or `XDG_CONFIG_HOME` ? Well, I guess bash and python suffer from the same issue. As long as we are consistent to their practices it should be no issue.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:523,usability,consist,consistent,523,"> My use case is to `#include <...>` some standard headers I often use. e.g. filesystem and thread. I will also put `namespace fs = std::filesystem;` in my startup file. cling already implicitly includes some standard headers so I think letting users to customize it makes sense. Thanks for explaining. It all makes sense. > About ""execute random code"", is there risk if the executed code/script is in user's home directory or `XDG_CONFIG_HOME` ? Well, I guess bash and python suffer from the same issue. As long as we are consistent to their practices it should be no issue.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:909,reliability,doe,does,909,"> cling startup scripts are different from rootlogon.C and rootrc . rootrc is a config file while .clingrc is a regular cling script. cling startup scripts are executed also in invocation of standalone cling binary (not from root interpreter). > . > Question:. > . > 1. Renaming `.cling_profile` and `.clingrc` with suffix `.C` ? > . > 2. Rename `.clingrc` to something else so that `.clingrc` can be reserved for cling config file in the future (if any)? > Making it a config file instead of a cling script aligns with rootrc but not with bashrc, zshrc. > . > 3. Drop `.clingrc` for now and keep `.cling_profile` only ? If a cling script can easily tell if it is in interactive mode then keeping only 1 script makes sense. Otherwise it is better to keep both to align with bash and other interpreter inspired by bash design. By easily telling I mean a macro like `CLING_INTERACTIVE` or something simple that does not access `gCling`. How about a `~/.cling.d` folder where we glob all files and execute?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:918,security,access,access,918,"> cling startup scripts are different from rootlogon.C and rootrc . rootrc is a config file while .clingrc is a regular cling script. cling startup scripts are executed also in invocation of standalone cling binary (not from root interpreter). > . > Question:. > . > 1. Renaming `.cling_profile` and `.clingrc` with suffix `.C` ? > . > 2. Rename `.clingrc` to something else so that `.clingrc` can be reserved for cling config file in the future (if any)? > Making it a config file instead of a cling script aligns with rootrc but not with bashrc, zshrc. > . > 3. Drop `.clingrc` for now and keep `.cling_profile` only ? If a cling script can easily tell if it is in interactive mode then keeping only 1 script makes sense. Otherwise it is better to keep both to align with bash and other interpreter inspired by bash design. By easily telling I mean a macro like `CLING_INTERACTIVE` or something simple that does not access `gCling`. How about a `~/.cling.d` folder where we glob all files and execute?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:897,testability,simpl,simple,897,"> cling startup scripts are different from rootlogon.C and rootrc . rootrc is a config file while .clingrc is a regular cling script. cling startup scripts are executed also in invocation of standalone cling binary (not from root interpreter). > . > Question:. > . > 1. Renaming `.cling_profile` and `.clingrc` with suffix `.C` ? > . > 2. Rename `.clingrc` to something else so that `.clingrc` can be reserved for cling config file in the future (if any)? > Making it a config file instead of a cling script aligns with rootrc but not with bashrc, zshrc. > . > 3. Drop `.clingrc` for now and keep `.cling_profile` only ? If a cling script can easily tell if it is in interactive mode then keeping only 1 script makes sense. Otherwise it is better to keep both to align with bash and other interpreter inspired by bash design. By easily telling I mean a macro like `CLING_INTERACTIVE` or something simple that does not access `gCling`. How about a `~/.cling.d` folder where we glob all files and execute?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:667,usability,interact,interactive,667,"> cling startup scripts are different from rootlogon.C and rootrc . rootrc is a config file while .clingrc is a regular cling script. cling startup scripts are executed also in invocation of standalone cling binary (not from root interpreter). > . > Question:. > . > 1. Renaming `.cling_profile` and `.clingrc` with suffix `.C` ? > . > 2. Rename `.clingrc` to something else so that `.clingrc` can be reserved for cling config file in the future (if any)? > Making it a config file instead of a cling script aligns with rootrc but not with bashrc, zshrc. > . > 3. Drop `.clingrc` for now and keep `.cling_profile` only ? If a cling script can easily tell if it is in interactive mode then keeping only 1 script makes sense. Otherwise it is better to keep both to align with bash and other interpreter inspired by bash design. By easily telling I mean a macro like `CLING_INTERACTIVE` or something simple that does not access `gCling`. How about a `~/.cling.d` folder where we glob all files and execute?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:897,usability,simpl,simple,897,"> cling startup scripts are different from rootlogon.C and rootrc . rootrc is a config file while .clingrc is a regular cling script. cling startup scripts are executed also in invocation of standalone cling binary (not from root interpreter). > . > Question:. > . > 1. Renaming `.cling_profile` and `.clingrc` with suffix `.C` ? > . > 2. Rename `.clingrc` to something else so that `.clingrc` can be reserved for cling config file in the future (if any)? > Making it a config file instead of a cling script aligns with rootrc but not with bashrc, zshrc. > . > 3. Drop `.clingrc` for now and keep `.cling_profile` only ? If a cling script can easily tell if it is in interactive mode then keeping only 1 script makes sense. Otherwise it is better to keep both to align with bash and other interpreter inspired by bash design. By easily telling I mean a macro like `CLING_INTERACTIVE` or something simple that does not access `gCling`. How about a `~/.cling.d` folder where we glob all files and execute?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:332,interoperability,specif,specific,332,> How about a `~/.cling.d` folder where we glob all files and execute? . Sounds good to me too. I will enumerate `.C` files in `.cling.d/` (if dir exists) with `llvm::vfs::directory_iterator` like [CompilerInstance.cpp](https://clang.llvm.org/doxygen/CompilerInstance_8cpp_source.html#l00248). So the enumeration does not guarantee specific orderings. Search order of `.cling.d/` is still. 1. ${CLING_HOME} envvar. 2. ${XDG_CONFIG_HOME}/cling/. 3. ${HOME}/.config/cling/. 4. ${HOME}/. Does that look good to you?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:313,reliability,doe,does,313,> How about a `~/.cling.d` folder where we glob all files and execute? . Sounds good to me too. I will enumerate `.C` files in `.cling.d/` (if dir exists) with `llvm::vfs::directory_iterator` like [CompilerInstance.cpp](https://clang.llvm.org/doxygen/CompilerInstance_8cpp_source.html#l00248). So the enumeration does not guarantee specific orderings. Search order of `.cling.d/` is still. 1. ${CLING_HOME} envvar. 2. ${XDG_CONFIG_HOME}/cling/. 3. ${HOME}/.config/cling/. 4. ${HOME}/. Does that look good to you?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:485,reliability,Doe,Does,485,> How about a `~/.cling.d` folder where we glob all files and execute? . Sounds good to me too. I will enumerate `.C` files in `.cling.d/` (if dir exists) with `llvm::vfs::directory_iterator` like [CompilerInstance.cpp](https://clang.llvm.org/doxygen/CompilerInstance_8cpp_source.html#l00248). So the enumeration does not guarantee specific orderings. Search order of `.cling.d/` is still. 1. ${CLING_HOME} envvar. 2. ${XDG_CONFIG_HOME}/cling/. 3. ${HOME}/.config/cling/. 4. ${HOME}/. Does that look good to you?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:61,deployability,updat,update,61,Apologies for not reacting - this sounds terrific! Could you update the PR?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:61,safety,updat,update,61,Apologies for not reacting - this sounds terrific! Could you update the PR?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:61,security,updat,update,61,Apologies for not reacting - this sounds terrific! Could you update the PR?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:93,availability,sli,slightly,93,> So the enumeration does not guarantee specific orderings. Updated. However the behavior is slightly different: the startup files are sorted after enumeration so the execution order is deterministic.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:60,deployability,Updat,Updated,60,> So the enumeration does not guarantee specific orderings. Updated. However the behavior is slightly different: the startup files are sorted after enumeration so the execution order is deterministic.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:40,interoperability,specif,specific,40,> So the enumeration does not guarantee specific orderings. Updated. However the behavior is slightly different: the startup files are sorted after enumeration so the execution order is deterministic.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:21,reliability,doe,does,21,> So the enumeration does not guarantee specific orderings. Updated. However the behavior is slightly different: the startup files are sorted after enumeration so the execution order is deterministic.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:93,reliability,sli,slightly,93,> So the enumeration does not guarantee specific orderings. Updated. However the behavior is slightly different: the startup files are sorted after enumeration so the execution order is deterministic.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:60,safety,Updat,Updated,60,> So the enumeration does not guarantee specific orderings. Updated. However the behavior is slightly different: the startup files are sorted after enumeration so the execution order is deterministic.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:60,security,Updat,Updated,60,> So the enumeration does not guarantee specific orderings. Updated. However the behavior is slightly different: the startup files are sorted after enumeration so the execution order is deterministic.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:81,usability,behavi,behavior,81,> So the enumeration does not guarantee specific orderings. Updated. However the behavior is slightly different: the startup files are sorted after enumeration so the execution order is deterministic.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:40,usability,statu,status,40,@jiangyilism I was wondering what's the status of this PR?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:128,deployability,fail,fail,128,. > @jiangyilism I was wondering what's the status of this PR? There is no pending issue as far as I know. The mac11/cxx14 test fail above is due to (flaky?) timeout so it seems irrelevant to this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:158,performance,time,timeout,158,. > @jiangyilism I was wondering what's the status of this PR? There is no pending issue as far as I know. The mac11/cxx14 test fail above is due to (flaky?) timeout so it seems irrelevant to this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:128,reliability,fail,fail,128,. > @jiangyilism I was wondering what's the status of this PR? There is no pending issue as far as I know. The mac11/cxx14 test fail above is due to (flaky?) timeout so it seems irrelevant to this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:123,safety,test,test,123,. > @jiangyilism I was wondering what's the status of this PR? There is no pending issue as far as I know. The mac11/cxx14 test fail above is due to (flaky?) timeout so it seems irrelevant to this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:158,safety,timeout,timeout,158,. > @jiangyilism I was wondering what's the status of this PR? There is no pending issue as far as I know. The mac11/cxx14 test fail above is due to (flaky?) timeout so it seems irrelevant to this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:123,testability,test,test,123,. > @jiangyilism I was wondering what's the status of this PR? There is no pending issue as far as I know. The mac11/cxx14 test fail above is due to (flaky?) timeout so it seems irrelevant to this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11262:44,usability,statu,status,44,. > @jiangyilism I was wondering what's the status of this PR? There is no pending issue as far as I know. The mac11/cxx14 test fail above is due to (flaky?) timeout so it seems irrelevant to this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11262
https://github.com/root-project/root/pull/11263:4,modifiability,concern,concern,4,One concern is a possible dead-lock between the ROOT lock and the dlopen lock .... We may need a more fine grain solution.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:31,performance,lock,lock,31,One concern is a possible dead-lock between the ROOT lock and the dlopen lock .... We may need a more fine grain solution.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:53,performance,lock,lock,53,One concern is a possible dead-lock between the ROOT lock and the dlopen lock .... We may need a more fine grain solution.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:73,performance,lock,lock,73,One concern is a possible dead-lock between the ROOT lock and the dlopen lock .... We may need a more fine grain solution.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:31,security,lock,lock,31,One concern is a possible dead-lock between the ROOT lock and the dlopen lock .... We may need a more fine grain solution.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:53,security,lock,lock,53,One concern is a possible dead-lock between the ROOT lock and the dlopen lock .... We may need a more fine grain solution.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:73,security,lock,lock,73,One concern is a possible dead-lock between the ROOT lock and the dlopen lock .... We may need a more fine grain solution.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:4,testability,concern,concern,4,One concern is a possible dead-lock between the ROOT lock and the dlopen lock .... We may need a more fine grain solution.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1134,availability,down,down,1134,"ught. that it was probably ok because a similar change was working fine. in production. But (a), i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure that there's any good way of addressing this short. of having ROOT release the core mutex before calling dlopen. But this would probably re",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:375,deployability,patch,patch,375,"Thanks Philippe. After further consideration, i think you're right. I had indeed been concerned about a possible deadlock, but i had thought. that it was probably ok because a similar change was working fine. in production. But (a), i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure tha",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:651,deployability,manag,manager,651,"Thanks Philippe. After further consideration, i think you're right. I had indeed been concerned about a possible deadlock, but i had thought. that it was probably ok because a similar change was working fine. in production. But (a), i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure tha",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:2064,deployability,releas,release,2064," forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure that there's any good way of addressing this short. of having ROOT release the core mutex before calling dlopen. But this would probably require introducing another mutex for use. in at least TClass::GetClass to serialize dictionary loading.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:472,energy efficiency,core,core,472,"Thanks Philippe. After further consideration, i think you're right. I had indeed been concerned about a possible deadlock, but i had thought. that it was probably ok because a similar change was working fine. in production. But (a), i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure tha",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:651,energy efficiency,manag,manager,651,"Thanks Philippe. After further consideration, i think you're right. I had indeed been concerned about a possible deadlock, but i had thought. that it was probably ok because a similar change was working fine. in production. But (a), i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure tha",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:677,energy efficiency,load,load,677,"Thanks Philippe. After further consideration, i think you're right. I had indeed been concerned about a possible deadlock, but i had thought. that it was probably ok because a similar change was working fine. in production. But (a), i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure tha",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:789,energy efficiency,core,core,789,"Thanks Philippe. After further consideration, i think you're right. I had indeed been concerned about a possible deadlock, but i had thought. that it was probably ok because a similar change was working fine. in production. But (a), i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure tha",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:884,energy efficiency,load,loaded,884,"Thanks Philippe. After further consideration, i think you're right. I had indeed been concerned about a possible deadlock, but i had thought. that it was probably ok because a similar change was working fine. in production. But (a), i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure tha",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1006,energy efficiency,load,loaded,1006,"ilippe. After further consideration, i think you're right. I had indeed been concerned about a possible deadlock, but i had thought. that it was probably ok because a similar change was working fine. in production. But (a), i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure that there's",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1385,energy efficiency,draw,drawback,1385," forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure that there's any good way of addressing this short. of having ROOT release the core mutex before calling dlopen. But this would probably require introducing another mutex for use. in at least TClass::GetClass to serialize dictionary loading.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1506,energy efficiency,core,core,1506," forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure that there's any good way of addressing this short. of having ROOT release the core mutex before calling dlopen. But this would probably require introducing another mutex for use. in at least TClass::GetClass to serialize dictionary loading.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1889,energy efficiency,core,core,1889," forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure that there's any good way of addressing this short. of having ROOT release the core mutex before calling dlopen. But this would probably require introducing another mutex for use. in at least TClass::GetClass to serialize dictionary loading.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:2076,energy efficiency,core,core,2076," forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure that there's any good way of addressing this short. of having ROOT release the core mutex before calling dlopen. But this would probably require introducing another mutex for use. in at least TClass::GetClass to serialize dictionary loading.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:2230,energy efficiency,load,loading,2230," forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure that there's any good way of addressing this short. of having ROOT release the core mutex before calling dlopen. But this would probably require introducing another mutex for use. in at least TClass::GetClass to serialize dictionary loading.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:433,integrability,wrap,wrapping,433,"Thanks Philippe. After further consideration, i think you're right. I had indeed been concerned about a possible deadlock, but i had thought. that it was probably ok because a similar change was working fine. in production. But (a), i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure tha",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:866,integrability,compon,components,866,"Thanks Philippe. After further consideration, i think you're right. I had indeed been concerned about a possible deadlock, but i had thought. that it was probably ok because a similar change was working fine. in production. But (a), i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure tha",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:897,integrability,event,event,897,"Thanks Philippe. After further consideration, i think you're right. I had indeed been concerned about a possible deadlock, but i had thought. that it was probably ok because a similar change was working fine. in production. But (a), i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure tha",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:644,interoperability,plug,plugin,644,"Thanks Philippe. After further consideration, i think you're right. I had indeed been concerned about a possible deadlock, but i had thought. that it was probably ok because a similar change was working fine. in production. But (a), i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure tha",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:866,interoperability,compon,components,866,"Thanks Philippe. After further consideration, i think you're right. I had indeed been concerned about a possible deadlock, but i had thought. that it was probably ok because a similar change was working fine. in production. But (a), i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure tha",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:967,interoperability,share,shared,967,"Thanks Philippe. After further consideration, i think you're right. I had indeed been concerned about a possible deadlock, but i had thought. that it was probably ok because a similar change was working fine. in production. But (a), i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure tha",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1783,interoperability,share,shared,1783," forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure that there's any good way of addressing this short. of having ROOT release the core mutex before calling dlopen. But this would probably require introducing another mutex for use. in at least TClass::GetClass to serialize dictionary loading.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:86,modifiability,concern,concerned,86,"Thanks Philippe. After further consideration, i think you're right. I had indeed been concerned about a possible deadlock, but i had thought. that it was probably ok because a similar change was working fine. in production. But (a), i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure tha",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:866,modifiability,compon,components,866,"Thanks Philippe. After further consideration, i think you're right. I had indeed been concerned about a possible deadlock, but i had thought. that it was probably ok because a similar change was working fine. in production. But (a), i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure tha",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:113,performance,deadlock,deadlock,113,"Thanks Philippe. After further consideration, i think you're right. I had indeed been concerned about a possible deadlock, but i had thought. that it was probably ok because a similar change was working fine. in production. But (a), i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure tha",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:266,performance,lock,lock,266,"Thanks Philippe. After further consideration, i think you're right. I had indeed been concerned about a possible deadlock, but i had thought. that it was probably ok because a similar change was working fine. in production. But (a), i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure tha",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:477,performance,lock,lock,477,"Thanks Philippe. After further consideration, i think you're right. I had indeed been concerned about a possible deadlock, but i had thought. that it was probably ok because a similar change was working fine. in production. But (a), i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure tha",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:677,performance,load,load,677,"Thanks Philippe. After further consideration, i think you're right. I had indeed been concerned about a possible deadlock, but i had thought. that it was probably ok because a similar change was working fine. in production. But (a), i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure tha",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:794,performance,lock,lock,794,"Thanks Philippe. After further consideration, i think you're right. I had indeed been concerned about a possible deadlock, but i had thought. that it was probably ok because a similar change was working fine. in production. But (a), i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure tha",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:884,performance,load,loaded,884,"Thanks Philippe. After further consideration, i think you're right. I had indeed been concerned about a possible deadlock, but i had thought. that it was probably ok because a similar change was working fine. in production. But (a), i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure tha",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1006,performance,load,loaded,1006,"ilippe. After further consideration, i think you're right. I had indeed been concerned about a possible deadlock, but i had thought. that it was probably ok because a similar change was working fine. in production. But (a), i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure that there's",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1227,performance,lock,locking,1227,", i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure that there's any good way of addressing this short. of having ROOT release the core mutex before calling dlopen. But this would probably require introducing another mutex for use. in at least TClass::GetClass to serialize dictionary l",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1702,performance,deadlock,deadlock,1702," forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure that there's any good way of addressing this short. of having ROOT release the core mutex before calling dlopen. But this would probably require introducing another mutex for use. in at least TClass::GetClass to serialize dictionary loading.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1971,performance,deadlock,deadlocking,1971," forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure that there's any good way of addressing this short. of having ROOT release the core mutex before calling dlopen. But this would probably require introducing another mutex for use. in at least TClass::GetClass to serialize dictionary loading.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:2230,performance,load,loading,2230," forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure that there's any good way of addressing this short. of having ROOT release the core mutex before calling dlopen. But this would probably require introducing another mutex for use. in at least TClass::GetClass to serialize dictionary loading.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:375,safety,patch,patch,375,"Thanks Philippe. After further consideration, i think you're right. I had indeed been concerned about a possible deadlock, but i had thought. that it was probably ok because a similar change was working fine. in production. But (a), i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure tha",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:651,safety,manag,manager,651,"Thanks Philippe. After further consideration, i think you're right. I had indeed been concerned about a possible deadlock, but i had thought. that it was probably ok because a similar change was working fine. in production. But (a), i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure tha",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1117,safety,compl,completely,1117," but i had thought. that it was probably ok because a similar change was working fine. in production. But (a), i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure that there's any good way of addressing this short. of having ROOT release the core mutex before calling dlopen. But this wou",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1745,safety,prevent,prevent,1745," forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure that there's any good way of addressing this short. of having ROOT release the core mutex before calling dlopen. But this would probably require introducing another mutex for use. in at least TClass::GetClass to serialize dictionary loading.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:266,security,lock,lock,266,"Thanks Philippe. After further consideration, i think you're right. I had indeed been concerned about a possible deadlock, but i had thought. that it was probably ok because a similar change was working fine. in production. But (a), i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure tha",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:375,security,patch,patch,375,"Thanks Philippe. After further consideration, i think you're right. I had indeed been concerned about a possible deadlock, but i had thought. that it was probably ok because a similar change was working fine. in production. But (a), i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure tha",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:477,security,lock,lock,477,"Thanks Philippe. After further consideration, i think you're right. I had indeed been concerned about a possible deadlock, but i had thought. that it was probably ok because a similar change was working fine. in production. But (a), i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure tha",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:794,security,lock,lock,794,"Thanks Philippe. After further consideration, i think you're right. I had indeed been concerned about a possible deadlock, but i had thought. that it was probably ok because a similar change was working fine. in production. But (a), i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure tha",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1117,security,compl,completely,1117," but i had thought. that it was probably ok because a similar change was working fine. in production. But (a), i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure that there's any good way of addressing this short. of having ROOT release the core mutex before calling dlopen. But this wou",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1227,security,lock,locking,1227,", i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure that there's any good way of addressing this short. of having ROOT release the core mutex before calling dlopen. But this would probably require introducing another mutex for use. in at least TClass::GetClass to serialize dictionary l",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1745,security,preven,prevent,1745," forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure that there's any good way of addressing this short. of having ROOT release the core mutex before calling dlopen. But this would probably require introducing another mutex for use. in at least TClass::GetClass to serialize dictionary loading.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:86,testability,concern,concerned,86,"Thanks Philippe. After further consideration, i think you're right. I had indeed been concerned about a possible deadlock, but i had thought. that it was probably ok because a similar change was working fine. in production. But (a), i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure tha",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:368,usability,custom,custom,368,"Thanks Philippe. After further consideration, i think you're right. I had indeed been concerned about a possible deadlock, but i had thought. that it was probably ok because a similar change was working fine. in production. But (a), i had forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure tha",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1943,usability,user,user,1943," forgotten about the dlopen lock and (b),. they weren't exactly the same change. As i alluded to above, we didn't. want to have a custom patch to ROOT, so for production we address this. race by wrapping dlopen. But in that case, the core lock is acquired. _before_ the call to dlopen, not after. So, what is to be done? There is probably only one code path in ATLAS that was giving us problems. The Gaudi plugin manager was being used to load one of the POOL libraries. that happened to include ROOT dictionary information. I could. acquire the ROOT core lock around this (and one or two other places. where i known that Gaudi components may be loaded after event processing. starts). However, there are many other places where shared libraries. could potentially be loaded. While those probably don't matter... the original bug here was quite opaque, taking several months. to completely track down. So i'm loathe to leave open any possibility. that it could bite us again. We could add locking within TClassTable. This is perhaps an attractive. way forward, as it should make it much easier to ensure that usages. of TClassTable are correct. A drawback is that is hard to then ensure. that we don't have something else that is also supposed to be protected. by the core mutex. Nevertheless, i could try to prepare a change. to do this if it sounds good. However, that's not the end of the problems. If this analysis is correct, then we _already_ have potential deadlock. problems, as there is nothing to prevent the initialization code of a. shared library (which can be arbitrary used code) from calling into ROOT. in a way that would acquire the core mutex. So code which would look. innocent to the user would have a chance of deadlocking. I'm not sure that there's any good way of addressing this short. of having ROOT release the core mutex before calling dlopen. But this would probably require introducing another mutex for use. in at least TClass::GetClass to serialize dictionary loading.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:36,performance,time,time,36,Will change this to a draft for the time being.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:361,deployability,releas,release,361,"> If this analysis is correct, then we already have potential deadlock problems, ... Indeed but the only we can really affect is the code that is intentionally (and necessarily) called during library loading. The rest (for better and worse) has to be left to the user (to avoid). > I'm not sure that there's any good way of addressing this short of having ROOT release the core mutex before calling dlopen. I don't think so either. The only way where we could have support this would be we could (and of course we can not :) ) enforce that all `dlopen` have to go through the ROOT wrapper for it. > We could add locking within TClassTable. . So I think this is the only choice ....",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:200,energy efficiency,load,loading,200,"> If this analysis is correct, then we already have potential deadlock problems, ... Indeed but the only we can really affect is the code that is intentionally (and necessarily) called during library loading. The rest (for better and worse) has to be left to the user (to avoid). > I'm not sure that there's any good way of addressing this short of having ROOT release the core mutex before calling dlopen. I don't think so either. The only way where we could have support this would be we could (and of course we can not :) ) enforce that all `dlopen` have to go through the ROOT wrapper for it. > We could add locking within TClassTable. . So I think this is the only choice ....",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:373,energy efficiency,core,core,373,"> If this analysis is correct, then we already have potential deadlock problems, ... Indeed but the only we can really affect is the code that is intentionally (and necessarily) called during library loading. The rest (for better and worse) has to be left to the user (to avoid). > I'm not sure that there's any good way of addressing this short of having ROOT release the core mutex before calling dlopen. I don't think so either. The only way where we could have support this would be we could (and of course we can not :) ) enforce that all `dlopen` have to go through the ROOT wrapper for it. > We could add locking within TClassTable. . So I think this is the only choice ....",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:581,integrability,wrap,wrapper,581,"> If this analysis is correct, then we already have potential deadlock problems, ... Indeed but the only we can really affect is the code that is intentionally (and necessarily) called during library loading. The rest (for better and worse) has to be left to the user (to avoid). > I'm not sure that there's any good way of addressing this short of having ROOT release the core mutex before calling dlopen. I don't think so either. The only way where we could have support this would be we could (and of course we can not :) ) enforce that all `dlopen` have to go through the ROOT wrapper for it. > We could add locking within TClassTable. . So I think this is the only choice ....",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:581,interoperability,wrapper,wrapper,581,"> If this analysis is correct, then we already have potential deadlock problems, ... Indeed but the only we can really affect is the code that is intentionally (and necessarily) called during library loading. The rest (for better and worse) has to be left to the user (to avoid). > I'm not sure that there's any good way of addressing this short of having ROOT release the core mutex before calling dlopen. I don't think so either. The only way where we could have support this would be we could (and of course we can not :) ) enforce that all `dlopen` have to go through the ROOT wrapper for it. > We could add locking within TClassTable. . So I think this is the only choice ....",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:62,performance,deadlock,deadlock,62,"> If this analysis is correct, then we already have potential deadlock problems, ... Indeed but the only we can really affect is the code that is intentionally (and necessarily) called during library loading. The rest (for better and worse) has to be left to the user (to avoid). > I'm not sure that there's any good way of addressing this short of having ROOT release the core mutex before calling dlopen. I don't think so either. The only way where we could have support this would be we could (and of course we can not :) ) enforce that all `dlopen` have to go through the ROOT wrapper for it. > We could add locking within TClassTable. . So I think this is the only choice ....",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:200,performance,load,loading,200,"> If this analysis is correct, then we already have potential deadlock problems, ... Indeed but the only we can really affect is the code that is intentionally (and necessarily) called during library loading. The rest (for better and worse) has to be left to the user (to avoid). > I'm not sure that there's any good way of addressing this short of having ROOT release the core mutex before calling dlopen. I don't think so either. The only way where we could have support this would be we could (and of course we can not :) ) enforce that all `dlopen` have to go through the ROOT wrapper for it. > We could add locking within TClassTable. . So I think this is the only choice ....",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:612,performance,lock,locking,612,"> If this analysis is correct, then we already have potential deadlock problems, ... Indeed but the only we can really affect is the code that is intentionally (and necessarily) called during library loading. The rest (for better and worse) has to be left to the user (to avoid). > I'm not sure that there's any good way of addressing this short of having ROOT release the core mutex before calling dlopen. I don't think so either. The only way where we could have support this would be we could (and of course we can not :) ) enforce that all `dlopen` have to go through the ROOT wrapper for it. > We could add locking within TClassTable. . So I think this is the only choice ....",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:272,safety,avoid,avoid,272,"> If this analysis is correct, then we already have potential deadlock problems, ... Indeed but the only we can really affect is the code that is intentionally (and necessarily) called during library loading. The rest (for better and worse) has to be left to the user (to avoid). > I'm not sure that there's any good way of addressing this short of having ROOT release the core mutex before calling dlopen. I don't think so either. The only way where we could have support this would be we could (and of course we can not :) ) enforce that all `dlopen` have to go through the ROOT wrapper for it. > We could add locking within TClassTable. . So I think this is the only choice ....",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:612,security,lock,locking,612,"> If this analysis is correct, then we already have potential deadlock problems, ... Indeed but the only we can really affect is the code that is intentionally (and necessarily) called during library loading. The rest (for better and worse) has to be left to the user (to avoid). > I'm not sure that there's any good way of addressing this short of having ROOT release the core mutex before calling dlopen. I don't think so either. The only way where we could have support this would be we could (and of course we can not :) ) enforce that all `dlopen` have to go through the ROOT wrapper for it. > We could add locking within TClassTable. . So I think this is the only choice ....",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:263,usability,user,user,263,"> If this analysis is correct, then we already have potential deadlock problems, ... Indeed but the only we can really affect is the code that is intentionally (and necessarily) called during library loading. The rest (for better and worse) has to be left to the user (to avoid). > I'm not sure that there's any good way of addressing this short of having ROOT release the core mutex before calling dlopen. I don't think so either. The only way where we could have support this would be we could (and of course we can not :) ) enforce that all `dlopen` have to go through the ROOT wrapper for it. > We could add locking within TClassTable. . So I think this is the only choice ....",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:465,usability,support,support,465,"> If this analysis is correct, then we already have potential deadlock problems, ... Indeed but the only we can really affect is the code that is intentionally (and necessarily) called during library loading. The rest (for better and worse) has to be left to the user (to avoid). > I'm not sure that there's any good way of addressing this short of having ROOT release the core mutex before calling dlopen. I don't think so either. The only way where we could have support this would be we could (and of course we can not :) ) enforce that all `dlopen` have to go through the ROOT wrapper for it. > We could add locking within TClassTable. . So I think this is the only choice ....",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:27,availability,failur,failure,27,"I am able to reproduce the failure with a simple standalone reproducer (2 threads one loading and unloading a library, the other interogating `TClassTable`). I will prepare a PR with the fine grained locking (or whatever is needed to make the crash go away :) )",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:27,deployability,fail,failure,27,"I am able to reproduce the failure with a simple standalone reproducer (2 threads one loading and unloading a library, the other interogating `TClassTable`). I will prepare a PR with the fine grained locking (or whatever is needed to make the crash go away :) )",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:98,deployability,unload,unloading,98,"I am able to reproduce the failure with a simple standalone reproducer (2 threads one loading and unloading a library, the other interogating `TClassTable`). I will prepare a PR with the fine grained locking (or whatever is needed to make the crash go away :) )",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:86,energy efficiency,load,loading,86,"I am able to reproduce the failure with a simple standalone reproducer (2 threads one loading and unloading a library, the other interogating `TClassTable`). I will prepare a PR with the fine grained locking (or whatever is needed to make the crash go away :) )",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:27,performance,failur,failure,27,"I am able to reproduce the failure with a simple standalone reproducer (2 threads one loading and unloading a library, the other interogating `TClassTable`). I will prepare a PR with the fine grained locking (or whatever is needed to make the crash go away :) )",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:86,performance,load,loading,86,"I am able to reproduce the failure with a simple standalone reproducer (2 threads one loading and unloading a library, the other interogating `TClassTable`). I will prepare a PR with the fine grained locking (or whatever is needed to make the crash go away :) )",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:200,performance,lock,locking,200,"I am able to reproduce the failure with a simple standalone reproducer (2 threads one loading and unloading a library, the other interogating `TClassTable`). I will prepare a PR with the fine grained locking (or whatever is needed to make the crash go away :) )",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:27,reliability,fail,failure,27,"I am able to reproduce the failure with a simple standalone reproducer (2 threads one loading and unloading a library, the other interogating `TClassTable`). I will prepare a PR with the fine grained locking (or whatever is needed to make the crash go away :) )",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:200,security,lock,locking,200,"I am able to reproduce the failure with a simple standalone reproducer (2 threads one loading and unloading a library, the other interogating `TClassTable`). I will prepare a PR with the fine grained locking (or whatever is needed to make the crash go away :) )",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:42,testability,simpl,simple,42,"I am able to reproduce the failure with a simple standalone reproducer (2 threads one loading and unloading a library, the other interogating `TClassTable`). I will prepare a PR with the fine grained locking (or whatever is needed to make the crash go away :) )",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:42,usability,simpl,simple,42,"I am able to reproduce the failure with a simple standalone reproducer (2 threads one loading and unloading a library, the other interogating `TClassTable`). I will prepare a PR with the fine grained locking (or whatever is needed to make the crash go away :) )",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:893,availability,error,error-skeleton,893,"For the record `Helgrind` does report the issue we have been discussed when run on my reproducer (i.e. this is a praise for helgrind :) ). ```. ==1413== Possible data race during write of size 8 at 0x56DD6F0 by thread #2. ==1413== Locks held: 1, at address 0x403AA48. ==1413== at 0x4CEDDBD: TClassTable::Remove(char const*) (TClassTable.cxx:500). ==1413== by 0x4CEEDD3: ROOT::RemoveClass(char const*) (TClassTable.cxx:859). ==1413== by 0x4882C25: ROOT::Internal::TDefaultInitBehavior::Unregister(char const*) const (Rtypes.h:172). ==1413== by 0x4D8180D: ROOT::TGenericClassInfo::~TGenericClassInfo() (TGenericClassInfo.cxx:221). ==1413== by 0x51F0A55: __cxa_finalize (cxa_finalize.c:83). ==1413== by 0x14FA76D6: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/libUser.so). ==1413== by 0x40021A1: call_destructors (dl-close.c:129). ==1413== by 0x531FC84: _dl_catch_exception (dl-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1144,availability,error,error-skeleton,1144,"= Possible data race during write of size 8 at 0x56DD6F0 by thread #2. ==1413== Locks held: 1, at address 0x403AA48. ==1413== at 0x4CEDDBD: TClassTable::Remove(char const*) (TClassTable.cxx:500). ==1413== by 0x4CEEDD3: ROOT::RemoveClass(char const*) (TClassTable.cxx:859). ==1413== by 0x4882C25: ROOT::Internal::TDefaultInitBehavior::Unregister(char const*) const (Rtypes.h:172). ==1413== by 0x4D8180D: ROOT::TGenericClassInfo::~TGenericClassInfo() (TGenericClassInfo.cxx:221). ==1413== by 0x51F0A55: __cxa_finalize (cxa_finalize.c:83). ==1413== by 0x14FA76D6: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/libUser.so). ==1413== by 0x40021A1: call_destructors (dl-close.c:129). ==1413== by 0x531FC84: _dl_catch_exception (dl-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC01: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==14",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1210,availability,error,error-skeleton,1210," #2. ==1413== Locks held: 1, at address 0x403AA48. ==1413== at 0x4CEDDBD: TClassTable::Remove(char const*) (TClassTable.cxx:500). ==1413== by 0x4CEEDD3: ROOT::RemoveClass(char const*) (TClassTable.cxx:859). ==1413== by 0x4882C25: ROOT::Internal::TDefaultInitBehavior::Unregister(char const*) const (Rtypes.h:172). ==1413== by 0x4D8180D: ROOT::TGenericClassInfo::~TGenericClassInfo() (TGenericClassInfo.cxx:221). ==1413== by 0x51F0A55: __cxa_finalize (cxa_finalize.c:83). ==1413== by 0x14FA76D6: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/libUser.so). ==1413== by 0x40021A1: call_destructors (dl-close.c:129). ==1413== by 0x531FC84: _dl_catch_exception (dl-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC01: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== Address 0x56dd6f0 is 7,312 bytes inside a block of size 8,072",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:2250,availability,operat,operator,2250,"13==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC01: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== Address 0x56dd6f0 is 7,312 bytes inside a block of size 8,072 alloc'd. ==1413== at 0x484C373: operator new[](unsigned long) (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so). ==1413== by 0x4CECE13: TClassTable::TClassTable() (TClassTable.cxx:223). ==1413== by 0x4CEF6F2: TClassTable::CheckClassTableInit() (TClassTable.cxx:266). ==1413== by 0x4CEE015: TClassTable::FindElement(char const*, bool) (TClassTable.cxx:541). ==1413== by 0x4CEEBF3: ROOT::ResetClassVersion(TClass*, char const*, short) (TClassTable.cxx:813). ==1413== by 0x4D82480: ROOT::TGenericClassInfo::SetVersion(short) (TGenericClassInfo.cxx:419). ==1413== by 0x4C22B41: __static_initialization_and_destruction_0(int, int) (String.cxx:39). ==1413== by 0x4C22B62: _GLOBAL__sub_I_String.cxx (String.cxx:39). ==1413== by 0x400647D: call_init.part.0 (dl-init.c:70). ==1413== by 0x4006567: call_init (dl-init.c:33). ==1413== by 0x4006567: _dl_init (dl-init.c:117). ==1413== by 0x40202E9: ??? (in /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2). ==1413== by 0x4: ??? ==1413== Block was alloc'd by thread #1. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:2218,energy efficiency,alloc,alloc,2218,"ton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC01: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== Address 0x56dd6f0 is 7,312 bytes inside a block of size 8,072 alloc'd. ==1413== at 0x484C373: operator new[](unsigned long) (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so). ==1413== by 0x4CECE13: TClassTable::TClassTable() (TClassTable.cxx:223). ==1413== by 0x4CEF6F2: TClassTable::CheckClassTableInit() (TClassTable.cxx:266). ==1413== by 0x4CEE015: TClassTable::FindElement(char const*, bool) (TClassTable.cxx:541). ==1413== by 0x4CEEBF3: ROOT::ResetClassVersion(TClass*, char const*, short) (TClassTable.cxx:813). ==1413== by 0x4D82480: ROOT::TGenericClassInfo::SetVersion(short) (TGenericClassInfo.cxx:419). ==1413== by 0x4C22B41: __static_initialization_and_destruction_0(int, int) (String.cxx:39). ==1413== by 0x4C22B62: _GLOBAL__sub_I_String.cxx (String.cxx:39). ==1413== by 0x400647D: call_init.part.0 (dl-init.c:70). ==1413== by 0x4006567: call_init (dl-init.c:33). ==1413== by 0x4006567: _dl_init (dl-init.c:117). ==1413== by 0x40202E9: ??? (in /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2). ==1413== by 0x4: ??? ==1413== Block was alloc'd b",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:3212,energy efficiency,alloc,alloc,3212,"13==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC01: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== Address 0x56dd6f0 is 7,312 bytes inside a block of size 8,072 alloc'd. ==1413== at 0x484C373: operator new[](unsigned long) (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so). ==1413== by 0x4CECE13: TClassTable::TClassTable() (TClassTable.cxx:223). ==1413== by 0x4CEF6F2: TClassTable::CheckClassTableInit() (TClassTable.cxx:266). ==1413== by 0x4CEE015: TClassTable::FindElement(char const*, bool) (TClassTable.cxx:541). ==1413== by 0x4CEEBF3: ROOT::ResetClassVersion(TClass*, char const*, short) (TClassTable.cxx:813). ==1413== by 0x4D82480: ROOT::TGenericClassInfo::SetVersion(short) (TGenericClassInfo.cxx:419). ==1413== by 0x4C22B41: __static_initialization_and_destruction_0(int, int) (String.cxx:39). ==1413== by 0x4C22B62: _GLOBAL__sub_I_String.cxx (String.cxx:39). ==1413== by 0x400647D: call_init.part.0 (dl-init.c:70). ==1413== by 0x4006567: call_init (dl-init.c:33). ==1413== by 0x4006567: _dl_init (dl-init.c:117). ==1413== by 0x40202E9: ??? (in /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2). ==1413== by 0x4: ??? ==1413== Block was alloc'd by thread #1. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:899,interoperability,skeleton,skeleton,899,"For the record `Helgrind` does report the issue we have been discussed when run on my reproducer (i.e. this is a praise for helgrind :) ). ```. ==1413== Possible data race during write of size 8 at 0x56DD6F0 by thread #2. ==1413== Locks held: 1, at address 0x403AA48. ==1413== at 0x4CEDDBD: TClassTable::Remove(char const*) (TClassTable.cxx:500). ==1413== by 0x4CEEDD3: ROOT::RemoveClass(char const*) (TClassTable.cxx:859). ==1413== by 0x4882C25: ROOT::Internal::TDefaultInitBehavior::Unregister(char const*) const (Rtypes.h:172). ==1413== by 0x4D8180D: ROOT::TGenericClassInfo::~TGenericClassInfo() (TGenericClassInfo.cxx:221). ==1413== by 0x51F0A55: __cxa_finalize (cxa_finalize.c:83). ==1413== by 0x14FA76D6: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/libUser.so). ==1413== by 0x40021A1: call_destructors (dl-close.c:129). ==1413== by 0x531FC84: _dl_catch_exception (dl-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1150,interoperability,skeleton,skeleton,1150,"ossible data race during write of size 8 at 0x56DD6F0 by thread #2. ==1413== Locks held: 1, at address 0x403AA48. ==1413== at 0x4CEDDBD: TClassTable::Remove(char const*) (TClassTable.cxx:500). ==1413== by 0x4CEEDD3: ROOT::RemoveClass(char const*) (TClassTable.cxx:859). ==1413== by 0x4882C25: ROOT::Internal::TDefaultInitBehavior::Unregister(char const*) const (Rtypes.h:172). ==1413== by 0x4D8180D: ROOT::TGenericClassInfo::~TGenericClassInfo() (TGenericClassInfo.cxx:221). ==1413== by 0x51F0A55: __cxa_finalize (cxa_finalize.c:83). ==1413== by 0x14FA76D6: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/libUser.so). ==1413== by 0x40021A1: call_destructors (dl-close.c:129). ==1413== by 0x531FC84: _dl_catch_exception (dl-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC01: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413=",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1216,interoperability,skeleton,skeleton,1216,". ==1413== Locks held: 1, at address 0x403AA48. ==1413== at 0x4CEDDBD: TClassTable::Remove(char const*) (TClassTable.cxx:500). ==1413== by 0x4CEEDD3: ROOT::RemoveClass(char const*) (TClassTable.cxx:859). ==1413== by 0x4882C25: ROOT::Internal::TDefaultInitBehavior::Unregister(char const*) const (Rtypes.h:172). ==1413== by 0x4D8180D: ROOT::TGenericClassInfo::~TGenericClassInfo() (TGenericClassInfo.cxx:221). ==1413== by 0x51F0A55: __cxa_finalize (cxa_finalize.c:83). ==1413== by 0x14FA76D6: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/libUser.so). ==1413== by 0x40021A1: call_destructors (dl-close.c:129). ==1413== by 0x531FC84: _dl_catch_exception (dl-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC01: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== Address 0x56dd6f0 is 7,312 bytes inside a block of size 8,072 al",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1257,interoperability,conflict,conflicts,1257,"AA48. ==1413== at 0x4CEDDBD: TClassTable::Remove(char const*) (TClassTable.cxx:500). ==1413== by 0x4CEEDD3: ROOT::RemoveClass(char const*) (TClassTable.cxx:859). ==1413== by 0x4882C25: ROOT::Internal::TDefaultInitBehavior::Unregister(char const*) const (Rtypes.h:172). ==1413== by 0x4D8180D: ROOT::TGenericClassInfo::~TGenericClassInfo() (TGenericClassInfo.cxx:221). ==1413== by 0x51F0A55: __cxa_finalize (cxa_finalize.c:83). ==1413== by 0x14FA76D6: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/libUser.so). ==1413== by 0x40021A1: call_destructors (dl-close.c:129). ==1413== by 0x531FC84: _dl_catch_exception (dl-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC01: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== Address 0x56dd6f0 is 7,312 bytes inside a block of size 8,072 alloc'd. ==1413== at 0x484C373: operator new",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:231,performance,Lock,Locks,231,"For the record `Helgrind` does report the issue we have been discussed when run on my reproducer (i.e. this is a praise for helgrind :) ). ```. ==1413== Possible data race during write of size 8 at 0x56DD6F0 by thread #2. ==1413== Locks held: 1, at address 0x403AA48. ==1413== at 0x4CEDDBD: TClassTable::Remove(char const*) (TClassTable.cxx:500). ==1413== by 0x4CEEDD3: ROOT::RemoveClass(char const*) (TClassTable.cxx:859). ==1413== by 0x4882C25: ROOT::Internal::TDefaultInitBehavior::Unregister(char const*) const (Rtypes.h:172). ==1413== by 0x4D8180D: ROOT::TGenericClassInfo::~TGenericClassInfo() (TGenericClassInfo.cxx:221). ==1413== by 0x51F0A55: __cxa_finalize (cxa_finalize.c:83). ==1413== by 0x14FA76D6: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/libUser.so). ==1413== by 0x40021A1: call_destructors (dl-close.c:129). ==1413== by 0x531FC84: _dl_catch_exception (dl-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:893,performance,error,error-skeleton,893,"For the record `Helgrind` does report the issue we have been discussed when run on my reproducer (i.e. this is a praise for helgrind :) ). ```. ==1413== Possible data race during write of size 8 at 0x56DD6F0 by thread #2. ==1413== Locks held: 1, at address 0x403AA48. ==1413== at 0x4CEDDBD: TClassTable::Remove(char const*) (TClassTable.cxx:500). ==1413== by 0x4CEEDD3: ROOT::RemoveClass(char const*) (TClassTable.cxx:859). ==1413== by 0x4882C25: ROOT::Internal::TDefaultInitBehavior::Unregister(char const*) const (Rtypes.h:172). ==1413== by 0x4D8180D: ROOT::TGenericClassInfo::~TGenericClassInfo() (TGenericClassInfo.cxx:221). ==1413== by 0x51F0A55: __cxa_finalize (cxa_finalize.c:83). ==1413== by 0x14FA76D6: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/libUser.so). ==1413== by 0x40021A1: call_destructors (dl-close.c:129). ==1413== by 0x531FC84: _dl_catch_exception (dl-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1144,performance,error,error-skeleton,1144,"= Possible data race during write of size 8 at 0x56DD6F0 by thread #2. ==1413== Locks held: 1, at address 0x403AA48. ==1413== at 0x4CEDDBD: TClassTable::Remove(char const*) (TClassTable.cxx:500). ==1413== by 0x4CEEDD3: ROOT::RemoveClass(char const*) (TClassTable.cxx:859). ==1413== by 0x4882C25: ROOT::Internal::TDefaultInitBehavior::Unregister(char const*) const (Rtypes.h:172). ==1413== by 0x4D8180D: ROOT::TGenericClassInfo::~TGenericClassInfo() (TGenericClassInfo.cxx:221). ==1413== by 0x51F0A55: __cxa_finalize (cxa_finalize.c:83). ==1413== by 0x14FA76D6: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/libUser.so). ==1413== by 0x40021A1: call_destructors (dl-close.c:129). ==1413== by 0x531FC84: _dl_catch_exception (dl-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC01: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==14",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1210,performance,error,error-skeleton,1210," #2. ==1413== Locks held: 1, at address 0x403AA48. ==1413== at 0x4CEDDBD: TClassTable::Remove(char const*) (TClassTable.cxx:500). ==1413== by 0x4CEEDD3: ROOT::RemoveClass(char const*) (TClassTable.cxx:859). ==1413== by 0x4882C25: ROOT::Internal::TDefaultInitBehavior::Unregister(char const*) const (Rtypes.h:172). ==1413== by 0x4D8180D: ROOT::TGenericClassInfo::~TGenericClassInfo() (TGenericClassInfo.cxx:221). ==1413== by 0x51F0A55: __cxa_finalize (cxa_finalize.c:83). ==1413== by 0x14FA76D6: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/libUser.so). ==1413== by 0x40021A1: call_destructors (dl-close.c:129). ==1413== by 0x531FC84: _dl_catch_exception (dl-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC01: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== Address 0x56dd6f0 is 7,312 bytes inside a block of size 8,072",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1321,performance,Lock,Locks,1321,"(TClassTable.cxx:500). ==1413== by 0x4CEEDD3: ROOT::RemoveClass(char const*) (TClassTable.cxx:859). ==1413== by 0x4882C25: ROOT::Internal::TDefaultInitBehavior::Unregister(char const*) const (Rtypes.h:172). ==1413== by 0x4D8180D: ROOT::TGenericClassInfo::~TGenericClassInfo() (TGenericClassInfo.cxx:221). ==1413== by 0x51F0A55: __cxa_finalize (cxa_finalize.c:83). ==1413== by 0x14FA76D6: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/libUser.so). ==1413== by 0x40021A1: call_destructors (dl-close.c:129). ==1413== by 0x531FC84: _dl_catch_exception (dl-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC01: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== Address 0x56dd6f0 is 7,312 bytes inside a block of size 8,072 alloc'd. ==1413== at 0x484C373: operator new[](unsigned long) (in /usr/libexec/valgrind/vgpreload_helgrind",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:26,reliability,doe,does,26,"For the record `Helgrind` does report the issue we have been discussed when run on my reproducer (i.e. this is a praise for helgrind :) ). ```. ==1413== Possible data race during write of size 8 at 0x56DD6F0 by thread #2. ==1413== Locks held: 1, at address 0x403AA48. ==1413== at 0x4CEDDBD: TClassTable::Remove(char const*) (TClassTable.cxx:500). ==1413== by 0x4CEEDD3: ROOT::RemoveClass(char const*) (TClassTable.cxx:859). ==1413== by 0x4882C25: ROOT::Internal::TDefaultInitBehavior::Unregister(char const*) const (Rtypes.h:172). ==1413== by 0x4D8180D: ROOT::TGenericClassInfo::~TGenericClassInfo() (TGenericClassInfo.cxx:221). ==1413== by 0x51F0A55: __cxa_finalize (cxa_finalize.c:83). ==1413== by 0x14FA76D6: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/libUser.so). ==1413== by 0x40021A1: call_destructors (dl-close.c:129). ==1413== by 0x531FC84: _dl_catch_exception (dl-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:113,reliability,pra,praise,113,"For the record `Helgrind` does report the issue we have been discussed when run on my reproducer (i.e. this is a praise for helgrind :) ). ```. ==1413== Possible data race during write of size 8 at 0x56DD6F0 by thread #2. ==1413== Locks held: 1, at address 0x403AA48. ==1413== at 0x4CEDDBD: TClassTable::Remove(char const*) (TClassTable.cxx:500). ==1413== by 0x4CEEDD3: ROOT::RemoveClass(char const*) (TClassTable.cxx:859). ==1413== by 0x4882C25: ROOT::Internal::TDefaultInitBehavior::Unregister(char const*) const (Rtypes.h:172). ==1413== by 0x4D8180D: ROOT::TGenericClassInfo::~TGenericClassInfo() (TGenericClassInfo.cxx:221). ==1413== by 0x51F0A55: __cxa_finalize (cxa_finalize.c:83). ==1413== by 0x14FA76D6: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/libUser.so). ==1413== by 0x40021A1: call_destructors (dl-close.c:129). ==1413== by 0x531FC84: _dl_catch_exception (dl-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:746,safety,test,test,746,"For the record `Helgrind` does report the issue we have been discussed when run on my reproducer (i.e. this is a praise for helgrind :) ). ```. ==1413== Possible data race during write of size 8 at 0x56DD6F0 by thread #2. ==1413== Locks held: 1, at address 0x403AA48. ==1413== at 0x4CEDDBD: TClassTable::Remove(char const*) (TClassTable.cxx:500). ==1413== by 0x4CEEDD3: ROOT::RemoveClass(char const*) (TClassTable.cxx:859). ==1413== by 0x4882C25: ROOT::Internal::TDefaultInitBehavior::Unregister(char const*) const (Rtypes.h:172). ==1413== by 0x4D8180D: ROOT::TGenericClassInfo::~TGenericClassInfo() (TGenericClassInfo.cxx:221). ==1413== by 0x51F0A55: __cxa_finalize (cxa_finalize.c:83). ==1413== by 0x14FA76D6: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/libUser.so). ==1413== by 0x40021A1: call_destructors (dl-close.c:129). ==1413== by 0x531FC84: _dl_catch_exception (dl-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:893,safety,error,error-skeleton,893,"For the record `Helgrind` does report the issue we have been discussed when run on my reproducer (i.e. this is a praise for helgrind :) ). ```. ==1413== Possible data race during write of size 8 at 0x56DD6F0 by thread #2. ==1413== Locks held: 1, at address 0x403AA48. ==1413== at 0x4CEDDBD: TClassTable::Remove(char const*) (TClassTable.cxx:500). ==1413== by 0x4CEEDD3: ROOT::RemoveClass(char const*) (TClassTable.cxx:859). ==1413== by 0x4882C25: ROOT::Internal::TDefaultInitBehavior::Unregister(char const*) const (Rtypes.h:172). ==1413== by 0x4D8180D: ROOT::TGenericClassInfo::~TGenericClassInfo() (TGenericClassInfo.cxx:221). ==1413== by 0x51F0A55: __cxa_finalize (cxa_finalize.c:83). ==1413== by 0x14FA76D6: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/libUser.so). ==1413== by 0x40021A1: call_destructors (dl-close.c:129). ==1413== by 0x531FC84: _dl_catch_exception (dl-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1144,safety,error,error-skeleton,1144,"= Possible data race during write of size 8 at 0x56DD6F0 by thread #2. ==1413== Locks held: 1, at address 0x403AA48. ==1413== at 0x4CEDDBD: TClassTable::Remove(char const*) (TClassTable.cxx:500). ==1413== by 0x4CEEDD3: ROOT::RemoveClass(char const*) (TClassTable.cxx:859). ==1413== by 0x4882C25: ROOT::Internal::TDefaultInitBehavior::Unregister(char const*) const (Rtypes.h:172). ==1413== by 0x4D8180D: ROOT::TGenericClassInfo::~TGenericClassInfo() (TGenericClassInfo.cxx:221). ==1413== by 0x51F0A55: __cxa_finalize (cxa_finalize.c:83). ==1413== by 0x14FA76D6: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/libUser.so). ==1413== by 0x40021A1: call_destructors (dl-close.c:129). ==1413== by 0x531FC84: _dl_catch_exception (dl-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC01: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==14",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1210,safety,error,error-skeleton,1210," #2. ==1413== Locks held: 1, at address 0x403AA48. ==1413== at 0x4CEDDBD: TClassTable::Remove(char const*) (TClassTable.cxx:500). ==1413== by 0x4CEEDD3: ROOT::RemoveClass(char const*) (TClassTable.cxx:859). ==1413== by 0x4882C25: ROOT::Internal::TDefaultInitBehavior::Unregister(char const*) const (Rtypes.h:172). ==1413== by 0x4D8180D: ROOT::TGenericClassInfo::~TGenericClassInfo() (TGenericClassInfo.cxx:221). ==1413== by 0x51F0A55: __cxa_finalize (cxa_finalize.c:83). ==1413== by 0x14FA76D6: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/libUser.so). ==1413== by 0x40021A1: call_destructors (dl-close.c:129). ==1413== by 0x531FC84: _dl_catch_exception (dl-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC01: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== Address 0x56dd6f0 is 7,312 bytes inside a block of size 8,072",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1575,safety,test,test,1575,"::~TGenericClassInfo() (TGenericClassInfo.cxx:221). ==1413== by 0x51F0A55: __cxa_finalize (cxa_finalize.c:83). ==1413== by 0x14FA76D6: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/libUser.so). ==1413== by 0x40021A1: call_destructors (dl-close.c:129). ==1413== by 0x531FC84: _dl_catch_exception (dl-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC01: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== Address 0x56dd6f0 is 7,312 bytes inside a block of size 8,072 alloc'd. ==1413== at 0x484C373: operator new[](unsigned long) (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so). ==1413== by 0x4CECE13: TClassTable::TClassTable() (TClassTable.cxx:223). ==1413== by 0x4CEF6F2: TClassTable::CheckClassTableInit() (TClassTable.cxx:266). ==1413== by 0x4CEE015: TClassTable::FindElement(char const*, bool) (TClassTable.c",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1680,safety,test,test,1680,":83). ==1413== by 0x14FA76D6: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/libUser.so). ==1413== by 0x40021A1: call_destructors (dl-close.c:129). ==1413== by 0x531FC84: _dl_catch_exception (dl-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC01: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== Address 0x56dd6f0 is 7,312 bytes inside a block of size 8,072 alloc'd. ==1413== at 0x484C373: operator new[](unsigned long) (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so). ==1413== by 0x4CECE13: TClassTable::TClassTable() (TClassTable.cxx:223). ==1413== by 0x4CEF6F2: TClassTable::CheckClassTableInit() (TClassTable.cxx:266). ==1413== by 0x4CEE015: TClassTable::FindElement(char const*, bool) (TClassTable.cxx:541). ==1413== by 0x4CEEBF3: ROOT::ResetClassVersion(TClass*, char const*, short) (TClassTable.cxx:813",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1785,safety,test,test,1785," ==1413== by 0x40021A1: call_destructors (dl-close.c:129). ==1413== by 0x531FC84: _dl_catch_exception (dl-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC01: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== Address 0x56dd6f0 is 7,312 bytes inside a block of size 8,072 alloc'd. ==1413== at 0x484C373: operator new[](unsigned long) (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so). ==1413== by 0x4CECE13: TClassTable::TClassTable() (TClassTable.cxx:223). ==1413== by 0x4CEF6F2: TClassTable::CheckClassTableInit() (TClassTable.cxx:266). ==1413== by 0x4CEE015: TClassTable::FindElement(char const*, bool) (TClassTable.cxx:541). ==1413== by 0x4CEEBF3: ROOT::ResetClassVersion(TClass*, char const*, short) (TClassTable.cxx:813). ==1413== by 0x4D82480: ROOT::TGenericClassInfo::SetVersion(short) (TGenericClassInfo.cxx:419). ==1413=",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1890,safety,test,test,1890,"-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC01: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== Address 0x56dd6f0 is 7,312 bytes inside a block of size 8,072 alloc'd. ==1413== at 0x484C373: operator new[](unsigned long) (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so). ==1413== by 0x4CECE13: TClassTable::TClassTable() (TClassTable.cxx:223). ==1413== by 0x4CEF6F2: TClassTable::CheckClassTableInit() (TClassTable.cxx:266). ==1413== by 0x4CEE015: TClassTable::FindElement(char const*, bool) (TClassTable.cxx:541). ==1413== by 0x4CEEBF3: ROOT::ResetClassVersion(TClass*, char const*, short) (TClassTable.cxx:813). ==1413== by 0x4D82480: ROOT::TGenericClassInfo::SetVersion(short) (TGenericClassInfo.cxx:419). ==1413== by 0x4C22B41: __static_initialization_and_destruction_0(int, int) (String.cxx:39). ==1413== by 0x4C22B6",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1995,safety,test,test,1995,"by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC01: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== Address 0x56dd6f0 is 7,312 bytes inside a block of size 8,072 alloc'd. ==1413== at 0x484C373: operator new[](unsigned long) (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so). ==1413== by 0x4CECE13: TClassTable::TClassTable() (TClassTable.cxx:223). ==1413== by 0x4CEF6F2: TClassTable::CheckClassTableInit() (TClassTable.cxx:266). ==1413== by 0x4CEE015: TClassTable::FindElement(char const*, bool) (TClassTable.cxx:541). ==1413== by 0x4CEEBF3: ROOT::ResetClassVersion(TClass*, char const*, short) (TClassTable.cxx:813). ==1413== by 0x4D82480: ROOT::TGenericClassInfo::SetVersion(short) (TGenericClassInfo.cxx:419). ==1413== by 0x4C22B41: __static_initialization_and_destruction_0(int, int) (String.cxx:39). ==1413== by 0x4C22B62: _GLOBAL__sub_I_String.cxx (String.cxx:39). ==1413== by 0x400647D: call_init.part.0 (dl-init.c:70). ==1",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:2100,safety,test,test,2100,"3== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC01: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== Address 0x56dd6f0 is 7,312 bytes inside a block of size 8,072 alloc'd. ==1413== at 0x484C373: operator new[](unsigned long) (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so). ==1413== by 0x4CECE13: TClassTable::TClassTable() (TClassTable.cxx:223). ==1413== by 0x4CEF6F2: TClassTable::CheckClassTableInit() (TClassTable.cxx:266). ==1413== by 0x4CEE015: TClassTable::FindElement(char const*, bool) (TClassTable.cxx:541). ==1413== by 0x4CEEBF3: ROOT::ResetClassVersion(TClass*, char const*, short) (TClassTable.cxx:813). ==1413== by 0x4D82480: ROOT::TGenericClassInfo::SetVersion(short) (TGenericClassInfo.cxx:419). ==1413== by 0x4C22B41: __static_initialization_and_destruction_0(int, int) (String.cxx:39). ==1413== by 0x4C22B62: _GLOBAL__sub_I_String.cxx (String.cxx:39). ==1413== by 0x400647D: call_init.part.0 (dl-init.c:70). ==1413== by 0x4006567: call_init (dl-init.c:33). ==1413== by 0x4006567: _dl_init (dl-init.c:117). ==1413== b",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:231,security,Lock,Locks,231,"For the record `Helgrind` does report the issue we have been discussed when run on my reproducer (i.e. this is a praise for helgrind :) ). ```. ==1413== Possible data race during write of size 8 at 0x56DD6F0 by thread #2. ==1413== Locks held: 1, at address 0x403AA48. ==1413== at 0x4CEDDBD: TClassTable::Remove(char const*) (TClassTable.cxx:500). ==1413== by 0x4CEEDD3: ROOT::RemoveClass(char const*) (TClassTable.cxx:859). ==1413== by 0x4882C25: ROOT::Internal::TDefaultInitBehavior::Unregister(char const*) const (Rtypes.h:172). ==1413== by 0x4D8180D: ROOT::TGenericClassInfo::~TGenericClassInfo() (TGenericClassInfo.cxx:221). ==1413== by 0x51F0A55: __cxa_finalize (cxa_finalize.c:83). ==1413== by 0x14FA76D6: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/libUser.so). ==1413== by 0x40021A1: call_destructors (dl-close.c:129). ==1413== by 0x531FC84: _dl_catch_exception (dl-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1321,security,Lock,Locks,1321,"(TClassTable.cxx:500). ==1413== by 0x4CEEDD3: ROOT::RemoveClass(char const*) (TClassTable.cxx:859). ==1413== by 0x4882C25: ROOT::Internal::TDefaultInitBehavior::Unregister(char const*) const (Rtypes.h:172). ==1413== by 0x4D8180D: ROOT::TGenericClassInfo::~TGenericClassInfo() (TGenericClassInfo.cxx:221). ==1413== by 0x51F0A55: __cxa_finalize (cxa_finalize.c:83). ==1413== by 0x14FA76D6: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/libUser.so). ==1413== by 0x40021A1: call_destructors (dl-close.c:129). ==1413== by 0x531FC84: _dl_catch_exception (dl-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC01: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== Address 0x56dd6f0 is 7,312 bytes inside a block of size 8,072 alloc'd. ==1413== at 0x484C373: operator new[](unsigned long) (in /usr/libexec/valgrind/vgpreload_helgrind",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:746,testability,test,test,746,"For the record `Helgrind` does report the issue we have been discussed when run on my reproducer (i.e. this is a praise for helgrind :) ). ```. ==1413== Possible data race during write of size 8 at 0x56DD6F0 by thread #2. ==1413== Locks held: 1, at address 0x403AA48. ==1413== at 0x4CEDDBD: TClassTable::Remove(char const*) (TClassTable.cxx:500). ==1413== by 0x4CEEDD3: ROOT::RemoveClass(char const*) (TClassTable.cxx:859). ==1413== by 0x4882C25: ROOT::Internal::TDefaultInitBehavior::Unregister(char const*) const (Rtypes.h:172). ==1413== by 0x4D8180D: ROOT::TGenericClassInfo::~TGenericClassInfo() (TGenericClassInfo.cxx:221). ==1413== by 0x51F0A55: __cxa_finalize (cxa_finalize.c:83). ==1413== by 0x14FA76D6: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/libUser.so). ==1413== by 0x40021A1: call_destructors (dl-close.c:129). ==1413== by 0x531FC84: _dl_catch_exception (dl-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1575,testability,test,test,1575,"::~TGenericClassInfo() (TGenericClassInfo.cxx:221). ==1413== by 0x51F0A55: __cxa_finalize (cxa_finalize.c:83). ==1413== by 0x14FA76D6: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/libUser.so). ==1413== by 0x40021A1: call_destructors (dl-close.c:129). ==1413== by 0x531FC84: _dl_catch_exception (dl-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC01: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== Address 0x56dd6f0 is 7,312 bytes inside a block of size 8,072 alloc'd. ==1413== at 0x484C373: operator new[](unsigned long) (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so). ==1413== by 0x4CECE13: TClassTable::TClassTable() (TClassTable.cxx:223). ==1413== by 0x4CEF6F2: TClassTable::CheckClassTableInit() (TClassTable.cxx:266). ==1413== by 0x4CEE015: TClassTable::FindElement(char const*, bool) (TClassTable.c",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1680,testability,test,test,1680,":83). ==1413== by 0x14FA76D6: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/libUser.so). ==1413== by 0x40021A1: call_destructors (dl-close.c:129). ==1413== by 0x531FC84: _dl_catch_exception (dl-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC01: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== Address 0x56dd6f0 is 7,312 bytes inside a block of size 8,072 alloc'd. ==1413== at 0x484C373: operator new[](unsigned long) (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so). ==1413== by 0x4CECE13: TClassTable::TClassTable() (TClassTable.cxx:223). ==1413== by 0x4CEF6F2: TClassTable::CheckClassTableInit() (TClassTable.cxx:266). ==1413== by 0x4CEE015: TClassTable::FindElement(char const*, bool) (TClassTable.cxx:541). ==1413== by 0x4CEEBF3: ROOT::ResetClassVersion(TClass*, char const*, short) (TClassTable.cxx:813",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1785,testability,test,test,1785," ==1413== by 0x40021A1: call_destructors (dl-close.c:129). ==1413== by 0x531FC84: _dl_catch_exception (dl-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC01: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== Address 0x56dd6f0 is 7,312 bytes inside a block of size 8,072 alloc'd. ==1413== at 0x484C373: operator new[](unsigned long) (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so). ==1413== by 0x4CECE13: TClassTable::TClassTable() (TClassTable.cxx:223). ==1413== by 0x4CEF6F2: TClassTable::CheckClassTableInit() (TClassTable.cxx:266). ==1413== by 0x4CEE015: TClassTable::FindElement(char const*, bool) (TClassTable.cxx:541). ==1413== by 0x4CEEBF3: ROOT::ResetClassVersion(TClass*, char const*, short) (TClassTable.cxx:813). ==1413== by 0x4D82480: ROOT::TGenericClassInfo::SetVersion(short) (TGenericClassInfo.cxx:419). ==1413=",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1890,testability,test,test,1890,"-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC01: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== Address 0x56dd6f0 is 7,312 bytes inside a block of size 8,072 alloc'd. ==1413== at 0x484C373: operator new[](unsigned long) (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so). ==1413== by 0x4CECE13: TClassTable::TClassTable() (TClassTable.cxx:223). ==1413== by 0x4CEF6F2: TClassTable::CheckClassTableInit() (TClassTable.cxx:266). ==1413== by 0x4CEE015: TClassTable::FindElement(char const*, bool) (TClassTable.cxx:541). ==1413== by 0x4CEEBF3: ROOT::ResetClassVersion(TClass*, char const*, short) (TClassTable.cxx:813). ==1413== by 0x4D82480: ROOT::TGenericClassInfo::SetVersion(short) (TGenericClassInfo.cxx:419). ==1413== by 0x4C22B41: __static_initialization_and_destruction_0(int, int) (String.cxx:39). ==1413== by 0x4C22B6",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1995,testability,test,test,1995,"by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC01: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== Address 0x56dd6f0 is 7,312 bytes inside a block of size 8,072 alloc'd. ==1413== at 0x484C373: operator new[](unsigned long) (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so). ==1413== by 0x4CECE13: TClassTable::TClassTable() (TClassTable.cxx:223). ==1413== by 0x4CEF6F2: TClassTable::CheckClassTableInit() (TClassTable.cxx:266). ==1413== by 0x4CEE015: TClassTable::FindElement(char const*, bool) (TClassTable.cxx:541). ==1413== by 0x4CEEBF3: ROOT::ResetClassVersion(TClass*, char const*, short) (TClassTable.cxx:813). ==1413== by 0x4D82480: ROOT::TGenericClassInfo::SetVersion(short) (TGenericClassInfo.cxx:419). ==1413== by 0x4C22B41: __static_initialization_and_destruction_0(int, int) (String.cxx:39). ==1413== by 0x4C22B62: _GLOBAL__sub_I_String.cxx (String.cxx:39). ==1413== by 0x400647D: call_init.part.0 (dl-init.c:70). ==1",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:2100,testability,test,test,2100,"3== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC01: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== Address 0x56dd6f0 is 7,312 bytes inside a block of size 8,072 alloc'd. ==1413== at 0x484C373: operator new[](unsigned long) (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so). ==1413== by 0x4CECE13: TClassTable::TClassTable() (TClassTable.cxx:223). ==1413== by 0x4CEF6F2: TClassTable::CheckClassTableInit() (TClassTable.cxx:266). ==1413== by 0x4CEE015: TClassTable::FindElement(char const*, bool) (TClassTable.cxx:541). ==1413== by 0x4CEEBF3: ROOT::ResetClassVersion(TClass*, char const*, short) (TClassTable.cxx:813). ==1413== by 0x4D82480: ROOT::TGenericClassInfo::SetVersion(short) (TGenericClassInfo.cxx:419). ==1413== by 0x4C22B41: __static_initialization_and_destruction_0(int, int) (String.cxx:39). ==1413== by 0x4C22B62: _GLOBAL__sub_I_String.cxx (String.cxx:39). ==1413== by 0x400647D: call_init.part.0 (dl-init.c:70). ==1413== by 0x4006567: call_init (dl-init.c:33). ==1413== by 0x4006567: _dl_init (dl-init.c:117). ==1413== b",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:832,usability,close,close,832,"For the record `Helgrind` does report the issue we have been discussed when run on my reproducer (i.e. this is a praise for helgrind :) ). ```. ==1413== Possible data race during write of size 8 at 0x56DD6F0 by thread #2. ==1413== Locks held: 1, at address 0x403AA48. ==1413== at 0x4CEDDBD: TClassTable::Remove(char const*) (TClassTable.cxx:500). ==1413== by 0x4CEEDD3: ROOT::RemoveClass(char const*) (TClassTable.cxx:859). ==1413== by 0x4882C25: ROOT::Internal::TDefaultInitBehavior::Unregister(char const*) const (Rtypes.h:172). ==1413== by 0x4D8180D: ROOT::TGenericClassInfo::~TGenericClassInfo() (TGenericClassInfo.cxx:221). ==1413== by 0x51F0A55: __cxa_finalize (cxa_finalize.c:83). ==1413== by 0x14FA76D6: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/libUser.so). ==1413== by 0x40021A1: call_destructors (dl-close.c:129). ==1413== by 0x531FC84: _dl_catch_exception (dl-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:893,usability,error,error-skeleton,893,"For the record `Helgrind` does report the issue we have been discussed when run on my reproducer (i.e. this is a praise for helgrind :) ). ```. ==1413== Possible data race during write of size 8 at 0x56DD6F0 by thread #2. ==1413== Locks held: 1, at address 0x403AA48. ==1413== at 0x4CEDDBD: TClassTable::Remove(char const*) (TClassTable.cxx:500). ==1413== by 0x4CEEDD3: ROOT::RemoveClass(char const*) (TClassTable.cxx:859). ==1413== by 0x4882C25: ROOT::Internal::TDefaultInitBehavior::Unregister(char const*) const (Rtypes.h:172). ==1413== by 0x4D8180D: ROOT::TGenericClassInfo::~TGenericClassInfo() (TGenericClassInfo.cxx:221). ==1413== by 0x51F0A55: __cxa_finalize (cxa_finalize.c:83). ==1413== by 0x14FA76D6: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/libUser.so). ==1413== by 0x40021A1: call_destructors (dl-close.c:129). ==1413== by 0x531FC84: _dl_catch_exception (dl-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:974,usability,close,close,974,"For the record `Helgrind` does report the issue we have been discussed when run on my reproducer (i.e. this is a praise for helgrind :) ). ```. ==1413== Possible data race during write of size 8 at 0x56DD6F0 by thread #2. ==1413== Locks held: 1, at address 0x403AA48. ==1413== at 0x4CEDDBD: TClassTable::Remove(char const*) (TClassTable.cxx:500). ==1413== by 0x4CEEDD3: ROOT::RemoveClass(char const*) (TClassTable.cxx:859). ==1413== by 0x4882C25: ROOT::Internal::TDefaultInitBehavior::Unregister(char const*) const (Rtypes.h:172). ==1413== by 0x4D8180D: ROOT::TGenericClassInfo::~TGenericClassInfo() (TGenericClassInfo.cxx:221). ==1413== by 0x51F0A55: __cxa_finalize (cxa_finalize.c:83). ==1413== by 0x14FA76D6: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/libUser.so). ==1413== by 0x40021A1: call_destructors (dl-close.c:129). ==1413== by 0x531FC84: _dl_catch_exception (dl-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1032,usability,close,close,1032,"rt the issue we have been discussed when run on my reproducer (i.e. this is a praise for helgrind :) ). ```. ==1413== Possible data race during write of size 8 at 0x56DD6F0 by thread #2. ==1413== Locks held: 1, at address 0x403AA48. ==1413== at 0x4CEDDBD: TClassTable::Remove(char const*) (TClassTable.cxx:500). ==1413== by 0x4CEEDD3: ROOT::RemoveClass(char const*) (TClassTable.cxx:859). ==1413== by 0x4882C25: ROOT::Internal::TDefaultInitBehavior::Unregister(char const*) const (Rtypes.h:172). ==1413== by 0x4D8180D: ROOT::TGenericClassInfo::~TGenericClassInfo() (TGenericClassInfo.cxx:221). ==1413== by 0x51F0A55: __cxa_finalize (cxa_finalize.c:83). ==1413== by 0x14FA76D6: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/libUser.so). ==1413== by 0x40021A1: call_destructors (dl-close.c:129). ==1413== by 0x531FC84: _dl_catch_exception (dl-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1083,usability,close,close,1083,"reproducer (i.e. this is a praise for helgrind :) ). ```. ==1413== Possible data race during write of size 8 at 0x56DD6F0 by thread #2. ==1413== Locks held: 1, at address 0x403AA48. ==1413== at 0x4CEDDBD: TClassTable::Remove(char const*) (TClassTable.cxx:500). ==1413== by 0x4CEEDD3: ROOT::RemoveClass(char const*) (TClassTable.cxx:859). ==1413== by 0x4882C25: ROOT::Internal::TDefaultInitBehavior::Unregister(char const*) const (Rtypes.h:172). ==1413== by 0x4D8180D: ROOT::TGenericClassInfo::~TGenericClassInfo() (TGenericClassInfo.cxx:221). ==1413== by 0x51F0A55: __cxa_finalize (cxa_finalize.c:83). ==1413== by 0x14FA76D6: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/libUser.so). ==1413== by 0x40021A1: call_destructors (dl-close.c:129). ==1413== by 0x531FC84: _dl_catch_exception (dl-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC01: ??? (in /home/pcanal",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1144,usability,error,error-skeleton,1144,"= Possible data race during write of size 8 at 0x56DD6F0 by thread #2. ==1413== Locks held: 1, at address 0x403AA48. ==1413== at 0x4CEDDBD: TClassTable::Remove(char const*) (TClassTable.cxx:500). ==1413== by 0x4CEEDD3: ROOT::RemoveClass(char const*) (TClassTable.cxx:859). ==1413== by 0x4882C25: ROOT::Internal::TDefaultInitBehavior::Unregister(char const*) const (Rtypes.h:172). ==1413== by 0x4D8180D: ROOT::TGenericClassInfo::~TGenericClassInfo() (TGenericClassInfo.cxx:221). ==1413== by 0x51F0A55: __cxa_finalize (cxa_finalize.c:83). ==1413== by 0x14FA76D6: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/libUser.so). ==1413== by 0x40021A1: call_destructors (dl-close.c:129). ==1413== by 0x531FC84: _dl_catch_exception (dl-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC01: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==14",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:1210,usability,error,error-skeleton,1210," #2. ==1413== Locks held: 1, at address 0x403AA48. ==1413== at 0x4CEDDBD: TClassTable::Remove(char const*) (TClassTable.cxx:500). ==1413== by 0x4CEEDD3: ROOT::RemoveClass(char const*) (TClassTable.cxx:859). ==1413== by 0x4882C25: ROOT::Internal::TDefaultInitBehavior::Unregister(char const*) const (Rtypes.h:172). ==1413== by 0x4D8180D: ROOT::TGenericClassInfo::~TGenericClassInfo() (TGenericClassInfo.cxx:221). ==1413== by 0x51F0A55: __cxa_finalize (cxa_finalize.c:83). ==1413== by 0x14FA76D6: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/libUser.so). ==1413== by 0x40021A1: call_destructors (dl-close.c:129). ==1413== by 0x531FC84: _dl_catch_exception (dl-error-skeleton.c:182). ==1413== by 0x4002635: _dl_close_worker.part.0.isra.0 (dl-close.c:292). ==1413== by 0x40032A1: _dl_close_worker (dl-close.c:150). ==1413== by 0x40032A1: _dl_close (dl-close.c:818). ==1413== by 0x531FC27: _dl_catch_exception (dl-error-skeleton.c:208). ==1413== by 0x531FCF2: _dl_catch_error (dl-error-skeleton.c:227). ==1413==. ==1413== This conflicts with a previous read of size 8 by thread #3. ==1413== Locks held: none. ==1413== at 0x4CEDF22: TClassTable::FindElementImpl(char const*, bool) (TClassTable.cxx:521). ==1413== by 0x4CEE388: TClassTable::GetDictNorm(char const*) (TClassTable.cxx:618). ==1413== by 0x12FA9DE1: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD97: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAD0C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC6C: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC21: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== by 0x12FAAC01: ??? (in /home/pcanal/root_working/test/2023-thread/tclasstable/dlopenrace_C.so). ==1413== Address 0x56dd6f0 is 7,312 bytes inside a block of size 8,072",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:118,performance,lock,locking,118,I am closing this PR. The resolution can be followed through the issue #12552. A new PR implementing the fine grained locking in `TClassTable` will be uploaded shortly.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11263:118,security,lock,locking,118,I am closing this PR. The resolution can be followed through the issue #12552. A new PR implementing the fine grained locking in `TClassTable` will be uploaded shortly.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11263
https://github.com/root-project/root/pull/11264:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11264
https://github.com/root-project/root/pull/11264:59,deployability,patch,patch,59,"@Axel-Naumann , @eguiraud Could anyone help reviewing this patch?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11264
https://github.com/root-project/root/pull/11264:44,safety,review,reviewing,44,"@Axel-Naumann , @eguiraud Could anyone help reviewing this patch?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11264
https://github.com/root-project/root/pull/11264:59,safety,patch,patch,59,"@Axel-Naumann , @eguiraud Could anyone help reviewing this patch?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11264
https://github.com/root-project/root/pull/11264:59,security,patch,patch,59,"@Axel-Naumann , @eguiraud Could anyone help reviewing this patch?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11264
https://github.com/root-project/root/pull/11264:44,testability,review,reviewing,44,"@Axel-Naumann , @eguiraud Could anyone help reviewing this patch?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11264
https://github.com/root-project/root/pull/11264:39,usability,help,help,39,"@Axel-Naumann , @eguiraud Could anyone help reviewing this patch?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11264
https://github.com/root-project/root/pull/11264:14,availability,slo,slow,14,"Sorry for the slow response. What's the behavior / output when running `.x` without filename once this PR is applied? If there is absolutely no diagnostic, could you maybe add one as part of this PR? (If not then I will merge this as is - it's still better than crashing!)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11264
https://github.com/root-project/root/pull/11264:14,reliability,slo,slow,14,"Sorry for the slow response. What's the behavior / output when running `.x` without filename once this PR is applied? If there is absolutely no diagnostic, could you maybe add one as part of this PR? (If not then I will merge this as is - it's still better than crashing!)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11264
https://github.com/root-project/root/pull/11264:144,reliability,diagno,diagnostic,144,"Sorry for the slow response. What's the behavior / output when running `.x` without filename once this PR is applied? If there is absolutely no diagnostic, could you maybe add one as part of this PR? (If not then I will merge this as is - it's still better than crashing!)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11264
https://github.com/root-project/root/pull/11264:144,testability,diagno,diagnostic,144,"Sorry for the slow response. What's the behavior / output when running `.x` without filename once this PR is applied? If there is absolutely no diagnostic, could you maybe add one as part of this PR? (If not then I will merge this as is - it's still better than crashing!)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11264
https://github.com/root-project/root/pull/11264:40,usability,behavi,behavior,40,"Sorry for the slow response. What's the behavior / output when running `.x` without filename once this PR is applied? If there is absolutely no diagnostic, could you maybe add one as part of this PR? (If not then I will merge this as is - it's still better than crashing!)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11264
https://github.com/root-project/root/pull/11264:16,availability,slo,slow,16,"> Sorry for the slow response. What's the behavior / output when running `.x` without filename once this PR is applied? If there is absolutely no diagnostic, could you maybe add one as part of this PR? (If not then I will merge this as is - it's still better than crashing!). After this patch, the outputs are as follows:. ```. [cling]$ .x. input_line_3:2:2: error: expected expression. .x. ^. ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11264
https://github.com/root-project/root/pull/11264:359,availability,error,error,359,"> Sorry for the slow response. What's the behavior / output when running `.x` without filename once this PR is applied? If there is absolutely no diagnostic, could you maybe add one as part of this PR? (If not then I will merge this as is - it's still better than crashing!). After this patch, the outputs are as follows:. ```. [cling]$ .x. input_line_3:2:2: error: expected expression. .x. ^. ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11264
https://github.com/root-project/root/pull/11264:287,deployability,patch,patch,287,"> Sorry for the slow response. What's the behavior / output when running `.x` without filename once this PR is applied? If there is absolutely no diagnostic, could you maybe add one as part of this PR? (If not then I will merge this as is - it's still better than crashing!). After this patch, the outputs are as follows:. ```. [cling]$ .x. input_line_3:2:2: error: expected expression. .x. ^. ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11264
https://github.com/root-project/root/pull/11264:359,performance,error,error,359,"> Sorry for the slow response. What's the behavior / output when running `.x` without filename once this PR is applied? If there is absolutely no diagnostic, could you maybe add one as part of this PR? (If not then I will merge this as is - it's still better than crashing!). After this patch, the outputs are as follows:. ```. [cling]$ .x. input_line_3:2:2: error: expected expression. .x. ^. ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11264
https://github.com/root-project/root/pull/11264:16,reliability,slo,slow,16,"> Sorry for the slow response. What's the behavior / output when running `.x` without filename once this PR is applied? If there is absolutely no diagnostic, could you maybe add one as part of this PR? (If not then I will merge this as is - it's still better than crashing!). After this patch, the outputs are as follows:. ```. [cling]$ .x. input_line_3:2:2: error: expected expression. .x. ^. ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11264
https://github.com/root-project/root/pull/11264:146,reliability,diagno,diagnostic,146,"> Sorry for the slow response. What's the behavior / output when running `.x` without filename once this PR is applied? If there is absolutely no diagnostic, could you maybe add one as part of this PR? (If not then I will merge this as is - it's still better than crashing!). After this patch, the outputs are as follows:. ```. [cling]$ .x. input_line_3:2:2: error: expected expression. .x. ^. ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11264
https://github.com/root-project/root/pull/11264:287,safety,patch,patch,287,"> Sorry for the slow response. What's the behavior / output when running `.x` without filename once this PR is applied? If there is absolutely no diagnostic, could you maybe add one as part of this PR? (If not then I will merge this as is - it's still better than crashing!). After this patch, the outputs are as follows:. ```. [cling]$ .x. input_line_3:2:2: error: expected expression. .x. ^. ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11264
https://github.com/root-project/root/pull/11264:359,safety,error,error,359,"> Sorry for the slow response. What's the behavior / output when running `.x` without filename once this PR is applied? If there is absolutely no diagnostic, could you maybe add one as part of this PR? (If not then I will merge this as is - it's still better than crashing!). After this patch, the outputs are as follows:. ```. [cling]$ .x. input_line_3:2:2: error: expected expression. .x. ^. ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11264
https://github.com/root-project/root/pull/11264:287,security,patch,patch,287,"> Sorry for the slow response. What's the behavior / output when running `.x` without filename once this PR is applied? If there is absolutely no diagnostic, could you maybe add one as part of this PR? (If not then I will merge this as is - it's still better than crashing!). After this patch, the outputs are as follows:. ```. [cling]$ .x. input_line_3:2:2: error: expected expression. .x. ^. ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11264
https://github.com/root-project/root/pull/11264:146,testability,diagno,diagnostic,146,"> Sorry for the slow response. What's the behavior / output when running `.x` without filename once this PR is applied? If there is absolutely no diagnostic, could you maybe add one as part of this PR? (If not then I will merge this as is - it's still better than crashing!). After this patch, the outputs are as follows:. ```. [cling]$ .x. input_line_3:2:2: error: expected expression. .x. ^. ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11264
https://github.com/root-project/root/pull/11264:42,usability,behavi,behavior,42,"> Sorry for the slow response. What's the behavior / output when running `.x` without filename once this PR is applied? If there is absolutely no diagnostic, could you maybe add one as part of this PR? (If not then I will merge this as is - it's still better than crashing!). After this patch, the outputs are as follows:. ```. [cling]$ .x. input_line_3:2:2: error: expected expression. .x. ^. ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11264
https://github.com/root-project/root/pull/11264:359,usability,error,error,359,"> Sorry for the slow response. What's the behavior / output when running `.x` without filename once this PR is applied? If there is absolutely no diagnostic, could you maybe add one as part of this PR? (If not then I will merge this as is - it's still better than crashing!). After this patch, the outputs are as follows:. ```. [cling]$ .x. input_line_3:2:2: error: expected expression. .x. ^. ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11264
https://github.com/root-project/root/pull/11265:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:47,safety,review,review,47,@jiangyilism Thanks for the pull request; I'll review soon. I had an issue open for this since Dec 2021 (https://github.com/root-project/root/issues/9449),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:47,testability,review,review,47,@jiangyilism Thanks for the pull request; I'll review soon. I had an issue open for this since Dec 2021 (https://github.com/root-project/root/issues/9449),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:31,safety,review,review,31,> jalopezg-git. Thanks for the review. I will address the issues and add test cases in `interpreter/cling/test/` .,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:73,safety,test,test,73,> jalopezg-git. Thanks for the review. I will address the issues and add test cases in `interpreter/cling/test/` .,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:106,safety,test,test,106,> jalopezg-git. Thanks for the review. I will address the issues and add test cases in `interpreter/cling/test/` .,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:31,testability,review,review,31,> jalopezg-git. Thanks for the review. I will address the issues and add test cases in `interpreter/cling/test/` .,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:73,testability,test,test,73,> jalopezg-git. Thanks for the review. I will address the issues and add test cases in `interpreter/cling/test/` .,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:106,testability,test,test,106,> jalopezg-git. Thanks for the review. I will address the issues and add test cases in `interpreter/cling/test/` .,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:18,usability,progress,progress,18,"@jiangyilism, any progress in this regard?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:4,usability,progress,progress,4,Any progress? I am college teacher and I can't teach student to overload cout<<Object in cling due to this issue!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:231,integrability,coupl,couple,231,"> Any progress? I am college teacher and I can't teach student to overload cout<<Object in cling due to this issue! Thanks for expressing interest @mylyu! :+1: . If @jiangyilism is not able to follow-up on this, I can take it in a couple of weeks or so.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:231,modifiability,coupl,couple,231,"> Any progress? I am college teacher and I can't teach student to overload cout<<Object in cling due to this issue! Thanks for expressing interest @mylyu! :+1: . If @jiangyilism is not able to follow-up on this, I can take it in a couple of weeks or so.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:231,testability,coupl,couple,231,"> Any progress? I am college teacher and I can't teach student to overload cout<<Object in cling due to this issue! Thanks for expressing interest @mylyu! :+1: . If @jiangyilism is not able to follow-up on this, I can take it in a couple of weeks or so.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:6,usability,progress,progress,6,"> Any progress? I am college teacher and I can't teach student to overload cout<<Object in cling due to this issue! Thanks for expressing interest @mylyu! :+1: . If @jiangyilism is not able to follow-up on this, I can take it in a couple of weeks or so.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:128,deployability,updat,update,128,@jalopezg-git Sorry for the late reply. I am still trying to fix some corner cases while avoiding too intrusive changes. I will update the pull request soon.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:89,safety,avoid,avoiding,89,@jalopezg-git Sorry for the late reply. I am still trying to fix some corner cases while avoiding too intrusive changes. I will update the pull request soon.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:128,safety,updat,update,128,@jalopezg-git Sorry for the late reply. I am still trying to fix some corner cases while avoiding too intrusive changes. I will update the pull request soon.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:102,security,intrus,intrusive,102,@jalopezg-git Sorry for the late reply. I am still trying to fix some corner cases while avoiding too intrusive changes. I will update the pull request soon.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:128,security,updat,update,128,@jalopezg-git Sorry for the late reply. I am still trying to fix some corner cases while avoiding too intrusive changes. I will update the pull request soon.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:228,deployability,updat,update,228,"Many thanks. Jiang Yi ***@***.***> 于 2023年6月5日周一 05:15写道：. > @jalopezg-git <https://github.com/jalopezg-git> Sorry for the late reply. > I am still trying to fix some corner cases while avoiding too intrusive. > changes. I will update the pull request soon. >. > —. > Reply to this email directly, view it on GitHub. > <https://github.com/root-project/root/pull/11265#issuecomment-1576431258>,. > or unsubscribe. > <https://github.com/notifications/unsubscribe-auth/ACN3SSVEF3GLBPRSV2CHAELXJWPUNANCNFSM573UE76Q>. > . > You are receiving this because you were mentioned.Message ID:. > ***@***.***>. >.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:569,integrability,Messag,Message,569,"Many thanks. Jiang Yi ***@***.***> 于 2023年6月5日周一 05:15写道：. > @jalopezg-git <https://github.com/jalopezg-git> Sorry for the late reply. > I am still trying to fix some corner cases while avoiding too intrusive. > changes. I will update the pull request soon. >. > —. > Reply to this email directly, view it on GitHub. > <https://github.com/root-project/root/pull/11265#issuecomment-1576431258>,. > or unsubscribe. > <https://github.com/notifications/unsubscribe-auth/ACN3SSVEF3GLBPRSV2CHAELXJWPUNANCNFSM573UE76Q>. > . > You are receiving this because you were mentioned.Message ID:. > ***@***.***>. >.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:569,interoperability,Messag,Message,569,"Many thanks. Jiang Yi ***@***.***> 于 2023年6月5日周一 05:15写道：. > @jalopezg-git <https://github.com/jalopezg-git> Sorry for the late reply. > I am still trying to fix some corner cases while avoiding too intrusive. > changes. I will update the pull request soon. >. > —. > Reply to this email directly, view it on GitHub. > <https://github.com/root-project/root/pull/11265#issuecomment-1576431258>,. > or unsubscribe. > <https://github.com/notifications/unsubscribe-auth/ACN3SSVEF3GLBPRSV2CHAELXJWPUNANCNFSM573UE76Q>. > . > You are receiving this because you were mentioned.Message ID:. > ***@***.***>. >.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:186,safety,avoid,avoiding,186,"Many thanks. Jiang Yi ***@***.***> 于 2023年6月5日周一 05:15写道：. > @jalopezg-git <https://github.com/jalopezg-git> Sorry for the late reply. > I am still trying to fix some corner cases while avoiding too intrusive. > changes. I will update the pull request soon. >. > —. > Reply to this email directly, view it on GitHub. > <https://github.com/root-project/root/pull/11265#issuecomment-1576431258>,. > or unsubscribe. > <https://github.com/notifications/unsubscribe-auth/ACN3SSVEF3GLBPRSV2CHAELXJWPUNANCNFSM573UE76Q>. > . > You are receiving this because you were mentioned.Message ID:. > ***@***.***>. >.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:228,safety,updat,update,228,"Many thanks. Jiang Yi ***@***.***> 于 2023年6月5日周一 05:15写道：. > @jalopezg-git <https://github.com/jalopezg-git> Sorry for the late reply. > I am still trying to fix some corner cases while avoiding too intrusive. > changes. I will update the pull request soon. >. > —. > Reply to this email directly, view it on GitHub. > <https://github.com/root-project/root/pull/11265#issuecomment-1576431258>,. > or unsubscribe. > <https://github.com/notifications/unsubscribe-auth/ACN3SSVEF3GLBPRSV2CHAELXJWPUNANCNFSM573UE76Q>. > . > You are receiving this because you were mentioned.Message ID:. > ***@***.***>. >.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:199,security,intrus,intrusive,199,"Many thanks. Jiang Yi ***@***.***> 于 2023年6月5日周一 05:15写道：. > @jalopezg-git <https://github.com/jalopezg-git> Sorry for the late reply. > I am still trying to fix some corner cases while avoiding too intrusive. > changes. I will update the pull request soon. >. > —. > Reply to this email directly, view it on GitHub. > <https://github.com/root-project/root/pull/11265#issuecomment-1576431258>,. > or unsubscribe. > <https://github.com/notifications/unsubscribe-auth/ACN3SSVEF3GLBPRSV2CHAELXJWPUNANCNFSM573UE76Q>. > . > You are receiving this because you were mentioned.Message ID:. > ***@***.***>. >.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:228,security,updat,update,228,"Many thanks. Jiang Yi ***@***.***> 于 2023年6月5日周一 05:15写道：. > @jalopezg-git <https://github.com/jalopezg-git> Sorry for the late reply. > I am still trying to fix some corner cases while avoiding too intrusive. > changes. I will update the pull request soon. >. > —. > Reply to this email directly, view it on GitHub. > <https://github.com/root-project/root/pull/11265#issuecomment-1576431258>,. > or unsubscribe. > <https://github.com/notifications/unsubscribe-auth/ACN3SSVEF3GLBPRSV2CHAELXJWPUNANCNFSM573UE76Q>. > . > You are receiving this because you were mentioned.Message ID:. > ***@***.***>. >.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:461,security,auth,auth,461,"Many thanks. Jiang Yi ***@***.***> 于 2023年6月5日周一 05:15写道：. > @jalopezg-git <https://github.com/jalopezg-git> Sorry for the late reply. > I am still trying to fix some corner cases while avoiding too intrusive. > changes. I will update the pull request soon. >. > —. > Reply to this email directly, view it on GitHub. > <https://github.com/root-project/root/pull/11265#issuecomment-1576431258>,. > or unsubscribe. > <https://github.com/notifications/unsubscribe-auth/ACN3SSVEF3GLBPRSV2CHAELXJWPUNANCNFSM573UE76Q>. > . > You are receiving this because you were mentioned.Message ID:. > ***@***.***>. >.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:271,energy efficiency,Current,Currently,271,https://github.com/SdtElectronics/cline/issues/10 and https://github.com/root-project/cling/issues/490 redirect the discussion of parsing `noexcept` to here. However I suggest to address it in another dedicate issue and pull request for it (or re-open the above issues). Currently cling seems to not parse `noexcept` at all. At least not at lexer/token level since string-searching `kw_noexcept` got nothing in `root/interpreter/cling/` directory.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:347,security,token,token,347,https://github.com/SdtElectronics/cline/issues/10 and https://github.com/root-project/cling/issues/490 redirect the discussion of parsing `noexcept` to here. However I suggest to address it in another dedicate issue and pull request for it (or re-open the above issues). Currently cling seems to not parse `noexcept` at all. At least not at lexer/token level since string-searching `kw_noexcept` got nothing in `root/interpreter/cling/` directory.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:326,energy efficiency,Current,Currently,326,"> [SdtElectronics/cline#10](https://github.com/SdtElectronics/cline/issues/10) and [root-project/cling#490](https://github.com/root-project/cling/issues/490) redirect the discussion of parsing `noexcept` to here. However I suggest to address it in another dedicate issue and pull request for it (or re-open the above issues). Currently cling seems to not parse `noexcept` at all. At least not at lexer/token level since string-searching `kw_noexcept` got nothing in `root/interpreter/cling/` directory. Many thanks @jiangyilism. Please, re-request a code review when you think it is ready :slightly_smiling_face:!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:555,safety,review,review,555,"> [SdtElectronics/cline#10](https://github.com/SdtElectronics/cline/issues/10) and [root-project/cling#490](https://github.com/root-project/cling/issues/490) redirect the discussion of parsing `noexcept` to here. However I suggest to address it in another dedicate issue and pull request for it (or re-open the above issues). Currently cling seems to not parse `noexcept` at all. At least not at lexer/token level since string-searching `kw_noexcept` got nothing in `root/interpreter/cling/` directory. Many thanks @jiangyilism. Please, re-request a code review when you think it is ready :slightly_smiling_face:!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:402,security,token,token,402,"> [SdtElectronics/cline#10](https://github.com/SdtElectronics/cline/issues/10) and [root-project/cling#490](https://github.com/root-project/cling/issues/490) redirect the discussion of parsing `noexcept` to here. However I suggest to address it in another dedicate issue and pull request for it (or re-open the above issues). Currently cling seems to not parse `noexcept` at all. At least not at lexer/token level since string-searching `kw_noexcept` got nothing in `root/interpreter/cling/` directory. Many thanks @jiangyilism. Please, re-request a code review when you think it is ready :slightly_smiling_face:!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:555,testability,review,review,555,"> [SdtElectronics/cline#10](https://github.com/SdtElectronics/cline/issues/10) and [root-project/cling#490](https://github.com/root-project/cling/issues/490) redirect the discussion of parsing `noexcept` to here. However I suggest to address it in another dedicate issue and pull request for it (or re-open the above issues). Currently cling seems to not parse `noexcept` at all. At least not at lexer/token level since string-searching `kw_noexcept` got nothing in `root/interpreter/cling/` directory. Many thanks @jiangyilism. Please, re-request a code review when you think it is ready :slightly_smiling_face:!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:657,availability,failur,failure,657,"> > [SdtElectronics/cline#10](https://github.com/SdtElectronics/cline/issues/10) and [root-project/cling#490](https://github.com/root-project/cling/issues/490) redirect the discussion of parsing `noexcept` to here. However I suggest to address it in another dedicate issue and pull request for it (or re-open the above issues). Currently cling seems to not parse `noexcept` at all. At least not at lexer/token level since string-searching `kw_noexcept` got nothing in `root/interpreter/cling/` directory. > . > Many thanks @jiangyilism. Please, re-request a code review when you think it is ready 🙂! It is ready for review. However I have no clue about the failure test report above. clang-format failed to checkout code before running. The windows test fail seems to be file permission error irrelevant to this pull request. The Fedora test fail is unreproducible on my ubuntu either.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:787,availability,error,error,787,"> > [SdtElectronics/cline#10](https://github.com/SdtElectronics/cline/issues/10) and [root-project/cling#490](https://github.com/root-project/cling/issues/490) redirect the discussion of parsing `noexcept` to here. However I suggest to address it in another dedicate issue and pull request for it (or re-open the above issues). Currently cling seems to not parse `noexcept` at all. At least not at lexer/token level since string-searching `kw_noexcept` got nothing in `root/interpreter/cling/` directory. > . > Many thanks @jiangyilism. Please, re-request a code review when you think it is ready 🙂! It is ready for review. However I have no clue about the failure test report above. clang-format failed to checkout code before running. The windows test fail seems to be file permission error irrelevant to this pull request. The Fedora test fail is unreproducible on my ubuntu either.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:657,deployability,fail,failure,657,"> > [SdtElectronics/cline#10](https://github.com/SdtElectronics/cline/issues/10) and [root-project/cling#490](https://github.com/root-project/cling/issues/490) redirect the discussion of parsing `noexcept` to here. However I suggest to address it in another dedicate issue and pull request for it (or re-open the above issues). Currently cling seems to not parse `noexcept` at all. At least not at lexer/token level since string-searching `kw_noexcept` got nothing in `root/interpreter/cling/` directory. > . > Many thanks @jiangyilism. Please, re-request a code review when you think it is ready 🙂! It is ready for review. However I have no clue about the failure test report above. clang-format failed to checkout code before running. The windows test fail seems to be file permission error irrelevant to this pull request. The Fedora test fail is unreproducible on my ubuntu either.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:697,deployability,fail,failed,697,"> > [SdtElectronics/cline#10](https://github.com/SdtElectronics/cline/issues/10) and [root-project/cling#490](https://github.com/root-project/cling/issues/490) redirect the discussion of parsing `noexcept` to here. However I suggest to address it in another dedicate issue and pull request for it (or re-open the above issues). Currently cling seems to not parse `noexcept` at all. At least not at lexer/token level since string-searching `kw_noexcept` got nothing in `root/interpreter/cling/` directory. > . > Many thanks @jiangyilism. Please, re-request a code review when you think it is ready 🙂! It is ready for review. However I have no clue about the failure test report above. clang-format failed to checkout code before running. The windows test fail seems to be file permission error irrelevant to this pull request. The Fedora test fail is unreproducible on my ubuntu either.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:754,deployability,fail,fail,754,"> > [SdtElectronics/cline#10](https://github.com/SdtElectronics/cline/issues/10) and [root-project/cling#490](https://github.com/root-project/cling/issues/490) redirect the discussion of parsing `noexcept` to here. However I suggest to address it in another dedicate issue and pull request for it (or re-open the above issues). Currently cling seems to not parse `noexcept` at all. At least not at lexer/token level since string-searching `kw_noexcept` got nothing in `root/interpreter/cling/` directory. > . > Many thanks @jiangyilism. Please, re-request a code review when you think it is ready 🙂! It is ready for review. However I have no clue about the failure test report above. clang-format failed to checkout code before running. The windows test fail seems to be file permission error irrelevant to this pull request. The Fedora test fail is unreproducible on my ubuntu either.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:842,deployability,fail,fail,842,"> > [SdtElectronics/cline#10](https://github.com/SdtElectronics/cline/issues/10) and [root-project/cling#490](https://github.com/root-project/cling/issues/490) redirect the discussion of parsing `noexcept` to here. However I suggest to address it in another dedicate issue and pull request for it (or re-open the above issues). Currently cling seems to not parse `noexcept` at all. At least not at lexer/token level since string-searching `kw_noexcept` got nothing in `root/interpreter/cling/` directory. > . > Many thanks @jiangyilism. Please, re-request a code review when you think it is ready 🙂! It is ready for review. However I have no clue about the failure test report above. clang-format failed to checkout code before running. The windows test fail seems to be file permission error irrelevant to this pull request. The Fedora test fail is unreproducible on my ubuntu either.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:328,energy efficiency,Current,Currently,328,"> > [SdtElectronics/cline#10](https://github.com/SdtElectronics/cline/issues/10) and [root-project/cling#490](https://github.com/root-project/cling/issues/490) redirect the discussion of parsing `noexcept` to here. However I suggest to address it in another dedicate issue and pull request for it (or re-open the above issues). Currently cling seems to not parse `noexcept` at all. At least not at lexer/token level since string-searching `kw_noexcept` got nothing in `root/interpreter/cling/` directory. > . > Many thanks @jiangyilism. Please, re-request a code review when you think it is ready 🙂! It is ready for review. However I have no clue about the failure test report above. clang-format failed to checkout code before running. The windows test fail seems to be file permission error irrelevant to this pull request. The Fedora test fail is unreproducible on my ubuntu either.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:690,interoperability,format,format,690,"> > [SdtElectronics/cline#10](https://github.com/SdtElectronics/cline/issues/10) and [root-project/cling#490](https://github.com/root-project/cling/issues/490) redirect the discussion of parsing `noexcept` to here. However I suggest to address it in another dedicate issue and pull request for it (or re-open the above issues). Currently cling seems to not parse `noexcept` at all. At least not at lexer/token level since string-searching `kw_noexcept` got nothing in `root/interpreter/cling/` directory. > . > Many thanks @jiangyilism. Please, re-request a code review when you think it is ready 🙂! It is ready for review. However I have no clue about the failure test report above. clang-format failed to checkout code before running. The windows test fail seems to be file permission error irrelevant to this pull request. The Fedora test fail is unreproducible on my ubuntu either.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:657,performance,failur,failure,657,"> > [SdtElectronics/cline#10](https://github.com/SdtElectronics/cline/issues/10) and [root-project/cling#490](https://github.com/root-project/cling/issues/490) redirect the discussion of parsing `noexcept` to here. However I suggest to address it in another dedicate issue and pull request for it (or re-open the above issues). Currently cling seems to not parse `noexcept` at all. At least not at lexer/token level since string-searching `kw_noexcept` got nothing in `root/interpreter/cling/` directory. > . > Many thanks @jiangyilism. Please, re-request a code review when you think it is ready 🙂! It is ready for review. However I have no clue about the failure test report above. clang-format failed to checkout code before running. The windows test fail seems to be file permission error irrelevant to this pull request. The Fedora test fail is unreproducible on my ubuntu either.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:787,performance,error,error,787,"> > [SdtElectronics/cline#10](https://github.com/SdtElectronics/cline/issues/10) and [root-project/cling#490](https://github.com/root-project/cling/issues/490) redirect the discussion of parsing `noexcept` to here. However I suggest to address it in another dedicate issue and pull request for it (or re-open the above issues). Currently cling seems to not parse `noexcept` at all. At least not at lexer/token level since string-searching `kw_noexcept` got nothing in `root/interpreter/cling/` directory. > . > Many thanks @jiangyilism. Please, re-request a code review when you think it is ready 🙂! It is ready for review. However I have no clue about the failure test report above. clang-format failed to checkout code before running. The windows test fail seems to be file permission error irrelevant to this pull request. The Fedora test fail is unreproducible on my ubuntu either.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:657,reliability,fail,failure,657,"> > [SdtElectronics/cline#10](https://github.com/SdtElectronics/cline/issues/10) and [root-project/cling#490](https://github.com/root-project/cling/issues/490) redirect the discussion of parsing `noexcept` to here. However I suggest to address it in another dedicate issue and pull request for it (or re-open the above issues). Currently cling seems to not parse `noexcept` at all. At least not at lexer/token level since string-searching `kw_noexcept` got nothing in `root/interpreter/cling/` directory. > . > Many thanks @jiangyilism. Please, re-request a code review when you think it is ready 🙂! It is ready for review. However I have no clue about the failure test report above. clang-format failed to checkout code before running. The windows test fail seems to be file permission error irrelevant to this pull request. The Fedora test fail is unreproducible on my ubuntu either.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:697,reliability,fail,failed,697,"> > [SdtElectronics/cline#10](https://github.com/SdtElectronics/cline/issues/10) and [root-project/cling#490](https://github.com/root-project/cling/issues/490) redirect the discussion of parsing `noexcept` to here. However I suggest to address it in another dedicate issue and pull request for it (or re-open the above issues). Currently cling seems to not parse `noexcept` at all. At least not at lexer/token level since string-searching `kw_noexcept` got nothing in `root/interpreter/cling/` directory. > . > Many thanks @jiangyilism. Please, re-request a code review when you think it is ready 🙂! It is ready for review. However I have no clue about the failure test report above. clang-format failed to checkout code before running. The windows test fail seems to be file permission error irrelevant to this pull request. The Fedora test fail is unreproducible on my ubuntu either.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:754,reliability,fail,fail,754,"> > [SdtElectronics/cline#10](https://github.com/SdtElectronics/cline/issues/10) and [root-project/cling#490](https://github.com/root-project/cling/issues/490) redirect the discussion of parsing `noexcept` to here. However I suggest to address it in another dedicate issue and pull request for it (or re-open the above issues). Currently cling seems to not parse `noexcept` at all. At least not at lexer/token level since string-searching `kw_noexcept` got nothing in `root/interpreter/cling/` directory. > . > Many thanks @jiangyilism. Please, re-request a code review when you think it is ready 🙂! It is ready for review. However I have no clue about the failure test report above. clang-format failed to checkout code before running. The windows test fail seems to be file permission error irrelevant to this pull request. The Fedora test fail is unreproducible on my ubuntu either.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:842,reliability,fail,fail,842,"> > [SdtElectronics/cline#10](https://github.com/SdtElectronics/cline/issues/10) and [root-project/cling#490](https://github.com/root-project/cling/issues/490) redirect the discussion of parsing `noexcept` to here. However I suggest to address it in another dedicate issue and pull request for it (or re-open the above issues). Currently cling seems to not parse `noexcept` at all. At least not at lexer/token level since string-searching `kw_noexcept` got nothing in `root/interpreter/cling/` directory. > . > Many thanks @jiangyilism. Please, re-request a code review when you think it is ready 🙂! It is ready for review. However I have no clue about the failure test report above. clang-format failed to checkout code before running. The windows test fail seems to be file permission error irrelevant to this pull request. The Fedora test fail is unreproducible on my ubuntu either.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:563,safety,review,review,563,"> > [SdtElectronics/cline#10](https://github.com/SdtElectronics/cline/issues/10) and [root-project/cling#490](https://github.com/root-project/cling/issues/490) redirect the discussion of parsing `noexcept` to here. However I suggest to address it in another dedicate issue and pull request for it (or re-open the above issues). Currently cling seems to not parse `noexcept` at all. At least not at lexer/token level since string-searching `kw_noexcept` got nothing in `root/interpreter/cling/` directory. > . > Many thanks @jiangyilism. Please, re-request a code review when you think it is ready 🙂! It is ready for review. However I have no clue about the failure test report above. clang-format failed to checkout code before running. The windows test fail seems to be file permission error irrelevant to this pull request. The Fedora test fail is unreproducible on my ubuntu either.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:616,safety,review,review,616,"> > [SdtElectronics/cline#10](https://github.com/SdtElectronics/cline/issues/10) and [root-project/cling#490](https://github.com/root-project/cling/issues/490) redirect the discussion of parsing `noexcept` to here. However I suggest to address it in another dedicate issue and pull request for it (or re-open the above issues). Currently cling seems to not parse `noexcept` at all. At least not at lexer/token level since string-searching `kw_noexcept` got nothing in `root/interpreter/cling/` directory. > . > Many thanks @jiangyilism. Please, re-request a code review when you think it is ready 🙂! It is ready for review. However I have no clue about the failure test report above. clang-format failed to checkout code before running. The windows test fail seems to be file permission error irrelevant to this pull request. The Fedora test fail is unreproducible on my ubuntu either.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:665,safety,test,test,665,"> > [SdtElectronics/cline#10](https://github.com/SdtElectronics/cline/issues/10) and [root-project/cling#490](https://github.com/root-project/cling/issues/490) redirect the discussion of parsing `noexcept` to here. However I suggest to address it in another dedicate issue and pull request for it (or re-open the above issues). Currently cling seems to not parse `noexcept` at all. At least not at lexer/token level since string-searching `kw_noexcept` got nothing in `root/interpreter/cling/` directory. > . > Many thanks @jiangyilism. Please, re-request a code review when you think it is ready 🙂! It is ready for review. However I have no clue about the failure test report above. clang-format failed to checkout code before running. The windows test fail seems to be file permission error irrelevant to this pull request. The Fedora test fail is unreproducible on my ubuntu either.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:749,safety,test,test,749,"> > [SdtElectronics/cline#10](https://github.com/SdtElectronics/cline/issues/10) and [root-project/cling#490](https://github.com/root-project/cling/issues/490) redirect the discussion of parsing `noexcept` to here. However I suggest to address it in another dedicate issue and pull request for it (or re-open the above issues). Currently cling seems to not parse `noexcept` at all. At least not at lexer/token level since string-searching `kw_noexcept` got nothing in `root/interpreter/cling/` directory. > . > Many thanks @jiangyilism. Please, re-request a code review when you think it is ready 🙂! It is ready for review. However I have no clue about the failure test report above. clang-format failed to checkout code before running. The windows test fail seems to be file permission error irrelevant to this pull request. The Fedora test fail is unreproducible on my ubuntu either.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:776,safety,permiss,permission,776,"> > [SdtElectronics/cline#10](https://github.com/SdtElectronics/cline/issues/10) and [root-project/cling#490](https://github.com/root-project/cling/issues/490) redirect the discussion of parsing `noexcept` to here. However I suggest to address it in another dedicate issue and pull request for it (or re-open the above issues). Currently cling seems to not parse `noexcept` at all. At least not at lexer/token level since string-searching `kw_noexcept` got nothing in `root/interpreter/cling/` directory. > . > Many thanks @jiangyilism. Please, re-request a code review when you think it is ready 🙂! It is ready for review. However I have no clue about the failure test report above. clang-format failed to checkout code before running. The windows test fail seems to be file permission error irrelevant to this pull request. The Fedora test fail is unreproducible on my ubuntu either.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:787,safety,error,error,787,"> > [SdtElectronics/cline#10](https://github.com/SdtElectronics/cline/issues/10) and [root-project/cling#490](https://github.com/root-project/cling/issues/490) redirect the discussion of parsing `noexcept` to here. However I suggest to address it in another dedicate issue and pull request for it (or re-open the above issues). Currently cling seems to not parse `noexcept` at all. At least not at lexer/token level since string-searching `kw_noexcept` got nothing in `root/interpreter/cling/` directory. > . > Many thanks @jiangyilism. Please, re-request a code review when you think it is ready 🙂! It is ready for review. However I have no clue about the failure test report above. clang-format failed to checkout code before running. The windows test fail seems to be file permission error irrelevant to this pull request. The Fedora test fail is unreproducible on my ubuntu either.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:837,safety,test,test,837,"> > [SdtElectronics/cline#10](https://github.com/SdtElectronics/cline/issues/10) and [root-project/cling#490](https://github.com/root-project/cling/issues/490) redirect the discussion of parsing `noexcept` to here. However I suggest to address it in another dedicate issue and pull request for it (or re-open the above issues). Currently cling seems to not parse `noexcept` at all. At least not at lexer/token level since string-searching `kw_noexcept` got nothing in `root/interpreter/cling/` directory. > . > Many thanks @jiangyilism. Please, re-request a code review when you think it is ready 🙂! It is ready for review. However I have no clue about the failure test report above. clang-format failed to checkout code before running. The windows test fail seems to be file permission error irrelevant to this pull request. The Fedora test fail is unreproducible on my ubuntu either.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:404,security,token,token,404,"> > [SdtElectronics/cline#10](https://github.com/SdtElectronics/cline/issues/10) and [root-project/cling#490](https://github.com/root-project/cling/issues/490) redirect the discussion of parsing `noexcept` to here. However I suggest to address it in another dedicate issue and pull request for it (or re-open the above issues). Currently cling seems to not parse `noexcept` at all. At least not at lexer/token level since string-searching `kw_noexcept` got nothing in `root/interpreter/cling/` directory. > . > Many thanks @jiangyilism. Please, re-request a code review when you think it is ready 🙂! It is ready for review. However I have no clue about the failure test report above. clang-format failed to checkout code before running. The windows test fail seems to be file permission error irrelevant to this pull request. The Fedora test fail is unreproducible on my ubuntu either.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:563,testability,review,review,563,"> > [SdtElectronics/cline#10](https://github.com/SdtElectronics/cline/issues/10) and [root-project/cling#490](https://github.com/root-project/cling/issues/490) redirect the discussion of parsing `noexcept` to here. However I suggest to address it in another dedicate issue and pull request for it (or re-open the above issues). Currently cling seems to not parse `noexcept` at all. At least not at lexer/token level since string-searching `kw_noexcept` got nothing in `root/interpreter/cling/` directory. > . > Many thanks @jiangyilism. Please, re-request a code review when you think it is ready 🙂! It is ready for review. However I have no clue about the failure test report above. clang-format failed to checkout code before running. The windows test fail seems to be file permission error irrelevant to this pull request. The Fedora test fail is unreproducible on my ubuntu either.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:616,testability,review,review,616,"> > [SdtElectronics/cline#10](https://github.com/SdtElectronics/cline/issues/10) and [root-project/cling#490](https://github.com/root-project/cling/issues/490) redirect the discussion of parsing `noexcept` to here. However I suggest to address it in another dedicate issue and pull request for it (or re-open the above issues). Currently cling seems to not parse `noexcept` at all. At least not at lexer/token level since string-searching `kw_noexcept` got nothing in `root/interpreter/cling/` directory. > . > Many thanks @jiangyilism. Please, re-request a code review when you think it is ready 🙂! It is ready for review. However I have no clue about the failure test report above. clang-format failed to checkout code before running. The windows test fail seems to be file permission error irrelevant to this pull request. The Fedora test fail is unreproducible on my ubuntu either.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:665,testability,test,test,665,"> > [SdtElectronics/cline#10](https://github.com/SdtElectronics/cline/issues/10) and [root-project/cling#490](https://github.com/root-project/cling/issues/490) redirect the discussion of parsing `noexcept` to here. However I suggest to address it in another dedicate issue and pull request for it (or re-open the above issues). Currently cling seems to not parse `noexcept` at all. At least not at lexer/token level since string-searching `kw_noexcept` got nothing in `root/interpreter/cling/` directory. > . > Many thanks @jiangyilism. Please, re-request a code review when you think it is ready 🙂! It is ready for review. However I have no clue about the failure test report above. clang-format failed to checkout code before running. The windows test fail seems to be file permission error irrelevant to this pull request. The Fedora test fail is unreproducible on my ubuntu either.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:749,testability,test,test,749,"> > [SdtElectronics/cline#10](https://github.com/SdtElectronics/cline/issues/10) and [root-project/cling#490](https://github.com/root-project/cling/issues/490) redirect the discussion of parsing `noexcept` to here. However I suggest to address it in another dedicate issue and pull request for it (or re-open the above issues). Currently cling seems to not parse `noexcept` at all. At least not at lexer/token level since string-searching `kw_noexcept` got nothing in `root/interpreter/cling/` directory. > . > Many thanks @jiangyilism. Please, re-request a code review when you think it is ready 🙂! It is ready for review. However I have no clue about the failure test report above. clang-format failed to checkout code before running. The windows test fail seems to be file permission error irrelevant to this pull request. The Fedora test fail is unreproducible on my ubuntu either.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:837,testability,test,test,837,"> > [SdtElectronics/cline#10](https://github.com/SdtElectronics/cline/issues/10) and [root-project/cling#490](https://github.com/root-project/cling/issues/490) redirect the discussion of parsing `noexcept` to here. However I suggest to address it in another dedicate issue and pull request for it (or re-open the above issues). Currently cling seems to not parse `noexcept` at all. At least not at lexer/token level since string-searching `kw_noexcept` got nothing in `root/interpreter/cling/` directory. > . > Many thanks @jiangyilism. Please, re-request a code review when you think it is ready 🙂! It is ready for review. However I have no clue about the failure test report above. clang-format failed to checkout code before running. The windows test fail seems to be file permission error irrelevant to this pull request. The Fedora test fail is unreproducible on my ubuntu either.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:787,usability,error,error,787,"> > [SdtElectronics/cline#10](https://github.com/SdtElectronics/cline/issues/10) and [root-project/cling#490](https://github.com/root-project/cling/issues/490) redirect the discussion of parsing `noexcept` to here. However I suggest to address it in another dedicate issue and pull request for it (or re-open the above issues). Currently cling seems to not parse `noexcept` at all. At least not at lexer/token level since string-searching `kw_noexcept` got nothing in `root/interpreter/cling/` directory. > . > Many thanks @jiangyilism. Please, re-request a code review when you think it is ready 🙂! It is ready for review. However I have no clue about the failure test report above. clang-format failed to checkout code before running. The windows test fail seems to be file permission error irrelevant to this pull request. The Fedora test fail is unreproducible on my ubuntu either.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11265:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11265
https://github.com/root-project/root/pull/11268:276,availability,error,error,276,"> It removes the requirement for version 3.9. Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. > It worsens the error message in case json_fwd.h when it is required for recent versions. They were written based on feedback from upstream, so I would like to keep the detailed messages. `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. After LLVM upgrade we could completely skip usage of `json_fwd.h`. I hope it will happen before 6.28 release.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:33,deployability,version,version,33,"> It removes the requirement for version 3.9. Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. > It worsens the error message in case json_fwd.h when it is required for recent versions. They were written based on feedback from upstream, so I would like to keep the detailed messages. `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. After LLVM upgrade we could completely skip usage of `json_fwd.h`. I hope it will happen before 6.28 release.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:82,deployability,version,versions,82,"> It removes the requirement for version 3.9. Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. > It worsens the error message in case json_fwd.h when it is required for recent versions. They were written based on feedback from upstream, so I would like to keep the detailed messages. `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. After LLVM upgrade we could completely skip usage of `json_fwd.h`. I hope it will happen before 6.28 release.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:221,deployability,version,version,221,"> It removes the requirement for version 3.9. Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. > It worsens the error message in case json_fwd.h when it is required for recent versions. They were written based on feedback from upstream, so I would like to keep the detailed messages. `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. After LLVM upgrade we could completely skip usage of `json_fwd.h`. I hope it will happen before 6.28 release.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:340,deployability,version,versions,340,"> It removes the requirement for version 3.9. Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. > It worsens the error message in case json_fwd.h when it is required for recent versions. They were written based on feedback from upstream, so I would like to keep the detailed messages. `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. After LLVM upgrade we could completely skip usage of `json_fwd.h`. I hope it will happen before 6.28 release.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:568,deployability,version,versions,568,"> It removes the requirement for version 3.9. Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. > It worsens the error message in case json_fwd.h when it is required for recent versions. They were written based on feedback from upstream, so I would like to keep the detailed messages. `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. After LLVM upgrade we could completely skip usage of `json_fwd.h`. I hope it will happen before 6.28 release.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:600,deployability,upgrad,upgrade,600,"> It removes the requirement for version 3.9. Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. > It worsens the error message in case json_fwd.h when it is required for recent versions. They were written based on feedback from upstream, so I would like to keep the detailed messages. `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. After LLVM upgrade we could completely skip usage of `json_fwd.h`. I hope it will happen before 6.28 release.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:690,deployability,releas,release,690,"> It removes the requirement for version 3.9. Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. > It worsens the error message in case json_fwd.h when it is required for recent versions. They were written based on feedback from upstream, so I would like to keep the detailed messages. `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. After LLVM upgrade we could completely skip usage of `json_fwd.h`. I hope it will happen before 6.28 release.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:33,integrability,version,version,33,"> It removes the requirement for version 3.9. Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. > It worsens the error message in case json_fwd.h when it is required for recent versions. They were written based on feedback from upstream, so I would like to keep the detailed messages. `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. After LLVM upgrade we could completely skip usage of `json_fwd.h`. I hope it will happen before 6.28 release.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:82,integrability,version,versions,82,"> It removes the requirement for version 3.9. Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. > It worsens the error message in case json_fwd.h when it is required for recent versions. They were written based on feedback from upstream, so I would like to keep the detailed messages. `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. After LLVM upgrade we could completely skip usage of `json_fwd.h`. I hope it will happen before 6.28 release.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:221,integrability,version,version,221,"> It removes the requirement for version 3.9. Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. > It worsens the error message in case json_fwd.h when it is required for recent versions. They were written based on feedback from upstream, so I would like to keep the detailed messages. `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. After LLVM upgrade we could completely skip usage of `json_fwd.h`. I hope it will happen before 6.28 release.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:282,integrability,messag,message,282,"> It removes the requirement for version 3.9. Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. > It worsens the error message in case json_fwd.h when it is required for recent versions. They were written based on feedback from upstream, so I would like to keep the detailed messages. `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. After LLVM upgrade we could completely skip usage of `json_fwd.h`. I hope it will happen before 6.28 release.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:340,integrability,version,versions,340,"> It removes the requirement for version 3.9. Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. > It worsens the error message in case json_fwd.h when it is required for recent versions. They were written based on feedback from upstream, so I would like to keep the detailed messages. `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. After LLVM upgrade we could completely skip usage of `json_fwd.h`. I hope it will happen before 6.28 release.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:438,integrability,messag,messages,438,"> It removes the requirement for version 3.9. Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. > It worsens the error message in case json_fwd.h when it is required for recent versions. They were written based on feedback from upstream, so I would like to keep the detailed messages. `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. After LLVM upgrade we could completely skip usage of `json_fwd.h`. I hope it will happen before 6.28 release.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:568,integrability,version,versions,568,"> It removes the requirement for version 3.9. Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. > It worsens the error message in case json_fwd.h when it is required for recent versions. They were written based on feedback from upstream, so I would like to keep the detailed messages. `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. After LLVM upgrade we could completely skip usage of `json_fwd.h`. I hope it will happen before 6.28 release.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:282,interoperability,messag,message,282,"> It removes the requirement for version 3.9. Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. > It worsens the error message in case json_fwd.h when it is required for recent versions. They were written based on feedback from upstream, so I would like to keep the detailed messages. `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. After LLVM upgrade we could completely skip usage of `json_fwd.h`. I hope it will happen before 6.28 release.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:438,interoperability,messag,messages,438,"> It removes the requirement for version 3.9. Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. > It worsens the error message in case json_fwd.h when it is required for recent versions. They were written based on feedback from upstream, so I would like to keep the detailed messages. `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. After LLVM upgrade we could completely skip usage of `json_fwd.h`. I hope it will happen before 6.28 release.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:33,modifiability,version,version,33,"> It removes the requirement for version 3.9. Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. > It worsens the error message in case json_fwd.h when it is required for recent versions. They were written based on feedback from upstream, so I would like to keep the detailed messages. `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. After LLVM upgrade we could completely skip usage of `json_fwd.h`. I hope it will happen before 6.28 release.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:82,modifiability,version,versions,82,"> It removes the requirement for version 3.9. Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. > It worsens the error message in case json_fwd.h when it is required for recent versions. They were written based on feedback from upstream, so I would like to keep the detailed messages. `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. After LLVM upgrade we could completely skip usage of `json_fwd.h`. I hope it will happen before 6.28 release.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:221,modifiability,version,version,221,"> It removes the requirement for version 3.9. Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. > It worsens the error message in case json_fwd.h when it is required for recent versions. They were written based on feedback from upstream, so I would like to keep the detailed messages. `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. After LLVM upgrade we could completely skip usage of `json_fwd.h`. I hope it will happen before 6.28 release.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:340,modifiability,version,versions,340,"> It removes the requirement for version 3.9. Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. > It worsens the error message in case json_fwd.h when it is required for recent versions. They were written based on feedback from upstream, so I would like to keep the detailed messages. `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. After LLVM upgrade we could completely skip usage of `json_fwd.h`. I hope it will happen before 6.28 release.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:568,modifiability,version,versions,568,"> It removes the requirement for version 3.9. Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. > It worsens the error message in case json_fwd.h when it is required for recent versions. They were written based on feedback from upstream, so I would like to keep the detailed messages. `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. After LLVM upgrade we could completely skip usage of `json_fwd.h`. I hope it will happen before 6.28 release.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:600,modifiability,upgrad,upgrade,600,"> It removes the requirement for version 3.9. Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. > It worsens the error message in case json_fwd.h when it is required for recent versions. They were written based on feedback from upstream, so I would like to keep the detailed messages. `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. After LLVM upgrade we could completely skip usage of `json_fwd.h`. I hope it will happen before 6.28 release.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:276,performance,error,error,276,"> It removes the requirement for version 3.9. Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. > It worsens the error message in case json_fwd.h when it is required for recent versions. They were written based on feedback from upstream, so I would like to keep the detailed messages. `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. After LLVM upgrade we could completely skip usage of `json_fwd.h`. I hope it will happen before 6.28 release.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:527,performance,time,time,527,"> It removes the requirement for version 3.9. Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. > It worsens the error message in case json_fwd.h when it is required for recent versions. They were written based on feedback from upstream, so I would like to keep the detailed messages. `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. After LLVM upgrade we could completely skip usage of `json_fwd.h`. I hope it will happen before 6.28 release.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:189,safety,test,testing,189,"> It removes the requirement for version 3.9. Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. > It worsens the error message in case json_fwd.h when it is required for recent versions. They were written based on feedback from upstream, so I would like to keep the detailed messages. `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. After LLVM upgrade we could completely skip usage of `json_fwd.h`. I hope it will happen before 6.28 release.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:276,safety,error,error,276,"> It removes the requirement for version 3.9. Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. > It worsens the error message in case json_fwd.h when it is required for recent versions. They were written based on feedback from upstream, so I would like to keep the detailed messages. `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. After LLVM upgrade we could completely skip usage of `json_fwd.h`. I hope it will happen before 6.28 release.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:617,safety,compl,completely,617,"> It removes the requirement for version 3.9. Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. > It worsens the error message in case json_fwd.h when it is required for recent versions. They were written based on feedback from upstream, so I would like to keep the detailed messages. `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. After LLVM upgrade we could completely skip usage of `json_fwd.h`. I hope it will happen before 6.28 release.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:617,security,compl,completely,617,"> It removes the requirement for version 3.9. Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. > It worsens the error message in case json_fwd.h when it is required for recent versions. They were written based on feedback from upstream, so I would like to keep the detailed messages. `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. After LLVM upgrade we could completely skip usage of `json_fwd.h`. I hope it will happen before 6.28 release.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:189,testability,test,testing,189,"> It removes the requirement for version 3.9. Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. > It worsens the error message in case json_fwd.h when it is required for recent versions. They were written based on feedback from upstream, so I would like to keep the detailed messages. `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. After LLVM upgrade we could completely skip usage of `json_fwd.h`. I hope it will happen before 6.28 release.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:276,usability,error,error,276,"> It removes the requirement for version 3.9. Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. > It worsens the error message in case json_fwd.h when it is required for recent versions. They were written based on feedback from upstream, so I would like to keep the detailed messages. `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. After LLVM upgrade we could completely skip usage of `json_fwd.h`. I hope it will happen before 6.28 release.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:377,usability,feedback,feedback,377,"> It removes the requirement for version 3.9. Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. > It worsens the error message in case json_fwd.h when it is required for recent versions. They were written based on feedback from upstream, so I would like to keep the detailed messages. `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. After LLVM upgrade we could completely skip usage of `json_fwd.h`. I hope it will happen before 6.28 release.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:533,availability,error,error,533,"> Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. My point is: why would we want to go back? AFAICT we already released ROOT with the requirement for 3.9. Did anybody complain? > `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. For me, this isn't an argument for changing the error message for *the current version* and make it worse. > After LLVM upgrade we could completely skip usage of `json_fwd.h`. I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:38,deployability,version,versions,38,"> Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. My point is: why would we want to go back? AFAICT we already released ROOT with the requirement for 3.9. Did anybody complain? > `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. For me, this isn't an argument for changing the error message for *the current version* and make it worse. > After LLVM upgrade we could completely skip usage of `json_fwd.h`. I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:177,deployability,version,version,177,"> Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. My point is: why would we want to go back? AFAICT we already released ROOT with the requirement for 3.9. Did anybody complain? > `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. For me, this isn't an argument for changing the error message for *the current version* and make it worse. > After LLVM upgrade we could completely skip usage of `json_fwd.h`. I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:276,deployability,releas,released,276,"> Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. My point is: why would we want to go back? AFAICT we already released ROOT with the requirement for 3.9. Did anybody complain? > `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. For me, this isn't an argument for changing the error message for *the current version* and make it worse. > After LLVM upgrade we could completely skip usage of `json_fwd.h`. I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:464,deployability,version,versions,464,"> Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. My point is: why would we want to go back? AFAICT we already released ROOT with the requirement for 3.9. Did anybody complain? > `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. For me, this isn't an argument for changing the error message for *the current version* and make it worse. > After LLVM upgrade we could completely skip usage of `json_fwd.h`. I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:564,deployability,version,version,564,"> Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. My point is: why would we want to go back? AFAICT we already released ROOT with the requirement for 3.9. Did anybody complain? > `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. For me, this isn't an argument for changing the error message for *the current version* and make it worse. > After LLVM upgrade we could completely skip usage of `json_fwd.h`. I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:605,deployability,upgrad,upgrade,605,"> Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. My point is: why would we want to go back? AFAICT we already released ROOT with the requirement for 3.9. Did anybody complain? > `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. For me, this isn't an argument for changing the error message for *the current version* and make it worse. > After LLVM upgrade we could completely skip usage of `json_fwd.h`. I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:756,deployability,upgrad,upgrade,756,"> Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. My point is: why would we want to go back? AFAICT we already released ROOT with the requirement for 3.9. Did anybody complain? > `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. For me, this isn't an argument for changing the error message for *the current version* and make it worse. > After LLVM upgrade we could completely skip usage of `json_fwd.h`. I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:556,energy efficiency,current,current,556,"> Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. My point is: why would we want to go back? AFAICT we already released ROOT with the requirement for 3.9. Did anybody complain? > `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. For me, this isn't an argument for changing the error message for *the current version* and make it worse. > After LLVM upgrade we could completely skip usage of `json_fwd.h`. I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:38,integrability,version,versions,38,"> Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. My point is: why would we want to go back? AFAICT we already released ROOT with the requirement for 3.9. Did anybody complain? > `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. For me, this isn't an argument for changing the error message for *the current version* and make it worse. > After LLVM upgrade we could completely skip usage of `json_fwd.h`. I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:177,integrability,version,version,177,"> Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. My point is: why would we want to go back? AFAICT we already released ROOT with the requirement for 3.9. Did anybody complain? > `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. For me, this isn't an argument for changing the error message for *the current version* and make it worse. > After LLVM upgrade we could completely skip usage of `json_fwd.h`. I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:464,integrability,version,versions,464,"> Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. My point is: why would we want to go back? AFAICT we already released ROOT with the requirement for 3.9. Did anybody complain? > `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. For me, this isn't an argument for changing the error message for *the current version* and make it worse. > After LLVM upgrade we could completely skip usage of `json_fwd.h`. I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:539,integrability,messag,message,539,"> Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. My point is: why would we want to go back? AFAICT we already released ROOT with the requirement for 3.9. Did anybody complain? > `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. For me, this isn't an argument for changing the error message for *the current version* and make it worse. > After LLVM upgrade we could completely skip usage of `json_fwd.h`. I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:564,integrability,version,version,564,"> Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. My point is: why would we want to go back? AFAICT we already released ROOT with the requirement for 3.9. Did anybody complain? > `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. For me, this isn't an argument for changing the error message for *the current version* and make it worse. > After LLVM upgrade we could completely skip usage of `json_fwd.h`. I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:539,interoperability,messag,message,539,"> Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. My point is: why would we want to go back? AFAICT we already released ROOT with the requirement for 3.9. Did anybody complain? > `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. For me, this isn't an argument for changing the error message for *the current version* and make it worse. > After LLVM upgrade we could completely skip usage of `json_fwd.h`. I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:38,modifiability,version,versions,38,"> Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. My point is: why would we want to go back? AFAICT we already released ROOT with the requirement for 3.9. Did anybody complain? > `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. For me, this isn't an argument for changing the error message for *the current version* and make it worse. > After LLVM upgrade we could completely skip usage of `json_fwd.h`. I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:177,modifiability,version,version,177,"> Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. My point is: why would we want to go back? AFAICT we already released ROOT with the requirement for 3.9. Did anybody complain? > `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. For me, this isn't an argument for changing the error message for *the current version* and make it worse. > After LLVM upgrade we could completely skip usage of `json_fwd.h`. I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:464,modifiability,version,versions,464,"> Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. My point is: why would we want to go back? AFAICT we already released ROOT with the requirement for 3.9. Did anybody complain? > `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. For me, this isn't an argument for changing the error message for *the current version* and make it worse. > After LLVM upgrade we could completely skip usage of `json_fwd.h`. I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:564,modifiability,version,version,564,"> Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. My point is: why would we want to go back? AFAICT we already released ROOT with the requirement for 3.9. Did anybody complain? > `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. For me, this isn't an argument for changing the error message for *the current version* and make it worse. > After LLVM upgrade we could completely skip usage of `json_fwd.h`. I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:605,modifiability,upgrad,upgrade,605,"> Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. My point is: why would we want to go back? AFAICT we already released ROOT with the requirement for 3.9. Did anybody complain? > `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. For me, this isn't an argument for changing the error message for *the current version* and make it worse. > After LLVM upgrade we could completely skip usage of `json_fwd.h`. I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:756,modifiability,upgrad,upgrade,756,"> Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. My point is: why would we want to go back? AFAICT we already released ROOT with the requirement for 3.9. Did anybody complain? > `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. For me, this isn't an argument for changing the error message for *the current version* and make it worse. > After LLVM upgrade we could completely skip usage of `json_fwd.h`. I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:423,performance,time,time,423,"> Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. My point is: why would we want to go back? AFAICT we already released ROOT with the requirement for 3.9. Did anybody complain? > `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. For me, this isn't an argument for changing the error message for *the current version* and make it worse. > After LLVM upgrade we could completely skip usage of `json_fwd.h`. I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:533,performance,error,error,533,"> Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. My point is: why would we want to go back? AFAICT we already released ROOT with the requirement for 3.9. Did anybody complain? > `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. For me, this isn't an argument for changing the error message for *the current version* and make it worse. > After LLVM upgrade we could completely skip usage of `json_fwd.h`. I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:145,safety,test,testing,145,"> Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. My point is: why would we want to go back? AFAICT we already released ROOT with the requirement for 3.9. Did anybody complain? > `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. For me, this isn't an argument for changing the error message for *the current version* and make it worse. > After LLVM upgrade we could completely skip usage of `json_fwd.h`. I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:332,safety,compl,complain,332,"> Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. My point is: why would we want to go back? AFAICT we already released ROOT with the requirement for 3.9. Did anybody complain? > `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. For me, this isn't an argument for changing the error message for *the current version* and make it worse. > After LLVM upgrade we could completely skip usage of `json_fwd.h`. I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:533,safety,error,error,533,"> Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. My point is: why would we want to go back? AFAICT we already released ROOT with the requirement for 3.9. Did anybody complain? > `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. For me, this isn't an argument for changing the error message for *the current version* and make it worse. > After LLVM upgrade we could completely skip usage of `json_fwd.h`. I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:622,safety,compl,completely,622,"> Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. My point is: why would we want to go back? AFAICT we already released ROOT with the requirement for 3.9. Did anybody complain? > `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. For me, this isn't an argument for changing the error message for *the current version* and make it worse. > After LLVM upgrade we could completely skip usage of `json_fwd.h`. I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:332,security,compl,complain,332,"> Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. My point is: why would we want to go back? AFAICT we already released ROOT with the requirement for 3.9. Did anybody complain? > `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. For me, this isn't an argument for changing the error message for *the current version* and make it worse. > After LLVM upgrade we could completely skip usage of `json_fwd.h`. I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:622,security,compl,completely,622,"> Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. My point is: why would we want to go back? AFAICT we already released ROOT with the requirement for 3.9. Did anybody complain? > `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. For me, this isn't an argument for changing the error message for *the current version* and make it worse. > After LLVM upgrade we could completely skip usage of `json_fwd.h`. I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:145,testability,test,testing,145,"> Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. My point is: why would we want to go back? AFAICT we already released ROOT with the requirement for 3.9. Did anybody complain? > `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. For me, this isn't an argument for changing the error message for *the current version* and make it worse. > After LLVM upgrade we could completely skip usage of `json_fwd.h`. I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:675,testability,understand,understand,675,"> Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. My point is: why would we want to go back? AFAICT we already released ROOT with the requirement for 3.9. Did anybody complain? > `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. For me, this isn't an argument for changing the error message for *the current version* and make it worse. > After LLVM upgrade we could completely skip usage of `json_fwd.h`. I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:533,usability,error,error,533,"> Technically code works with all 3.x versions of `nlohmann/json.hpp`. I add requirement for 3.9 recently just because we were not using and not testing for `json_fwd.hpp`. Now version restriction is not necessary. My point is: why would we want to go back? AFAICT we already released ROOT with the requirement for 3.9. Did anybody complain? > `json_fwd.hpp` now always required - not only for 3.11. Just as workaround for time been we allow to use [3.10 .. 3.11] versions without it. For me, this isn't an argument for changing the error message for *the current version* and make it worse. > After LLVM upgrade we could completely skip usage of `json_fwd.h`. I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:97,deployability,upgrad,upgrade,97,> I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library. After LLVM upgrade we can use `json.hpp` directly in header files. Thus one can simply avoid complication with `json_fwd.hpp`.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:158,deployability,upgrad,upgrade,158,> I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library. After LLVM upgrade we can use `json.hpp` directly in header files. Thus one can simply avoid complication with `json_fwd.hpp`.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:97,modifiability,upgrad,upgrade,97,> I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library. After LLVM upgrade we can use `json.hpp` directly in header files. Thus one can simply avoid complication with `json_fwd.hpp`.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:158,modifiability,upgrad,upgrade,158,> I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library. After LLVM upgrade we can use `json.hpp` directly in header files. Thus one can simply avoid complication with `json_fwd.hpp`.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:234,safety,avoid,avoid,234,> I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library. After LLVM upgrade we can use `json.hpp` directly in header files. Thus one can simply avoid complication with `json_fwd.hpp`.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:240,safety,compl,complication,240,> I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library. After LLVM upgrade we can use `json.hpp` directly in header files. Thus one can simply avoid complication with `json_fwd.hpp`.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:240,security,compl,complication,240,> I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library. After LLVM upgrade we can use `json.hpp` directly in header files. Thus one can simply avoid complication with `json_fwd.hpp`.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:16,testability,understand,understand,16,> I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library. After LLVM upgrade we can use `json.hpp` directly in header files. Thus one can simply avoid complication with `json_fwd.hpp`.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:227,testability,simpl,simply,227,> I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library. After LLVM upgrade we can use `json.hpp` directly in header files. Thus one can simply avoid complication with `json_fwd.hpp`.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:227,usability,simpl,simply,227,> I still don't understand this. All discussions we had so far ended with agreeing that the LLVM upgrade will change nothing wrt the JSON library. After LLVM upgrade we can use `json.hpp` directly in header files. Thus one can simply avoid complication with `json_fwd.hpp`.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:136,deployability,instal,installation,136,"That about this PR? . It is necessary to correctly detect situation when `json_fwd.hpp` is really required. Main problem if system-wide installation of newer 3.11.x version of `nlohmann/json.hpp` does not includes `json_fwd.hpp`. That's why this PR. Older (lower than 3.9 are) rare now, but can work without problems - if provides `json_fwd.hpp`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:165,deployability,version,version,165,"That about this PR? . It is necessary to correctly detect situation when `json_fwd.hpp` is really required. Main problem if system-wide installation of newer 3.11.x version of `nlohmann/json.hpp` does not includes `json_fwd.hpp`. That's why this PR. Older (lower than 3.9 are) rare now, but can work without problems - if provides `json_fwd.hpp`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:165,integrability,version,version,165,"That about this PR? . It is necessary to correctly detect situation when `json_fwd.hpp` is really required. Main problem if system-wide installation of newer 3.11.x version of `nlohmann/json.hpp` does not includes `json_fwd.hpp`. That's why this PR. Older (lower than 3.9 are) rare now, but can work without problems - if provides `json_fwd.hpp`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:165,modifiability,version,version,165,"That about this PR? . It is necessary to correctly detect situation when `json_fwd.hpp` is really required. Main problem if system-wide installation of newer 3.11.x version of `nlohmann/json.hpp` does not includes `json_fwd.hpp`. That's why this PR. Older (lower than 3.9 are) rare now, but can work without problems - if provides `json_fwd.hpp`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:196,reliability,doe,does,196,"That about this PR? . It is necessary to correctly detect situation when `json_fwd.hpp` is really required. Main problem if system-wide installation of newer 3.11.x version of `nlohmann/json.hpp` does not includes `json_fwd.hpp`. That's why this PR. Older (lower than 3.9 are) rare now, but can work without problems - if provides `json_fwd.hpp`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:51,safety,detect,detect,51,"That about this PR? . It is necessary to correctly detect situation when `json_fwd.hpp` is really required. Main problem if system-wide installation of newer 3.11.x version of `nlohmann/json.hpp` does not includes `json_fwd.hpp`. That's why this PR. Older (lower than 3.9 are) rare now, but can work without problems - if provides `json_fwd.hpp`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:51,security,detect,detect,51,"That about this PR? . It is necessary to correctly detect situation when `json_fwd.hpp` is really required. Main problem if system-wide installation of newer 3.11.x version of `nlohmann/json.hpp` does not includes `json_fwd.hpp`. That's why this PR. Older (lower than 3.9 are) rare now, but can work without problems - if provides `json_fwd.hpp`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:135,deployability,fail,fail-on-missing,135,"@linev as I said in https://github.com/root-project/root/pull/11268#pullrequestreview-1088542373 two weeks ago, I approve the fix for `fail-on-missing`. I'm not happy about the other changes (in particular, I don't understand why we would want to allow older versions than we did in the past), and I disagree with the references to the ""LLVM upgrade"" solving something with `nlohmann/json.hpp` - this never stood up to a factual check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:259,deployability,version,versions,259,"@linev as I said in https://github.com/root-project/root/pull/11268#pullrequestreview-1088542373 two weeks ago, I approve the fix for `fail-on-missing`. I'm not happy about the other changes (in particular, I don't understand why we would want to allow older versions than we did in the past), and I disagree with the references to the ""LLVM upgrade"" solving something with `nlohmann/json.hpp` - this never stood up to a factual check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:342,deployability,upgrad,upgrade,342,"@linev as I said in https://github.com/root-project/root/pull/11268#pullrequestreview-1088542373 two weeks ago, I approve the fix for `fail-on-missing`. I'm not happy about the other changes (in particular, I don't understand why we would want to allow older versions than we did in the past), and I disagree with the references to the ""LLVM upgrade"" solving something with `nlohmann/json.hpp` - this never stood up to a factual check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:259,integrability,version,versions,259,"@linev as I said in https://github.com/root-project/root/pull/11268#pullrequestreview-1088542373 two weeks ago, I approve the fix for `fail-on-missing`. I'm not happy about the other changes (in particular, I don't understand why we would want to allow older versions than we did in the past), and I disagree with the references to the ""LLVM upgrade"" solving something with `nlohmann/json.hpp` - this never stood up to a factual check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:259,modifiability,version,versions,259,"@linev as I said in https://github.com/root-project/root/pull/11268#pullrequestreview-1088542373 two weeks ago, I approve the fix for `fail-on-missing`. I'm not happy about the other changes (in particular, I don't understand why we would want to allow older versions than we did in the past), and I disagree with the references to the ""LLVM upgrade"" solving something with `nlohmann/json.hpp` - this never stood up to a factual check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:342,modifiability,upgrad,upgrade,342,"@linev as I said in https://github.com/root-project/root/pull/11268#pullrequestreview-1088542373 two weeks ago, I approve the fix for `fail-on-missing`. I'm not happy about the other changes (in particular, I don't understand why we would want to allow older versions than we did in the past), and I disagree with the references to the ""LLVM upgrade"" solving something with `nlohmann/json.hpp` - this never stood up to a factual check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:135,reliability,fail,fail-on-missing,135,"@linev as I said in https://github.com/root-project/root/pull/11268#pullrequestreview-1088542373 two weeks ago, I approve the fix for `fail-on-missing`. I'm not happy about the other changes (in particular, I don't understand why we would want to allow older versions than we did in the past), and I disagree with the references to the ""LLVM upgrade"" solving something with `nlohmann/json.hpp` - this never stood up to a factual check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:215,testability,understand,understand,215,"@linev as I said in https://github.com/root-project/root/pull/11268#pullrequestreview-1088542373 two weeks ago, I approve the fix for `fail-on-missing`. I'm not happy about the other changes (in particular, I don't understand why we would want to allow older versions than we did in the past), and I disagree with the references to the ""LLVM upgrade"" solving something with `nlohmann/json.hpp` - this never stood up to a factual check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:50,deployability,upgrad,upgrade,50,"> and I disagree with the references to the ""LLVM upgrade"" solving something with nlohmann/json.hpp - this never stood up to a factual check. I did check with llvm 13 branch - it was working.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:50,modifiability,upgrad,upgrade,50,"> and I disagree with the references to the ""LLVM upgrade"" solving something with nlohmann/json.hpp - this never stood up to a factual check. I did check with llvm 13 branch - it was working.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:52,deployability,upgrad,upgrade,52,"> > and I disagree with the references to the ""LLVM upgrade"" solving something with nlohmann/json.hpp - this never stood up to a factual check. > . > I did check with llvm 13 branch - it was working. What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including `json.hpp` into a header in one module is fine, merging from multiple modules doesn't work in either version.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:245,deployability,build,build,245,"> > and I disagree with the references to the ""LLVM upgrade"" solving something with nlohmann/json.hpp - this never stood up to a factual check. > . > I did check with llvm 13 branch - it was working. What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including `json.hpp` into a header in one module is fine, merging from multiple modules doesn't work in either version.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:253,deployability,modul,module,253,"> > and I disagree with the references to the ""LLVM upgrade"" solving something with nlohmann/json.hpp - this never stood up to a factual check. > . > I did check with llvm 13 branch - it was working. What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including `json.hpp` into a header in one module is fine, merging from multiple modules doesn't work in either version.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:352,deployability,modul,module,352,"> > and I disagree with the references to the ""LLVM upgrade"" solving something with nlohmann/json.hpp - this never stood up to a factual check. > . > I did check with llvm 13 branch - it was working. What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including `json.hpp` into a header in one module is fine, merging from multiple modules doesn't work in either version.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:390,deployability,modul,modules,390,"> > and I disagree with the references to the ""LLVM upgrade"" solving something with nlohmann/json.hpp - this never stood up to a factual check. > . > I did check with llvm 13 branch - it was working. What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including `json.hpp` into a header in one module is fine, merging from multiple modules doesn't work in either version.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:421,deployability,version,version,421,"> > and I disagree with the references to the ""LLVM upgrade"" solving something with nlohmann/json.hpp - this never stood up to a factual check. > . > I did check with llvm 13 branch - it was working. What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including `json.hpp` into a header in one module is fine, merging from multiple modules doesn't work in either version.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:421,integrability,version,version,421,"> > and I disagree with the references to the ""LLVM upgrade"" solving something with nlohmann/json.hpp - this never stood up to a factual check. > . > I did check with llvm 13 branch - it was working. What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including `json.hpp` into a header in one module is fine, merging from multiple modules doesn't work in either version.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:52,modifiability,upgrad,upgrade,52,"> > and I disagree with the references to the ""LLVM upgrade"" solving something with nlohmann/json.hpp - this never stood up to a factual check. > . > I did check with llvm 13 branch - it was working. What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including `json.hpp` into a header in one module is fine, merging from multiple modules doesn't work in either version.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:253,modifiability,modul,module,253,"> > and I disagree with the references to the ""LLVM upgrade"" solving something with nlohmann/json.hpp - this never stood up to a factual check. > . > I did check with llvm 13 branch - it was working. What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including `json.hpp` into a header in one module is fine, merging from multiple modules doesn't work in either version.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:352,modifiability,modul,module,352,"> > and I disagree with the references to the ""LLVM upgrade"" solving something with nlohmann/json.hpp - this never stood up to a factual check. > . > I did check with llvm 13 branch - it was working. What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including `json.hpp` into a header in one module is fine, merging from multiple modules doesn't work in either version.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:390,modifiability,modul,modules,390,"> > and I disagree with the references to the ""LLVM upgrade"" solving something with nlohmann/json.hpp - this never stood up to a factual check. > . > I did check with llvm 13 branch - it was working. What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including `json.hpp` into a header in one module is fine, merging from multiple modules doesn't work in either version.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:421,modifiability,version,version,421,"> > and I disagree with the references to the ""LLVM upgrade"" solving something with nlohmann/json.hpp - this never stood up to a factual check. > . > I did check with llvm 13 branch - it was working. What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including `json.hpp` into a header in one module is fine, merging from multiple modules doesn't work in either version.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:398,reliability,doe,doesn,398,"> > and I disagree with the references to the ""LLVM upgrade"" solving something with nlohmann/json.hpp - this never stood up to a factual check. > . > I did check with llvm 13 branch - it was working. What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including `json.hpp` into a header in one module is fine, merging from multiple modules doesn't work in either version.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:253,safety,modul,module,253,"> > and I disagree with the references to the ""LLVM upgrade"" solving something with nlohmann/json.hpp - this never stood up to a factual check. > . > I did check with llvm 13 branch - it was working. What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including `json.hpp` into a header in one module is fine, merging from multiple modules doesn't work in either version.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:352,safety,modul,module,352,"> > and I disagree with the references to the ""LLVM upgrade"" solving something with nlohmann/json.hpp - this never stood up to a factual check. > . > I did check with llvm 13 branch - it was working. What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including `json.hpp` into a header in one module is fine, merging from multiple modules doesn't work in either version.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:390,safety,modul,modules,390,"> > and I disagree with the references to the ""LLVM upgrade"" solving something with nlohmann/json.hpp - this never stood up to a factual check. > . > I did check with llvm 13 branch - it was working. What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including `json.hpp` into a header in one module is fine, merging from multiple modules doesn't work in either version.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:54,deployability,version,versions,54,"> I don't understand why we would want to allow older versions than we did in the past. The reason why we restrict version - we were not testing for `json_fwd.hpp`. . With 3.11.x version such simple restriction no longer working. But now we testing `json_fwd.hpp` and can use it, and restriction making no sense.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:115,deployability,version,version,115,"> I don't understand why we would want to allow older versions than we did in the past. The reason why we restrict version - we were not testing for `json_fwd.hpp`. . With 3.11.x version such simple restriction no longer working. But now we testing `json_fwd.hpp` and can use it, and restriction making no sense.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:179,deployability,version,version,179,"> I don't understand why we would want to allow older versions than we did in the past. The reason why we restrict version - we were not testing for `json_fwd.hpp`. . With 3.11.x version such simple restriction no longer working. But now we testing `json_fwd.hpp` and can use it, and restriction making no sense.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:54,integrability,version,versions,54,"> I don't understand why we would want to allow older versions than we did in the past. The reason why we restrict version - we were not testing for `json_fwd.hpp`. . With 3.11.x version such simple restriction no longer working. But now we testing `json_fwd.hpp` and can use it, and restriction making no sense.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:115,integrability,version,version,115,"> I don't understand why we would want to allow older versions than we did in the past. The reason why we restrict version - we were not testing for `json_fwd.hpp`. . With 3.11.x version such simple restriction no longer working. But now we testing `json_fwd.hpp` and can use it, and restriction making no sense.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:179,integrability,version,version,179,"> I don't understand why we would want to allow older versions than we did in the past. The reason why we restrict version - we were not testing for `json_fwd.hpp`. . With 3.11.x version such simple restriction no longer working. But now we testing `json_fwd.hpp` and can use it, and restriction making no sense.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:54,modifiability,version,versions,54,"> I don't understand why we would want to allow older versions than we did in the past. The reason why we restrict version - we were not testing for `json_fwd.hpp`. . With 3.11.x version such simple restriction no longer working. But now we testing `json_fwd.hpp` and can use it, and restriction making no sense.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:115,modifiability,version,version,115,"> I don't understand why we would want to allow older versions than we did in the past. The reason why we restrict version - we were not testing for `json_fwd.hpp`. . With 3.11.x version such simple restriction no longer working. But now we testing `json_fwd.hpp` and can use it, and restriction making no sense.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:179,modifiability,version,version,179,"> I don't understand why we would want to allow older versions than we did in the past. The reason why we restrict version - we were not testing for `json_fwd.hpp`. . With 3.11.x version such simple restriction no longer working. But now we testing `json_fwd.hpp` and can use it, and restriction making no sense.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:137,safety,test,testing,137,"> I don't understand why we would want to allow older versions than we did in the past. The reason why we restrict version - we were not testing for `json_fwd.hpp`. . With 3.11.x version such simple restriction no longer working. But now we testing `json_fwd.hpp` and can use it, and restriction making no sense.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:241,safety,test,testing,241,"> I don't understand why we would want to allow older versions than we did in the past. The reason why we restrict version - we were not testing for `json_fwd.hpp`. . With 3.11.x version such simple restriction no longer working. But now we testing `json_fwd.hpp` and can use it, and restriction making no sense.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:10,testability,understand,understand,10,"> I don't understand why we would want to allow older versions than we did in the past. The reason why we restrict version - we were not testing for `json_fwd.hpp`. . With 3.11.x version such simple restriction no longer working. But now we testing `json_fwd.hpp` and can use it, and restriction making no sense.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:137,testability,test,testing,137,"> I don't understand why we would want to allow older versions than we did in the past. The reason why we restrict version - we were not testing for `json_fwd.hpp`. . With 3.11.x version such simple restriction no longer working. But now we testing `json_fwd.hpp` and can use it, and restriction making no sense.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:192,testability,simpl,simple,192,"> I don't understand why we would want to allow older versions than we did in the past. The reason why we restrict version - we were not testing for `json_fwd.hpp`. . With 3.11.x version such simple restriction no longer working. But now we testing `json_fwd.hpp` and can use it, and restriction making no sense.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:241,testability,test,testing,241,"> I don't understand why we would want to allow older versions than we did in the past. The reason why we restrict version - we were not testing for `json_fwd.hpp`. . With 3.11.x version such simple restriction no longer working. But now we testing `json_fwd.hpp` and can use it, and restriction making no sense.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:192,usability,simpl,simple,192,"> I don't understand why we would want to allow older versions than we did in the past. The reason why we restrict version - we were not testing for `json_fwd.hpp`. . With 3.11.x version such simple restriction no longer working. But now we testing `json_fwd.hpp` and can use it, and restriction making no sense.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:47,deployability,build,build,47,"> What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including json.hpp into a header in one module is fine, merging from multiple modules doesn't work in either version. I compile with llvm13 and directly include json.hpp in REve classes and can load and use it. . But I did not try to use json.hpp from several libraries - may be this makes problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:55,deployability,modul,module,55,"> What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including json.hpp into a header in one module is fine, merging from multiple modules doesn't work in either version. I compile with llvm13 and directly include json.hpp in REve classes and can load and use it. . But I did not try to use json.hpp from several libraries - may be this makes problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:152,deployability,modul,module,152,"> What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including json.hpp into a header in one module is fine, merging from multiple modules doesn't work in either version. I compile with llvm13 and directly include json.hpp in REve classes and can load and use it. . But I did not try to use json.hpp from several libraries - may be this makes problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:190,deployability,modul,modules,190,"> What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including json.hpp into a header in one module is fine, merging from multiple modules doesn't work in either version. I compile with llvm13 and directly include json.hpp in REve classes and can load and use it. . But I did not try to use json.hpp from several libraries - may be this makes problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:221,deployability,version,version,221,"> What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including json.hpp into a header in one module is fine, merging from multiple modules doesn't work in either version. I compile with llvm13 and directly include json.hpp in REve classes and can load and use it. . But I did not try to use json.hpp from several libraries - may be this makes problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:306,energy efficiency,load,load,306,"> What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including json.hpp into a header in one module is fine, merging from multiple modules doesn't work in either version. I compile with llvm13 and directly include json.hpp in REve classes and can load and use it. . But I did not try to use json.hpp from several libraries - may be this makes problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:221,integrability,version,version,221,"> What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including json.hpp into a header in one module is fine, merging from multiple modules doesn't work in either version. I compile with llvm13 and directly include json.hpp in REve classes and can load and use it. . But I did not try to use json.hpp from several libraries - may be this makes problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:55,modifiability,modul,module,55,"> What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including json.hpp into a header in one module is fine, merging from multiple modules doesn't work in either version. I compile with llvm13 and directly include json.hpp in REve classes and can load and use it. . But I did not try to use json.hpp from several libraries - may be this makes problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:152,modifiability,modul,module,152,"> What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including json.hpp into a header in one module is fine, merging from multiple modules doesn't work in either version. I compile with llvm13 and directly include json.hpp in REve classes and can load and use it. . But I did not try to use json.hpp from several libraries - may be this makes problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:190,modifiability,modul,modules,190,"> What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including json.hpp into a header in one module is fine, merging from multiple modules doesn't work in either version. I compile with llvm13 and directly include json.hpp in REve classes and can load and use it. . But I did not try to use json.hpp from several libraries - may be this makes problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:221,modifiability,version,version,221,"> What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including json.hpp into a header in one module is fine, merging from multiple modules doesn't work in either version. I compile with llvm13 and directly include json.hpp in REve classes and can load and use it. . But I did not try to use json.hpp from several libraries - may be this makes problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:306,performance,load,load,306,"> What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including json.hpp into a header in one module is fine, merging from multiple modules doesn't work in either version. I compile with llvm13 and directly include json.hpp in REve classes and can load and use it. . But I did not try to use json.hpp from several libraries - may be this makes problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:198,reliability,doe,doesn,198,"> What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including json.hpp into a header in one module is fine, merging from multiple modules doesn't work in either version. I compile with llvm13 and directly include json.hpp in REve classes and can load and use it. . But I did not try to use json.hpp from several libraries - may be this makes problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:55,safety,modul,module,55,"> What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including json.hpp into a header in one module is fine, merging from multiple modules doesn't work in either version. I compile with llvm13 and directly include json.hpp in REve classes and can load and use it. . But I did not try to use json.hpp from several libraries - may be this makes problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:152,safety,modul,module,152,"> What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including json.hpp into a header in one module is fine, merging from multiple modules doesn't work in either version. I compile with llvm13 and directly include json.hpp in REve classes and can load and use it. . But I did not try to use json.hpp from several libraries - may be this makes problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:190,safety,modul,modules,190,"> What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including json.hpp into a header in one module is fine, merging from multiple modules doesn't work in either version. I compile with llvm13 and directly include json.hpp in REve classes and can load and use it. . But I did not try to use json.hpp from several libraries - may be this makes problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:49,deployability,build,build,49,"> > What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including json.hpp into a header in one module is fine, merging from multiple modules doesn't work in either version. > . > I compile with llvm13 and directly include json.hpp in REve classes and can load and use it. This already works with LLVM 9 for me. Last time we discussed, the issues you mentioned were due to GCC12. > But I did not try to use json.hpp from several libraries - may be this makes problem. Yes, this will be a problem as discussed at CERN a while back.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:57,deployability,modul,module,57,"> > What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including json.hpp into a header in one module is fine, merging from multiple modules doesn't work in either version. > . > I compile with llvm13 and directly include json.hpp in REve classes and can load and use it. This already works with LLVM 9 for me. Last time we discussed, the issues you mentioned were due to GCC12. > But I did not try to use json.hpp from several libraries - may be this makes problem. Yes, this will be a problem as discussed at CERN a while back.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:154,deployability,modul,module,154,"> > What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including json.hpp into a header in one module is fine, merging from multiple modules doesn't work in either version. > . > I compile with llvm13 and directly include json.hpp in REve classes and can load and use it. This already works with LLVM 9 for me. Last time we discussed, the issues you mentioned were due to GCC12. > But I did not try to use json.hpp from several libraries - may be this makes problem. Yes, this will be a problem as discussed at CERN a while back.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:192,deployability,modul,modules,192,"> > What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including json.hpp into a header in one module is fine, merging from multiple modules doesn't work in either version. > . > I compile with llvm13 and directly include json.hpp in REve classes and can load and use it. This already works with LLVM 9 for me. Last time we discussed, the issues you mentioned were due to GCC12. > But I did not try to use json.hpp from several libraries - may be this makes problem. Yes, this will be a problem as discussed at CERN a while back.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:223,deployability,version,version,223,"> > What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including json.hpp into a header in one module is fine, merging from multiple modules doesn't work in either version. > . > I compile with llvm13 and directly include json.hpp in REve classes and can load and use it. This already works with LLVM 9 for me. Last time we discussed, the issues you mentioned were due to GCC12. > But I did not try to use json.hpp from several libraries - may be this makes problem. Yes, this will be a problem as discussed at CERN a while back.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:314,energy efficiency,load,load,314,"> > What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including json.hpp into a header in one module is fine, merging from multiple modules doesn't work in either version. > . > I compile with llvm13 and directly include json.hpp in REve classes and can load and use it. This already works with LLVM 9 for me. Last time we discussed, the issues you mentioned were due to GCC12. > But I did not try to use json.hpp from several libraries - may be this makes problem. Yes, this will be a problem as discussed at CERN a while back.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:223,integrability,version,version,223,"> > What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including json.hpp into a header in one module is fine, merging from multiple modules doesn't work in either version. > . > I compile with llvm13 and directly include json.hpp in REve classes and can load and use it. This already works with LLVM 9 for me. Last time we discussed, the issues you mentioned were due to GCC12. > But I did not try to use json.hpp from several libraries - may be this makes problem. Yes, this will be a problem as discussed at CERN a while back.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:57,modifiability,modul,module,57,"> > What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including json.hpp into a header in one module is fine, merging from multiple modules doesn't work in either version. > . > I compile with llvm13 and directly include json.hpp in REve classes and can load and use it. This already works with LLVM 9 for me. Last time we discussed, the issues you mentioned were due to GCC12. > But I did not try to use json.hpp from several libraries - may be this makes problem. Yes, this will be a problem as discussed at CERN a while back.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:154,modifiability,modul,module,154,"> > What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including json.hpp into a header in one module is fine, merging from multiple modules doesn't work in either version. > . > I compile with llvm13 and directly include json.hpp in REve classes and can load and use it. This already works with LLVM 9 for me. Last time we discussed, the issues you mentioned were due to GCC12. > But I did not try to use json.hpp from several libraries - may be this makes problem. Yes, this will be a problem as discussed at CERN a while back.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:192,modifiability,modul,modules,192,"> > What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including json.hpp into a header in one module is fine, merging from multiple modules doesn't work in either version. > . > I compile with llvm13 and directly include json.hpp in REve classes and can load and use it. This already works with LLVM 9 for me. Last time we discussed, the issues you mentioned were due to GCC12. > But I did not try to use json.hpp from several libraries - may be this makes problem. Yes, this will be a problem as discussed at CERN a while back.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:223,modifiability,version,version,223,"> > What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including json.hpp into a header in one module is fine, merging from multiple modules doesn't work in either version. > . > I compile with llvm13 and directly include json.hpp in REve classes and can load and use it. This already works with LLVM 9 for me. Last time we discussed, the issues you mentioned were due to GCC12. > But I did not try to use json.hpp from several libraries - may be this makes problem. Yes, this will be a problem as discussed at CERN a while back.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:314,performance,load,load,314,"> > What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including json.hpp into a header in one module is fine, merging from multiple modules doesn't work in either version. > . > I compile with llvm13 and directly include json.hpp in REve classes and can load and use it. This already works with LLVM 9 for me. Last time we discussed, the issues you mentioned were due to GCC12. > But I did not try to use json.hpp from several libraries - may be this makes problem. Yes, this will be a problem as discussed at CERN a while back.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:375,performance,time,time,375,"> > What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including json.hpp into a header in one module is fine, merging from multiple modules doesn't work in either version. > . > I compile with llvm13 and directly include json.hpp in REve classes and can load and use it. This already works with LLVM 9 for me. Last time we discussed, the issues you mentioned were due to GCC12. > But I did not try to use json.hpp from several libraries - may be this makes problem. Yes, this will be a problem as discussed at CERN a while back.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:200,reliability,doe,doesn,200,"> > What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including json.hpp into a header in one module is fine, merging from multiple modules doesn't work in either version. > . > I compile with llvm13 and directly include json.hpp in REve classes and can load and use it. This already works with LLVM 9 for me. Last time we discussed, the issues you mentioned were due to GCC12. > But I did not try to use json.hpp from several libraries - may be this makes problem. Yes, this will be a problem as discussed at CERN a while back.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:57,safety,modul,module,57,"> > What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including json.hpp into a header in one module is fine, merging from multiple modules doesn't work in either version. > . > I compile with llvm13 and directly include json.hpp in REve classes and can load and use it. This already works with LLVM 9 for me. Last time we discussed, the issues you mentioned were due to GCC12. > But I did not try to use json.hpp from several libraries - may be this makes problem. Yes, this will be a problem as discussed at CERN a while back.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:154,safety,modul,module,154,"> > What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including json.hpp into a header in one module is fine, merging from multiple modules doesn't work in either version. > . > I compile with llvm13 and directly include json.hpp in REve classes and can load and use it. This already works with LLVM 9 for me. Last time we discussed, the issues you mentioned were due to GCC12. > But I did not try to use json.hpp from several libraries - may be this makes problem. Yes, this will be a problem as discussed at CERN a while back.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11268:192,safety,modul,modules,192,"> > What did you check, and what worked? Did you build a module? For me, LLVM 9 and LLVM 13 give the same result: including json.hpp into a header in one module is fine, merging from multiple modules doesn't work in either version. > . > I compile with llvm13 and directly include json.hpp in REve classes and can load and use it. This already works with LLVM 9 for me. Last time we discussed, the issues you mentioned were due to GCC12. > But I did not try to use json.hpp from several libraries - may be this makes problem. Yes, this will be a problem as discussed at CERN a while back.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11268
https://github.com/root-project/root/pull/11270:11,deployability,build,build,11,@phsft-bot build please.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11270
https://github.com/root-project/root/pull/11270:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11270
https://github.com/root-project/root/pull/11270:11,deployability,build,build,11,@phsft-bot build pretty please,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11270
https://github.com/root-project/root/pull/11270:61,deployability,patch,patches,61,@ikabadzhov can you please rebase on top of latest `v6-26-00-patches` and do a force-push? I hope that will fix the CI issues.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11270
https://github.com/root-project/root/pull/11270:61,safety,patch,patches,61,@ikabadzhov can you please rebase on top of latest `v6-26-00-patches` and do a force-push? I hope that will fix the CI issues.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11270
https://github.com/root-project/root/pull/11270:61,security,patch,patches,61,@ikabadzhov can you please rebase on top of latest `v6-26-00-patches` and do a force-push? I hope that will fix the CI issues.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11270
https://github.com/root-project/root/issues/11271:112,security,team,team,112,I'm tentatively assigning @agheata (because it's geometry) and @Axel-Naumann as we briefly discussed during the team meeting if it makes sense to fix this or deprecate and drop the code if apparently nobody is using it.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11271
https://github.com/root-project/root/issues/11271:53,integrability,interfac,interface,53,I'll fix the compilation and provide a test for this interface.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11271
https://github.com/root-project/root/issues/11271:53,interoperability,interfac,interface,53,I'll fix the compilation and provide a test for this interface.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11271
https://github.com/root-project/root/issues/11271:53,modifiability,interfac,interface,53,I'll fix the compilation and provide a test for this interface.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11271
https://github.com/root-project/root/issues/11271:39,safety,test,test,39,I'll fix the compilation and provide a test for this interface.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11271
https://github.com/root-project/root/issues/11271:39,testability,test,test,39,I'll fix the compilation and provide a test for this interface.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11271
https://github.com/root-project/root/issues/11272:89,deployability,version,versions,89,"This is truly bizarre. I do not understand at all why this should not happen in previous versions of root. For some reasons in the mixture the element is added twice. If you invert the creation of the mixture this does not happen. This is bad:. ```. TGeoMixture *mix2 = new TGeoMixture(""Pipe:Sintimid15G"", 2, 1.42);. mix2->AddElement(mix, 0.85);. mix2->AddElement(c, 0.15);. ```. This however works as expected:. ```. TGeoMixture *mix2 = new TGeoMixture(""Pipe:Sintimid15G"", 2, 1.42);. mix2->AddElement(c, 0.15);. mix2->AddElement(mix, 0.85);. ```. and gives:. ```. Mixture Pipe:Sintimid15G Aeff=12.9939 Zeff=6.49292 rho=1.42 radlen=28.2183 intlen=57.7889 index=1. Element: C Z=6 N=12.000000 A=12.010700 [g/mole]. Element: N Z=7 N=14.000000 A=14.006740 [g/mole]. Element: O Z=8 N=16.000000 A=15.999400 [g/mole]. Number of elements:3. Element 0: C. Element 1: N. Element 2: O. ```. Somehow in TGeoMaterial.cxx:816 the logic looks suspicious, but I am not really sure of:. ```. for (i=0; i<fNelements; i++) {. if (!fElements && TMath::Abs(z-fZmixture[i])<1.e-6 && TMath::Abs(a-fAmixture[i])<1.e-6) {. fWeights[i] += weight;. AverageProperties();. return;. }. }. ```. Andrei, what is you interpretation ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:916,deployability,log,logic,916,"This is truly bizarre. I do not understand at all why this should not happen in previous versions of root. For some reasons in the mixture the element is added twice. If you invert the creation of the mixture this does not happen. This is bad:. ```. TGeoMixture *mix2 = new TGeoMixture(""Pipe:Sintimid15G"", 2, 1.42);. mix2->AddElement(mix, 0.85);. mix2->AddElement(c, 0.15);. ```. This however works as expected:. ```. TGeoMixture *mix2 = new TGeoMixture(""Pipe:Sintimid15G"", 2, 1.42);. mix2->AddElement(c, 0.15);. mix2->AddElement(mix, 0.85);. ```. and gives:. ```. Mixture Pipe:Sintimid15G Aeff=12.9939 Zeff=6.49292 rho=1.42 radlen=28.2183 intlen=57.7889 index=1. Element: C Z=6 N=12.000000 A=12.010700 [g/mole]. Element: N Z=7 N=14.000000 A=14.006740 [g/mole]. Element: O Z=8 N=16.000000 A=15.999400 [g/mole]. Number of elements:3. Element 0: C. Element 1: N. Element 2: O. ```. Somehow in TGeoMaterial.cxx:816 the logic looks suspicious, but I am not really sure of:. ```. for (i=0; i<fNelements; i++) {. if (!fElements && TMath::Abs(z-fZmixture[i])<1.e-6 && TMath::Abs(a-fAmixture[i])<1.e-6) {. fWeights[i] += weight;. AverageProperties();. return;. }. }. ```. Andrei, what is you interpretation ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:89,integrability,version,versions,89,"This is truly bizarre. I do not understand at all why this should not happen in previous versions of root. For some reasons in the mixture the element is added twice. If you invert the creation of the mixture this does not happen. This is bad:. ```. TGeoMixture *mix2 = new TGeoMixture(""Pipe:Sintimid15G"", 2, 1.42);. mix2->AddElement(mix, 0.85);. mix2->AddElement(c, 0.15);. ```. This however works as expected:. ```. TGeoMixture *mix2 = new TGeoMixture(""Pipe:Sintimid15G"", 2, 1.42);. mix2->AddElement(c, 0.15);. mix2->AddElement(mix, 0.85);. ```. and gives:. ```. Mixture Pipe:Sintimid15G Aeff=12.9939 Zeff=6.49292 rho=1.42 radlen=28.2183 intlen=57.7889 index=1. Element: C Z=6 N=12.000000 A=12.010700 [g/mole]. Element: N Z=7 N=14.000000 A=14.006740 [g/mole]. Element: O Z=8 N=16.000000 A=15.999400 [g/mole]. Number of elements:3. Element 0: C. Element 1: N. Element 2: O. ```. Somehow in TGeoMaterial.cxx:816 the logic looks suspicious, but I am not really sure of:. ```. for (i=0; i<fNelements; i++) {. if (!fElements && TMath::Abs(z-fZmixture[i])<1.e-6 && TMath::Abs(a-fAmixture[i])<1.e-6) {. fWeights[i] += weight;. AverageProperties();. return;. }. }. ```. Andrei, what is you interpretation ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:89,modifiability,version,versions,89,"This is truly bizarre. I do not understand at all why this should not happen in previous versions of root. For some reasons in the mixture the element is added twice. If you invert the creation of the mixture this does not happen. This is bad:. ```. TGeoMixture *mix2 = new TGeoMixture(""Pipe:Sintimid15G"", 2, 1.42);. mix2->AddElement(mix, 0.85);. mix2->AddElement(c, 0.15);. ```. This however works as expected:. ```. TGeoMixture *mix2 = new TGeoMixture(""Pipe:Sintimid15G"", 2, 1.42);. mix2->AddElement(c, 0.15);. mix2->AddElement(mix, 0.85);. ```. and gives:. ```. Mixture Pipe:Sintimid15G Aeff=12.9939 Zeff=6.49292 rho=1.42 radlen=28.2183 intlen=57.7889 index=1. Element: C Z=6 N=12.000000 A=12.010700 [g/mole]. Element: N Z=7 N=14.000000 A=14.006740 [g/mole]. Element: O Z=8 N=16.000000 A=15.999400 [g/mole]. Number of elements:3. Element 0: C. Element 1: N. Element 2: O. ```. Somehow in TGeoMaterial.cxx:816 the logic looks suspicious, but I am not really sure of:. ```. for (i=0; i<fNelements; i++) {. if (!fElements && TMath::Abs(z-fZmixture[i])<1.e-6 && TMath::Abs(a-fAmixture[i])<1.e-6) {. fWeights[i] += weight;. AverageProperties();. return;. }. }. ```. Andrei, what is you interpretation ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:214,reliability,doe,does,214,"This is truly bizarre. I do not understand at all why this should not happen in previous versions of root. For some reasons in the mixture the element is added twice. If you invert the creation of the mixture this does not happen. This is bad:. ```. TGeoMixture *mix2 = new TGeoMixture(""Pipe:Sintimid15G"", 2, 1.42);. mix2->AddElement(mix, 0.85);. mix2->AddElement(c, 0.15);. ```. This however works as expected:. ```. TGeoMixture *mix2 = new TGeoMixture(""Pipe:Sintimid15G"", 2, 1.42);. mix2->AddElement(c, 0.15);. mix2->AddElement(mix, 0.85);. ```. and gives:. ```. Mixture Pipe:Sintimid15G Aeff=12.9939 Zeff=6.49292 rho=1.42 radlen=28.2183 intlen=57.7889 index=1. Element: C Z=6 N=12.000000 A=12.010700 [g/mole]. Element: N Z=7 N=14.000000 A=14.006740 [g/mole]. Element: O Z=8 N=16.000000 A=15.999400 [g/mole]. Number of elements:3. Element 0: C. Element 1: N. Element 2: O. ```. Somehow in TGeoMaterial.cxx:816 the logic looks suspicious, but I am not really sure of:. ```. for (i=0; i<fNelements; i++) {. if (!fElements && TMath::Abs(z-fZmixture[i])<1.e-6 && TMath::Abs(a-fAmixture[i])<1.e-6) {. fWeights[i] += weight;. AverageProperties();. return;. }. }. ```. Andrei, what is you interpretation ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:916,safety,log,logic,916,"This is truly bizarre. I do not understand at all why this should not happen in previous versions of root. For some reasons in the mixture the element is added twice. If you invert the creation of the mixture this does not happen. This is bad:. ```. TGeoMixture *mix2 = new TGeoMixture(""Pipe:Sintimid15G"", 2, 1.42);. mix2->AddElement(mix, 0.85);. mix2->AddElement(c, 0.15);. ```. This however works as expected:. ```. TGeoMixture *mix2 = new TGeoMixture(""Pipe:Sintimid15G"", 2, 1.42);. mix2->AddElement(c, 0.15);. mix2->AddElement(mix, 0.85);. ```. and gives:. ```. Mixture Pipe:Sintimid15G Aeff=12.9939 Zeff=6.49292 rho=1.42 radlen=28.2183 intlen=57.7889 index=1. Element: C Z=6 N=12.000000 A=12.010700 [g/mole]. Element: N Z=7 N=14.000000 A=14.006740 [g/mole]. Element: O Z=8 N=16.000000 A=15.999400 [g/mole]. Number of elements:3. Element 0: C. Element 1: N. Element 2: O. ```. Somehow in TGeoMaterial.cxx:816 the logic looks suspicious, but I am not really sure of:. ```. for (i=0; i<fNelements; i++) {. if (!fElements && TMath::Abs(z-fZmixture[i])<1.e-6 && TMath::Abs(a-fAmixture[i])<1.e-6) {. fWeights[i] += weight;. AverageProperties();. return;. }. }. ```. Andrei, what is you interpretation ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:916,security,log,logic,916,"This is truly bizarre. I do not understand at all why this should not happen in previous versions of root. For some reasons in the mixture the element is added twice. If you invert the creation of the mixture this does not happen. This is bad:. ```. TGeoMixture *mix2 = new TGeoMixture(""Pipe:Sintimid15G"", 2, 1.42);. mix2->AddElement(mix, 0.85);. mix2->AddElement(c, 0.15);. ```. This however works as expected:. ```. TGeoMixture *mix2 = new TGeoMixture(""Pipe:Sintimid15G"", 2, 1.42);. mix2->AddElement(c, 0.15);. mix2->AddElement(mix, 0.85);. ```. and gives:. ```. Mixture Pipe:Sintimid15G Aeff=12.9939 Zeff=6.49292 rho=1.42 radlen=28.2183 intlen=57.7889 index=1. Element: C Z=6 N=12.000000 A=12.010700 [g/mole]. Element: N Z=7 N=14.000000 A=14.006740 [g/mole]. Element: O Z=8 N=16.000000 A=15.999400 [g/mole]. Number of elements:3. Element 0: C. Element 1: N. Element 2: O. ```. Somehow in TGeoMaterial.cxx:816 the logic looks suspicious, but I am not really sure of:. ```. for (i=0; i<fNelements; i++) {. if (!fElements && TMath::Abs(z-fZmixture[i])<1.e-6 && TMath::Abs(a-fAmixture[i])<1.e-6) {. fWeights[i] += weight;. AverageProperties();. return;. }. }. ```. Andrei, what is you interpretation ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:32,testability,understand,understand,32,"This is truly bizarre. I do not understand at all why this should not happen in previous versions of root. For some reasons in the mixture the element is added twice. If you invert the creation of the mixture this does not happen. This is bad:. ```. TGeoMixture *mix2 = new TGeoMixture(""Pipe:Sintimid15G"", 2, 1.42);. mix2->AddElement(mix, 0.85);. mix2->AddElement(c, 0.15);. ```. This however works as expected:. ```. TGeoMixture *mix2 = new TGeoMixture(""Pipe:Sintimid15G"", 2, 1.42);. mix2->AddElement(c, 0.15);. mix2->AddElement(mix, 0.85);. ```. and gives:. ```. Mixture Pipe:Sintimid15G Aeff=12.9939 Zeff=6.49292 rho=1.42 radlen=28.2183 intlen=57.7889 index=1. Element: C Z=6 N=12.000000 A=12.010700 [g/mole]. Element: N Z=7 N=14.000000 A=14.006740 [g/mole]. Element: O Z=8 N=16.000000 A=15.999400 [g/mole]. Number of elements:3. Element 0: C. Element 1: N. Element 2: O. ```. Somehow in TGeoMaterial.cxx:816 the logic looks suspicious, but I am not really sure of:. ```. for (i=0; i<fNelements; i++) {. if (!fElements && TMath::Abs(z-fZmixture[i])<1.e-6 && TMath::Abs(a-fAmixture[i])<1.e-6) {. fWeights[i] += weight;. AverageProperties();. return;. }. }. ```. Andrei, what is you interpretation ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:916,testability,log,logic,916,"This is truly bizarre. I do not understand at all why this should not happen in previous versions of root. For some reasons in the mixture the element is added twice. If you invert the creation of the mixture this does not happen. This is bad:. ```. TGeoMixture *mix2 = new TGeoMixture(""Pipe:Sintimid15G"", 2, 1.42);. mix2->AddElement(mix, 0.85);. mix2->AddElement(c, 0.15);. ```. This however works as expected:. ```. TGeoMixture *mix2 = new TGeoMixture(""Pipe:Sintimid15G"", 2, 1.42);. mix2->AddElement(c, 0.15);. mix2->AddElement(mix, 0.85);. ```. and gives:. ```. Mixture Pipe:Sintimid15G Aeff=12.9939 Zeff=6.49292 rho=1.42 radlen=28.2183 intlen=57.7889 index=1. Element: C Z=6 N=12.000000 A=12.010700 [g/mole]. Element: N Z=7 N=14.000000 A=14.006740 [g/mole]. Element: O Z=8 N=16.000000 A=15.999400 [g/mole]. Number of elements:3. Element 0: C. Element 1: N. Element 2: O. ```. Somehow in TGeoMaterial.cxx:816 the logic looks suspicious, but I am not really sure of:. ```. for (i=0; i<fNelements; i++) {. if (!fElements && TMath::Abs(z-fZmixture[i])<1.e-6 && TMath::Abs(a-fAmixture[i])<1.e-6) {. fWeights[i] += weight;. AverageProperties();. return;. }. }. ```. Andrei, what is you interpretation ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:65,deployability,releas,releases,65,. I also get that output when using `/cvmfs/lhcb.cern.ch/lib/lcg/releases/ROOT/6.24.06-3455f/x86_64-centos7-gcc11-dbg/bin/root`.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:131,integrability,interfac,interface,131,"I'm working on a fix. The bug affects the cases when an element is added to a mixture having already that element (defined via the interface taking an element, and not A/Z).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:131,interoperability,interfac,interface,131,"I'm working on a fix. The bug affects the cases when an element is added to a mixture having already that element (defined via the interface taking an element, and not A/Z).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:131,modifiability,interfac,interface,131,"I'm working on a fix. The bug affects the cases when an element is added to a mixture having already that element (defined via the interface taking an element, and not A/Z).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:54,deployability,integr,integration,54,"The fix works in my standalone ROOT test. To test the integration with DD4hep and the LHCb detector, the simplest is to add it to the SFT nightlies.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:54,integrability,integr,integration,54,"The fix works in my standalone ROOT test. To test the integration with DD4hep and the LHCb detector, the simplest is to add it to the SFT nightlies.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:54,interoperability,integr,integration,54,"The fix works in my standalone ROOT test. To test the integration with DD4hep and the LHCb detector, the simplest is to add it to the SFT nightlies.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:54,modifiability,integr,integration,54,"The fix works in my standalone ROOT test. To test the integration with DD4hep and the LHCb detector, the simplest is to add it to the SFT nightlies.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:54,reliability,integr,integration,54,"The fix works in my standalone ROOT test. To test the integration with DD4hep and the LHCb detector, the simplest is to add it to the SFT nightlies.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:36,safety,test,test,36,"The fix works in my standalone ROOT test. To test the integration with DD4hep and the LHCb detector, the simplest is to add it to the SFT nightlies.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:45,safety,test,test,45,"The fix works in my standalone ROOT test. To test the integration with DD4hep and the LHCb detector, the simplest is to add it to the SFT nightlies.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:91,safety,detect,detector,91,"The fix works in my standalone ROOT test. To test the integration with DD4hep and the LHCb detector, the simplest is to add it to the SFT nightlies.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:54,security,integr,integration,54,"The fix works in my standalone ROOT test. To test the integration with DD4hep and the LHCb detector, the simplest is to add it to the SFT nightlies.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:91,security,detect,detector,91,"The fix works in my standalone ROOT test. To test the integration with DD4hep and the LHCb detector, the simplest is to add it to the SFT nightlies.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:36,testability,test,test,36,"The fix works in my standalone ROOT test. To test the integration with DD4hep and the LHCb detector, the simplest is to add it to the SFT nightlies.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:45,testability,test,test,45,"The fix works in my standalone ROOT test. To test the integration with DD4hep and the LHCb detector, the simplest is to add it to the SFT nightlies.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:54,testability,integr,integration,54,"The fix works in my standalone ROOT test. To test the integration with DD4hep and the LHCb detector, the simplest is to add it to the SFT nightlies.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:105,testability,simpl,simplest,105,"The fix works in my standalone ROOT test. To test the integration with DD4hep and the LHCb detector, the simplest is to add it to the SFT nightlies.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:105,usability,simpl,simplest,105,"The fix works in my standalone ROOT test. To test the integration with DD4hep and the LHCb detector, the simplest is to add it to the SFT nightlies.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:2,usability,confirm,confirm,2,I confirm: in standalone ROOT this fix works for me.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:78,deployability,integr,integration,78,"OK, merging this and backporting once confirmed that it works with the DD4hep integration",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:78,integrability,integr,integration,78,"OK, merging this and backporting once confirmed that it works with the DD4hep integration",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:78,interoperability,integr,integration,78,"OK, merging this and backporting once confirmed that it works with the DD4hep integration",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:78,modifiability,integr,integration,78,"OK, merging this and backporting once confirmed that it works with the DD4hep integration",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:78,reliability,integr,integration,78,"OK, merging this and backporting once confirmed that it works with the DD4hep integration",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:78,security,integr,integration,78,"OK, merging this and backporting once confirmed that it works with the DD4hep integration",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:78,testability,integr,integration,78,"OK, merging this and backporting once confirmed that it works with the DD4hep integration",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:38,usability,confirm,confirmed,38,"OK, merging this and backporting once confirmed that it works with the DD4hep integration",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:188,safety,test,tested,188,"@bencouturier I've ported this fix to 6.24 (see PR #11303) and noticed other changes not yet backported, so I've put in sync the TGeoMaterial.cxx file from the master to this branch. I've tested it locally and it seems to work properly.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:188,testability,test,tested,188,"@bencouturier I've ported this fix to 6.24 (see PR #11303) and noticed other changes not yet backported, so I've put in sync the TGeoMaterial.cxx file from the master to this branch. I've tested it locally and it seems to work properly.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:52,availability,slo,slot,52,"Hi Andrei, we will check the changes in the nightly slot being prepared by Andre. We will get back to you once that is done.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:52,reliability,slo,slot,52,"Hi Andrei, we will check the changes in the nightly slot being prepared by Andre. We will get back to you once that is done.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:341,energy efficiency,current,currently,341,"> > @bencouturier I have merged material changes in 6.24. Please let me know if your checks pass and if you need the fix in v6.26 as well. > . > Hi @agheata , it would be great if we could get this fix also for 6.26. OK, so I assume it's OK in 6.24 then, @Axel-Naumann asked me if he can tag. I'll be able to port it to v6.26 next week, I'm currently traveling.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:30,safety,test,test,30,@agheata we have been able to test the path in 6.24 and everything seemed fine indeed.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/issues/11272:30,testability,test,test,30,@agheata we have been able to test the path in 6.24 and everything seemed fine indeed.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11272
https://github.com/root-project/root/pull/11273:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11273
https://github.com/root-project/root/pull/11273:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11273
https://github.com/root-project/root/pull/11273:44,deployability,fail,fail,44,"@alja Something wrong with the PR - Jenkins fail to build it. May be ""-"" sign in branch name is a problem. Can you recreate PR with other branch name without ""-"" signs?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11273
https://github.com/root-project/root/pull/11273:52,deployability,build,build,52,"@alja Something wrong with the PR - Jenkins fail to build it. May be ""-"" sign in branch name is a problem. Can you recreate PR with other branch name without ""-"" signs?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11273
https://github.com/root-project/root/pull/11273:44,reliability,fail,fail,44,"@alja Something wrong with the PR - Jenkins fail to build it. May be ""-"" sign in branch name is a problem. Can you recreate PR with other branch name without ""-"" signs?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11273
https://github.com/root-project/root/pull/11273:73,security,sign,sign,73,"@alja Something wrong with the PR - Jenkins fail to build it. May be ""-"" sign in branch name is a problem. Can you recreate PR with other branch name without ""-"" signs?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11273
https://github.com/root-project/root/pull/11273:162,security,sign,signs,162,"@alja Something wrong with the PR - Jenkins fail to build it. May be ""-"" sign in branch name is a problem. Can you recreate PR with other branch name without ""-"" signs?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11273
https://github.com/root-project/root/pull/11273:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11273
https://github.com/root-project/root/pull/11273:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11273
https://github.com/root-project/root/pull/11273:38,deployability,build,build,38,Multiple infra issues here:. - the PR build didn't start by itself because @alja wasn't part of ROOT-project in GitHub; invite is pending. - we seem to have an issue picking up the PR branches on root.cern; I'm looking into this.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11273
https://github.com/root-project/root/pull/11273:10,integrability,sub,submit,10,I already submit new one - #11277. I will merge it soon,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11273
https://github.com/root-project/root/pull/11274:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:829,availability,state,states,829,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:731,deployability,build,building,731,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:873,deployability,depend,depending,873,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:959,deployability,depend,depends,959,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:1276,deployability,depend,dependency,1276,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:265,energy efficiency,Current,Currently,265,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:781,energy efficiency,core,core,781,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:1217,energy efficiency,current,currently,1217,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:347,integrability,buffer,buffer,347,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:769,integrability,wrap,wrapper,769,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:829,integrability,state,states,829,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:873,integrability,depend,depending,873,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:959,integrability,depend,depends,959,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:1206,integrability,compon,components,1206,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:1276,integrability,depend,dependency,1276,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:1392,integrability,wrap,wrapper,1392,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:769,interoperability,wrapper,wrapper,769,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:1206,interoperability,compon,components,1206,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:1392,interoperability,wrapper,wrapper,1392,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:873,modifiability,depend,depending,873,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:959,modifiability,depend,depends,959,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:1206,modifiability,compon,components,1206,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:1276,modifiability,depend,dependency,1276,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:1294,modifiability,refact,refactor,1294,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:1294,performance,refactor,refactor,1294,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:319,reliability,doe,does,319,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:435,reliability,doe,does,435,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:489,reliability,doe,does,489,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:550,reliability,doe,does,550,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:212,safety,compl,completion,212,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:253,safety,compl,completion,253,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:293,safety,compl,completion,293,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:328,safety,compl,complete,328,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:341,safety,input,input,341,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:396,safety,compl,completion,396,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:424,safety,compl,completion,424,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:505,safety,compl,complete,505,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:867,safety,avoid,avoid,867,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:873,safety,depend,depending,873,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:959,safety,depend,depends,959,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:1121,safety,compl,completion,1121,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:1276,safety,depend,dependency,1276,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:142,security,access,access,142,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:212,security,compl,completion,212,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:253,security,compl,completion,253,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:293,security,compl,completion,293,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:328,security,compl,complete,328,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:396,security,compl,completion,396,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:424,security,compl,completion,424,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:505,security,compl,complete,505,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:1121,security,compl,completion,1121,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:873,testability,depend,depending,873,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:959,testability,depend,depends,959,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:1276,testability,depend,dependency,1276,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:223,usability,support,support,223,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:341,usability,input,input,341,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:362,usability,user,user,362,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:459,usability,command,command,459,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:1081,usability,prototyp,prototype,1081,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:1132,usability,support,support,1132,"Removed the false comment and moved the `unique_ptr` declaration above `TextInputHolder`, in case `TextInputHolder::~TextInputHolder()` still access it (in the future). However, I am thinking about enhancing CLI completion support of cling. Such as tab completion. Currently cling only prints completion suggestion but does not complete the input buffer for the user when only single unambiguous completion exists. Also the completion does not recognize meta command like `.x`, `.L` so it does not try to complete its arguments (paths). And the path does not expand `~` to home dir. @Axel-Naumann , do you think it is a good idea for cling to adopt `llvm::LineEditor` ? (https://llvm.org/doxygen/classllvm_1_1LineEditor.html) . Or building cling's own readline/libedit wrapper? . `core/textinput/src/textinput/doc/textinput.txt` states that `textinput` is created to avoid depending on readline/libedit in year 2011. Is it still true today 2022? cling highly depends on llvm now so it should be fine to adopt `llvm::LineEditor` (created in 2013. `textinput` predates it). I have a prototype cling with the above enhanced completion support based on libedit but I will only create PR if cling (and all root components currently using `textinput` ) are open to such changes and dependency. I can refactor to use `llvm::LineEditor` instead. It is not too hard since the latter is also a libedit wrapper.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:35,usability,help,help,35,"@Axel-Naumann , @guitargeek Please help approve the github workflow.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:59,usability,workflow,workflow,59,"@Axel-Naumann , @guitargeek Please help approve the github workflow.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:57,availability,slo,slow,57,"Thanks for the PR, @jiangyilism - apologies for being so slow! I'd be very curious to see llvm's libedit work with ROOT and cling. We can certainly use it for cling - that PR would be very welcome!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11274:57,reliability,slo,slow,57,"Thanks for the PR, @jiangyilism - apologies for being so slow! I'd be very curious to see llvm's libedit work with ROOT and cling. We can certainly use it for cling - that PR would be very welcome!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11274
https://github.com/root-project/root/pull/11275:118,security,sign,sign,118,"> But please let the CI finish :-). Why jenkins works here, but not in other PRs like #11273 and #11270? . May be ""-"" sign in branch names?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11275
https://github.com/root-project/root/issues/11276:304,availability,slo,slower,304,"The performance of `hadd/TFileMerger` for some times of files (eg. with histograms) is proportional to the number of batches of files processed. So reducing it the max number of files could significantly decrease performance. As a compromise, I propose to reduce the max value to 256 (already a factor 4 slower compared to the typical 1024) ? Would that be okay for your situation?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:148,energy efficiency,reduc,reducing,148,"The performance of `hadd/TFileMerger` for some times of files (eg. with histograms) is proportional to the number of batches of files processed. So reducing it the max number of files could significantly decrease performance. As a compromise, I propose to reduce the max value to 256 (already a factor 4 slower compared to the typical 1024) ? Would that be okay for your situation?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:256,energy efficiency,reduc,reduce,256,"The performance of `hadd/TFileMerger` for some times of files (eg. with histograms) is proportional to the number of batches of files processed. So reducing it the max number of files could significantly decrease performance. As a compromise, I propose to reduce the max value to 256 (already a factor 4 slower compared to the typical 1024) ? Would that be okay for your situation?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:117,integrability,batch,batches,117,"The performance of `hadd/TFileMerger` for some times of files (eg. with histograms) is proportional to the number of batches of files processed. So reducing it the max number of files could significantly decrease performance. As a compromise, I propose to reduce the max value to 256 (already a factor 4 slower compared to the typical 1024) ? Would that be okay for your situation?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:4,performance,perform,performance,4,"The performance of `hadd/TFileMerger` for some times of files (eg. with histograms) is proportional to the number of batches of files processed. So reducing it the max number of files could significantly decrease performance. As a compromise, I propose to reduce the max value to 256 (already a factor 4 slower compared to the typical 1024) ? Would that be okay for your situation?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:47,performance,time,times,47,"The performance of `hadd/TFileMerger` for some times of files (eg. with histograms) is proportional to the number of batches of files processed. So reducing it the max number of files could significantly decrease performance. As a compromise, I propose to reduce the max value to 256 (already a factor 4 slower compared to the typical 1024) ? Would that be okay for your situation?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:117,performance,batch,batches,117,"The performance of `hadd/TFileMerger` for some times of files (eg. with histograms) is proportional to the number of batches of files processed. So reducing it the max number of files could significantly decrease performance. As a compromise, I propose to reduce the max value to 256 (already a factor 4 slower compared to the typical 1024) ? Would that be okay for your situation?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:213,performance,perform,performance,213,"The performance of `hadd/TFileMerger` for some times of files (eg. with histograms) is proportional to the number of batches of files processed. So reducing it the max number of files could significantly decrease performance. As a compromise, I propose to reduce the max value to 256 (already a factor 4 slower compared to the typical 1024) ? Would that be okay for your situation?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:304,reliability,slo,slower,304,"The performance of `hadd/TFileMerger` for some times of files (eg. with histograms) is proportional to the number of batches of files processed. So reducing it the max number of files could significantly decrease performance. As a compromise, I propose to reduce the max value to 256 (already a factor 4 slower compared to the typical 1024) ? Would that be okay for your situation?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:190,security,sign,significantly,190,"The performance of `hadd/TFileMerger` for some times of files (eg. with histograms) is proportional to the number of batches of files processed. So reducing it the max number of files could significantly decrease performance. As a compromise, I propose to reduce the max value to 256 (already a factor 4 slower compared to the typical 1024) ? Would that be okay for your situation?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:4,usability,perform,performance,4,"The performance of `hadd/TFileMerger` for some times of files (eg. with histograms) is proportional to the number of batches of files processed. So reducing it the max number of files could significantly decrease performance. As a compromise, I propose to reduce the max value to 256 (already a factor 4 slower compared to the typical 1024) ? Would that be okay for your situation?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:213,usability,perform,performance,213,"The performance of `hadd/TFileMerger` for some times of files (eg. with histograms) is proportional to the number of batches of files processed. So reducing it the max number of files could significantly decrease performance. As a compromise, I propose to reduce the max value to 256 (already a factor 4 slower compared to the typical 1024) ? Would that be okay for your situation?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:155,performance,concurren,concurrent,155,"256 wouldn't have helped in the mentioned GGUS ticket. There was an input set of 133 files, of which more than 24 were on a single pool with a limit of 24 concurrent transfers. Another approach could be to detect this situation in hadd and then suggest the use of `-n`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:68,safety,input,input,68,"256 wouldn't have helped in the mentioned GGUS ticket. There was an input set of 133 files, of which more than 24 were on a single pool with a limit of 24 concurrent transfers. Another approach could be to detect this situation in hadd and then suggest the use of `-n`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:206,safety,detect,detect,206,"256 wouldn't have helped in the mentioned GGUS ticket. There was an input set of 133 files, of which more than 24 were on a single pool with a limit of 24 concurrent transfers. Another approach could be to detect this situation in hadd and then suggest the use of `-n`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:206,security,detect,detect,206,"256 wouldn't have helped in the mentioned GGUS ticket. There was an input set of 133 files, of which more than 24 were on a single pool with a limit of 24 concurrent transfers. Another approach could be to detect this situation in hadd and then suggest the use of `-n`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:18,usability,help,helped,18,"256 wouldn't have helped in the mentioned GGUS ticket. There was an input set of 133 files, of which more than 24 were on a single pool with a limit of 24 concurrent transfers. Another approach could be to detect this situation in hadd and then suggest the use of `-n`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:68,usability,input,input,68,"256 wouldn't have helped in the mentioned GGUS ticket. There was an input set of 133 files, of which more than 24 were on a single pool with a limit of 24 concurrent transfers. Another approach could be to detect this situation in hadd and then suggest the use of `-n`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:131,performance,concurren,concurrent,131,I see. So actually this is a case where the limit is not known to the OS/through-getrlimit. How can we detect locally the limit of concurrent transfers for a given server?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:103,safety,detect,detect,103,I see. So actually this is a case where the limit is not known to the OS/through-getrlimit. How can we detect locally the limit of concurrent transfers for a given server?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:103,security,detect,detect,103,I see. So actually this is a case where the limit is not known to the OS/through-getrlimit. How can we detect locally the limit of concurrent transfers for a given server?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:393,deployability,automat,automatically,393,"We can not access the original ticket. What is the actual hardware that was being accessed? What is mounted as a local -appearing file system or was it being accessed via a remote protocols (i.e the file name were prefixed with root://...). In first approximation, I don't how we could detect your use case? If you were able to set `ulimit` locally to whatever limit fit your need, hadd would automatically adjust.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:180,integrability,protocol,protocols,180,"We can not access the original ticket. What is the actual hardware that was being accessed? What is mounted as a local -appearing file system or was it being accessed via a remote protocols (i.e the file name were prefixed with root://...). In first approximation, I don't how we could detect your use case? If you were able to set `ulimit` locally to whatever limit fit your need, hadd would automatically adjust.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:180,interoperability,protocol,protocols,180,"We can not access the original ticket. What is the actual hardware that was being accessed? What is mounted as a local -appearing file system or was it being accessed via a remote protocols (i.e the file name were prefixed with root://...). In first approximation, I don't how we could detect your use case? If you were able to set `ulimit` locally to whatever limit fit your need, hadd would automatically adjust.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:286,safety,detect,detect,286,"We can not access the original ticket. What is the actual hardware that was being accessed? What is mounted as a local -appearing file system or was it being accessed via a remote protocols (i.e the file name were prefixed with root://...). In first approximation, I don't how we could detect your use case? If you were able to set `ulimit` locally to whatever limit fit your need, hadd would automatically adjust.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:11,security,access,access,11,"We can not access the original ticket. What is the actual hardware that was being accessed? What is mounted as a local -appearing file system or was it being accessed via a remote protocols (i.e the file name were prefixed with root://...). In first approximation, I don't how we could detect your use case? If you were able to set `ulimit` locally to whatever limit fit your need, hadd would automatically adjust.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:82,security,access,accessed,82,"We can not access the original ticket. What is the actual hardware that was being accessed? What is mounted as a local -appearing file system or was it being accessed via a remote protocols (i.e the file name were prefixed with root://...). In first approximation, I don't how we could detect your use case? If you were able to set `ulimit` locally to whatever limit fit your need, hadd would automatically adjust.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:158,security,access,accessed,158,"We can not access the original ticket. What is the actual hardware that was being accessed? What is mounted as a local -appearing file system or was it being accessed via a remote protocols (i.e the file name were prefixed with root://...). In first approximation, I don't how we could detect your use case? If you were able to set `ulimit` locally to whatever limit fit your need, hadd would automatically adjust.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:286,security,detect,detect,286,"We can not access the original ticket. What is the actual hardware that was being accessed? What is mounted as a local -appearing file system or was it being accessed via a remote protocols (i.e the file name were prefixed with root://...). In first approximation, I don't how we could detect your use case? If you were able to set `ulimit` locally to whatever limit fit your need, hadd would automatically adjust.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:393,testability,automat,automatically,393,"We can not access the original ticket. What is the actual hardware that was being accessed? What is mounted as a local -appearing file system or was it being accessed via a remote protocols (i.e the file name were prefixed with root://...). In first approximation, I don't how we could detect your use case? If you were able to set `ulimit` locally to whatever limit fit your need, hadd would automatically adjust.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:1249,availability,avail,available,1249,"Hi @pcanal,. The input is a list of 133 files in the format root://x509up_u<userid>@xrootd.grid.surfsara.nl//pnfs/grid.sara.nl/data/lhcb/LHCb_USER/lhcb/user/v/username/2021_08/520789/520789382/x24mu__wmomsc_a.root. The limit is in the dCache storage system (xrootd.grid.surfsara.nl), not on the client side. This limit is there for a reason: it prevents the storage pools from being overloaded with transfers and crashing. When hadd tries to open all files at once, it tries to read more files concurrently than the limit per dCache storage pool allows. The first files are served, but the rest of the transfers are queued. This means, that they remain open but zero bytes are served, until some of the other transfers finish. But hadd never finishes those because it insists on reading from all files at the same time. So it gets stuck into a deadlock situation. If hadd would detect this situation (I'm getting data for some files but zero bytes for other files), it would make sense to stop reading all files concurrently, but instead continue reading from all files that it can, close those files, and then receive data for the other files. If hadd could do that, such a deadlock would be prevented, while performance would still be the maximum available. Cheers,. Onno",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:1038,deployability,continu,continue,1038,"Hi @pcanal,. The input is a list of 133 files in the format root://x509up_u<userid>@xrootd.grid.surfsara.nl//pnfs/grid.sara.nl/data/lhcb/LHCb_USER/lhcb/user/v/username/2021_08/520789/520789382/x24mu__wmomsc_a.root. The limit is in the dCache storage system (xrootd.grid.surfsara.nl), not on the client side. This limit is there for a reason: it prevents the storage pools from being overloaded with transfers and crashing. When hadd tries to open all files at once, it tries to read more files concurrently than the limit per dCache storage pool allows. The first files are served, but the rest of the transfers are queued. This means, that they remain open but zero bytes are served, until some of the other transfers finish. But hadd never finishes those because it insists on reading from all files at the same time. So it gets stuck into a deadlock situation. If hadd would detect this situation (I'm getting data for some files but zero bytes for other files), it would make sense to stop reading all files concurrently, but instead continue reading from all files that it can, close those files, and then receive data for the other files. If hadd could do that, such a deadlock would be prevented, while performance would still be the maximum available. Cheers,. Onno",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:616,integrability,queue,queued,616,"Hi @pcanal,. The input is a list of 133 files in the format root://x509up_u<userid>@xrootd.grid.surfsara.nl//pnfs/grid.sara.nl/data/lhcb/LHCb_USER/lhcb/user/v/username/2021_08/520789/520789382/x24mu__wmomsc_a.root. The limit is in the dCache storage system (xrootd.grid.surfsara.nl), not on the client side. This limit is there for a reason: it prevents the storage pools from being overloaded with transfers and crashing. When hadd tries to open all files at once, it tries to read more files concurrently than the limit per dCache storage pool allows. The first files are served, but the rest of the transfers are queued. This means, that they remain open but zero bytes are served, until some of the other transfers finish. But hadd never finishes those because it insists on reading from all files at the same time. So it gets stuck into a deadlock situation. If hadd would detect this situation (I'm getting data for some files but zero bytes for other files), it would make sense to stop reading all files concurrently, but instead continue reading from all files that it can, close those files, and then receive data for the other files. If hadd could do that, such a deadlock would be prevented, while performance would still be the maximum available. Cheers,. Onno",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:53,interoperability,format,format,53,"Hi @pcanal,. The input is a list of 133 files in the format root://x509up_u<userid>@xrootd.grid.surfsara.nl//pnfs/grid.sara.nl/data/lhcb/LHCb_USER/lhcb/user/v/username/2021_08/520789/520789382/x24mu__wmomsc_a.root. The limit is in the dCache storage system (xrootd.grid.surfsara.nl), not on the client side. This limit is there for a reason: it prevents the storage pools from being overloaded with transfers and crashing. When hadd tries to open all files at once, it tries to read more files concurrently than the limit per dCache storage pool allows. The first files are served, but the rest of the transfers are queued. This means, that they remain open but zero bytes are served, until some of the other transfers finish. But hadd never finishes those because it insists on reading from all files at the same time. So it gets stuck into a deadlock situation. If hadd would detect this situation (I'm getting data for some files but zero bytes for other files), it would make sense to stop reading all files concurrently, but instead continue reading from all files that it can, close those files, and then receive data for the other files. If hadd could do that, such a deadlock would be prevented, while performance would still be the maximum available. Cheers,. Onno",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:494,performance,concurren,concurrently,494,"Hi @pcanal,. The input is a list of 133 files in the format root://x509up_u<userid>@xrootd.grid.surfsara.nl//pnfs/grid.sara.nl/data/lhcb/LHCb_USER/lhcb/user/v/username/2021_08/520789/520789382/x24mu__wmomsc_a.root. The limit is in the dCache storage system (xrootd.grid.surfsara.nl), not on the client side. This limit is there for a reason: it prevents the storage pools from being overloaded with transfers and crashing. When hadd tries to open all files at once, it tries to read more files concurrently than the limit per dCache storage pool allows. The first files are served, but the rest of the transfers are queued. This means, that they remain open but zero bytes are served, until some of the other transfers finish. But hadd never finishes those because it insists on reading from all files at the same time. So it gets stuck into a deadlock situation. If hadd would detect this situation (I'm getting data for some files but zero bytes for other files), it would make sense to stop reading all files concurrently, but instead continue reading from all files that it can, close those files, and then receive data for the other files. If hadd could do that, such a deadlock would be prevented, while performance would still be the maximum available. Cheers,. Onno",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:616,performance,queue,queued,616,"Hi @pcanal,. The input is a list of 133 files in the format root://x509up_u<userid>@xrootd.grid.surfsara.nl//pnfs/grid.sara.nl/data/lhcb/LHCb_USER/lhcb/user/v/username/2021_08/520789/520789382/x24mu__wmomsc_a.root. The limit is in the dCache storage system (xrootd.grid.surfsara.nl), not on the client side. This limit is there for a reason: it prevents the storage pools from being overloaded with transfers and crashing. When hadd tries to open all files at once, it tries to read more files concurrently than the limit per dCache storage pool allows. The first files are served, but the rest of the transfers are queued. This means, that they remain open but zero bytes are served, until some of the other transfers finish. But hadd never finishes those because it insists on reading from all files at the same time. So it gets stuck into a deadlock situation. If hadd would detect this situation (I'm getting data for some files but zero bytes for other files), it would make sense to stop reading all files concurrently, but instead continue reading from all files that it can, close those files, and then receive data for the other files. If hadd could do that, such a deadlock would be prevented, while performance would still be the maximum available. Cheers,. Onno",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:814,performance,time,time,814,"Hi @pcanal,. The input is a list of 133 files in the format root://x509up_u<userid>@xrootd.grid.surfsara.nl//pnfs/grid.sara.nl/data/lhcb/LHCb_USER/lhcb/user/v/username/2021_08/520789/520789382/x24mu__wmomsc_a.root. The limit is in the dCache storage system (xrootd.grid.surfsara.nl), not on the client side. This limit is there for a reason: it prevents the storage pools from being overloaded with transfers and crashing. When hadd tries to open all files at once, it tries to read more files concurrently than the limit per dCache storage pool allows. The first files are served, but the rest of the transfers are queued. This means, that they remain open but zero bytes are served, until some of the other transfers finish. But hadd never finishes those because it insists on reading from all files at the same time. So it gets stuck into a deadlock situation. If hadd would detect this situation (I'm getting data for some files but zero bytes for other files), it would make sense to stop reading all files concurrently, but instead continue reading from all files that it can, close those files, and then receive data for the other files. If hadd could do that, such a deadlock would be prevented, while performance would still be the maximum available. Cheers,. Onno",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:844,performance,deadlock,deadlock,844,"Hi @pcanal,. The input is a list of 133 files in the format root://x509up_u<userid>@xrootd.grid.surfsara.nl//pnfs/grid.sara.nl/data/lhcb/LHCb_USER/lhcb/user/v/username/2021_08/520789/520789382/x24mu__wmomsc_a.root. The limit is in the dCache storage system (xrootd.grid.surfsara.nl), not on the client side. This limit is there for a reason: it prevents the storage pools from being overloaded with transfers and crashing. When hadd tries to open all files at once, it tries to read more files concurrently than the limit per dCache storage pool allows. The first files are served, but the rest of the transfers are queued. This means, that they remain open but zero bytes are served, until some of the other transfers finish. But hadd never finishes those because it insists on reading from all files at the same time. So it gets stuck into a deadlock situation. If hadd would detect this situation (I'm getting data for some files but zero bytes for other files), it would make sense to stop reading all files concurrently, but instead continue reading from all files that it can, close those files, and then receive data for the other files. If hadd could do that, such a deadlock would be prevented, while performance would still be the maximum available. Cheers,. Onno",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:1012,performance,concurren,concurrently,1012,"Hi @pcanal,. The input is a list of 133 files in the format root://x509up_u<userid>@xrootd.grid.surfsara.nl//pnfs/grid.sara.nl/data/lhcb/LHCb_USER/lhcb/user/v/username/2021_08/520789/520789382/x24mu__wmomsc_a.root. The limit is in the dCache storage system (xrootd.grid.surfsara.nl), not on the client side. This limit is there for a reason: it prevents the storage pools from being overloaded with transfers and crashing. When hadd tries to open all files at once, it tries to read more files concurrently than the limit per dCache storage pool allows. The first files are served, but the rest of the transfers are queued. This means, that they remain open but zero bytes are served, until some of the other transfers finish. But hadd never finishes those because it insists on reading from all files at the same time. So it gets stuck into a deadlock situation. If hadd would detect this situation (I'm getting data for some files but zero bytes for other files), it would make sense to stop reading all files concurrently, but instead continue reading from all files that it can, close those files, and then receive data for the other files. If hadd could do that, such a deadlock would be prevented, while performance would still be the maximum available. Cheers,. Onno",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:1175,performance,deadlock,deadlock,1175,"Hi @pcanal,. The input is a list of 133 files in the format root://x509up_u<userid>@xrootd.grid.surfsara.nl//pnfs/grid.sara.nl/data/lhcb/LHCb_USER/lhcb/user/v/username/2021_08/520789/520789382/x24mu__wmomsc_a.root. The limit is in the dCache storage system (xrootd.grid.surfsara.nl), not on the client side. This limit is there for a reason: it prevents the storage pools from being overloaded with transfers and crashing. When hadd tries to open all files at once, it tries to read more files concurrently than the limit per dCache storage pool allows. The first files are served, but the rest of the transfers are queued. This means, that they remain open but zero bytes are served, until some of the other transfers finish. But hadd never finishes those because it insists on reading from all files at the same time. So it gets stuck into a deadlock situation. If hadd would detect this situation (I'm getting data for some files but zero bytes for other files), it would make sense to stop reading all files concurrently, but instead continue reading from all files that it can, close those files, and then receive data for the other files. If hadd could do that, such a deadlock would be prevented, while performance would still be the maximum available. Cheers,. Onno",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:1210,performance,perform,performance,1210,"Hi @pcanal,. The input is a list of 133 files in the format root://x509up_u<userid>@xrootd.grid.surfsara.nl//pnfs/grid.sara.nl/data/lhcb/LHCb_USER/lhcb/user/v/username/2021_08/520789/520789382/x24mu__wmomsc_a.root. The limit is in the dCache storage system (xrootd.grid.surfsara.nl), not on the client side. This limit is there for a reason: it prevents the storage pools from being overloaded with transfers and crashing. When hadd tries to open all files at once, it tries to read more files concurrently than the limit per dCache storage pool allows. The first files are served, but the rest of the transfers are queued. This means, that they remain open but zero bytes are served, until some of the other transfers finish. But hadd never finishes those because it insists on reading from all files at the same time. So it gets stuck into a deadlock situation. If hadd would detect this situation (I'm getting data for some files but zero bytes for other files), it would make sense to stop reading all files concurrently, but instead continue reading from all files that it can, close those files, and then receive data for the other files. If hadd could do that, such a deadlock would be prevented, while performance would still be the maximum available. Cheers,. Onno",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:1249,reliability,availab,available,1249,"Hi @pcanal,. The input is a list of 133 files in the format root://x509up_u<userid>@xrootd.grid.surfsara.nl//pnfs/grid.sara.nl/data/lhcb/LHCb_USER/lhcb/user/v/username/2021_08/520789/520789382/x24mu__wmomsc_a.root. The limit is in the dCache storage system (xrootd.grid.surfsara.nl), not on the client side. This limit is there for a reason: it prevents the storage pools from being overloaded with transfers and crashing. When hadd tries to open all files at once, it tries to read more files concurrently than the limit per dCache storage pool allows. The first files are served, but the rest of the transfers are queued. This means, that they remain open but zero bytes are served, until some of the other transfers finish. But hadd never finishes those because it insists on reading from all files at the same time. So it gets stuck into a deadlock situation. If hadd would detect this situation (I'm getting data for some files but zero bytes for other files), it would make sense to stop reading all files concurrently, but instead continue reading from all files that it can, close those files, and then receive data for the other files. If hadd could do that, such a deadlock would be prevented, while performance would still be the maximum available. Cheers,. Onno",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:17,safety,input,input,17,"Hi @pcanal,. The input is a list of 133 files in the format root://x509up_u<userid>@xrootd.grid.surfsara.nl//pnfs/grid.sara.nl/data/lhcb/LHCb_USER/lhcb/user/v/username/2021_08/520789/520789382/x24mu__wmomsc_a.root. The limit is in the dCache storage system (xrootd.grid.surfsara.nl), not on the client side. This limit is there for a reason: it prevents the storage pools from being overloaded with transfers and crashing. When hadd tries to open all files at once, it tries to read more files concurrently than the limit per dCache storage pool allows. The first files are served, but the rest of the transfers are queued. This means, that they remain open but zero bytes are served, until some of the other transfers finish. But hadd never finishes those because it insists on reading from all files at the same time. So it gets stuck into a deadlock situation. If hadd would detect this situation (I'm getting data for some files but zero bytes for other files), it would make sense to stop reading all files concurrently, but instead continue reading from all files that it can, close those files, and then receive data for the other files. If hadd could do that, such a deadlock would be prevented, while performance would still be the maximum available. Cheers,. Onno",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:345,safety,prevent,prevents,345,"Hi @pcanal,. The input is a list of 133 files in the format root://x509up_u<userid>@xrootd.grid.surfsara.nl//pnfs/grid.sara.nl/data/lhcb/LHCb_USER/lhcb/user/v/username/2021_08/520789/520789382/x24mu__wmomsc_a.root. The limit is in the dCache storage system (xrootd.grid.surfsara.nl), not on the client side. This limit is there for a reason: it prevents the storage pools from being overloaded with transfers and crashing. When hadd tries to open all files at once, it tries to read more files concurrently than the limit per dCache storage pool allows. The first files are served, but the rest of the transfers are queued. This means, that they remain open but zero bytes are served, until some of the other transfers finish. But hadd never finishes those because it insists on reading from all files at the same time. So it gets stuck into a deadlock situation. If hadd would detect this situation (I'm getting data for some files but zero bytes for other files), it would make sense to stop reading all files concurrently, but instead continue reading from all files that it can, close those files, and then receive data for the other files. If hadd could do that, such a deadlock would be prevented, while performance would still be the maximum available. Cheers,. Onno",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:878,safety,detect,detect,878,"Hi @pcanal,. The input is a list of 133 files in the format root://x509up_u<userid>@xrootd.grid.surfsara.nl//pnfs/grid.sara.nl/data/lhcb/LHCb_USER/lhcb/user/v/username/2021_08/520789/520789382/x24mu__wmomsc_a.root. The limit is in the dCache storage system (xrootd.grid.surfsara.nl), not on the client side. This limit is there for a reason: it prevents the storage pools from being overloaded with transfers and crashing. When hadd tries to open all files at once, it tries to read more files concurrently than the limit per dCache storage pool allows. The first files are served, but the rest of the transfers are queued. This means, that they remain open but zero bytes are served, until some of the other transfers finish. But hadd never finishes those because it insists on reading from all files at the same time. So it gets stuck into a deadlock situation. If hadd would detect this situation (I'm getting data for some files but zero bytes for other files), it would make sense to stop reading all files concurrently, but instead continue reading from all files that it can, close those files, and then receive data for the other files. If hadd could do that, such a deadlock would be prevented, while performance would still be the maximum available. Cheers,. Onno",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:1193,safety,prevent,prevented,1193,"Hi @pcanal,. The input is a list of 133 files in the format root://x509up_u<userid>@xrootd.grid.surfsara.nl//pnfs/grid.sara.nl/data/lhcb/LHCb_USER/lhcb/user/v/username/2021_08/520789/520789382/x24mu__wmomsc_a.root. The limit is in the dCache storage system (xrootd.grid.surfsara.nl), not on the client side. This limit is there for a reason: it prevents the storage pools from being overloaded with transfers and crashing. When hadd tries to open all files at once, it tries to read more files concurrently than the limit per dCache storage pool allows. The first files are served, but the rest of the transfers are queued. This means, that they remain open but zero bytes are served, until some of the other transfers finish. But hadd never finishes those because it insists on reading from all files at the same time. So it gets stuck into a deadlock situation. If hadd would detect this situation (I'm getting data for some files but zero bytes for other files), it would make sense to stop reading all files concurrently, but instead continue reading from all files that it can, close those files, and then receive data for the other files. If hadd could do that, such a deadlock would be prevented, while performance would still be the maximum available. Cheers,. Onno",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:1249,safety,avail,available,1249,"Hi @pcanal,. The input is a list of 133 files in the format root://x509up_u<userid>@xrootd.grid.surfsara.nl//pnfs/grid.sara.nl/data/lhcb/LHCb_USER/lhcb/user/v/username/2021_08/520789/520789382/x24mu__wmomsc_a.root. The limit is in the dCache storage system (xrootd.grid.surfsara.nl), not on the client side. This limit is there for a reason: it prevents the storage pools from being overloaded with transfers and crashing. When hadd tries to open all files at once, it tries to read more files concurrently than the limit per dCache storage pool allows. The first files are served, but the rest of the transfers are queued. This means, that they remain open but zero bytes are served, until some of the other transfers finish. But hadd never finishes those because it insists on reading from all files at the same time. So it gets stuck into a deadlock situation. If hadd would detect this situation (I'm getting data for some files but zero bytes for other files), it would make sense to stop reading all files concurrently, but instead continue reading from all files that it can, close those files, and then receive data for the other files. If hadd could do that, such a deadlock would be prevented, while performance would still be the maximum available. Cheers,. Onno",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:345,security,preven,prevents,345,"Hi @pcanal,. The input is a list of 133 files in the format root://x509up_u<userid>@xrootd.grid.surfsara.nl//pnfs/grid.sara.nl/data/lhcb/LHCb_USER/lhcb/user/v/username/2021_08/520789/520789382/x24mu__wmomsc_a.root. The limit is in the dCache storage system (xrootd.grid.surfsara.nl), not on the client side. This limit is there for a reason: it prevents the storage pools from being overloaded with transfers and crashing. When hadd tries to open all files at once, it tries to read more files concurrently than the limit per dCache storage pool allows. The first files are served, but the rest of the transfers are queued. This means, that they remain open but zero bytes are served, until some of the other transfers finish. But hadd never finishes those because it insists on reading from all files at the same time. So it gets stuck into a deadlock situation. If hadd would detect this situation (I'm getting data for some files but zero bytes for other files), it would make sense to stop reading all files concurrently, but instead continue reading from all files that it can, close those files, and then receive data for the other files. If hadd could do that, such a deadlock would be prevented, while performance would still be the maximum available. Cheers,. Onno",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:878,security,detect,detect,878,"Hi @pcanal,. The input is a list of 133 files in the format root://x509up_u<userid>@xrootd.grid.surfsara.nl//pnfs/grid.sara.nl/data/lhcb/LHCb_USER/lhcb/user/v/username/2021_08/520789/520789382/x24mu__wmomsc_a.root. The limit is in the dCache storage system (xrootd.grid.surfsara.nl), not on the client side. This limit is there for a reason: it prevents the storage pools from being overloaded with transfers and crashing. When hadd tries to open all files at once, it tries to read more files concurrently than the limit per dCache storage pool allows. The first files are served, but the rest of the transfers are queued. This means, that they remain open but zero bytes are served, until some of the other transfers finish. But hadd never finishes those because it insists on reading from all files at the same time. So it gets stuck into a deadlock situation. If hadd would detect this situation (I'm getting data for some files but zero bytes for other files), it would make sense to stop reading all files concurrently, but instead continue reading from all files that it can, close those files, and then receive data for the other files. If hadd could do that, such a deadlock would be prevented, while performance would still be the maximum available. Cheers,. Onno",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:1193,security,preven,prevented,1193,"Hi @pcanal,. The input is a list of 133 files in the format root://x509up_u<userid>@xrootd.grid.surfsara.nl//pnfs/grid.sara.nl/data/lhcb/LHCb_USER/lhcb/user/v/username/2021_08/520789/520789382/x24mu__wmomsc_a.root. The limit is in the dCache storage system (xrootd.grid.surfsara.nl), not on the client side. This limit is there for a reason: it prevents the storage pools from being overloaded with transfers and crashing. When hadd tries to open all files at once, it tries to read more files concurrently than the limit per dCache storage pool allows. The first files are served, but the rest of the transfers are queued. This means, that they remain open but zero bytes are served, until some of the other transfers finish. But hadd never finishes those because it insists on reading from all files at the same time. So it gets stuck into a deadlock situation. If hadd would detect this situation (I'm getting data for some files but zero bytes for other files), it would make sense to stop reading all files concurrently, but instead continue reading from all files that it can, close those files, and then receive data for the other files. If hadd could do that, such a deadlock would be prevented, while performance would still be the maximum available. Cheers,. Onno",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:1249,security,availab,available,1249,"Hi @pcanal,. The input is a list of 133 files in the format root://x509up_u<userid>@xrootd.grid.surfsara.nl//pnfs/grid.sara.nl/data/lhcb/LHCb_USER/lhcb/user/v/username/2021_08/520789/520789382/x24mu__wmomsc_a.root. The limit is in the dCache storage system (xrootd.grid.surfsara.nl), not on the client side. This limit is there for a reason: it prevents the storage pools from being overloaded with transfers and crashing. When hadd tries to open all files at once, it tries to read more files concurrently than the limit per dCache storage pool allows. The first files are served, but the rest of the transfers are queued. This means, that they remain open but zero bytes are served, until some of the other transfers finish. But hadd never finishes those because it insists on reading from all files at the same time. So it gets stuck into a deadlock situation. If hadd would detect this situation (I'm getting data for some files but zero bytes for other files), it would make sense to stop reading all files concurrently, but instead continue reading from all files that it can, close those files, and then receive data for the other files. If hadd could do that, such a deadlock would be prevented, while performance would still be the maximum available. Cheers,. Onno",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:17,usability,input,input,17,"Hi @pcanal,. The input is a list of 133 files in the format root://x509up_u<userid>@xrootd.grid.surfsara.nl//pnfs/grid.sara.nl/data/lhcb/LHCb_USER/lhcb/user/v/username/2021_08/520789/520789382/x24mu__wmomsc_a.root. The limit is in the dCache storage system (xrootd.grid.surfsara.nl), not on the client side. This limit is there for a reason: it prevents the storage pools from being overloaded with transfers and crashing. When hadd tries to open all files at once, it tries to read more files concurrently than the limit per dCache storage pool allows. The first files are served, but the rest of the transfers are queued. This means, that they remain open but zero bytes are served, until some of the other transfers finish. But hadd never finishes those because it insists on reading from all files at the same time. So it gets stuck into a deadlock situation. If hadd would detect this situation (I'm getting data for some files but zero bytes for other files), it would make sense to stop reading all files concurrently, but instead continue reading from all files that it can, close those files, and then receive data for the other files. If hadd could do that, such a deadlock would be prevented, while performance would still be the maximum available. Cheers,. Onno",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:76,usability,user,userid,76,"Hi @pcanal,. The input is a list of 133 files in the format root://x509up_u<userid>@xrootd.grid.surfsara.nl//pnfs/grid.sara.nl/data/lhcb/LHCb_USER/lhcb/user/v/username/2021_08/520789/520789382/x24mu__wmomsc_a.root. The limit is in the dCache storage system (xrootd.grid.surfsara.nl), not on the client side. This limit is there for a reason: it prevents the storage pools from being overloaded with transfers and crashing. When hadd tries to open all files at once, it tries to read more files concurrently than the limit per dCache storage pool allows. The first files are served, but the rest of the transfers are queued. This means, that they remain open but zero bytes are served, until some of the other transfers finish. But hadd never finishes those because it insists on reading from all files at the same time. So it gets stuck into a deadlock situation. If hadd would detect this situation (I'm getting data for some files but zero bytes for other files), it would make sense to stop reading all files concurrently, but instead continue reading from all files that it can, close those files, and then receive data for the other files. If hadd could do that, such a deadlock would be prevented, while performance would still be the maximum available. Cheers,. Onno",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:152,usability,user,user,152,"Hi @pcanal,. The input is a list of 133 files in the format root://x509up_u<userid>@xrootd.grid.surfsara.nl//pnfs/grid.sara.nl/data/lhcb/LHCb_USER/lhcb/user/v/username/2021_08/520789/520789382/x24mu__wmomsc_a.root. The limit is in the dCache storage system (xrootd.grid.surfsara.nl), not on the client side. This limit is there for a reason: it prevents the storage pools from being overloaded with transfers and crashing. When hadd tries to open all files at once, it tries to read more files concurrently than the limit per dCache storage pool allows. The first files are served, but the rest of the transfers are queued. This means, that they remain open but zero bytes are served, until some of the other transfers finish. But hadd never finishes those because it insists on reading from all files at the same time. So it gets stuck into a deadlock situation. If hadd would detect this situation (I'm getting data for some files but zero bytes for other files), it would make sense to stop reading all files concurrently, but instead continue reading from all files that it can, close those files, and then receive data for the other files. If hadd could do that, such a deadlock would be prevented, while performance would still be the maximum available. Cheers,. Onno",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:159,usability,user,username,159,"Hi @pcanal,. The input is a list of 133 files in the format root://x509up_u<userid>@xrootd.grid.surfsara.nl//pnfs/grid.sara.nl/data/lhcb/LHCb_USER/lhcb/user/v/username/2021_08/520789/520789382/x24mu__wmomsc_a.root. The limit is in the dCache storage system (xrootd.grid.surfsara.nl), not on the client side. This limit is there for a reason: it prevents the storage pools from being overloaded with transfers and crashing. When hadd tries to open all files at once, it tries to read more files concurrently than the limit per dCache storage pool allows. The first files are served, but the rest of the transfers are queued. This means, that they remain open but zero bytes are served, until some of the other transfers finish. But hadd never finishes those because it insists on reading from all files at the same time. So it gets stuck into a deadlock situation. If hadd would detect this situation (I'm getting data for some files but zero bytes for other files), it would make sense to stop reading all files concurrently, but instead continue reading from all files that it can, close those files, and then receive data for the other files. If hadd could do that, such a deadlock would be prevented, while performance would still be the maximum available. Cheers,. Onno",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:989,usability,stop,stop,989,"Hi @pcanal,. The input is a list of 133 files in the format root://x509up_u<userid>@xrootd.grid.surfsara.nl//pnfs/grid.sara.nl/data/lhcb/LHCb_USER/lhcb/user/v/username/2021_08/520789/520789382/x24mu__wmomsc_a.root. The limit is in the dCache storage system (xrootd.grid.surfsara.nl), not on the client side. This limit is there for a reason: it prevents the storage pools from being overloaded with transfers and crashing. When hadd tries to open all files at once, it tries to read more files concurrently than the limit per dCache storage pool allows. The first files are served, but the rest of the transfers are queued. This means, that they remain open but zero bytes are served, until some of the other transfers finish. But hadd never finishes those because it insists on reading from all files at the same time. So it gets stuck into a deadlock situation. If hadd would detect this situation (I'm getting data for some files but zero bytes for other files), it would make sense to stop reading all files concurrently, but instead continue reading from all files that it can, close those files, and then receive data for the other files. If hadd could do that, such a deadlock would be prevented, while performance would still be the maximum available. Cheers,. Onno",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:1083,usability,close,close,1083,"Hi @pcanal,. The input is a list of 133 files in the format root://x509up_u<userid>@xrootd.grid.surfsara.nl//pnfs/grid.sara.nl/data/lhcb/LHCb_USER/lhcb/user/v/username/2021_08/520789/520789382/x24mu__wmomsc_a.root. The limit is in the dCache storage system (xrootd.grid.surfsara.nl), not on the client side. This limit is there for a reason: it prevents the storage pools from being overloaded with transfers and crashing. When hadd tries to open all files at once, it tries to read more files concurrently than the limit per dCache storage pool allows. The first files are served, but the rest of the transfers are queued. This means, that they remain open but zero bytes are served, until some of the other transfers finish. But hadd never finishes those because it insists on reading from all files at the same time. So it gets stuck into a deadlock situation. If hadd would detect this situation (I'm getting data for some files but zero bytes for other files), it would make sense to stop reading all files concurrently, but instead continue reading from all files that it can, close those files, and then receive data for the other files. If hadd could do that, such a deadlock would be prevented, while performance would still be the maximum available. Cheers,. Onno",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:1210,usability,perform,performance,1210,"Hi @pcanal,. The input is a list of 133 files in the format root://x509up_u<userid>@xrootd.grid.surfsara.nl//pnfs/grid.sara.nl/data/lhcb/LHCb_USER/lhcb/user/v/username/2021_08/520789/520789382/x24mu__wmomsc_a.root. The limit is in the dCache storage system (xrootd.grid.surfsara.nl), not on the client side. This limit is there for a reason: it prevents the storage pools from being overloaded with transfers and crashing. When hadd tries to open all files at once, it tries to read more files concurrently than the limit per dCache storage pool allows. The first files are served, but the rest of the transfers are queued. This means, that they remain open but zero bytes are served, until some of the other transfers finish. But hadd never finishes those because it insists on reading from all files at the same time. So it gets stuck into a deadlock situation. If hadd would detect this situation (I'm getting data for some files but zero bytes for other files), it would make sense to stop reading all files concurrently, but instead continue reading from all files that it can, close those files, and then receive data for the other files. If hadd could do that, such a deadlock would be prevented, while performance would still be the maximum available. Cheers,. Onno",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:442,deployability,updat,update,442,"> This means, that they remain open but zero bytes are served,. > (I'm getting data for some files but zero bytes for other files). Do you know if the xrootd routine just ""hang"" in that case or return with request to retry later? If they just hang there is not much I can see doing to detect the case unless there is an xrootd routine that detect/support this case that we could replace the current call with. (and we would need some help to update the xrootd plugin in ROOT to support and test this).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:391,energy efficiency,current,current,391,"> This means, that they remain open but zero bytes are served,. > (I'm getting data for some files but zero bytes for other files). Do you know if the xrootd routine just ""hang"" in that case or return with request to retry later? If they just hang there is not much I can see doing to detect the case unless there is an xrootd routine that detect/support this case that we could replace the current call with. (and we would need some help to update the xrootd plugin in ROOT to support and test this).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:158,integrability,rout,routine,158,"> This means, that they remain open but zero bytes are served,. > (I'm getting data for some files but zero bytes for other files). Do you know if the xrootd routine just ""hang"" in that case or return with request to retry later? If they just hang there is not much I can see doing to detect the case unless there is an xrootd routine that detect/support this case that we could replace the current call with. (and we would need some help to update the xrootd plugin in ROOT to support and test this).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:327,integrability,rout,routine,327,"> This means, that they remain open but zero bytes are served,. > (I'm getting data for some files but zero bytes for other files). Do you know if the xrootd routine just ""hang"" in that case or return with request to retry later? If they just hang there is not much I can see doing to detect the case unless there is an xrootd routine that detect/support this case that we could replace the current call with. (and we would need some help to update the xrootd plugin in ROOT to support and test this).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:460,interoperability,plug,plugin,460,"> This means, that they remain open but zero bytes are served,. > (I'm getting data for some files but zero bytes for other files). Do you know if the xrootd routine just ""hang"" in that case or return with request to retry later? If they just hang there is not much I can see doing to detect the case unless there is an xrootd routine that detect/support this case that we could replace the current call with. (and we would need some help to update the xrootd plugin in ROOT to support and test this).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:285,safety,detect,detect,285,"> This means, that they remain open but zero bytes are served,. > (I'm getting data for some files but zero bytes for other files). Do you know if the xrootd routine just ""hang"" in that case or return with request to retry later? If they just hang there is not much I can see doing to detect the case unless there is an xrootd routine that detect/support this case that we could replace the current call with. (and we would need some help to update the xrootd plugin in ROOT to support and test this).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:340,safety,detect,detect,340,"> This means, that they remain open but zero bytes are served,. > (I'm getting data for some files but zero bytes for other files). Do you know if the xrootd routine just ""hang"" in that case or return with request to retry later? If they just hang there is not much I can see doing to detect the case unless there is an xrootd routine that detect/support this case that we could replace the current call with. (and we would need some help to update the xrootd plugin in ROOT to support and test this).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:442,safety,updat,update,442,"> This means, that they remain open but zero bytes are served,. > (I'm getting data for some files but zero bytes for other files). Do you know if the xrootd routine just ""hang"" in that case or return with request to retry later? If they just hang there is not much I can see doing to detect the case unless there is an xrootd routine that detect/support this case that we could replace the current call with. (and we would need some help to update the xrootd plugin in ROOT to support and test this).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:490,safety,test,test,490,"> This means, that they remain open but zero bytes are served,. > (I'm getting data for some files but zero bytes for other files). Do you know if the xrootd routine just ""hang"" in that case or return with request to retry later? If they just hang there is not much I can see doing to detect the case unless there is an xrootd routine that detect/support this case that we could replace the current call with. (and we would need some help to update the xrootd plugin in ROOT to support and test this).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:285,security,detect,detect,285,"> This means, that they remain open but zero bytes are served,. > (I'm getting data for some files but zero bytes for other files). Do you know if the xrootd routine just ""hang"" in that case or return with request to retry later? If they just hang there is not much I can see doing to detect the case unless there is an xrootd routine that detect/support this case that we could replace the current call with. (and we would need some help to update the xrootd plugin in ROOT to support and test this).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:340,security,detect,detect,340,"> This means, that they remain open but zero bytes are served,. > (I'm getting data for some files but zero bytes for other files). Do you know if the xrootd routine just ""hang"" in that case or return with request to retry later? If they just hang there is not much I can see doing to detect the case unless there is an xrootd routine that detect/support this case that we could replace the current call with. (and we would need some help to update the xrootd plugin in ROOT to support and test this).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:442,security,updat,update,442,"> This means, that they remain open but zero bytes are served,. > (I'm getting data for some files but zero bytes for other files). Do you know if the xrootd routine just ""hang"" in that case or return with request to retry later? If they just hang there is not much I can see doing to detect the case unless there is an xrootd routine that detect/support this case that we could replace the current call with. (and we would need some help to update the xrootd plugin in ROOT to support and test this).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:490,testability,test,test,490,"> This means, that they remain open but zero bytes are served,. > (I'm getting data for some files but zero bytes for other files). Do you know if the xrootd routine just ""hang"" in that case or return with request to retry later? If they just hang there is not much I can see doing to detect the case unless there is an xrootd routine that detect/support this case that we could replace the current call with. (and we would need some help to update the xrootd plugin in ROOT to support and test this).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:347,usability,support,support,347,"> This means, that they remain open but zero bytes are served,. > (I'm getting data for some files but zero bytes for other files). Do you know if the xrootd routine just ""hang"" in that case or return with request to retry later? If they just hang there is not much I can see doing to detect the case unless there is an xrootd routine that detect/support this case that we could replace the current call with. (and we would need some help to update the xrootd plugin in ROOT to support and test this).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:434,usability,help,help,434,"> This means, that they remain open but zero bytes are served,. > (I'm getting data for some files but zero bytes for other files). Do you know if the xrootd routine just ""hang"" in that case or return with request to retry later? If they just hang there is not much I can see doing to detect the case unless there is an xrootd routine that detect/support this case that we could replace the current call with. (and we would need some help to update the xrootd plugin in ROOT to support and test this).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:478,usability,support,support,478,"> This means, that they remain open but zero bytes are served,. > (I'm getting data for some files but zero bytes for other files). Do you know if the xrootd routine just ""hang"" in that case or return with request to retry later? If they just hang there is not much I can see doing to detect the case unless there is an xrootd routine that detect/support this case that we could replace the current call with. (and we would need some help to update the xrootd plugin in ROOT to support and test this).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:147,deployability,fail,fails,147,"I'm afraid I don't know answer your question. But I understand the difficulty. . There might be a more pragmatic approach: if reading remote files fails, `hadd` could quit with the suggestion to try again with the `-n` parameter. There might be problems to which `-n` is not the solution, but it takes only a minute to try, so why not suggest it.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:219,modifiability,paramet,parameter,219,"I'm afraid I don't know answer your question. But I understand the difficulty. . There might be a more pragmatic approach: if reading remote files fails, `hadd` could quit with the suggestion to try again with the `-n` parameter. There might be problems to which `-n` is not the solution, but it takes only a minute to try, so why not suggest it.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:103,reliability,pra,pragmatic,103,"I'm afraid I don't know answer your question. But I understand the difficulty. . There might be a more pragmatic approach: if reading remote files fails, `hadd` could quit with the suggestion to try again with the `-n` parameter. There might be problems to which `-n` is not the solution, but it takes only a minute to try, so why not suggest it.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:147,reliability,fail,fails,147,"I'm afraid I don't know answer your question. But I understand the difficulty. . There might be a more pragmatic approach: if reading remote files fails, `hadd` could quit with the suggestion to try again with the `-n` parameter. There might be problems to which `-n` is not the solution, but it takes only a minute to try, so why not suggest it.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11276:52,testability,understand,understand,52,"I'm afraid I don't know answer your question. But I understand the difficulty. . There might be a more pragmatic approach: if reading remote files fails, `hadd` could quit with the suggestion to try again with the `-n` parameter. There might be problems to which `-n` is not the solution, but it takes only a minute to try, so why not suggest it.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11276
https://github.com/root-project/root/issues/11280:211,usability,user,user-images,211,"> You said: TGaxis::SetNdivisions is recommended to set the maximum number of digits. > . > It is not SetNdivisions but SetMaxDigits. I mean for an individual TGaxis, as suggested in the docu:. ![image](https://user-images.githubusercontent.com/10653970/187424190-e979eee5-6f1e-431a-9938-f79081d63420.png).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11280
https://github.com/root-project/root/issues/11280:99,reliability,doe,does,99,"Oh, I see ... you are using a function to label the axis... this functionality is very fragile and does not follow the TGaxis setting. It should be used very cautiously. The number of divisions or the max digits do not apply. Do not try these things on such an axis.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11280
https://github.com/root-project/root/issues/11280:6,usability,close,close,6,Can I close this one?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11280
https://github.com/root-project/root/issues/11280:101,reliability,doe,does,101,"> Oh, I see ... you are using a function to label the axis... this functionality is very fragile and does not follow the TGaxis setting. It should be used very cautiously. The number of divisions or the max digits do not apply. Do not try these things on such an axis. Could this 'insider' information could be added in the documentation? Otherwise, it seems like a bug to me... and other users might reach the same problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11280
https://github.com/root-project/root/issues/11280:324,usability,document,documentation,324,"> Oh, I see ... you are using a function to label the axis... this functionality is very fragile and does not follow the TGaxis setting. It should be used very cautiously. The number of divisions or the max digits do not apply. Do not try these things on such an axis. Could this 'insider' information could be added in the documentation? Otherwise, it seems like a bug to me... and other users might reach the same problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11280
https://github.com/root-project/root/issues/11280:389,usability,user,users,389,"> Oh, I see ... you are using a function to label the axis... this functionality is very fragile and does not follow the TGaxis setting. It should be used very cautiously. The number of divisions or the max digits do not apply. Do not try these things on such an axis. Could this 'insider' information could be added in the documentation? Otherwise, it seems like a bug to me... and other users might reach the same problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11280
https://github.com/root-project/root/issues/11280:12,deployability,updat,update,12,"Yes, I will update the doc and then close this report. Thanks.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11280
https://github.com/root-project/root/issues/11280:12,safety,updat,update,12,"Yes, I will update the doc and then close this report. Thanks.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11280
https://github.com/root-project/root/issues/11280:12,security,updat,update,12,"Yes, I will update the doc and then close this report. Thanks.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11280
https://github.com/root-project/root/issues/11280:36,usability,close,close,36,"Yes, I will update the doc and then close this report. Thanks.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11280
https://github.com/root-project/root/issues/11280:4,deployability,updat,updated,4,doc updated. thanks,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11280
https://github.com/root-project/root/issues/11280:4,safety,updat,updated,4,doc updated. thanks,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11280
https://github.com/root-project/root/issues/11280:4,security,updat,updated,4,doc updated. thanks,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11280
https://github.com/root-project/root/pull/11281:0,availability,ping,pinging,0,pinging @couet,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11281
https://github.com/root-project/root/pull/11285:112,integrability,sub,subsystem,112,Hi! > most if not all override should actually be final. Are your referring to `dataframe` here or all the tree subsystem? And would this not break usercode where people are further inheriting from the overriding classes?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11285
https://github.com/root-project/root/pull/11285:182,modifiability,inherit,inheriting,182,Hi! > most if not all override should actually be final. Are your referring to `dataframe` here or all the tree subsystem? And would this not break usercode where people are further inheriting from the overriding classes?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11285
https://github.com/root-project/root/pull/11285:148,usability,user,usercode,148,Hi! > most if not all override should actually be final. Are your referring to `dataframe` here or all the tree subsystem? And would this not break usercode where people are further inheriting from the overriding classes?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11285
https://github.com/root-project/root/pull/11285:0,deployability,Updat,Updated,0,Updated the PR with leaving `lexertk.hpp` alone and also adding missing `overrides` in compiler macros.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11285
https://github.com/root-project/root/pull/11285:0,safety,Updat,Updated,0,Updated the PR with leaving `lexertk.hpp` alone and also adding missing `overrides` in compiler macros.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11285
https://github.com/root-project/root/pull/11285:0,security,Updat,Updated,0,Updated the PR with leaving `lexertk.hpp` alone and also adding missing `overrides` in compiler macros.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11285
https://github.com/root-project/root/pull/11285:55,integrability,sub,subsystem,55,"> Are your referring to dataframe here or all the tree subsystem? dataframe. > would this not break usercode where people are further inheriting from the overriding classes? In RDF, the only public classes that are designed for inheritance are `RActionImpl` and `RDataSource` (they should not be final or have methods marked final, but they do not have a base class either so I don't think this PR touches them). All other classes are in namespace `Detail` or `Internal` and I cannot think of any case where I designed them for multiple levels of inheritance.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11285
https://github.com/root-project/root/pull/11285:191,integrability,pub,public,191,"> Are your referring to dataframe here or all the tree subsystem? dataframe. > would this not break usercode where people are further inheriting from the overriding classes? In RDF, the only public classes that are designed for inheritance are `RActionImpl` and `RDataSource` (they should not be final or have methods marked final, but they do not have a base class either so I don't think this PR touches them). All other classes are in namespace `Detail` or `Internal` and I cannot think of any case where I designed them for multiple levels of inheritance.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11285
https://github.com/root-project/root/pull/11285:134,modifiability,inherit,inheriting,134,"> Are your referring to dataframe here or all the tree subsystem? dataframe. > would this not break usercode where people are further inheriting from the overriding classes? In RDF, the only public classes that are designed for inheritance are `RActionImpl` and `RDataSource` (they should not be final or have methods marked final, but they do not have a base class either so I don't think this PR touches them). All other classes are in namespace `Detail` or `Internal` and I cannot think of any case where I designed them for multiple levels of inheritance.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11285
https://github.com/root-project/root/pull/11285:228,modifiability,inherit,inheritance,228,"> Are your referring to dataframe here or all the tree subsystem? dataframe. > would this not break usercode where people are further inheriting from the overriding classes? In RDF, the only public classes that are designed for inheritance are `RActionImpl` and `RDataSource` (they should not be final or have methods marked final, but they do not have a base class either so I don't think this PR touches them). All other classes are in namespace `Detail` or `Internal` and I cannot think of any case where I designed them for multiple levels of inheritance.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11285
https://github.com/root-project/root/pull/11285:547,modifiability,inherit,inheritance,547,"> Are your referring to dataframe here or all the tree subsystem? dataframe. > would this not break usercode where people are further inheriting from the overriding classes? In RDF, the only public classes that are designed for inheritance are `RActionImpl` and `RDataSource` (they should not be final or have methods marked final, but they do not have a base class either so I don't think this PR touches them). All other classes are in namespace `Detail` or `Internal` and I cannot think of any case where I designed them for multiple levels of inheritance.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11285
https://github.com/root-project/root/pull/11285:100,usability,user,usercode,100,"> Are your referring to dataframe here or all the tree subsystem? dataframe. > would this not break usercode where people are further inheriting from the overriding classes? In RDF, the only public classes that are designed for inheritance are `RActionImpl` and `RDataSource` (they should not be final or have methods marked final, but they do not have a base class either so I don't think this PR touches them). All other classes are in namespace `Detail` or `Internal` and I cannot think of any case where I designed them for multiple levels of inheritance.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11285
https://github.com/root-project/root/pull/11285:154,safety,except,except,154,"Alright, I have reverted the addition of `override` to the destructors in `dataframe` and added `final` where I could. That was indeed almost everywhere, except for `RRange::GetGraph()`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11285
https://github.com/root-project/root/pull/11285:332,availability,redund,redundant,332,"Hi @eguiraud, thanks for the review and the comments! I addressed almost all of them, except for the ones related to the destructors. There are three options we have for the overriding destructors, and there are arguments against all of them:. 1. Add `override` as suggested by `clang-tidy`, which you don't like because it appears redundant. 2. Adding nothing, but then removing the base class would break downsteam inheritance. 3. Adding `virtual`, but this implies that it's the first function in the override chain. Let me know what you want me to do! Personally, I'm for doing what clang-tidy wants :). Clang tidy suggests to add `override` to the constructor if it overrides a base class,",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11285
https://github.com/root-project/root/pull/11285:407,availability,down,downsteam,407,"Hi @eguiraud, thanks for the review and the comments! I addressed almost all of them, except for the ones related to the destructors. There are three options we have for the overriding destructors, and there are arguments against all of them:. 1. Add `override` as suggested by `clang-tidy`, which you don't like because it appears redundant. 2. Adding nothing, but then removing the base class would break downsteam inheritance. 3. Adding `virtual`, but this implies that it's the first function in the override chain. Let me know what you want me to do! Personally, I'm for doing what clang-tidy wants :). Clang tidy suggests to add `override` to the constructor if it overrides a base class,",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11285
https://github.com/root-project/root/pull/11285:332,deployability,redundan,redundant,332,"Hi @eguiraud, thanks for the review and the comments! I addressed almost all of them, except for the ones related to the destructors. There are three options we have for the overriding destructors, and there are arguments against all of them:. 1. Add `override` as suggested by `clang-tidy`, which you don't like because it appears redundant. 2. Adding nothing, but then removing the base class would break downsteam inheritance. 3. Adding `virtual`, but this implies that it's the first function in the override chain. Let me know what you want me to do! Personally, I'm for doing what clang-tidy wants :). Clang tidy suggests to add `override` to the constructor if it overrides a base class,",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11285
https://github.com/root-project/root/pull/11285:417,modifiability,inherit,inheritance,417,"Hi @eguiraud, thanks for the review and the comments! I addressed almost all of them, except for the ones related to the destructors. There are three options we have for the overriding destructors, and there are arguments against all of them:. 1. Add `override` as suggested by `clang-tidy`, which you don't like because it appears redundant. 2. Adding nothing, but then removing the base class would break downsteam inheritance. 3. Adding `virtual`, but this implies that it's the first function in the override chain. Let me know what you want me to do! Personally, I'm for doing what clang-tidy wants :). Clang tidy suggests to add `override` to the constructor if it overrides a base class,",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11285
https://github.com/root-project/root/pull/11285:332,reliability,redundan,redundant,332,"Hi @eguiraud, thanks for the review and the comments! I addressed almost all of them, except for the ones related to the destructors. There are three options we have for the overriding destructors, and there are arguments against all of them:. 1. Add `override` as suggested by `clang-tidy`, which you don't like because it appears redundant. 2. Adding nothing, but then removing the base class would break downsteam inheritance. 3. Adding `virtual`, but this implies that it's the first function in the override chain. Let me know what you want me to do! Personally, I'm for doing what clang-tidy wants :). Clang tidy suggests to add `override` to the constructor if it overrides a base class,",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11285
https://github.com/root-project/root/pull/11285:29,safety,review,review,29,"Hi @eguiraud, thanks for the review and the comments! I addressed almost all of them, except for the ones related to the destructors. There are three options we have for the overriding destructors, and there are arguments against all of them:. 1. Add `override` as suggested by `clang-tidy`, which you don't like because it appears redundant. 2. Adding nothing, but then removing the base class would break downsteam inheritance. 3. Adding `virtual`, but this implies that it's the first function in the override chain. Let me know what you want me to do! Personally, I'm for doing what clang-tidy wants :). Clang tidy suggests to add `override` to the constructor if it overrides a base class,",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11285
https://github.com/root-project/root/pull/11285:86,safety,except,except,86,"Hi @eguiraud, thanks for the review and the comments! I addressed almost all of them, except for the ones related to the destructors. There are three options we have for the overriding destructors, and there are arguments against all of them:. 1. Add `override` as suggested by `clang-tidy`, which you don't like because it appears redundant. 2. Adding nothing, but then removing the base class would break downsteam inheritance. 3. Adding `virtual`, but this implies that it's the first function in the override chain. Let me know what you want me to do! Personally, I'm for doing what clang-tidy wants :). Clang tidy suggests to add `override` to the constructor if it overrides a base class,",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11285
https://github.com/root-project/root/pull/11285:332,safety,redund,redundant,332,"Hi @eguiraud, thanks for the review and the comments! I addressed almost all of them, except for the ones related to the destructors. There are three options we have for the overriding destructors, and there are arguments against all of them:. 1. Add `override` as suggested by `clang-tidy`, which you don't like because it appears redundant. 2. Adding nothing, but then removing the base class would break downsteam inheritance. 3. Adding `virtual`, but this implies that it's the first function in the override chain. Let me know what you want me to do! Personally, I'm for doing what clang-tidy wants :). Clang tidy suggests to add `override` to the constructor if it overrides a base class,",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11285
https://github.com/root-project/root/pull/11285:29,testability,review,review,29,"Hi @eguiraud, thanks for the review and the comments! I addressed almost all of them, except for the ones related to the destructors. There are three options we have for the overriding destructors, and there are arguments against all of them:. 1. Add `override` as suggested by `clang-tidy`, which you don't like because it appears redundant. 2. Adding nothing, but then removing the base class would break downsteam inheritance. 3. Adding `virtual`, but this implies that it's the first function in the override chain. Let me know what you want me to do! Personally, I'm for doing what clang-tidy wants :). Clang tidy suggests to add `override` to the constructor if it overrides a base class,",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11285
https://github.com/root-project/root/pull/11285:556,usability,Person,Personally,556,"Hi @eguiraud, thanks for the review and the comments! I addressed almost all of them, except for the ones related to the destructors. There are three options we have for the overriding destructors, and there are arguments against all of them:. 1. Add `override` as suggested by `clang-tidy`, which you don't like because it appears redundant. 2. Adding nothing, but then removing the base class would break downsteam inheritance. 3. Adding `virtual`, but this implies that it's the first function in the override chain. Let me know what you want me to do! Personally, I'm for doing what clang-tidy wants :). Clang tidy suggests to add `override` to the constructor if it overrides a base class,",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11285
https://github.com/root-project/root/pull/11285:145,integrability,complian,compliant,145,"Thank you for your patience @guitargeek :). Given clang-tidy's behavior, I think you are right, option 1 is the best: I'd rather have clang-tidy-compliant code than code that looks exactly how I like it :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11285
https://github.com/root-project/root/pull/11285:145,safety,compl,compliant,145,"Thank you for your patience @guitargeek :). Given clang-tidy's behavior, I think you are right, option 1 is the best: I'd rather have clang-tidy-compliant code than code that looks exactly how I like it :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11285
https://github.com/root-project/root/pull/11285:145,security,compl,compliant,145,"Thank you for your patience @guitargeek :). Given clang-tidy's behavior, I think you are right, option 1 is the best: I'd rather have clang-tidy-compliant code than code that looks exactly how I like it :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11285
https://github.com/root-project/root/pull/11285:63,usability,behavi,behavior,63,"Thank you for your patience @guitargeek :). Given clang-tidy's behavior, I think you are right, option 1 is the best: I'd rather have clang-tidy-compliant code than code that looks exactly how I like it :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11285
https://github.com/root-project/root/pull/11286:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:5,deployability,build,build,5,(the build can only be triggered like this by the maintainers),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:50,modifiability,maintain,maintainers,50,(the build can only be triggered like this by the maintainers),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:50,safety,maintain,maintainers,50,(the build can only be triggered like this by the maintainers),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:210,availability,servic,services,210,"@guitargeek The build failed in a strange way. Did jenkins build branch `[cling_cmd_history_config](https://github.com/jiangyilism/root/tree/cling_cmd_history_config)` of this pull request? From https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/ and https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/ , It built root master branch cdd1bdf3b46 . Which does not contain my branch/commits . And the failing test [roottest_python_distrdf_spark_test_all](https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/) . seems related to several distrdf changes in master branch recently.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:387,availability,servic,services,387,"@guitargeek The build failed in a strange way. Did jenkins build branch `[cling_cmd_history_config](https://github.com/jiangyilism/root/tree/cling_cmd_history_config)` of this pull request? From https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/ and https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/ , It built root master branch cdd1bdf3b46 . Which does not contain my branch/commits . And the failing test [roottest_python_distrdf_spark_test_all](https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/) . seems related to several distrdf changes in master branch recently.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:617,availability,servic,services,617,"@guitargeek The build failed in a strange way. Did jenkins build branch `[cling_cmd_history_config](https://github.com/jiangyilism/root/tree/cling_cmd_history_config)` of this pull request? From https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/ and https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/ , It built root master branch cdd1bdf3b46 . Which does not contain my branch/commits . And the failing test [roottest_python_distrdf_spark_test_all](https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/) . seems related to several distrdf changes in master branch recently.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:16,deployability,build,build,16,"@guitargeek The build failed in a strange way. Did jenkins build branch `[cling_cmd_history_config](https://github.com/jiangyilism/root/tree/cling_cmd_history_config)` of this pull request? From https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/ and https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/ , It built root master branch cdd1bdf3b46 . Which does not contain my branch/commits . And the failing test [roottest_python_distrdf_spark_test_all](https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/) . seems related to several distrdf changes in master branch recently.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:22,deployability,fail,failed,22,"@guitargeek The build failed in a strange way. Did jenkins build branch `[cling_cmd_history_config](https://github.com/jiangyilism/root/tree/cling_cmd_history_config)` of this pull request? From https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/ and https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/ , It built root master branch cdd1bdf3b46 . Which does not contain my branch/commits . And the failing test [roottest_python_distrdf_spark_test_all](https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/) . seems related to several distrdf changes in master branch recently.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:59,deployability,build,build,59,"@guitargeek The build failed in a strange way. Did jenkins build branch `[cling_cmd_history_config](https://github.com/jiangyilism/root/tree/cling_cmd_history_config)` of this pull request? From https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/ and https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/ , It built root master branch cdd1bdf3b46 . Which does not contain my branch/commits . And the failing test [roottest_python_distrdf_spark_test_all](https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/) . seems related to several distrdf changes in master branch recently.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:210,deployability,servic,services,210,"@guitargeek The build failed in a strange way. Did jenkins build branch `[cling_cmd_history_config](https://github.com/jiangyilism/root/tree/cling_cmd_history_config)` of this pull request? From https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/ and https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/ , It built root master branch cdd1bdf3b46 . Which does not contain my branch/commits . And the failing test [roottest_python_distrdf_spark_test_all](https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/) . seems related to several distrdf changes in master branch recently.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:262,deployability,build,build,262,"@guitargeek The build failed in a strange way. Did jenkins build branch `[cling_cmd_history_config](https://github.com/jiangyilism/root/tree/cling_cmd_history_config)` of this pull request? From https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/ and https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/ , It built root master branch cdd1bdf3b46 . Which does not contain my branch/commits . And the failing test [roottest_python_distrdf_spark_test_all](https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/) . seems related to several distrdf changes in master branch recently.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:387,deployability,servic,services,387,"@guitargeek The build failed in a strange way. Did jenkins build branch `[cling_cmd_history_config](https://github.com/jiangyilism/root/tree/cling_cmd_history_config)` of this pull request? From https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/ and https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/ , It built root master branch cdd1bdf3b46 . Which does not contain my branch/commits . And the failing test [roottest_python_distrdf_spark_test_all](https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/) . seems related to several distrdf changes in master branch recently.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:439,deployability,build,build,439,"@guitargeek The build failed in a strange way. Did jenkins build branch `[cling_cmd_history_config](https://github.com/jiangyilism/root/tree/cling_cmd_history_config)` of this pull request? From https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/ and https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/ , It built root master branch cdd1bdf3b46 . Which does not contain my branch/commits . And the failing test [roottest_python_distrdf_spark_test_all](https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/) . seems related to several distrdf changes in master branch recently.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:512,deployability,contain,contain,512,"@guitargeek The build failed in a strange way. Did jenkins build branch `[cling_cmd_history_config](https://github.com/jiangyilism/root/tree/cling_cmd_history_config)` of this pull request? From https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/ and https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/ , It built root master branch cdd1bdf3b46 . Which does not contain my branch/commits . And the failing test [roottest_python_distrdf_spark_test_all](https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/) . seems related to several distrdf changes in master branch recently.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:548,deployability,fail,failing,548,"@guitargeek The build failed in a strange way. Did jenkins build branch `[cling_cmd_history_config](https://github.com/jiangyilism/root/tree/cling_cmd_history_config)` of this pull request? From https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/ and https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/ , It built root master branch cdd1bdf3b46 . Which does not contain my branch/commits . And the failing test [roottest_python_distrdf_spark_test_all](https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/) . seems related to several distrdf changes in master branch recently.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:617,deployability,servic,services,617,"@guitargeek The build failed in a strange way. Did jenkins build branch `[cling_cmd_history_config](https://github.com/jiangyilism/root/tree/cling_cmd_history_config)` of this pull request? From https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/ and https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/ , It built root master branch cdd1bdf3b46 . Which does not contain my branch/commits . And the failing test [roottest_python_distrdf_spark_test_all](https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/) . seems related to several distrdf changes in master branch recently.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:669,deployability,build,build,669,"@guitargeek The build failed in a strange way. Did jenkins build branch `[cling_cmd_history_config](https://github.com/jiangyilism/root/tree/cling_cmd_history_config)` of this pull request? From https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/ and https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/ , It built root master branch cdd1bdf3b46 . Which does not contain my branch/commits . And the failing test [roottest_python_distrdf_spark_test_all](https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/) . seems related to several distrdf changes in master branch recently.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:210,integrability,servic,services,210,"@guitargeek The build failed in a strange way. Did jenkins build branch `[cling_cmd_history_config](https://github.com/jiangyilism/root/tree/cling_cmd_history_config)` of this pull request? From https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/ and https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/ , It built root master branch cdd1bdf3b46 . Which does not contain my branch/commits . And the failing test [roottest_python_distrdf_spark_test_all](https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/) . seems related to several distrdf changes in master branch recently.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:387,integrability,servic,services,387,"@guitargeek The build failed in a strange way. Did jenkins build branch `[cling_cmd_history_config](https://github.com/jiangyilism/root/tree/cling_cmd_history_config)` of this pull request? From https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/ and https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/ , It built root master branch cdd1bdf3b46 . Which does not contain my branch/commits . And the failing test [roottest_python_distrdf_spark_test_all](https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/) . seems related to several distrdf changes in master branch recently.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:617,integrability,servic,services,617,"@guitargeek The build failed in a strange way. Did jenkins build branch `[cling_cmd_history_config](https://github.com/jiangyilism/root/tree/cling_cmd_history_config)` of this pull request? From https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/ and https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/ , It built root master branch cdd1bdf3b46 . Which does not contain my branch/commits . And the failing test [roottest_python_distrdf_spark_test_all](https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/) . seems related to several distrdf changes in master branch recently.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:210,modifiability,servic,services,210,"@guitargeek The build failed in a strange way. Did jenkins build branch `[cling_cmd_history_config](https://github.com/jiangyilism/root/tree/cling_cmd_history_config)` of this pull request? From https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/ and https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/ , It built root master branch cdd1bdf3b46 . Which does not contain my branch/commits . And the failing test [roottest_python_distrdf_spark_test_all](https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/) . seems related to several distrdf changes in master branch recently.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:387,modifiability,servic,services,387,"@guitargeek The build failed in a strange way. Did jenkins build branch `[cling_cmd_history_config](https://github.com/jiangyilism/root/tree/cling_cmd_history_config)` of this pull request? From https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/ and https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/ , It built root master branch cdd1bdf3b46 . Which does not contain my branch/commits . And the failing test [roottest_python_distrdf_spark_test_all](https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/) . seems related to several distrdf changes in master branch recently.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:617,modifiability,servic,services,617,"@guitargeek The build failed in a strange way. Did jenkins build branch `[cling_cmd_history_config](https://github.com/jiangyilism/root/tree/cling_cmd_history_config)` of this pull request? From https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/ and https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/ , It built root master branch cdd1bdf3b46 . Which does not contain my branch/commits . And the failing test [roottest_python_distrdf_spark_test_all](https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/) . seems related to several distrdf changes in master branch recently.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:22,reliability,fail,failed,22,"@guitargeek The build failed in a strange way. Did jenkins build branch `[cling_cmd_history_config](https://github.com/jiangyilism/root/tree/cling_cmd_history_config)` of this pull request? From https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/ and https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/ , It built root master branch cdd1bdf3b46 . Which does not contain my branch/commits . And the failing test [roottest_python_distrdf_spark_test_all](https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/) . seems related to several distrdf changes in master branch recently.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:503,reliability,doe,does,503,"@guitargeek The build failed in a strange way. Did jenkins build branch `[cling_cmd_history_config](https://github.com/jiangyilism/root/tree/cling_cmd_history_config)` of this pull request? From https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/ and https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/ , It built root master branch cdd1bdf3b46 . Which does not contain my branch/commits . And the failing test [roottest_python_distrdf_spark_test_all](https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/) . seems related to several distrdf changes in master branch recently.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:548,reliability,fail,failing,548,"@guitargeek The build failed in a strange way. Did jenkins build branch `[cling_cmd_history_config](https://github.com/jiangyilism/root/tree/cling_cmd_history_config)` of this pull request? From https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/ and https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/ , It built root master branch cdd1bdf3b46 . Which does not contain my branch/commits . And the failing test [roottest_python_distrdf_spark_test_all](https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/) . seems related to several distrdf changes in master branch recently.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:275,safety,test,testReport,275,"@guitargeek The build failed in a strange way. Did jenkins build branch `[cling_cmd_history_config](https://github.com/jiangyilism/root/tree/cling_cmd_history_config)` of this pull request? From https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/ and https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/ , It built root master branch cdd1bdf3b46 . Which does not contain my branch/commits . And the failing test [roottest_python_distrdf_spark_test_all](https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/) . seems related to several distrdf changes in master branch recently.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:556,safety,test,test,556,"@guitargeek The build failed in a strange way. Did jenkins build branch `[cling_cmd_history_config](https://github.com/jiangyilism/root/tree/cling_cmd_history_config)` of this pull request? From https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/ and https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/ , It built root master branch cdd1bdf3b46 . Which does not contain my branch/commits . And the failing test [roottest_python_distrdf_spark_test_all](https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/) . seems related to several distrdf changes in master branch recently.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:682,safety,test,testReport,682,"@guitargeek The build failed in a strange way. Did jenkins build branch `[cling_cmd_history_config](https://github.com/jiangyilism/root/tree/cling_cmd_history_config)` of this pull request? From https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/ and https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/ , It built root master branch cdd1bdf3b46 . Which does not contain my branch/commits . And the failing test [roottest_python_distrdf_spark_test_all](https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/) . seems related to several distrdf changes in master branch recently.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:275,testability,test,testReport,275,"@guitargeek The build failed in a strange way. Did jenkins build branch `[cling_cmd_history_config](https://github.com/jiangyilism/root/tree/cling_cmd_history_config)` of this pull request? From https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/ and https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/ , It built root master branch cdd1bdf3b46 . Which does not contain my branch/commits . And the failing test [roottest_python_distrdf_spark_test_all](https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/) . seems related to several distrdf changes in master branch recently.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:556,testability,test,test,556,"@guitargeek The build failed in a strange way. Did jenkins build branch `[cling_cmd_history_config](https://github.com/jiangyilism/root/tree/cling_cmd_history_config)` of this pull request? From https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/ and https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/ , It built root master branch cdd1bdf3b46 . Which does not contain my branch/commits . And the failing test [roottest_python_distrdf_spark_test_all](https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/) . seems related to several distrdf changes in master branch recently.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:682,testability,test,testReport,682,"@guitargeek The build failed in a strange way. Did jenkins build branch `[cling_cmd_history_config](https://github.com/jiangyilism/root/tree/cling_cmd_history_config)` of this pull request? From https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/ and https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/ , It built root master branch cdd1bdf3b46 . Which does not contain my branch/commits . And the failing test [roottest_python_distrdf_spark_test_all](https://lcgapp-services.cern.ch/root-jenkins/job/root-pullrequests-build/153465/testReport/projectroot.roottest.python.distrdf/spark/roottest_python_distrdf_spark_test_all/) . seems related to several distrdf changes in master branch recently.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:71,deployability,patch,patch,71,"@guitargeek , @pcanal , @Axel-Naumann Could anyone help reviewing this patch?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:56,safety,review,reviewing,56,"@guitargeek , @pcanal , @Axel-Naumann Could anyone help reviewing this patch?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:71,safety,patch,patch,71,"@guitargeek , @pcanal , @Axel-Naumann Could anyone help reviewing this patch?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:71,security,patch,patch,71,"@guitargeek , @pcanal , @Axel-Naumann Could anyone help reviewing this patch?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:56,testability,review,reviewing,56,"@guitargeek , @pcanal , @Axel-Naumann Could anyone help reviewing this patch?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:51,usability,help,help,51,"@guitargeek , @pcanal , @Axel-Naumann Could anyone help reviewing this patch?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:30,deployability,patch,patch,30,"@jiangyilism, thanks for your patch! Looks reasonable approach to me. Can you add some tests for it?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:30,safety,patch,patch,30,"@jiangyilism, thanks for your patch! Looks reasonable approach to me. Can you add some tests for it?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:87,safety,test,tests,87,"@jiangyilism, thanks for your patch! Looks reasonable approach to me. Can you add some tests for it?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:30,security,patch,patch,30,"@jiangyilism, thanks for your patch! Looks reasonable approach to me. Can you add some tests for it?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:87,testability,test,tests,87,"@jiangyilism, thanks for your patch! Looks reasonable approach to me. Can you add some tests for it?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:53,deployability,pipelin,pipeline,53,@vgvassilev Test is added. Please help resume github pipeline.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:53,integrability,pipelin,pipeline,53,@vgvassilev Test is added. Please help resume github pipeline.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:12,safety,Test,Test,12,@vgvassilev Test is added. Please help resume github pipeline.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:12,testability,Test,Test,12,@vgvassilev Test is added. Please help resume github pipeline.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:34,usability,help,help,34,@vgvassilev Test is added. Please help resume github pipeline.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:39,usability,resum,resume,39,@vgvassilev Test is added. Please help resume github pipeline.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:207,usability,feedback,feedback,207,"> Many thanks for the contribution, @jiangyilism! 🙂. > . > In principle, LGTM, but I will defer the approval to @vgvassilev. Could you apply the included suggestions in the interim? > . Sure. Thanks for the feedback.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/pull/11286:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11286
https://github.com/root-project/root/issues/11287:69,security,hash,hash,69,That's intentional: we don't want to rebuild libCore because the git hash changes. The only way out would be to have `TROOT::GetGitCommit()` read a text file rather than rebuilding anything. I'll leave this open; this sounds like a useful improvement!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11287
https://github.com/root-project/root/issues/11287:26,deployability,Updat,Updating,26,My reasoning is bogus :-) Updating a *text* file obviously doesn't trigger a rebuild. We should just update `gitinfo.txt` any time we build.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11287
https://github.com/root-project/root/issues/11287:101,deployability,updat,update,101,My reasoning is bogus :-) Updating a *text* file obviously doesn't trigger a rebuild. We should just update `gitinfo.txt` any time we build.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11287
https://github.com/root-project/root/issues/11287:134,deployability,build,build,134,My reasoning is bogus :-) Updating a *text* file obviously doesn't trigger a rebuild. We should just update `gitinfo.txt` any time we build.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11287
https://github.com/root-project/root/issues/11287:126,performance,time,time,126,My reasoning is bogus :-) Updating a *text* file obviously doesn't trigger a rebuild. We should just update `gitinfo.txt` any time we build.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11287
https://github.com/root-project/root/issues/11287:59,reliability,doe,doesn,59,My reasoning is bogus :-) Updating a *text* file obviously doesn't trigger a rebuild. We should just update `gitinfo.txt` any time we build.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11287
https://github.com/root-project/root/issues/11287:26,safety,Updat,Updating,26,My reasoning is bogus :-) Updating a *text* file obviously doesn't trigger a rebuild. We should just update `gitinfo.txt` any time we build.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11287
https://github.com/root-project/root/issues/11287:101,safety,updat,update,101,My reasoning is bogus :-) Updating a *text* file obviously doesn't trigger a rebuild. We should just update `gitinfo.txt` any time we build.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11287
https://github.com/root-project/root/issues/11287:26,security,Updat,Updating,26,My reasoning is bogus :-) Updating a *text* file obviously doesn't trigger a rebuild. We should just update `gitinfo.txt` any time we build.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11287
https://github.com/root-project/root/issues/11287:101,security,updat,update,101,My reasoning is bogus :-) Updating a *text* file obviously doesn't trigger a rebuild. We should just update `gitinfo.txt` any time we build.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11287
https://github.com/root-project/root/issues/11287:44,usability,confirm,confirm,44,Should be fixed in master and 6.30. Can you confirm?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11287
https://github.com/root-project/root/issues/11287:0,usability,Confirm,Confirmed,0,"Confirmed, thanks a lot !!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11287
https://github.com/root-project/root/pull/11291:12,availability,failur,failure,12,The windows failure is unrelated (due to a git lock).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11291
https://github.com/root-project/root/pull/11291:12,deployability,fail,failure,12,The windows failure is unrelated (due to a git lock).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11291
https://github.com/root-project/root/pull/11291:12,performance,failur,failure,12,The windows failure is unrelated (due to a git lock).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11291
https://github.com/root-project/root/pull/11291:47,performance,lock,lock,47,The windows failure is unrelated (due to a git lock).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11291
https://github.com/root-project/root/pull/11291:12,reliability,fail,failure,12,The windows failure is unrelated (due to a git lock).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11291
https://github.com/root-project/root/pull/11291:47,security,lock,lock,47,The windows failure is unrelated (due to a git lock).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11291
https://github.com/root-project/root/pull/11292:4,availability,failur,failure,4,The failure is unrelated (Cling issue with symbols),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11292
https://github.com/root-project/root/pull/11292:4,deployability,fail,failure,4,The failure is unrelated (Cling issue with symbols),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11292
https://github.com/root-project/root/pull/11292:4,performance,failur,failure,4,The failure is unrelated (Cling issue with symbols),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11292
https://github.com/root-project/root/pull/11292:4,reliability,fail,failure,4,The failure is unrelated (Cling issue with symbols),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11292
https://github.com/root-project/root/pull/11293:48,safety,valid,validated,48,"@couet, @bellenot I need approval for this one, validated in #11272",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11293
https://github.com/root-project/root/pull/11293:48,security,validat,validated,48,"@couet, @bellenot I need approval for this one, validated in #11272",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11293
https://github.com/root-project/root/issues/11294:120,security,sign,signature,120,"Fixed in #11553 with the caveat that in order to be able to pass temporaries one should use e.g. `""const RVecF""` in the signature passed to `Numba.Declare` rather than simply `""RVecF""`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11294
https://github.com/root-project/root/issues/11294:168,testability,simpl,simply,168,"Fixed in #11553 with the caveat that in order to be able to pass temporaries one should use e.g. `""const RVecF""` in the signature passed to `Numba.Declare` rather than simply `""RVecF""`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11294
https://github.com/root-project/root/issues/11294:168,usability,simpl,simply,168,"Fixed in #11553 with the caveat that in order to be able to pass temporaries one should use e.g. `""const RVecF""` in the signature passed to `Numba.Declare` rather than simply `""RVecF""`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11294
https://github.com/root-project/root/issues/11295:40,deployability,integr,integrate,40,"Hi @ferdymercury . If you like, one can integrate this functionality into `RBrowser`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11295
https://github.com/root-project/root/issues/11295:40,integrability,integr,integrate,40,"Hi @ferdymercury . If you like, one can integrate this functionality into `RBrowser`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11295
https://github.com/root-project/root/issues/11295:40,interoperability,integr,integrate,40,"Hi @ferdymercury . If you like, one can integrate this functionality into `RBrowser`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11295
https://github.com/root-project/root/issues/11295:40,modifiability,integr,integrate,40,"Hi @ferdymercury . If you like, one can integrate this functionality into `RBrowser`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11295
https://github.com/root-project/root/issues/11295:40,reliability,integr,integrate,40,"Hi @ferdymercury . If you like, one can integrate this functionality into `RBrowser`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11295
https://github.com/root-project/root/issues/11295:40,security,integr,integrate,40,"Hi @ferdymercury . If you like, one can integrate this functionality into `RBrowser`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11295
https://github.com/root-project/root/issues/11295:40,testability,integr,integrate,40,"Hi @ferdymercury . If you like, one can integrate this functionality into `RBrowser`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11295
https://github.com/root-project/root/issues/11295:16,usability,close,close,16,"I guess, we can close issue now",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11295
https://github.com/root-project/root/issues/11299:106,security,ident,identical,106,"For reference, https://github.com/root-project/root/pull/11262 has a commit to support entry function not identical to filename. If the file is a hidden file that name starts with a dot, cling executes the function name which is same as file name but without preceding dot.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:79,usability,support,support,79,"For reference, https://github.com/root-project/root/pull/11262 has a commit to support entry function not identical to filename. If the file is a hidden file that name starts with a dot, cling executes the function name which is same as file name but without preceding dot.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:132,safety,test,test,132,Wouldn't an unnamed macro do the job? See attached file. The filename can be changed without having to 'rename' the main function. [test.C.zip](https://github.com/root-project/root/files/9468881/test.C.zip).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:195,safety,test,test,195,Wouldn't an unnamed macro do the job? See attached file. The filename can be changed without having to 'rename' the main function. [test.C.zip](https://github.com/root-project/root/files/9468881/test.C.zip).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:132,testability,test,test,132,Wouldn't an unnamed macro do the job? See attached file. The filename can be changed without having to 'rename' the main function. [test.C.zip](https://github.com/root-project/root/files/9468881/test.C.zip).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:195,testability,test,test,195,Wouldn't an unnamed macro do the job? See attached file. The filename can be changed without having to 'rename' the main function. [test.C.zip](https://github.com/root-project/root/files/9468881/test.C.zip).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:159,availability,state,stated,159,"Unnamed macro is a root feature. standalone cling does not support it. In a cling test case `root/interpreter/cling/test/Prompt/MetaProcessor/Macros.C`, it is stated that ""This test should test the unnamed macro support once it is moved in cling."" So cling does not support it yet. Personally I would suggest cling to never support it unless future c++ standard supports similar construct. https://root-forum.cern.ch/t/what-is-the-difference-between-unnamed-macro-and-named-macro/30455 discouraged usage of unnamed macro in root too though I do not know if it is cling's current position. @Axel-Naumann what is cling's future plan on unnamed macro?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:571,energy efficiency,current,current,571,"Unnamed macro is a root feature. standalone cling does not support it. In a cling test case `root/interpreter/cling/test/Prompt/MetaProcessor/Macros.C`, it is stated that ""This test should test the unnamed macro support once it is moved in cling."" So cling does not support it yet. Personally I would suggest cling to never support it unless future c++ standard supports similar construct. https://root-forum.cern.ch/t/what-is-the-difference-between-unnamed-macro-and-named-macro/30455 discouraged usage of unnamed macro in root too though I do not know if it is cling's current position. @Axel-Naumann what is cling's future plan on unnamed macro?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:159,integrability,state,stated,159,"Unnamed macro is a root feature. standalone cling does not support it. In a cling test case `root/interpreter/cling/test/Prompt/MetaProcessor/Macros.C`, it is stated that ""This test should test the unnamed macro support once it is moved in cling."" So cling does not support it yet. Personally I would suggest cling to never support it unless future c++ standard supports similar construct. https://root-forum.cern.ch/t/what-is-the-difference-between-unnamed-macro-and-named-macro/30455 discouraged usage of unnamed macro in root too though I do not know if it is cling's current position. @Axel-Naumann what is cling's future plan on unnamed macro?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:353,interoperability,standard,standard,353,"Unnamed macro is a root feature. standalone cling does not support it. In a cling test case `root/interpreter/cling/test/Prompt/MetaProcessor/Macros.C`, it is stated that ""This test should test the unnamed macro support once it is moved in cling."" So cling does not support it yet. Personally I would suggest cling to never support it unless future c++ standard supports similar construct. https://root-forum.cern.ch/t/what-is-the-difference-between-unnamed-macro-and-named-macro/30455 discouraged usage of unnamed macro in root too though I do not know if it is cling's current position. @Axel-Naumann what is cling's future plan on unnamed macro?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:50,reliability,doe,does,50,"Unnamed macro is a root feature. standalone cling does not support it. In a cling test case `root/interpreter/cling/test/Prompt/MetaProcessor/Macros.C`, it is stated that ""This test should test the unnamed macro support once it is moved in cling."" So cling does not support it yet. Personally I would suggest cling to never support it unless future c++ standard supports similar construct. https://root-forum.cern.ch/t/what-is-the-difference-between-unnamed-macro-and-named-macro/30455 discouraged usage of unnamed macro in root too though I do not know if it is cling's current position. @Axel-Naumann what is cling's future plan on unnamed macro?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:257,reliability,doe,does,257,"Unnamed macro is a root feature. standalone cling does not support it. In a cling test case `root/interpreter/cling/test/Prompt/MetaProcessor/Macros.C`, it is stated that ""This test should test the unnamed macro support once it is moved in cling."" So cling does not support it yet. Personally I would suggest cling to never support it unless future c++ standard supports similar construct. https://root-forum.cern.ch/t/what-is-the-difference-between-unnamed-macro-and-named-macro/30455 discouraged usage of unnamed macro in root too though I do not know if it is cling's current position. @Axel-Naumann what is cling's future plan on unnamed macro?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:82,safety,test,test,82,"Unnamed macro is a root feature. standalone cling does not support it. In a cling test case `root/interpreter/cling/test/Prompt/MetaProcessor/Macros.C`, it is stated that ""This test should test the unnamed macro support once it is moved in cling."" So cling does not support it yet. Personally I would suggest cling to never support it unless future c++ standard supports similar construct. https://root-forum.cern.ch/t/what-is-the-difference-between-unnamed-macro-and-named-macro/30455 discouraged usage of unnamed macro in root too though I do not know if it is cling's current position. @Axel-Naumann what is cling's future plan on unnamed macro?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:116,safety,test,test,116,"Unnamed macro is a root feature. standalone cling does not support it. In a cling test case `root/interpreter/cling/test/Prompt/MetaProcessor/Macros.C`, it is stated that ""This test should test the unnamed macro support once it is moved in cling."" So cling does not support it yet. Personally I would suggest cling to never support it unless future c++ standard supports similar construct. https://root-forum.cern.ch/t/what-is-the-difference-between-unnamed-macro-and-named-macro/30455 discouraged usage of unnamed macro in root too though I do not know if it is cling's current position. @Axel-Naumann what is cling's future plan on unnamed macro?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:177,safety,test,test,177,"Unnamed macro is a root feature. standalone cling does not support it. In a cling test case `root/interpreter/cling/test/Prompt/MetaProcessor/Macros.C`, it is stated that ""This test should test the unnamed macro support once it is moved in cling."" So cling does not support it yet. Personally I would suggest cling to never support it unless future c++ standard supports similar construct. https://root-forum.cern.ch/t/what-is-the-difference-between-unnamed-macro-and-named-macro/30455 discouraged usage of unnamed macro in root too though I do not know if it is cling's current position. @Axel-Naumann what is cling's future plan on unnamed macro?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:189,safety,test,test,189,"Unnamed macro is a root feature. standalone cling does not support it. In a cling test case `root/interpreter/cling/test/Prompt/MetaProcessor/Macros.C`, it is stated that ""This test should test the unnamed macro support once it is moved in cling."" So cling does not support it yet. Personally I would suggest cling to never support it unless future c++ standard supports similar construct. https://root-forum.cern.ch/t/what-is-the-difference-between-unnamed-macro-and-named-macro/30455 discouraged usage of unnamed macro in root too though I do not know if it is cling's current position. @Axel-Naumann what is cling's future plan on unnamed macro?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:82,testability,test,test,82,"Unnamed macro is a root feature. standalone cling does not support it. In a cling test case `root/interpreter/cling/test/Prompt/MetaProcessor/Macros.C`, it is stated that ""This test should test the unnamed macro support once it is moved in cling."" So cling does not support it yet. Personally I would suggest cling to never support it unless future c++ standard supports similar construct. https://root-forum.cern.ch/t/what-is-the-difference-between-unnamed-macro-and-named-macro/30455 discouraged usage of unnamed macro in root too though I do not know if it is cling's current position. @Axel-Naumann what is cling's future plan on unnamed macro?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:116,testability,test,test,116,"Unnamed macro is a root feature. standalone cling does not support it. In a cling test case `root/interpreter/cling/test/Prompt/MetaProcessor/Macros.C`, it is stated that ""This test should test the unnamed macro support once it is moved in cling."" So cling does not support it yet. Personally I would suggest cling to never support it unless future c++ standard supports similar construct. https://root-forum.cern.ch/t/what-is-the-difference-between-unnamed-macro-and-named-macro/30455 discouraged usage of unnamed macro in root too though I do not know if it is cling's current position. @Axel-Naumann what is cling's future plan on unnamed macro?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:177,testability,test,test,177,"Unnamed macro is a root feature. standalone cling does not support it. In a cling test case `root/interpreter/cling/test/Prompt/MetaProcessor/Macros.C`, it is stated that ""This test should test the unnamed macro support once it is moved in cling."" So cling does not support it yet. Personally I would suggest cling to never support it unless future c++ standard supports similar construct. https://root-forum.cern.ch/t/what-is-the-difference-between-unnamed-macro-and-named-macro/30455 discouraged usage of unnamed macro in root too though I do not know if it is cling's current position. @Axel-Naumann what is cling's future plan on unnamed macro?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:189,testability,test,test,189,"Unnamed macro is a root feature. standalone cling does not support it. In a cling test case `root/interpreter/cling/test/Prompt/MetaProcessor/Macros.C`, it is stated that ""This test should test the unnamed macro support once it is moved in cling."" So cling does not support it yet. Personally I would suggest cling to never support it unless future c++ standard supports similar construct. https://root-forum.cern.ch/t/what-is-the-difference-between-unnamed-macro-and-named-macro/30455 discouraged usage of unnamed macro in root too though I do not know if it is cling's current position. @Axel-Naumann what is cling's future plan on unnamed macro?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:626,testability,plan,plan,626,"Unnamed macro is a root feature. standalone cling does not support it. In a cling test case `root/interpreter/cling/test/Prompt/MetaProcessor/Macros.C`, it is stated that ""This test should test the unnamed macro support once it is moved in cling."" So cling does not support it yet. Personally I would suggest cling to never support it unless future c++ standard supports similar construct. https://root-forum.cern.ch/t/what-is-the-difference-between-unnamed-macro-and-named-macro/30455 discouraged usage of unnamed macro in root too though I do not know if it is cling's current position. @Axel-Naumann what is cling's future plan on unnamed macro?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:59,usability,support,support,59,"Unnamed macro is a root feature. standalone cling does not support it. In a cling test case `root/interpreter/cling/test/Prompt/MetaProcessor/Macros.C`, it is stated that ""This test should test the unnamed macro support once it is moved in cling."" So cling does not support it yet. Personally I would suggest cling to never support it unless future c++ standard supports similar construct. https://root-forum.cern.ch/t/what-is-the-difference-between-unnamed-macro-and-named-macro/30455 discouraged usage of unnamed macro in root too though I do not know if it is cling's current position. @Axel-Naumann what is cling's future plan on unnamed macro?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:212,usability,support,support,212,"Unnamed macro is a root feature. standalone cling does not support it. In a cling test case `root/interpreter/cling/test/Prompt/MetaProcessor/Macros.C`, it is stated that ""This test should test the unnamed macro support once it is moved in cling."" So cling does not support it yet. Personally I would suggest cling to never support it unless future c++ standard supports similar construct. https://root-forum.cern.ch/t/what-is-the-difference-between-unnamed-macro-and-named-macro/30455 discouraged usage of unnamed macro in root too though I do not know if it is cling's current position. @Axel-Naumann what is cling's future plan on unnamed macro?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:266,usability,support,support,266,"Unnamed macro is a root feature. standalone cling does not support it. In a cling test case `root/interpreter/cling/test/Prompt/MetaProcessor/Macros.C`, it is stated that ""This test should test the unnamed macro support once it is moved in cling."" So cling does not support it yet. Personally I would suggest cling to never support it unless future c++ standard supports similar construct. https://root-forum.cern.ch/t/what-is-the-difference-between-unnamed-macro-and-named-macro/30455 discouraged usage of unnamed macro in root too though I do not know if it is cling's current position. @Axel-Naumann what is cling's future plan on unnamed macro?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:282,usability,Person,Personally,282,"Unnamed macro is a root feature. standalone cling does not support it. In a cling test case `root/interpreter/cling/test/Prompt/MetaProcessor/Macros.C`, it is stated that ""This test should test the unnamed macro support once it is moved in cling."" So cling does not support it yet. Personally I would suggest cling to never support it unless future c++ standard supports similar construct. https://root-forum.cern.ch/t/what-is-the-difference-between-unnamed-macro-and-named-macro/30455 discouraged usage of unnamed macro in root too though I do not know if it is cling's current position. @Axel-Naumann what is cling's future plan on unnamed macro?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:324,usability,support,support,324,"Unnamed macro is a root feature. standalone cling does not support it. In a cling test case `root/interpreter/cling/test/Prompt/MetaProcessor/Macros.C`, it is stated that ""This test should test the unnamed macro support once it is moved in cling."" So cling does not support it yet. Personally I would suggest cling to never support it unless future c++ standard supports similar construct. https://root-forum.cern.ch/t/what-is-the-difference-between-unnamed-macro-and-named-macro/30455 discouraged usage of unnamed macro in root too though I do not know if it is cling's current position. @Axel-Naumann what is cling's future plan on unnamed macro?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:362,usability,support,supports,362,"Unnamed macro is a root feature. standalone cling does not support it. In a cling test case `root/interpreter/cling/test/Prompt/MetaProcessor/Macros.C`, it is stated that ""This test should test the unnamed macro support once it is moved in cling."" So cling does not support it yet. Personally I would suggest cling to never support it unless future c++ standard supports similar construct. https://root-forum.cern.ch/t/what-is-the-difference-between-unnamed-macro-and-named-macro/30455 discouraged usage of unnamed macro in root too though I do not know if it is cling's current position. @Axel-Naumann what is cling's future plan on unnamed macro?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:104,availability,state,statements,104,"No plans. But whatever the plans currently are will need to be adjusted if and once the clang patch for statements at global scope is in, as that changes the equation dramatically.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:94,deployability,patch,patch,94,"No plans. But whatever the plans currently are will need to be adjusted if and once the clang patch for statements at global scope is in, as that changes the equation dramatically.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:33,energy efficiency,current,currently,33,"No plans. But whatever the plans currently are will need to be adjusted if and once the clang patch for statements at global scope is in, as that changes the equation dramatically.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:104,integrability,state,statements,104,"No plans. But whatever the plans currently are will need to be adjusted if and once the clang patch for statements at global scope is in, as that changes the equation dramatically.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:94,safety,patch,patch,94,"No plans. But whatever the plans currently are will need to be adjusted if and once the clang patch for statements at global scope is in, as that changes the equation dramatically.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:94,security,patch,patch,94,"No plans. But whatever the plans currently are will need to be adjusted if and once the clang patch for statements at global scope is in, as that changes the equation dramatically.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:3,testability,plan,plans,3,"No plans. But whatever the plans currently are will need to be adjusted if and once the clang patch for statements at global scope is in, as that changes the equation dramatically.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:27,testability,plan,plans,27,"No plans. But whatever the plans currently are will need to be adjusted if and once the clang patch for statements at global scope is in, as that changes the equation dramatically.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:61,interoperability,standard,standard,61,"> However identifier with two underscores is reserved by c++ standard. They are reserved for implementers. Cling is an implementation, so we can totally do that :-) We actually **have** to do that, to avoid misinterpretation of an existing function. The attribute seems like a good alternative, though!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:201,safety,avoid,avoid,201,"> However identifier with two underscores is reserved by c++ standard. They are reserved for implementers. Cling is an implementation, so we can totally do that :-) We actually **have** to do that, to avoid misinterpretation of an existing function. The attribute seems like a good alternative, though!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:10,security,ident,identifier,10,"> However identifier with two underscores is reserved by c++ standard. They are reserved for implementers. Cling is an implementation, so we can totally do that :-) We actually **have** to do that, to avoid misinterpretation of an existing function. The attribute seems like a good alternative, though!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:49,availability,state,statements,49,"Do you meaning this patch? [[clang-repl] Support statements on global scope in incremental mode](https://reviews.llvm.org/D127284) . It looks almost identical to unnamed macro support. So I assumed clang-repl (and later cling) will have that feature soon. However, both ""on load"" feature implemented with that patch or unnamed macro bring a problem that the script file is not a valid c++ source file anymore so a compiler, not an interpreter like cling, cannot compile it. While my proposed approaches do not have this limitation. But of course, we can `#include ""a_valid_cxx_file.cpp""` in a `.C` script file containing unnamed macro for ""on load"". Just a little indirect.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:20,deployability,patch,patch,20,"Do you meaning this patch? [[clang-repl] Support statements on global scope in incremental mode](https://reviews.llvm.org/D127284) . It looks almost identical to unnamed macro support. So I assumed clang-repl (and later cling) will have that feature soon. However, both ""on load"" feature implemented with that patch or unnamed macro bring a problem that the script file is not a valid c++ source file anymore so a compiler, not an interpreter like cling, cannot compile it. While my proposed approaches do not have this limitation. But of course, we can `#include ""a_valid_cxx_file.cpp""` in a `.C` script file containing unnamed macro for ""on load"". Just a little indirect.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:310,deployability,patch,patch,310,"Do you meaning this patch? [[clang-repl] Support statements on global scope in incremental mode](https://reviews.llvm.org/D127284) . It looks almost identical to unnamed macro support. So I assumed clang-repl (and later cling) will have that feature soon. However, both ""on load"" feature implemented with that patch or unnamed macro bring a problem that the script file is not a valid c++ source file anymore so a compiler, not an interpreter like cling, cannot compile it. While my proposed approaches do not have this limitation. But of course, we can `#include ""a_valid_cxx_file.cpp""` in a `.C` script file containing unnamed macro for ""on load"". Just a little indirect.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:610,deployability,contain,containing,610,"Do you meaning this patch? [[clang-repl] Support statements on global scope in incremental mode](https://reviews.llvm.org/D127284) . It looks almost identical to unnamed macro support. So I assumed clang-repl (and later cling) will have that feature soon. However, both ""on load"" feature implemented with that patch or unnamed macro bring a problem that the script file is not a valid c++ source file anymore so a compiler, not an interpreter like cling, cannot compile it. While my proposed approaches do not have this limitation. But of course, we can `#include ""a_valid_cxx_file.cpp""` in a `.C` script file containing unnamed macro for ""on load"". Just a little indirect.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:274,energy efficiency,load,load,274,"Do you meaning this patch? [[clang-repl] Support statements on global scope in incremental mode](https://reviews.llvm.org/D127284) . It looks almost identical to unnamed macro support. So I assumed clang-repl (and later cling) will have that feature soon. However, both ""on load"" feature implemented with that patch or unnamed macro bring a problem that the script file is not a valid c++ source file anymore so a compiler, not an interpreter like cling, cannot compile it. While my proposed approaches do not have this limitation. But of course, we can `#include ""a_valid_cxx_file.cpp""` in a `.C` script file containing unnamed macro for ""on load"". Just a little indirect.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:643,energy efficiency,load,load,643,"Do you meaning this patch? [[clang-repl] Support statements on global scope in incremental mode](https://reviews.llvm.org/D127284) . It looks almost identical to unnamed macro support. So I assumed clang-repl (and later cling) will have that feature soon. However, both ""on load"" feature implemented with that patch or unnamed macro bring a problem that the script file is not a valid c++ source file anymore so a compiler, not an interpreter like cling, cannot compile it. While my proposed approaches do not have this limitation. But of course, we can `#include ""a_valid_cxx_file.cpp""` in a `.C` script file containing unnamed macro for ""on load"". Just a little indirect.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:49,integrability,state,statements,49,"Do you meaning this patch? [[clang-repl] Support statements on global scope in incremental mode](https://reviews.llvm.org/D127284) . It looks almost identical to unnamed macro support. So I assumed clang-repl (and later cling) will have that feature soon. However, both ""on load"" feature implemented with that patch or unnamed macro bring a problem that the script file is not a valid c++ source file anymore so a compiler, not an interpreter like cling, cannot compile it. While my proposed approaches do not have this limitation. But of course, we can `#include ""a_valid_cxx_file.cpp""` in a `.C` script file containing unnamed macro for ""on load"". Just a little indirect.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:274,performance,load,load,274,"Do you meaning this patch? [[clang-repl] Support statements on global scope in incremental mode](https://reviews.llvm.org/D127284) . It looks almost identical to unnamed macro support. So I assumed clang-repl (and later cling) will have that feature soon. However, both ""on load"" feature implemented with that patch or unnamed macro bring a problem that the script file is not a valid c++ source file anymore so a compiler, not an interpreter like cling, cannot compile it. While my proposed approaches do not have this limitation. But of course, we can `#include ""a_valid_cxx_file.cpp""` in a `.C` script file containing unnamed macro for ""on load"". Just a little indirect.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:643,performance,load,load,643,"Do you meaning this patch? [[clang-repl] Support statements on global scope in incremental mode](https://reviews.llvm.org/D127284) . It looks almost identical to unnamed macro support. So I assumed clang-repl (and later cling) will have that feature soon. However, both ""on load"" feature implemented with that patch or unnamed macro bring a problem that the script file is not a valid c++ source file anymore so a compiler, not an interpreter like cling, cannot compile it. While my proposed approaches do not have this limitation. But of course, we can `#include ""a_valid_cxx_file.cpp""` in a `.C` script file containing unnamed macro for ""on load"". Just a little indirect.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:20,safety,patch,patch,20,"Do you meaning this patch? [[clang-repl] Support statements on global scope in incremental mode](https://reviews.llvm.org/D127284) . It looks almost identical to unnamed macro support. So I assumed clang-repl (and later cling) will have that feature soon. However, both ""on load"" feature implemented with that patch or unnamed macro bring a problem that the script file is not a valid c++ source file anymore so a compiler, not an interpreter like cling, cannot compile it. While my proposed approaches do not have this limitation. But of course, we can `#include ""a_valid_cxx_file.cpp""` in a `.C` script file containing unnamed macro for ""on load"". Just a little indirect.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:105,safety,review,reviews,105,"Do you meaning this patch? [[clang-repl] Support statements on global scope in incremental mode](https://reviews.llvm.org/D127284) . It looks almost identical to unnamed macro support. So I assumed clang-repl (and later cling) will have that feature soon. However, both ""on load"" feature implemented with that patch or unnamed macro bring a problem that the script file is not a valid c++ source file anymore so a compiler, not an interpreter like cling, cannot compile it. While my proposed approaches do not have this limitation. But of course, we can `#include ""a_valid_cxx_file.cpp""` in a `.C` script file containing unnamed macro for ""on load"". Just a little indirect.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:310,safety,patch,patch,310,"Do you meaning this patch? [[clang-repl] Support statements on global scope in incremental mode](https://reviews.llvm.org/D127284) . It looks almost identical to unnamed macro support. So I assumed clang-repl (and later cling) will have that feature soon. However, both ""on load"" feature implemented with that patch or unnamed macro bring a problem that the script file is not a valid c++ source file anymore so a compiler, not an interpreter like cling, cannot compile it. While my proposed approaches do not have this limitation. But of course, we can `#include ""a_valid_cxx_file.cpp""` in a `.C` script file containing unnamed macro for ""on load"". Just a little indirect.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:379,safety,valid,valid,379,"Do you meaning this patch? [[clang-repl] Support statements on global scope in incremental mode](https://reviews.llvm.org/D127284) . It looks almost identical to unnamed macro support. So I assumed clang-repl (and later cling) will have that feature soon. However, both ""on load"" feature implemented with that patch or unnamed macro bring a problem that the script file is not a valid c++ source file anymore so a compiler, not an interpreter like cling, cannot compile it. While my proposed approaches do not have this limitation. But of course, we can `#include ""a_valid_cxx_file.cpp""` in a `.C` script file containing unnamed macro for ""on load"". Just a little indirect.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:20,security,patch,patch,20,"Do you meaning this patch? [[clang-repl] Support statements on global scope in incremental mode](https://reviews.llvm.org/D127284) . It looks almost identical to unnamed macro support. So I assumed clang-repl (and later cling) will have that feature soon. However, both ""on load"" feature implemented with that patch or unnamed macro bring a problem that the script file is not a valid c++ source file anymore so a compiler, not an interpreter like cling, cannot compile it. While my proposed approaches do not have this limitation. But of course, we can `#include ""a_valid_cxx_file.cpp""` in a `.C` script file containing unnamed macro for ""on load"". Just a little indirect.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:149,security,ident,identical,149,"Do you meaning this patch? [[clang-repl] Support statements on global scope in incremental mode](https://reviews.llvm.org/D127284) . It looks almost identical to unnamed macro support. So I assumed clang-repl (and later cling) will have that feature soon. However, both ""on load"" feature implemented with that patch or unnamed macro bring a problem that the script file is not a valid c++ source file anymore so a compiler, not an interpreter like cling, cannot compile it. While my proposed approaches do not have this limitation. But of course, we can `#include ""a_valid_cxx_file.cpp""` in a `.C` script file containing unnamed macro for ""on load"". Just a little indirect.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:310,security,patch,patch,310,"Do you meaning this patch? [[clang-repl] Support statements on global scope in incremental mode](https://reviews.llvm.org/D127284) . It looks almost identical to unnamed macro support. So I assumed clang-repl (and later cling) will have that feature soon. However, both ""on load"" feature implemented with that patch or unnamed macro bring a problem that the script file is not a valid c++ source file anymore so a compiler, not an interpreter like cling, cannot compile it. While my proposed approaches do not have this limitation. But of course, we can `#include ""a_valid_cxx_file.cpp""` in a `.C` script file containing unnamed macro for ""on load"". Just a little indirect.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:105,testability,review,reviews,105,"Do you meaning this patch? [[clang-repl] Support statements on global scope in incremental mode](https://reviews.llvm.org/D127284) . It looks almost identical to unnamed macro support. So I assumed clang-repl (and later cling) will have that feature soon. However, both ""on load"" feature implemented with that patch or unnamed macro bring a problem that the script file is not a valid c++ source file anymore so a compiler, not an interpreter like cling, cannot compile it. While my proposed approaches do not have this limitation. But of course, we can `#include ""a_valid_cxx_file.cpp""` in a `.C` script file containing unnamed macro for ""on load"". Just a little indirect.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:41,usability,Support,Support,41,"Do you meaning this patch? [[clang-repl] Support statements on global scope in incremental mode](https://reviews.llvm.org/D127284) . It looks almost identical to unnamed macro support. So I assumed clang-repl (and later cling) will have that feature soon. However, both ""on load"" feature implemented with that patch or unnamed macro bring a problem that the script file is not a valid c++ source file anymore so a compiler, not an interpreter like cling, cannot compile it. While my proposed approaches do not have this limitation. But of course, we can `#include ""a_valid_cxx_file.cpp""` in a `.C` script file containing unnamed macro for ""on load"". Just a little indirect.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:176,usability,support,support,176,"Do you meaning this patch? [[clang-repl] Support statements on global scope in incremental mode](https://reviews.llvm.org/D127284) . It looks almost identical to unnamed macro support. So I assumed clang-repl (and later cling) will have that feature soon. However, both ""on load"" feature implemented with that patch or unnamed macro bring a problem that the script file is not a valid c++ source file anymore so a compiler, not an interpreter like cling, cannot compile it. While my proposed approaches do not have this limitation. But of course, we can `#include ""a_valid_cxx_file.cpp""` in a `.C` script file containing unnamed macro for ""on load"". Just a little indirect.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:199,deployability,unload,unload,199,"As a side note, C++ already has a notion of onload so another option could be for the user to simply use:. ```. int anyfunction( .... ) { ... }. int execthefunctonload = anyfunction();. ```. (and on-unload can also be done (using a class destructor for example) but requires a bit more scaffolding)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:94,testability,simpl,simply,94,"As a side note, C++ already has a notion of onload so another option could be for the user to simply use:. ```. int anyfunction( .... ) { ... }. int execthefunctonload = anyfunction();. ```. (and on-unload can also be done (using a class destructor for example) but requires a bit more scaffolding)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:86,usability,user,user,86,"As a side note, C++ already has a notion of onload so another option could be for the user to simply use:. ```. int anyfunction( .... ) { ... }. int execthefunctonload = anyfunction();. ```. (and on-unload can also be done (using a class destructor for example) but requires a bit more scaffolding)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:94,usability,simpl,simply,94,"As a side note, C++ already has a notion of onload so another option could be for the user to simply use:. ```. int anyfunction( .... ) { ... }. int execthefunctonload = anyfunction();. ```. (and on-unload can also be done (using a class destructor for example) but requires a bit more scaffolding)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:359,energy efficiency,current,current,359,"I was not advocating for unnamed macros as alternative to what you propose here, @jiangyilism . I think @pcanal 's proposal qualifies as a (technically correct) ""hack"" :-) We could indeed use `__attribute__((constructor))` as the attribute - but that calls the function as part of static initialization, not *after* static initialization like `main()` or the current function-name-as-file-name, and the file would have to be loaded through `.L` not `.x`. Would that be good enough, @jiangyilism ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:425,energy efficiency,load,loaded,425,"I was not advocating for unnamed macros as alternative to what you propose here, @jiangyilism . I think @pcanal 's proposal qualifies as a (technically correct) ""hack"" :-) We could indeed use `__attribute__((constructor))` as the attribute - but that calls the function as part of static initialization, not *after* static initialization like `main()` or the current function-name-as-file-name, and the file would have to be loaded through `.L` not `.x`. Would that be good enough, @jiangyilism ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:425,performance,load,loaded,425,"I was not advocating for unnamed macros as alternative to what you propose here, @jiangyilism . I think @pcanal 's proposal qualifies as a (technically correct) ""hack"" :-) We could indeed use `__attribute__((constructor))` as the attribute - but that calls the function as part of static initialization, not *after* static initialization like `main()` or the current function-name-as-file-name, and the file would have to be loaded through `.L` not `.x`. Would that be good enough, @jiangyilism ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:162,security,hack,hack,162,"I was not advocating for unnamed macros as alternative to what you propose here, @jiangyilism . I think @pcanal 's proposal qualifies as a (technically correct) ""hack"" :-) We could indeed use `__attribute__((constructor))` as the attribute - but that calls the function as part of static initialization, not *after* static initialization like `main()` or the current function-name-as-file-name, and the file would have to be loaded through `.L` not `.x`. Would that be good enough, @jiangyilism ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:267,availability,error,error,267,"Using `.L` or `__attribute__((constructor))` or static initialization are good alternatives. However that does not improve usability of `.x` . As mentioned in the first post, entry function still need renaming when file get renamed. Also we get function redefinition error when `.x` or `.L` two scripts with same name. For example `dir0/test.C` and `dir1/dir2/test.C` (with completely different content) cannot both define their `test(...)` entry functions. They cannot be put into different namespaces either otherwise cling does not recognize them as entry functions. However, `__main__(...)` approach suffers from multiple definitions too. Unless cling unloads/drops symbol `__main__` after executing it (btw. In this case will static variables of `__main__` get destructed too?).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:656,deployability,unload,unloads,656,"Using `.L` or `__attribute__((constructor))` or static initialization are good alternatives. However that does not improve usability of `.x` . As mentioned in the first post, entry function still need renaming when file get renamed. Also we get function redefinition error when `.x` or `.L` two scripts with same name. For example `dir0/test.C` and `dir1/dir2/test.C` (with completely different content) cannot both define their `test(...)` entry functions. They cannot be put into different namespaces either otherwise cling does not recognize them as entry functions. However, `__main__(...)` approach suffers from multiple definitions too. Unless cling unloads/drops symbol `__main__` after executing it (btw. In this case will static variables of `__main__` get destructed too?).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:738,modifiability,variab,variables,738,"Using `.L` or `__attribute__((constructor))` or static initialization are good alternatives. However that does not improve usability of `.x` . As mentioned in the first post, entry function still need renaming when file get renamed. Also we get function redefinition error when `.x` or `.L` two scripts with same name. For example `dir0/test.C` and `dir1/dir2/test.C` (with completely different content) cannot both define their `test(...)` entry functions. They cannot be put into different namespaces either otherwise cling does not recognize them as entry functions. However, `__main__(...)` approach suffers from multiple definitions too. Unless cling unloads/drops symbol `__main__` after executing it (btw. In this case will static variables of `__main__` get destructed too?).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:267,performance,error,error,267,"Using `.L` or `__attribute__((constructor))` or static initialization are good alternatives. However that does not improve usability of `.x` . As mentioned in the first post, entry function still need renaming when file get renamed. Also we get function redefinition error when `.x` or `.L` two scripts with same name. For example `dir0/test.C` and `dir1/dir2/test.C` (with completely different content) cannot both define their `test(...)` entry functions. They cannot be put into different namespaces either otherwise cling does not recognize them as entry functions. However, `__main__(...)` approach suffers from multiple definitions too. Unless cling unloads/drops symbol `__main__` after executing it (btw. In this case will static variables of `__main__` get destructed too?).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:395,performance,content,content,395,"Using `.L` or `__attribute__((constructor))` or static initialization are good alternatives. However that does not improve usability of `.x` . As mentioned in the first post, entry function still need renaming when file get renamed. Also we get function redefinition error when `.x` or `.L` two scripts with same name. For example `dir0/test.C` and `dir1/dir2/test.C` (with completely different content) cannot both define their `test(...)` entry functions. They cannot be put into different namespaces either otherwise cling does not recognize them as entry functions. However, `__main__(...)` approach suffers from multiple definitions too. Unless cling unloads/drops symbol `__main__` after executing it (btw. In this case will static variables of `__main__` get destructed too?).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:106,reliability,doe,does,106,"Using `.L` or `__attribute__((constructor))` or static initialization are good alternatives. However that does not improve usability of `.x` . As mentioned in the first post, entry function still need renaming when file get renamed. Also we get function redefinition error when `.x` or `.L` two scripts with same name. For example `dir0/test.C` and `dir1/dir2/test.C` (with completely different content) cannot both define their `test(...)` entry functions. They cannot be put into different namespaces either otherwise cling does not recognize them as entry functions. However, `__main__(...)` approach suffers from multiple definitions too. Unless cling unloads/drops symbol `__main__` after executing it (btw. In this case will static variables of `__main__` get destructed too?).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:526,reliability,doe,does,526,"Using `.L` or `__attribute__((constructor))` or static initialization are good alternatives. However that does not improve usability of `.x` . As mentioned in the first post, entry function still need renaming when file get renamed. Also we get function redefinition error when `.x` or `.L` two scripts with same name. For example `dir0/test.C` and `dir1/dir2/test.C` (with completely different content) cannot both define their `test(...)` entry functions. They cannot be put into different namespaces either otherwise cling does not recognize them as entry functions. However, `__main__(...)` approach suffers from multiple definitions too. Unless cling unloads/drops symbol `__main__` after executing it (btw. In this case will static variables of `__main__` get destructed too?).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:267,safety,error,error,267,"Using `.L` or `__attribute__((constructor))` or static initialization are good alternatives. However that does not improve usability of `.x` . As mentioned in the first post, entry function still need renaming when file get renamed. Also we get function redefinition error when `.x` or `.L` two scripts with same name. For example `dir0/test.C` and `dir1/dir2/test.C` (with completely different content) cannot both define their `test(...)` entry functions. They cannot be put into different namespaces either otherwise cling does not recognize them as entry functions. However, `__main__(...)` approach suffers from multiple definitions too. Unless cling unloads/drops symbol `__main__` after executing it (btw. In this case will static variables of `__main__` get destructed too?).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:337,safety,test,test,337,"Using `.L` or `__attribute__((constructor))` or static initialization are good alternatives. However that does not improve usability of `.x` . As mentioned in the first post, entry function still need renaming when file get renamed. Also we get function redefinition error when `.x` or `.L` two scripts with same name. For example `dir0/test.C` and `dir1/dir2/test.C` (with completely different content) cannot both define their `test(...)` entry functions. They cannot be put into different namespaces either otherwise cling does not recognize them as entry functions. However, `__main__(...)` approach suffers from multiple definitions too. Unless cling unloads/drops symbol `__main__` after executing it (btw. In this case will static variables of `__main__` get destructed too?).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:360,safety,test,test,360,"Using `.L` or `__attribute__((constructor))` or static initialization are good alternatives. However that does not improve usability of `.x` . As mentioned in the first post, entry function still need renaming when file get renamed. Also we get function redefinition error when `.x` or `.L` two scripts with same name. For example `dir0/test.C` and `dir1/dir2/test.C` (with completely different content) cannot both define their `test(...)` entry functions. They cannot be put into different namespaces either otherwise cling does not recognize them as entry functions. However, `__main__(...)` approach suffers from multiple definitions too. Unless cling unloads/drops symbol `__main__` after executing it (btw. In this case will static variables of `__main__` get destructed too?).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:374,safety,compl,completely,374,"Using `.L` or `__attribute__((constructor))` or static initialization are good alternatives. However that does not improve usability of `.x` . As mentioned in the first post, entry function still need renaming when file get renamed. Also we get function redefinition error when `.x` or `.L` two scripts with same name. For example `dir0/test.C` and `dir1/dir2/test.C` (with completely different content) cannot both define their `test(...)` entry functions. They cannot be put into different namespaces either otherwise cling does not recognize them as entry functions. However, `__main__(...)` approach suffers from multiple definitions too. Unless cling unloads/drops symbol `__main__` after executing it (btw. In this case will static variables of `__main__` get destructed too?).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:430,safety,test,test,430,"Using `.L` or `__attribute__((constructor))` or static initialization are good alternatives. However that does not improve usability of `.x` . As mentioned in the first post, entry function still need renaming when file get renamed. Also we get function redefinition error when `.x` or `.L` two scripts with same name. For example `dir0/test.C` and `dir1/dir2/test.C` (with completely different content) cannot both define their `test(...)` entry functions. They cannot be put into different namespaces either otherwise cling does not recognize them as entry functions. However, `__main__(...)` approach suffers from multiple definitions too. Unless cling unloads/drops symbol `__main__` after executing it (btw. In this case will static variables of `__main__` get destructed too?).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:374,security,compl,completely,374,"Using `.L` or `__attribute__((constructor))` or static initialization are good alternatives. However that does not improve usability of `.x` . As mentioned in the first post, entry function still need renaming when file get renamed. Also we get function redefinition error when `.x` or `.L` two scripts with same name. For example `dir0/test.C` and `dir1/dir2/test.C` (with completely different content) cannot both define their `test(...)` entry functions. They cannot be put into different namespaces either otherwise cling does not recognize them as entry functions. However, `__main__(...)` approach suffers from multiple definitions too. Unless cling unloads/drops symbol `__main__` after executing it (btw. In this case will static variables of `__main__` get destructed too?).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:337,testability,test,test,337,"Using `.L` or `__attribute__((constructor))` or static initialization are good alternatives. However that does not improve usability of `.x` . As mentioned in the first post, entry function still need renaming when file get renamed. Also we get function redefinition error when `.x` or `.L` two scripts with same name. For example `dir0/test.C` and `dir1/dir2/test.C` (with completely different content) cannot both define their `test(...)` entry functions. They cannot be put into different namespaces either otherwise cling does not recognize them as entry functions. However, `__main__(...)` approach suffers from multiple definitions too. Unless cling unloads/drops symbol `__main__` after executing it (btw. In this case will static variables of `__main__` get destructed too?).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:360,testability,test,test,360,"Using `.L` or `__attribute__((constructor))` or static initialization are good alternatives. However that does not improve usability of `.x` . As mentioned in the first post, entry function still need renaming when file get renamed. Also we get function redefinition error when `.x` or `.L` two scripts with same name. For example `dir0/test.C` and `dir1/dir2/test.C` (with completely different content) cannot both define their `test(...)` entry functions. They cannot be put into different namespaces either otherwise cling does not recognize them as entry functions. However, `__main__(...)` approach suffers from multiple definitions too. Unless cling unloads/drops symbol `__main__` after executing it (btw. In this case will static variables of `__main__` get destructed too?).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:430,testability,test,test,430,"Using `.L` or `__attribute__((constructor))` or static initialization are good alternatives. However that does not improve usability of `.x` . As mentioned in the first post, entry function still need renaming when file get renamed. Also we get function redefinition error when `.x` or `.L` two scripts with same name. For example `dir0/test.C` and `dir1/dir2/test.C` (with completely different content) cannot both define their `test(...)` entry functions. They cannot be put into different namespaces either otherwise cling does not recognize them as entry functions. However, `__main__(...)` approach suffers from multiple definitions too. Unless cling unloads/drops symbol `__main__` after executing it (btw. In this case will static variables of `__main__` get destructed too?).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:123,usability,usab,usability,123,"Using `.L` or `__attribute__((constructor))` or static initialization are good alternatives. However that does not improve usability of `.x` . As mentioned in the first post, entry function still need renaming when file get renamed. Also we get function redefinition error when `.x` or `.L` two scripts with same name. For example `dir0/test.C` and `dir1/dir2/test.C` (with completely different content) cannot both define their `test(...)` entry functions. They cannot be put into different namespaces either otherwise cling does not recognize them as entry functions. However, `__main__(...)` approach suffers from multiple definitions too. Unless cling unloads/drops symbol `__main__` after executing it (btw. In this case will static variables of `__main__` get destructed too?).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:267,usability,error,error,267,"Using `.L` or `__attribute__((constructor))` or static initialization are good alternatives. However that does not improve usability of `.x` . As mentioned in the first post, entry function still need renaming when file get renamed. Also we get function redefinition error when `.x` or `.L` two scripts with same name. For example `dir0/test.C` and `dir1/dir2/test.C` (with completely different content) cannot both define their `test(...)` entry functions. They cannot be put into different namespaces either otherwise cling does not recognize them as entry functions. However, `__main__(...)` approach suffers from multiple definitions too. Unless cling unloads/drops symbol `__main__` after executing it (btw. In this case will static variables of `__main__` get destructed too?).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:66,safety,compl,complain,66,@jiangyilism I am proposing to change the behavior of `.x` to not complain about a missing function `filename()` *if* there is a function marked with `__attribute__((constructor))`. How is that not a solution to this issue?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:66,security,compl,complain,66,@jiangyilism I am proposing to change the behavior of `.x` to not complain about a missing function `filename()` *if* there is a function marked with `__attribute__((constructor))`. How is that not a solution to this issue?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11299:42,usability,behavi,behavior,42,@jiangyilism I am proposing to change the behavior of `.x` to not complain about a missing function `filename()` *if* there is a function marked with `__attribute__((constructor))`. How is that not a solution to this issue?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11299
https://github.com/root-project/root/issues/11300:24,usability,document,documentation,24,Marked as legacy in the documentation.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11300
https://github.com/root-project/root/issues/11300:14,testability,plan,plans,14,"Are there any plans for a modern alternative to TGenPhaseSpace, now that it is marked as legacy?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11300
https://github.com/root-project/root/issues/11300:265,availability,consist,consistency,265,"Just for the context, the `TGenPhaseSpace` was first declared a legacy with no alternative in ROOT 6.28 by @Axel-Naumann:. https://github.com/root-project/root/commit/1b32e042e47f8684817b86b4b80f4563cb271191. The new legacy warning box with 6.32 was only added for consistency. See also the discussion here:. https://github.com/root-project/root/pull/14754#issuecomment-1948944502. The ""legacy"" status should not prevent you from using this class I think. At least there is not plan to definitely remove it. Maybe @Axel-Naumann can comment on 1b32e042, given that the commit has no associated commit or PR description?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11300
https://github.com/root-project/root/issues/11300:413,safety,prevent,prevent,413,"Just for the context, the `TGenPhaseSpace` was first declared a legacy with no alternative in ROOT 6.28 by @Axel-Naumann:. https://github.com/root-project/root/commit/1b32e042e47f8684817b86b4b80f4563cb271191. The new legacy warning box with 6.32 was only added for consistency. See also the discussion here:. https://github.com/root-project/root/pull/14754#issuecomment-1948944502. The ""legacy"" status should not prevent you from using this class I think. At least there is not plan to definitely remove it. Maybe @Axel-Naumann can comment on 1b32e042, given that the commit has no associated commit or PR description?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11300
https://github.com/root-project/root/issues/11300:413,security,preven,prevent,413,"Just for the context, the `TGenPhaseSpace` was first declared a legacy with no alternative in ROOT 6.28 by @Axel-Naumann:. https://github.com/root-project/root/commit/1b32e042e47f8684817b86b4b80f4563cb271191. The new legacy warning box with 6.32 was only added for consistency. See also the discussion here:. https://github.com/root-project/root/pull/14754#issuecomment-1948944502. The ""legacy"" status should not prevent you from using this class I think. At least there is not plan to definitely remove it. Maybe @Axel-Naumann can comment on 1b32e042, given that the commit has no associated commit or PR description?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11300
https://github.com/root-project/root/issues/11300:13,testability,context,context,13,"Just for the context, the `TGenPhaseSpace` was first declared a legacy with no alternative in ROOT 6.28 by @Axel-Naumann:. https://github.com/root-project/root/commit/1b32e042e47f8684817b86b4b80f4563cb271191. The new legacy warning box with 6.32 was only added for consistency. See also the discussion here:. https://github.com/root-project/root/pull/14754#issuecomment-1948944502. The ""legacy"" status should not prevent you from using this class I think. At least there is not plan to definitely remove it. Maybe @Axel-Naumann can comment on 1b32e042, given that the commit has no associated commit or PR description?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11300
https://github.com/root-project/root/issues/11300:478,testability,plan,plan,478,"Just for the context, the `TGenPhaseSpace` was first declared a legacy with no alternative in ROOT 6.28 by @Axel-Naumann:. https://github.com/root-project/root/commit/1b32e042e47f8684817b86b4b80f4563cb271191. The new legacy warning box with 6.32 was only added for consistency. See also the discussion here:. https://github.com/root-project/root/pull/14754#issuecomment-1948944502. The ""legacy"" status should not prevent you from using this class I think. At least there is not plan to definitely remove it. Maybe @Axel-Naumann can comment on 1b32e042, given that the commit has no associated commit or PR description?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11300
https://github.com/root-project/root/issues/11300:265,usability,consist,consistency,265,"Just for the context, the `TGenPhaseSpace` was first declared a legacy with no alternative in ROOT 6.28 by @Axel-Naumann:. https://github.com/root-project/root/commit/1b32e042e47f8684817b86b4b80f4563cb271191. The new legacy warning box with 6.32 was only added for consistency. See also the discussion here:. https://github.com/root-project/root/pull/14754#issuecomment-1948944502. The ""legacy"" status should not prevent you from using this class I think. At least there is not plan to definitely remove it. Maybe @Axel-Naumann can comment on 1b32e042, given that the commit has no associated commit or PR description?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11300
https://github.com/root-project/root/issues/11300:395,usability,statu,status,395,"Just for the context, the `TGenPhaseSpace` was first declared a legacy with no alternative in ROOT 6.28 by @Axel-Naumann:. https://github.com/root-project/root/commit/1b32e042e47f8684817b86b4b80f4563cb271191. The new legacy warning box with 6.32 was only added for consistency. See also the discussion here:. https://github.com/root-project/root/pull/14754#issuecomment-1948944502. The ""legacy"" status should not prevent you from using this class I think. At least there is not plan to definitely remove it. Maybe @Axel-Naumann can comment on 1b32e042, given that the commit has no associated commit or PR description?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11300
https://github.com/root-project/root/issues/11300:97,interoperability,share,share,97,"I have been provided with a set of contributed classes that can replace `TGenPhasespace`. I will share it with you, @guitargeek !",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11300
https://github.com/root-project/root/issues/11304:63,usability,close,closed,63,@lmoneta can this issue be assigned to the project 6.32 and be closed?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11304
https://github.com/root-project/root/pull/11306:11,deployability,build,build,11,@phsft-bot build please,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11306
https://github.com/root-project/root/pull/11307:43,availability,error,error,43,"Ah, I need to update a test reference, the error message slightly changed",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11307
https://github.com/root-project/root/pull/11307:57,availability,sli,slightly,57,"Ah, I need to update a test reference, the error message slightly changed",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11307
https://github.com/root-project/root/pull/11307:14,deployability,updat,update,14,"Ah, I need to update a test reference, the error message slightly changed",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11307
https://github.com/root-project/root/pull/11307:49,integrability,messag,message,49,"Ah, I need to update a test reference, the error message slightly changed",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11307
https://github.com/root-project/root/pull/11307:49,interoperability,messag,message,49,"Ah, I need to update a test reference, the error message slightly changed",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11307
https://github.com/root-project/root/pull/11307:43,performance,error,error,43,"Ah, I need to update a test reference, the error message slightly changed",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11307
https://github.com/root-project/root/pull/11307:57,reliability,sli,slightly,57,"Ah, I need to update a test reference, the error message slightly changed",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11307
https://github.com/root-project/root/pull/11307:14,safety,updat,update,14,"Ah, I need to update a test reference, the error message slightly changed",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11307
https://github.com/root-project/root/pull/11307:23,safety,test,test,23,"Ah, I need to update a test reference, the error message slightly changed",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11307
https://github.com/root-project/root/pull/11307:43,safety,error,error,43,"Ah, I need to update a test reference, the error message slightly changed",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11307
https://github.com/root-project/root/pull/11307:14,security,updat,update,14,"Ah, I need to update a test reference, the error message slightly changed",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11307
https://github.com/root-project/root/pull/11307:23,testability,test,test,23,"Ah, I need to update a test reference, the error message slightly changed",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11307
https://github.com/root-project/root/pull/11307:43,usability,error,error,43,"Ah, I need to update a test reference, the error message slightly changed",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11307
https://github.com/root-project/root/pull/11309:11,deployability,build,build,11,"@phsft-bot build just on ROOT-ubuntu2204/default, ROOT-ubuntu18.04/default with flags -Dtmva-sofie=On",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11309
https://github.com/root-project/root/pull/11309:11,deployability,build,build,11,"@phsft-bot build just on ROOT-ubuntu2204/default, ROOT-ubuntu18.04/default with flags -Dtmva-sofie=On",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11309
https://github.com/root-project/root/pull/11309:11,deployability,build,build,11,"@phsft-bot build just on ROOT-ubuntu2204/default, ROOT-ubuntu18.04/default with flags -Dtmva-sofie=On",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11309
https://github.com/root-project/root/pull/11310:4,availability,failur,failures,4,The failures are unrelated.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11310
https://github.com/root-project/root/pull/11310:4,deployability,fail,failures,4,The failures are unrelated.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11310
https://github.com/root-project/root/pull/11310:4,performance,failur,failures,4,The failures are unrelated.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11310
https://github.com/root-project/root/pull/11310:4,reliability,fail,failures,4,The failures are unrelated.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11310
https://github.com/root-project/root/pull/11311:316,availability,avail,available,316,"In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:88,deployability,build,build,88,"In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:121,deployability,instal,installed,121,"In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:281,deployability,build,build,281,"In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:74,integrability,configur,configured,74,"In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:267,integrability,configur,configure,267,"In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:74,modifiability,configur,configured,74,"In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:267,modifiability,configur,configure,267,"In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:287,performance,time,time,287,"In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:316,reliability,availab,available,316,"In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:296,safety,detect,detected,296,"In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:316,safety,avail,available,316,"In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:74,security,configur,configured,74,"In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:267,security,configur,configure,267,"In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:296,security,detect,detected,296,"In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:316,security,availab,available,316,"In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:318,availability,avail,available,318,"> In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available). In fact, I have a project that uses C++20, and uses ROOT compiled with C++17, and I encountered compilation errors in the ROOT header file RSpan.hxx as mentioned (redefinition of std::span). However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. I also checked RStringView.hxx, this header file also uses a similar technique, so I submitted this patch. I believe that I may not be considerate about this in depth, but I hope that the issues of ""mixing standards"", which seems not to be issues, can be solved. If there are indeed many restrictions/issues on this issue, I admit that this is not such simple...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:438,availability,error,errors,438,"> In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available). In fact, I have a project that uses C++20, and uses ROOT compiled with C++17, and I encountered compilation errors in the ROOT header file RSpan.hxx as mentioned (redefinition of std::span). However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. I also checked RStringView.hxx, this header file also uses a similar technique, so I submitted this patch. I believe that I may not be considerate about this in depth, but I hope that the issues of ""mixing standards"", which seems not to be issues, can be solved. If there are indeed many restrictions/issues on this issue, I admit that this is not such simple...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:90,deployability,build,build,90,"> In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available). In fact, I have a project that uses C++20, and uses ROOT compiled with C++17, and I encountered compilation errors in the ROOT header file RSpan.hxx as mentioned (redefinition of std::span). However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. I also checked RStringView.hxx, this header file also uses a similar technique, so I submitted this patch. I believe that I may not be considerate about this in depth, but I hope that the issues of ""mixing standards"", which seems not to be issues, can be solved. If there are indeed many restrictions/issues on this issue, I admit that this is not such simple...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:123,deployability,instal,installed,123,"> In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available). In fact, I have a project that uses C++20, and uses ROOT compiled with C++17, and I encountered compilation errors in the ROOT header file RSpan.hxx as mentioned (redefinition of std::span). However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. I also checked RStringView.hxx, this header file also uses a similar technique, so I submitted this patch. I believe that I may not be considerate about this in depth, but I hope that the issues of ""mixing standards"", which seems not to be issues, can be solved. If there are indeed many restrictions/issues on this issue, I admit that this is not such simple...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:283,deployability,build,build,283,"> In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available). In fact, I have a project that uses C++20, and uses ROOT compiled with C++17, and I encountered compilation errors in the ROOT header file RSpan.hxx as mentioned (redefinition of std::span). However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. I also checked RStringView.hxx, this header file also uses a similar technique, so I submitted this patch. I believe that I may not be considerate about this in depth, but I hope that the issues of ""mixing standards"", which seems not to be issues, can be solved. If there are indeed many restrictions/issues on this issue, I admit that this is not such simple...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:785,deployability,patch,patch,785,"> In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available). In fact, I have a project that uses C++20, and uses ROOT compiled with C++17, and I encountered compilation errors in the ROOT header file RSpan.hxx as mentioned (redefinition of std::span). However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. I also checked RStringView.hxx, this header file also uses a similar technique, so I submitted this patch. I believe that I may not be considerate about this in depth, but I hope that the issues of ""mixing standards"", which seems not to be issues, can be solved. If there are indeed many restrictions/issues on this issue, I admit that this is not such simple...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:76,integrability,configur,configured,76,"> In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available). In fact, I have a project that uses C++20, and uses ROOT compiled with C++17, and I encountered compilation errors in the ROOT header file RSpan.hxx as mentioned (redefinition of std::span). However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. I also checked RStringView.hxx, this header file also uses a similar technique, so I submitted this patch. I believe that I may not be considerate about this in depth, but I hope that the issues of ""mixing standards"", which seems not to be issues, can be solved. If there are indeed many restrictions/issues on this issue, I admit that this is not such simple...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:269,integrability,configur,configure,269,"> In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available). In fact, I have a project that uses C++20, and uses ROOT compiled with C++17, and I encountered compilation errors in the ROOT header file RSpan.hxx as mentioned (redefinition of std::span). However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. I also checked RStringView.hxx, this header file also uses a similar technique, so I submitted this patch. I believe that I may not be considerate about this in depth, but I hope that the issues of ""mixing standards"", which seems not to be issues, can be solved. If there are indeed many restrictions/issues on this issue, I admit that this is not such simple...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:770,integrability,sub,submitted,770,"> In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available). In fact, I have a project that uses C++20, and uses ROOT compiled with C++17, and I encountered compilation errors in the ROOT header file RSpan.hxx as mentioned (redefinition of std::span). However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. I also checked RStringView.hxx, this header file also uses a similar technique, so I submitted this patch. I believe that I may not be considerate about this in depth, but I hope that the issues of ""mixing standards"", which seems not to be issues, can be solved. If there are indeed many restrictions/issues on this issue, I admit that this is not such simple...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:891,interoperability,standard,standards,891,"> In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available). In fact, I have a project that uses C++20, and uses ROOT compiled with C++17, and I encountered compilation errors in the ROOT header file RSpan.hxx as mentioned (redefinition of std::span). However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. I also checked RStringView.hxx, this header file also uses a similar technique, so I submitted this patch. I believe that I may not be considerate about this in depth, but I hope that the issues of ""mixing standards"", which seems not to be issues, can be solved. If there are indeed many restrictions/issues on this issue, I admit that this is not such simple...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:76,modifiability,configur,configured,76,"> In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available). In fact, I have a project that uses C++20, and uses ROOT compiled with C++17, and I encountered compilation errors in the ROOT header file RSpan.hxx as mentioned (redefinition of std::span). However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. I also checked RStringView.hxx, this header file also uses a similar technique, so I submitted this patch. I believe that I may not be considerate about this in depth, but I hope that the issues of ""mixing standards"", which seems not to be issues, can be solved. If there are indeed many restrictions/issues on this issue, I admit that this is not such simple...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:269,modifiability,configur,configure,269,"> In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available). In fact, I have a project that uses C++20, and uses ROOT compiled with C++17, and I encountered compilation errors in the ROOT header file RSpan.hxx as mentioned (redefinition of std::span). However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. I also checked RStringView.hxx, this header file also uses a similar technique, so I submitted this patch. I believe that I may not be considerate about this in depth, but I hope that the issues of ""mixing standards"", which seems not to be issues, can be solved. If there are indeed many restrictions/issues on this issue, I admit that this is not such simple...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:289,performance,time,time,289,"> In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available). In fact, I have a project that uses C++20, and uses ROOT compiled with C++17, and I encountered compilation errors in the ROOT header file RSpan.hxx as mentioned (redefinition of std::span). However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. I also checked RStringView.hxx, this header file also uses a similar technique, so I submitted this patch. I believe that I may not be considerate about this in depth, but I hope that the issues of ""mixing standards"", which seems not to be issues, can be solved. If there are indeed many restrictions/issues on this issue, I admit that this is not such simple...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:438,performance,error,errors,438,"> In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available). In fact, I have a project that uses C++20, and uses ROOT compiled with C++17, and I encountered compilation errors in the ROOT header file RSpan.hxx as mentioned (redefinition of std::span). However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. I also checked RStringView.hxx, this header file also uses a similar technique, so I submitted this patch. I believe that I may not be considerate about this in depth, but I hope that the issues of ""mixing standards"", which seems not to be issues, can be solved. If there are indeed many restrictions/issues on this issue, I admit that this is not such simple...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:673,performance,time,time,673,"> In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available). In fact, I have a project that uses C++20, and uses ROOT compiled with C++17, and I encountered compilation errors in the ROOT header file RSpan.hxx as mentioned (redefinition of std::span). However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. I also checked RStringView.hxx, this header file also uses a similar technique, so I submitted this patch. I believe that I may not be considerate about this in depth, but I hope that the issues of ""mixing standards"", which seems not to be issues, can be solved. If there are indeed many restrictions/issues on this issue, I admit that this is not such simple...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:318,reliability,availab,available,318,"> In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available). In fact, I have a project that uses C++20, and uses ROOT compiled with C++17, and I encountered compilation errors in the ROOT header file RSpan.hxx as mentioned (redefinition of std::span). However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. I also checked RStringView.hxx, this header file also uses a similar technique, so I submitted this patch. I believe that I may not be considerate about this in depth, but I hope that the issues of ""mixing standards"", which seems not to be issues, can be solved. If there are indeed many restrictions/issues on this issue, I admit that this is not such simple...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:298,safety,detect,detected,298,"> In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available). In fact, I have a project that uses C++20, and uses ROOT compiled with C++17, and I encountered compilation errors in the ROOT header file RSpan.hxx as mentioned (redefinition of std::span). However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. I also checked RStringView.hxx, this header file also uses a similar technique, so I submitted this patch. I believe that I may not be considerate about this in depth, but I hope that the issues of ""mixing standards"", which seems not to be issues, can be solved. If there are indeed many restrictions/issues on this issue, I admit that this is not such simple...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:318,safety,avail,available,318,"> In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available). In fact, I have a project that uses C++20, and uses ROOT compiled with C++17, and I encountered compilation errors in the ROOT header file RSpan.hxx as mentioned (redefinition of std::span). However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. I also checked RStringView.hxx, this header file also uses a similar technique, so I submitted this patch. I believe that I may not be considerate about this in depth, but I hope that the issues of ""mixing standards"", which seems not to be issues, can be solved. If there are indeed many restrictions/issues on this issue, I admit that this is not such simple...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:438,safety,error,errors,438,"> In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available). In fact, I have a project that uses C++20, and uses ROOT compiled with C++17, and I encountered compilation errors in the ROOT header file RSpan.hxx as mentioned (redefinition of std::span). However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. I also checked RStringView.hxx, this header file also uses a similar technique, so I submitted this patch. I believe that I may not be considerate about this in depth, but I hope that the issues of ""mixing standards"", which seems not to be issues, can be solved. If there are indeed many restrictions/issues on this issue, I admit that this is not such simple...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:785,safety,patch,patch,785,"> In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available). In fact, I have a project that uses C++20, and uses ROOT compiled with C++17, and I encountered compilation errors in the ROOT header file RSpan.hxx as mentioned (redefinition of std::span). However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. I also checked RStringView.hxx, this header file also uses a similar technique, so I submitted this patch. I believe that I may not be considerate about this in depth, but I hope that the issues of ""mixing standards"", which seems not to be issues, can be solved. If there are indeed many restrictions/issues on this issue, I admit that this is not such simple...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:76,security,configur,configured,76,"> In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available). In fact, I have a project that uses C++20, and uses ROOT compiled with C++17, and I encountered compilation errors in the ROOT header file RSpan.hxx as mentioned (redefinition of std::span). However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. I also checked RStringView.hxx, this header file also uses a similar technique, so I submitted this patch. I believe that I may not be considerate about this in depth, but I hope that the issues of ""mixing standards"", which seems not to be issues, can be solved. If there are indeed many restrictions/issues on this issue, I admit that this is not such simple...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:269,security,configur,configure,269,"> In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available). In fact, I have a project that uses C++20, and uses ROOT compiled with C++17, and I encountered compilation errors in the ROOT header file RSpan.hxx as mentioned (redefinition of std::span). However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. I also checked RStringView.hxx, this header file also uses a similar technique, so I submitted this patch. I believe that I may not be considerate about this in depth, but I hope that the issues of ""mixing standards"", which seems not to be issues, can be solved. If there are indeed many restrictions/issues on this issue, I admit that this is not such simple...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:298,security,detect,detected,298,"> In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available). In fact, I have a project that uses C++20, and uses ROOT compiled with C++17, and I encountered compilation errors in the ROOT header file RSpan.hxx as mentioned (redefinition of std::span). However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. I also checked RStringView.hxx, this header file also uses a similar technique, so I submitted this patch. I believe that I may not be considerate about this in depth, but I hope that the issues of ""mixing standards"", which seems not to be issues, can be solved. If there are indeed many restrictions/issues on this issue, I admit that this is not such simple...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:318,security,availab,available,318,"> In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available). In fact, I have a project that uses C++20, and uses ROOT compiled with C++17, and I encountered compilation errors in the ROOT header file RSpan.hxx as mentioned (redefinition of std::span). However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. I also checked RStringView.hxx, this header file also uses a similar technique, so I submitted this patch. I believe that I may not be considerate about this in depth, but I hope that the issues of ""mixing standards"", which seems not to be issues, can be solved. If there are indeed many restrictions/issues on this issue, I admit that this is not such simple...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:785,security,patch,patch,785,"> In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available). In fact, I have a project that uses C++20, and uses ROOT compiled with C++17, and I encountered compilation errors in the ROOT header file RSpan.hxx as mentioned (redefinition of std::span). However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. I also checked RStringView.hxx, this header file also uses a similar technique, so I submitted this patch. I believe that I may not be considerate about this in depth, but I hope that the issues of ""mixing standards"", which seems not to be issues, can be solved. If there are indeed many restrictions/issues on this issue, I admit that this is not such simple...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1038,testability,simpl,simple,1038,"> In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available). In fact, I have a project that uses C++20, and uses ROOT compiled with C++17, and I encountered compilation errors in the ROOT header file RSpan.hxx as mentioned (redefinition of std::span). However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. I also checked RStringView.hxx, this header file also uses a similar technique, so I submitted this patch. I believe that I may not be considerate about this in depth, but I hope that the issues of ""mixing standards"", which seems not to be issues, can be solved. If there are indeed many restrictions/issues on this issue, I admit that this is not such simple...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:438,usability,error,errors,438,"> In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available). In fact, I have a project that uses C++20, and uses ROOT compiled with C++17, and I encountered compilation errors in the ROOT header file RSpan.hxx as mentioned (redefinition of std::span). However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. I also checked RStringView.hxx, this header file also uses a similar technique, so I submitted this patch. I believe that I may not be considerate about this in depth, but I hope that the issues of ""mixing standards"", which seems not to be issues, can be solved. If there are indeed many restrictions/issues on this issue, I admit that this is not such simple...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1038,usability,simpl,simple,1038,"> In what situation is `R__HAS_STD_SPAN` not sufficient? If `ROOT` has been configured to build in C++20 mode and properly installed, it must be set in `RConfigure.h`. If it is not set, this means that the `ROOT` code will use an alternative to `std::span` (because at configure and build time, it detected it was not available). In fact, I have a project that uses C++20, and uses ROOT compiled with C++17, and I encountered compilation errors in the ROOT header file RSpan.hxx as mentioned (redefinition of std::span). However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. I also checked RStringView.hxx, this header file also uses a similar technique, so I submitted this patch. I believe that I may not be considerate about this in depth, but I hope that the issues of ""mixing standards"", which seems not to be issues, can be solved. If there are indeed many restrictions/issues on this issue, I admit that this is not such simple...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:442,deployability,version,version,442,"> In fact, I have a project that uses C++20, and uses ROOT compiled with C++17,. We currently do not support this mixing of standard. > However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. . This means that the example/test that have been run so far did not stress the interfaces that uses `std::span` (and/or your lucky that both version are similar enough). In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span` .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:598,deployability,version,version,598,"> In fact, I have a project that uses C++20, and uses ROOT compiled with C++17,. We currently do not support this mixing of standard. > However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. . This means that the example/test that have been run so far did not stress the interfaces that uses `std::span` (and/or your lucky that both version are similar enough). In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span` .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:658,deployability,version,version,658,"> In fact, I have a project that uses C++20, and uses ROOT compiled with C++17,. We currently do not support this mixing of standard. > However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. . This means that the example/test that have been run so far did not stress the interfaces that uses `std::span` (and/or your lucky that both version are similar enough). In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span` .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:84,energy efficiency,current,currently,84,"> In fact, I have a project that uses C++20, and uses ROOT compiled with C++17,. We currently do not support this mixing of standard. > However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. . This means that the example/test that have been run so far did not stress the interfaces that uses `std::span` (and/or your lucky that both version are similar enough). In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span` .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:380,integrability,interfac,interfaces,380,"> In fact, I have a project that uses C++20, and uses ROOT compiled with C++17,. We currently do not support this mixing of standard. > However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. . This means that the example/test that have been run so far did not stress the interfaces that uses `std::span` (and/or your lucky that both version are similar enough). In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span` .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:442,integrability,version,version,442,"> In fact, I have a project that uses C++20, and uses ROOT compiled with C++17,. We currently do not support this mixing of standard. > However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. . This means that the example/test that have been run so far did not stress the interfaces that uses `std::span` (and/or your lucky that both version are similar enough). In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span` .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:598,integrability,version,version,598,"> In fact, I have a project that uses C++20, and uses ROOT compiled with C++17,. We currently do not support this mixing of standard. > However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. . This means that the example/test that have been run so far did not stress the interfaces that uses `std::span` (and/or your lucky that both version are similar enough). In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span` .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:658,integrability,version,version,658,"> In fact, I have a project that uses C++20, and uses ROOT compiled with C++17,. We currently do not support this mixing of standard. > However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. . This means that the example/test that have been run so far did not stress the interfaces that uses `std::span` (and/or your lucky that both version are similar enough). In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span` .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:124,interoperability,standard,standard,124,"> In fact, I have a project that uses C++20, and uses ROOT compiled with C++17,. We currently do not support this mixing of standard. > However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. . This means that the example/test that have been run so far did not stress the interfaces that uses `std::span` (and/or your lucky that both version are similar enough). In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span` .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:380,interoperability,interfac,interfaces,380,"> In fact, I have a project that uses C++20, and uses ROOT compiled with C++17,. We currently do not support this mixing of standard. > However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. . This means that the example/test that have been run so far did not stress the interfaces that uses `std::span` (and/or your lucky that both version are similar enough). In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span` .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:380,modifiability,interfac,interfaces,380,"> In fact, I have a project that uses C++20, and uses ROOT compiled with C++17,. We currently do not support this mixing of standard. > However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. . This means that the example/test that have been run so far did not stress the interfaces that uses `std::span` (and/or your lucky that both version are similar enough). In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span` .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:442,modifiability,version,version,442,"> In fact, I have a project that uses C++20, and uses ROOT compiled with C++17,. We currently do not support this mixing of standard. > However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. . This means that the example/test that have been run so far did not stress the interfaces that uses `std::span` (and/or your lucky that both version are similar enough). In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span` .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:598,modifiability,version,version,598,"> In fact, I have a project that uses C++20, and uses ROOT compiled with C++17,. We currently do not support this mixing of standard. > However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. . This means that the example/test that have been run so far did not stress the interfaces that uses `std::span` (and/or your lucky that both version are similar enough). In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span` .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:658,modifiability,version,version,658,"> In fact, I have a project that uses C++20, and uses ROOT compiled with C++17,. We currently do not support this mixing of standard. > However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. . This means that the example/test that have been run so far did not stress the interfaces that uses `std::span` (and/or your lucky that both version are similar enough). In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span` .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:288,performance,time,time,288,"> In fact, I have a project that uses C++20, and uses ROOT compiled with C++17,. We currently do not support this mixing of standard. > However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. . This means that the example/test that have been run so far did not stress the interfaces that uses `std::span` (and/or your lucky that both version are similar enough). In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span` .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:474,reliability,pra,practice,474,"> In fact, I have a project that uses C++20, and uses ROOT compiled with C++17,. We currently do not support this mixing of standard. > However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. . This means that the example/test that have been run so far did not stress the interfaces that uses `std::span` (and/or your lucky that both version are similar enough). In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span` .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:513,reliability,doe,does,513,"> In fact, I have a project that uses C++20, and uses ROOT compiled with C++17,. We currently do not support this mixing of standard. > However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. . This means that the example/test that have been run so far did not stress the interfaces that uses `std::span` (and/or your lucky that both version are similar enough). In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span` .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:330,safety,test,test,330,"> In fact, I have a project that uses C++20, and uses ROOT compiled with C++17,. We currently do not support this mixing of standard. > However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. . This means that the example/test that have been run so far did not stress the interfaces that uses `std::span` (and/or your lucky that both version are similar enough). In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span` .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:497,safety,test,test,497,"> In fact, I have a project that uses C++20, and uses ROOT compiled with C++17,. We currently do not support this mixing of standard. > However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. . This means that the example/test that have been run so far did not stress the interfaces that uses `std::span` (and/or your lucky that both version are similar enough). In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span` .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:330,testability,test,test,330,"> In fact, I have a project that uses C++20, and uses ROOT compiled with C++17,. We currently do not support this mixing of standard. > However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. . This means that the example/test that have been run so far did not stress the interfaces that uses `std::span` (and/or your lucky that both version are similar enough). In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span` .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:497,testability,test,test,497,"> In fact, I have a project that uses C++20, and uses ROOT compiled with C++17,. We currently do not support this mixing of standard. > However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. . This means that the example/test that have been run so far did not stress the interfaces that uses `std::span` (and/or your lucky that both version are similar enough). In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span` .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:101,usability,support,support,101,"> In fact, I have a project that uses C++20, and uses ROOT compiled with C++17,. We currently do not support this mixing of standard. > However, once the restriction of this preprocessor macro is resolved, the compilation could pass, and no related problems have been encountered for the time being. . This means that the example/test that have been run so far did not stress the interfaces that uses `std::span` (and/or your lucky that both version are similar enough). In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span` .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1202,availability,avail,available,1202,"pan`. Exactly, that's the tricky part of this issue. If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... here is the normal implementation, too. };. }. ```. It seems that sometimes ROOT programming does not strictly follow the C++ standard... For me, it is not reassuring to rely on the well-defined situation of",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1809,availability,operat,operator,1809," If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... here is the normal implementation, too. };. }. ```. It seems that sometimes ROOT programming does not strictly follow the C++ standard... For me, it is not reassuring to rely on the well-defined situation of undefined behaviors. It is really tricky to handle.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1929,availability,operat,operator,1929," If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... here is the normal implementation, too. };. }. ```. It seems that sometimes ROOT programming does not strictly follow the C++ standard... For me, it is not reassuring to rely on the well-defined situation of undefined behaviors. It is really tricky to handle.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:129,deployability,version,version,129,"> In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span`. Exactly, that's the tricky part of this issue. If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:189,deployability,version,version,189,"> In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span`. Exactly, that's the tricky part of this issue. If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1259,deployability,API,API,1259," If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... here is the normal implementation, too. };. }. ```. It seems that sometimes ROOT programming does not strictly follow the C++ standard... For me, it is not reassuring to rely on the well-defined situation of undefined behaviors. It is really tricky to handle.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:129,integrability,version,version,129,"> In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span`. Exactly, that's the tricky part of this issue. If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:189,integrability,version,version,189,"> In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span`. Exactly, that's the tricky part of this issue. If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1259,integrability,API,API,1259," If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... here is the normal implementation, too. };. }. ```. It seems that sometimes ROOT programming does not strictly follow the C++ standard... For me, it is not reassuring to rely on the well-defined situation of undefined behaviors. It is really tricky to handle.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1790,integrability,pub,public,1790," If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... here is the normal implementation, too. };. }. ```. It seems that sometimes ROOT programming does not strictly follow the C++ standard... For me, it is not reassuring to rely on the well-defined situation of undefined behaviors. It is really tricky to handle.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1078,interoperability,convers,conversion,1078,"ule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span`. Exactly, that's the tricky part of this issue. If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... here is the normal implementation, too. };. }. ```. It seems that sometimes ROOT pr",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1098,interoperability,standard,standard,1098,". some of the code use one version of `std::span` and some of the code use a different version of `std::span`. Exactly, that's the tricky part of this issue. If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... here is the normal implementation, too. };. }. ```. It seems that sometimes ROOT programming does not ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1259,interoperability,API,API,1259," If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... here is the normal implementation, too. };. }. ```. It seems that sometimes ROOT programming does not strictly follow the C++ standard... For me, it is not reassuring to rely on the well-defined situation of undefined behaviors. It is really tricky to handle.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1314,interoperability,standard,standard,1314," If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... here is the normal implementation, too. };. }. ```. It seems that sometimes ROOT programming does not strictly follow the C++ standard... For me, it is not reassuring to rely on the well-defined situation of undefined behaviors. It is really tricky to handle.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1399,interoperability,convers,conversion,1399," If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... here is the normal implementation, too. };. }. ```. It seems that sometimes ROOT programming does not strictly follow the C++ standard... For me, it is not reassuring to rely on the well-defined situation of undefined behaviors. It is really tricky to handle.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:2126,interoperability,standard,standard,2126," If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... here is the normal implementation, too. };. }. ```. It seems that sometimes ROOT programming does not strictly follow the C++ standard... For me, it is not reassuring to rely on the well-defined situation of undefined behaviors. It is really tricky to handle.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:129,modifiability,version,version,129,"> In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span`. Exactly, that's the tricky part of this issue. If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:189,modifiability,version,version,189,"> In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span`. Exactly, that's the tricky part of this issue. If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1680,modifiability,Exten,Extent,1680," If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... here is the normal implementation, too. };. }. ```. It seems that sometimes ROOT programming does not strictly follow the C++ standard... For me, it is not reassuring to rely on the well-defined situation of undefined behaviors. It is really tricky to handle.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1831,modifiability,Exten,Extent,1831," If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... here is the normal implementation, too. };. }. ```. It seems that sometimes ROOT programming does not strictly follow the C++ standard... For me, it is not reassuring to rely on the well-defined situation of undefined behaviors. It is really tricky to handle.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1886,modifiability,Exten,Extent,1886," If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... here is the normal implementation, too. };. }. ```. It seems that sometimes ROOT programming does not strictly follow the C++ standard... For me, it is not reassuring to rely on the well-defined situation of undefined behaviors. It is really tricky to handle.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1958,modifiability,Exten,Extent,1958," If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... here is the normal implementation, too. };. }. ```. It seems that sometimes ROOT programming does not strictly follow the C++ standard... For me, it is not reassuring to rely on the well-defined situation of undefined behaviors. It is really tricky to handle.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:5,reliability,pra,practice,5,"> In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span`. Exactly, that's the tricky part of this issue. If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:44,reliability,doe,does,44,"> In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span`. Exactly, that's the tricky part of this issue. If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:956,reliability,pra,practice,956,"> In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span`. Exactly, that's the tricky part of this issue. If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1202,reliability,availab,available,1202,"pan`. Exactly, that's the tricky part of this issue. If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... here is the normal implementation, too. };. }. ```. It seems that sometimes ROOT programming does not strictly follow the C++ standard... For me, it is not reassuring to rely on the well-defined situation of",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:2093,reliability,doe,does,2093," If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... here is the normal implementation, too. };. }. ```. It seems that sometimes ROOT programming does not strictly follow the C++ standard... For me, it is not reassuring to rely on the well-defined situation of undefined behaviors. It is really tricky to handle.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:28,safety,test,test,28,"> In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span`. Exactly, that's the tricky part of this issue. If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:290,safety,avoid,avoid,290,"> In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span`. Exactly, that's the tricky part of this issue. If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:821,safety,test,test,821,"> In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span`. Exactly, that's the tricky part of this issue. If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1202,safety,avail,available,1202,"pan`. Exactly, that's the tricky part of this issue. If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... here is the normal implementation, too. };. }. ```. It seems that sometimes ROOT programming does not strictly follow the C++ standard... For me, it is not reassuring to rely on the well-defined situation of",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1202,security,availab,available,1202,"pan`. Exactly, that's the tricky part of this issue. If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... here is the normal implementation, too. };. }. ```. It seems that sometimes ROOT programming does not strictly follow the C++ standard... For me, it is not reassuring to rely on the well-defined situation of",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1285,security,expos,exposed,1285," If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... here is the normal implementation, too. };. }. ```. It seems that sometimes ROOT programming does not strictly follow the C++ standard... For me, it is not reassuring to rely on the well-defined situation of undefined behaviors. It is really tricky to handle.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:28,testability,test,test,28,"> In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span`. Exactly, that's the tricky part of this issue. If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:430,testability,understand,understand,430,"> In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span`. Exactly, that's the tricky part of this issue. If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:821,testability,test,test,821,"> In practice, changing the test as this PR does introduces a ODR (one definition rule) violation: i.e. some of the code use one version of `std::span` and some of the code use a different version of `std::span`. Exactly, that's the tricky part of this issue. If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1129,usability,user,users,1129,"sion of `std::span` and some of the code use a different version of `std::span`. Exactly, that's the tricky part of this issue. If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... here is the normal implementation, too. };. }. ```. It seems that sometimes ROOT programming does not strictly follow the C++ standa",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1332,usability,user,users,1332," If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... here is the normal implementation, too. };. }. ```. It seems that sometimes ROOT programming does not strictly follow the C++ standard... For me, it is not reassuring to rely on the well-defined situation of undefined behaviors. It is really tricky to handle.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:2218,usability,behavi,behaviors,2218," If no other means are used to avoid problems, and the compilation is successful, directly adding the same name to the std will potentially lead to many surprises. . If I understand correctly, the same is true for `std::string_view`. See `RStringView.hxx`:. ```C++. #if defined(R__HAS_STD_STRING_VIEW) || R__MSVC_LANG >= 201703L || __cplusplus >= 201703L. #include <string_view>. #else. # if defined(R__HAS_STD_EXPERIMENTAL_STRING_VIEW). # include <experimental/string_view>. # else. # include ""RWrap_libcpp_string_view.h"". # endif. ```. There is also a feature test macro. If someone uses C++17 and links to the ROOT compiled by C++14, they might encounter the same issue. I think it is a better practice to change a namespace (such as `cxx20::span`, `cxx17::string_view`, etc.) and provide the corresponding implicit conversion when the standard matches. In this way, users will not be disturbed to use normally, and these features are also available inside ROOT. The only symmetry break is in the API. Because the features exposed are not those of the standard library, users may need to manually convert them in some cases, so implicit conversion should be provided. . For example:. ```C++. #if __cplusplus >= 202002L. # include <span>. #endif. namespace cxx20 {. constexpr std::size_t dynamic_extent =. #if __cplusplus >= 202002L. std::dynamic_extent;. #else. /* something */;. #endif. template<class T, std::size_t Extent = dynamic_extent>. class span {. // ... here is the normal implementation. #if __cplusplus >= 202002L. public:. constexpr operator std::span<T, Extent>() noexcept;. constexpr span(const std::span<T, Extent>& other) noexcept;. constexpr span& operator=(const std::span<T, Extent>& other) noexcept;. #endif. // ... here is the normal implementation, too. };. }. ```. It seems that sometimes ROOT programming does not strictly follow the C++ standard... For me, it is not reassuring to rely on the well-defined situation of undefined behaviors. It is really tricky to handle.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:90,integrability,configur,configure,90,We require that the language standard including the header is the same as the one used to configure ROOT. Would enforcing that be another option to solve this? Can you point me to documentation of GCC stating that mixing language standards across libraries is supported?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:29,interoperability,standard,standard,29,We require that the language standard including the header is the same as the one used to configure ROOT. Would enforcing that be another option to solve this? Can you point me to documentation of GCC stating that mixing language standards across libraries is supported?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:230,interoperability,standard,standards,230,We require that the language standard including the header is the same as the one used to configure ROOT. Would enforcing that be another option to solve this? Can you point me to documentation of GCC stating that mixing language standards across libraries is supported?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:90,modifiability,configur,configure,90,We require that the language standard including the header is the same as the one used to configure ROOT. Would enforcing that be another option to solve this? Can you point me to documentation of GCC stating that mixing language standards across libraries is supported?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:90,security,configur,configure,90,We require that the language standard including the header is the same as the one used to configure ROOT. Would enforcing that be another option to solve this? Can you point me to documentation of GCC stating that mixing language standards across libraries is supported?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:180,usability,document,documentation,180,We require that the language standard including the header is the same as the one used to configure ROOT. Would enforcing that be another option to solve this? Can you point me to documentation of GCC stating that mixing language standards across libraries is supported?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:260,usability,support,supported,260,We require that the language standard including the header is the same as the one used to configure ROOT. Would enforcing that be another option to solve this? Can you point me to documentation of GCC stating that mixing language standards across libraries is supported?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:219,deployability,API,API,219,"If I understand correctly, this basically involves ABI compatibility. According to the GCC [document (ABI policy)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), in C++, ABI is a mixture of standard library API and compiler ABI. Suppose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header fi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:426,deployability,API,API,426,"If I understand correctly, this basically involves ABI compatibility. According to the GCC [document (ABI policy)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), in C++, ABI is a mixture of standard library API and compiler ABI. Suppose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header fi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:672,deployability,automat,automatically,672,"If I understand correctly, this basically involves ABI compatibility. According to the GCC [document (ABI policy)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), in C++, ABI is a mixture of standard library API and compiler ABI. Suppose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header fi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:735,deployability,API,API,735,"If I understand correctly, this basically involves ABI compatibility. According to the GCC [document (ABI policy)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), in C++, ABI is a mixture of standard library API and compiler ABI. Suppose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header fi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1282,deployability,version,version,1282,"d libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header file, the only thing left is to ensure ABI compatibility, which should be guaranteed by the compiler. It can be said that if the current `span` implementation of ROOT is compatible with the implementation of the standard library, the problem of mixed standards is not serious, but it is d",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1460,deployability,observ,observable,1460,"atible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header file, the only thing left is to ensure ABI compatibility, which should be guaranteed by the compiler. It can be said that if the current `span` implementation of ROOT is compatible with the implementation of the standard library, the problem of mixed standards is not serious, but it is difficult to always guarantee. But as I said, if there is something like `cxx20::span` instead of crashing with the standard library, this issue can be solved from its source. The ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1751,deployability,Stack,StackOverflow,1751," with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header file, the only thing left is to ensure ABI compatibility, which should be guaranteed by the compiler. It can be said that if the current `span` implementation of ROOT is compatible with the implementation of the standard library, the problem of mixed standards is not serious, but it is difficult to always guarantee. But as I said, if there is something like `cxx20::span` instead of crashing with the standard library, this issue can be solved from its source. The rest is just the ABI compatibility of this `cxx20::span`, which is guaranteed by the compiler.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1774,deployability,stack,stackoverflow,1774," with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header file, the only thing left is to ensure ABI compatibility, which should be guaranteed by the compiler. It can be said that if the current `span` implementation of ROOT is compatible with the implementation of the standard library, the problem of mixed standards is not serious, but it is difficult to always guarantee. But as I said, if there is something like `cxx20::span` instead of crashing with the standard library, this issue can be solved from its source. The rest is just the ABI compatibility of this `cxx20::span`, which is guaranteed by the compiler.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1914,energy efficiency,current,current,1914," with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header file, the only thing left is to ensure ABI compatibility, which should be guaranteed by the compiler. It can be said that if the current `span` implementation of ROOT is compatible with the implementation of the standard library, the problem of mixed standards is not serious, but it is difficult to always guarantee. But as I said, if there is something like `cxx20::span` instead of crashing with the standard library, this issue can be solved from its source. The rest is just the ABI compatibility of this `cxx20::span`, which is guaranteed by the compiler.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:2127,energy efficiency,current,current,2127," with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header file, the only thing left is to ensure ABI compatibility, which should be guaranteed by the compiler. It can be said that if the current `span` implementation of ROOT is compatible with the implementation of the standard library, the problem of mixed standards is not serious, but it is difficult to always guarantee. But as I said, if there is something like `cxx20::span` instead of crashing with the standard library, this issue can be solved from its source. The rest is just the ABI compatibility of this `cxx20::span`, which is guaranteed by the compiler.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:219,integrability,API,API,219,"If I understand correctly, this basically involves ABI compatibility. According to the GCC [document (ABI policy)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), in C++, ABI is a mixture of standard library API and compiler ABI. Suppose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header fi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:426,integrability,API,API,426,"If I understand correctly, this basically involves ABI compatibility. According to the GCC [document (ABI policy)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), in C++, ABI is a mixture of standard library API and compiler ABI. Suppose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header fi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:735,integrability,API,API,735,"If I understand correctly, this basically involves ABI compatibility. According to the GCC [document (ABI policy)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), in C++, ABI is a mixture of standard library API and compiler ABI. Suppose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header fi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1282,integrability,version,version,1282,"d libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header file, the only thing left is to ensure ABI compatibility, which should be guaranteed by the compiler. It can be said that if the current `span` implementation of ROOT is compatible with the implementation of the standard library, the problem of mixed standards is not serious, but it is d",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:55,interoperability,compatib,compatibility,55,"If I understand correctly, this basically involves ABI compatibility. According to the GCC [document (ABI policy)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), in C++, ABI is a mixture of standard library API and compiler ABI. Suppose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header fi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:202,interoperability,standard,standard,202,"If I understand correctly, this basically involves ABI compatibility. According to the GCC [document (ABI policy)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), in C++, ABI is a mixture of standard library API and compiler ABI. Suppose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header fi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:219,interoperability,API,API,219,"If I understand correctly, this basically involves ABI compatibility. According to the GCC [document (ABI policy)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), in C++, ABI is a mixture of standard library API and compiler ABI. Suppose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header fi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:316,interoperability,compatib,compatible,316,"If I understand correctly, this basically involves ABI compatibility. According to the GCC [document (ABI policy)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), in C++, ABI is a mixture of standard library API and compiler ABI. Suppose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header fi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:342,interoperability,standard,standard,342,"If I understand correctly, this basically involves ABI compatibility. According to the GCC [document (ABI policy)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), in C++, ABI is a mixture of standard library API and compiler ABI. Suppose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header fi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:398,interoperability,compatib,compatible,398,"If I understand correctly, this basically involves ABI compatibility. According to the GCC [document (ABI policy)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), in C++, ABI is a mixture of standard library API and compiler ABI. Suppose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header fi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:409,interoperability,standard,standard,409,"If I understand correctly, this basically involves ABI compatibility. According to the GCC [document (ABI policy)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), in C++, ABI is a mixture of standard library API and compiler ABI. Suppose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header fi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:426,interoperability,API,API,426,"If I understand correctly, this basically involves ABI compatibility. According to the GCC [document (ABI policy)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), in C++, ABI is a mixture of standard library API and compiler ABI. Suppose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header fi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:461,interoperability,compatib,compatible,461,"If I understand correctly, this basically involves ABI compatibility. According to the GCC [document (ABI policy)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), in C++, ABI is a mixture of standard library API and compiler ABI. Suppose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header fi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:718,interoperability,standard,standard,718,"If I understand correctly, this basically involves ABI compatibility. According to the GCC [document (ABI policy)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), in C++, ABI is a mixture of standard library API and compiler ABI. Suppose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header fi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:735,interoperability,API,API,735,"If I understand correctly, this basically involves ABI compatibility. According to the GCC [document (ABI policy)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), in C++, ABI is a mixture of standard library API and compiler ABI. Suppose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header fi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:742,interoperability,specif,specified,742,"If I understand correctly, this basically involves ABI compatibility. According to the GCC [document (ABI policy)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), in C++, ABI is a mixture of standard library API and compiler ABI. Suppose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header fi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:814,interoperability,standard,standard,814,"If I understand correctly, this basically involves ABI compatibility. According to the GCC [document (ABI policy)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), in C++, ABI is a mixture of standard library API and compiler ABI. Suppose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header fi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:834,interoperability,compatib,compatible,834,"If I understand correctly, this basically involves ABI compatibility. According to the GCC [document (ABI policy)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), in C++, ABI is a mixture of standard library API and compiler ABI. Suppose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header fi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:863,interoperability,standard,standards,863,"If I understand correctly, this basically involves ABI compatibility. According to the GCC [document (ABI policy)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), in C++, ABI is a mixture of standard library API and compiler ABI. Suppose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header fi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:915,interoperability,compatib,compatible,915,"If I understand correctly, this basically involves ABI compatibility. According to the GCC [document (ABI policy)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), in C++, ABI is a mixture of standard library API and compiler ABI. Suppose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header fi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:965,interoperability,standard,standards,965,"If I understand correctly, this basically involves ABI compatibility. According to the GCC [document (ABI policy)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), in C++, ABI is a mixture of standard library API and compiler ABI. Suppose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header fi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1094,interoperability,standard,standards,1094,"t (ABI policy)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), in C++, ABI is a mixture of standard library API and compiler ABI. Suppose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header file, the only thing left is to ensure ABI compatibility, which should be guaranteed by the compiler.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1254,interoperability,compatib,compatible,1254,"two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header file, the only thing left is to ensure ABI compatibility, which should be guaranteed by the compiler. It can be said that if the current `span` implementation of ROOT is compatible with the implementation of the standard library, the problem of mixed standards ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1560,interoperability,standard,standards,1560," with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header file, the only thing left is to ensure ABI compatibility, which should be guaranteed by the compiler. It can be said that if the current `span` implementation of ROOT is compatible with the implementation of the standard library, the problem of mixed standards is not serious, but it is difficult to always guarantee. But as I said, if there is something like `cxx20::span` instead of crashing with the standard library, this issue can be solved from its source. The rest is just the ABI compatibility of this `cxx20::span`, which is guaranteed by the compiler.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:2041,interoperability,compatib,compatibility,2041," with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header file, the only thing left is to ensure ABI compatibility, which should be guaranteed by the compiler. It can be said that if the current `span` implementation of ROOT is compatible with the implementation of the standard library, the problem of mixed standards is not serious, but it is difficult to always guarantee. But as I said, if there is something like `cxx20::span` instead of crashing with the standard library, this issue can be solved from its source. The rest is just the ABI compatibility of this `cxx20::span`, which is guaranteed by the compiler.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:2168,interoperability,compatib,compatible,2168," with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header file, the only thing left is to ensure ABI compatibility, which should be guaranteed by the compiler. It can be said that if the current `span` implementation of ROOT is compatible with the implementation of the standard library, the problem of mixed standards is not serious, but it is difficult to always guarantee. But as I said, if there is something like `cxx20::span` instead of crashing with the standard library, this issue can be solved from its source. The rest is just the ABI compatibility of this `cxx20::span`, which is guaranteed by the compiler.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:2210,interoperability,standard,standard,2210," with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header file, the only thing left is to ensure ABI compatibility, which should be guaranteed by the compiler. It can be said that if the current `span` implementation of ROOT is compatible with the implementation of the standard library, the problem of mixed standards is not serious, but it is difficult to always guarantee. But as I said, if there is something like `cxx20::span` instead of crashing with the standard library, this issue can be solved from its source. The rest is just the ABI compatibility of this `cxx20::span`, which is guaranteed by the compiler.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:2249,interoperability,standard,standards,2249," with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header file, the only thing left is to ensure ABI compatibility, which should be guaranteed by the compiler. It can be said that if the current `span` implementation of ROOT is compatible with the implementation of the standard library, the problem of mixed standards is not serious, but it is difficult to always guarantee. But as I said, if there is something like `cxx20::span` instead of crashing with the standard library, this issue can be solved from its source. The rest is just the ABI compatibility of this `cxx20::span`, which is guaranteed by the compiler.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:2401,interoperability,standard,standard,2401," with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header file, the only thing left is to ensure ABI compatibility, which should be guaranteed by the compiler. It can be said that if the current `span` implementation of ROOT is compatible with the implementation of the standard library, the problem of mixed standards is not serious, but it is difficult to always guarantee. But as I said, if there is something like `cxx20::span` instead of crashing with the standard library, this issue can be solved from its source. The rest is just the ABI compatibility of this `cxx20::span`, which is guaranteed by the compiler.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:2486,interoperability,compatib,compatibility,2486," with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header file, the only thing left is to ensure ABI compatibility, which should be guaranteed by the compiler. It can be said that if the current `span` implementation of ROOT is compatible with the implementation of the standard library, the problem of mixed standards is not serious, but it is difficult to always guarantee. But as I said, if there is something like `cxx20::span` instead of crashing with the standard library, this issue can be solved from its source. The rest is just the ABI compatibility of this `cxx20::span`, which is guaranteed by the compiler.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1282,modifiability,version,version,1282,"d libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header file, the only thing left is to ensure ABI compatibility, which should be guaranteed by the compiler. It can be said that if the current `span` implementation of ROOT is compatible with the implementation of the standard library, the problem of mixed standards is not serious, but it is d",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:988,reliability,pra,practice,988,"If I understand correctly, this basically involves ABI compatibility. According to the GCC [document (ABI policy)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), in C++, ABI is a mixture of standard library API and compiler ABI. Suppose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header fi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1443,reliability,doe,does,1443,"I, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header file, the only thing left is to ensure ABI compatibility, which should be guaranteed by the compiler. It can be said that if the current `span` implementation of ROOT is compatible with the implementation of the standard library, the problem of mixed standards is not serious, but it is difficult to always guarantee. But as I said, if there is something like `cxx20::span` instead of crashing with the standard library, this issue can be solved f",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1497,reliability,doe,does,1497,"s long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header file, the only thing left is to ensure ABI compatibility, which should be guaranteed by the compiler. It can be said that if the current `span` implementation of ROOT is compatible with the implementation of the standard library, the problem of mixed standards is not serious, but it is difficult to always guarantee. But as I said, if there is something like `cxx20::span` instead of crashing with the standard library, this issue can be solved from its source. The rest is just the ABI compatibility",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:327,safety,except,except,327,"If I understand correctly, this basically involves ABI compatibility. According to the GCC [document (ABI policy)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), in C++, ABI is a mixture of standard library API and compiler ABI. Suppose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header fi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1817,safety,safe,safe-to-link-,1817," with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header file, the only thing left is to ensure ABI compatibility, which should be guaranteed by the compiler. It can be said that if the current `span` implementation of ROOT is compatible with the implementation of the standard library, the problem of mixed standards is not serious, but it is difficult to always guarantee. But as I said, if there is something like `cxx20::span` instead of crashing with the standard library, this issue can be solved from its source. The rest is just the ABI compatibility of this `cxx20::span`, which is guaranteed by the compiler.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:106,security,polic,policy,106,"If I understand correctly, this basically involves ABI compatibility. According to the GCC [document (ABI policy)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), in C++, ABI is a mixture of standard library API and compiler ABI. Suppose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header fi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:755,security,ISO,ISO,755,"If I understand correctly, this basically involves ABI compatibility. According to the GCC [document (ABI policy)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), in C++, ABI is a mixture of standard library API and compiler ABI. Suppose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header fi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1014,security,token,tokens,1014,"orrectly, this basically involves ABI compatibility. According to the GCC [document (ABI policy)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), in C++, ABI is a mixture of standard library API and compiler ABI. Suppose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header file, the only thin",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1595,security,polic,policy,1595," with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header file, the only thing left is to ensure ABI compatibility, which should be guaranteed by the compiler. It can be said that if the current `span` implementation of ROOT is compatible with the implementation of the standard library, the problem of mixed standards is not serious, but it is difficult to always guarantee. But as I said, if there is something like `cxx20::span` instead of crashing with the standard library, this issue can be solved from its source. The rest is just the ABI compatibility of this `cxx20::span`, which is guaranteed by the compiler.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:5,testability,understand,understand,5,"If I understand correctly, this basically involves ABI compatibility. According to the GCC [document (ABI policy)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), in C++, ABI is a mixture of standard library API and compiler ABI. Suppose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header fi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:672,testability,automat,automatically,672,"If I understand correctly, this basically involves ABI compatibility. According to the GCC [document (ABI policy)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), in C++, ABI is a mixture of standard library API and compiler ABI. Suppose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header fi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1460,testability,observ,observable,1460,"atible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header file, the only thing left is to ensure ABI compatibility, which should be guaranteed by the compiler. It can be said that if the current `span` implementation of ROOT is compatible with the implementation of the standard library, the problem of mixed standards is not serious, but it is difficult to always guarantee. But as I said, if there is something like `cxx20::span` instead of crashing with the standard library, this issue can be solved from its source. The ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:92,usability,document,document,92,"If I understand correctly, this basically involves ABI compatibility. According to the GCC [document (ABI policy)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), in C++, ABI is a mixture of standard library API and compiler ABI. Suppose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header fi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:509,usability,user,users,509,"If I understand correctly, this basically involves ABI compatibility. According to the GCC [document (ABI policy)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), in C++, ABI is a mixture of standard library API and compiler ABI. Suppose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header fi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:631,usability,behavi,behavior,631,"If I understand correctly, this basically involves ABI compatibility. According to the GCC [document (ABI policy)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), in C++, ABI is a mixture of standard library API and compiler ABI. Suppose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header fi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1240,usability,behavi,behaviors,1240,"ose there are two ideal libraries libA and libB (that is, they are ABI compatible except for the standard library), as long as they are generated by the compatible standard library API and compiler ABI, they are ABI compatible. From this point of view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header file, the only thing left is to ensure ABI compatibility, which should be guaranteed by the compiler. It can be said that if the current `span` implementation of ROOT is compatible with the implementation of the standard library, the problem of mi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1488,usability,document,document,1488,"view, as long as users use the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header file, the only thing left is to ensure ABI compatibility, which should be guaranteed by the compiler. It can be said that if the current `span` implementation of ROOT is compatible with the implementation of the standard library, the problem of mixed standards is not serious, but it is difficult to always guarantee. But as I said, if there is something like `cxx20::span` instead of crashing with the standard library, this issue can be solved from its source. The rest is just the ABI compat",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1514,usability,clear,clearly,1514," the same compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header file, the only thing left is to ensure ABI compatibility, which should be guaranteed by the compiler. It can be said that if the current `span` implementation of ROOT is compatible with the implementation of the standard library, the problem of mixed standards is not serious, but it is difficult to always guarantee. But as I said, if there is something like `cxx20::span` instead of crashing with the standard library, this issue can be solved from its source. The rest is just the ABI compatibility of this `cxx20::sp",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1522,usability,indicat,indicate,1522,"e compiler (or at least compilers with the same compiler ABI) to compile libA and libB (this is a common behavior), the compiler ABI condition is automatically met. On the other hand, the C++ standard library API is specified by ISO C++, and we can believe that the implementation of the standard library is compatible between different standards. So generally speaking, libA and libB are compatible even if they are compiled by different standards. However, in practice, the sequence of tokens of the same entity in the library may be different between different C++ standards, so the same symbol (such as a function) may correspond to different binaries, which indeed violates the ODR. However, as long as their behaviors are compatible, no matter which version of the linker is selected, there should be no serious problems. In other words, it can be considered that this is only a minor ODR violation, because it does not produce observable effects. The GCC document does not seem to clearly indicate whether compiling with mixed standards would work, but its [ABI policy](https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html) seems to imply that this is feasible. In addition, this issue has also been [discussed on StackOverflow](https://stackoverflow.com/questions/46746878/is-it-safe-to-link-c17-c14-and-c11-objects), and the view is that it is feasible to do so. Back to our current issue, ideally, as long as there is no explicit ODR violation in the header file, the only thing left is to ensure ABI compatibility, which should be guaranteed by the compiler. It can be said that if the current `span` implementation of ROOT is compatible with the implementation of the standard library, the problem of mixed standards is not serious, but it is difficult to always guarantee. But as I said, if there is something like `cxx20::span` instead of crashing with the standard library, this issue can be solved from its source. The rest is just the ABI compatibility of this `cxx20::span`, whi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:45,availability,state,states,45,"I cannot follow. Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? Jonathan Wakely's statement is indeed an excellent indication, but this is still not guaranteed, only ""an important property of our implementation which we work hard to ensure"", and he explicitly calls out something people don't realize: this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:151,availability,state,statement,151,"I cannot follow. Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? Jonathan Wakely's statement is indeed an excellent indication, but this is still not guaranteed, only ""an important property of our implementation which we work hard to ensure"", and he explicitly calls out something people don't realize: this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:78,deployability,API,API,78,"I cannot follow. Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? Jonathan Wakely's statement is indeed an excellent indication, but this is still not guaranteed, only ""an important property of our implementation which we work hard to ensure"", and he explicitly calls out something people don't realize: this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:123,deployability,version,versions,123,"I cannot follow. Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? Jonathan Wakely's statement is indeed an excellent indication, but this is still not guaranteed, only ""an important property of our implementation which we work hard to ensure"", and he explicitly calls out something people don't realize: this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:524,deployability,version,versions,524,"I cannot follow. Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? Jonathan Wakely's statement is indeed an excellent indication, but this is still not guaranteed, only ""an important property of our implementation which we work hard to ensure"", and he explicitly calls out something people don't realize: this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:45,integrability,state,states,45,"I cannot follow. Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? Jonathan Wakely's statement is indeed an excellent indication, but this is still not guaranteed, only ""an important property of our implementation which we work hard to ensure"", and he explicitly calls out something people don't realize: this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:78,integrability,API,API,78,"I cannot follow. Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? Jonathan Wakely's statement is indeed an excellent indication, but this is still not guaranteed, only ""an important property of our implementation which we work hard to ensure"", and he explicitly calls out something people don't realize: this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:123,integrability,version,versions,123,"I cannot follow. Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? Jonathan Wakely's statement is indeed an excellent indication, but this is still not guaranteed, only ""an important property of our implementation which we work hard to ensure"", and he explicitly calls out something people don't realize: this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:151,integrability,state,statement,151,"I cannot follow. Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? Jonathan Wakely's statement is indeed an excellent indication, but this is still not guaranteed, only ""an important property of our implementation which we work hard to ensure"", and he explicitly calls out something people don't realize: this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:524,integrability,version,versions,524,"I cannot follow. Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? Jonathan Wakely's statement is indeed an excellent indication, but this is still not guaranteed, only ""an important property of our implementation which we work hard to ensure"", and he explicitly calls out something people don't realize: this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:78,interoperability,API,API,78,"I cannot follow. Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? Jonathan Wakely's statement is indeed an excellent indication, but this is still not guaranteed, only ""an important property of our implementation which we work hard to ensure"", and he explicitly calls out something people don't realize: this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:85,interoperability,compatib,compatible,85,"I cannot follow. Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? Jonathan Wakely's statement is indeed an excellent indication, but this is still not guaranteed, only ""an important property of our implementation which we work hard to ensure"", and he explicitly calls out something people don't realize: this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:114,interoperability,standard,standard,114,"I cannot follow. Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? Jonathan Wakely's statement is indeed an excellent indication, but this is still not guaranteed, only ""an important property of our implementation which we work hard to ensure"", and he explicitly calls out something people don't realize: this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:515,interoperability,standard,standard,515,"I cannot follow. Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? Jonathan Wakely's statement is indeed an excellent indication, but this is still not guaranteed, only ""an important property of our implementation which we work hard to ensure"", and he explicitly calls out something people don't realize: this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:769,interoperability,standard,standard,769,"I cannot follow. Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? Jonathan Wakely's statement is indeed an excellent indication, but this is still not guaranteed, only ""an important property of our implementation which we work hard to ensure"", and he explicitly calls out something people don't realize: this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:123,modifiability,version,versions,123,"I cannot follow. Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? Jonathan Wakely's statement is indeed an excellent indication, but this is still not guaranteed, only ""an important property of our implementation which we work hard to ensure"", and he explicitly calls out something people don't realize: this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:524,modifiability,version,versions,524,"I cannot follow. Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? Jonathan Wakely's statement is indeed an excellent indication, but this is still not guaranteed, only ""an important property of our implementation which we work hard to ensure"", and he explicitly calls out something people don't realize: this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:783,reliability,doe,doesn,783,"I cannot follow. Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? Jonathan Wakely's statement is indeed an excellent indication, but this is still not guaranteed, only ""an important property of our implementation which we work hard to ensure"", and he explicitly calls out something people don't realize: this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:547,testability,understand,understand,547,"I cannot follow. Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? Jonathan Wakely's statement is indeed an excellent indication, but this is still not guaranteed, only ""an important property of our implementation which we work hard to ensure"", and he explicitly calls out something people don't realize: this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:184,usability,indicat,indication,184,"I cannot follow. Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? Jonathan Wakely's statement is indeed an excellent indication, but this is still not guaranteed, only ""an important property of our implementation which we work hard to ensure"", and he explicitly calls out something people don't realize: this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:402,usability,support,support,402,"I cannot follow. Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? Jonathan Wakely's statement is indeed an excellent indication, but this is still not guaranteed, only ""an important property of our implementation which we work hard to ensure"", and he explicitly calls out something people don't realize: this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:606,usability,user,users,606,"I cannot follow. Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? Jonathan Wakely's statement is indeed an excellent indication, but this is still not guaranteed, only ""an important property of our implementation which we work hard to ensure"", and he explicitly calls out something people don't realize: this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:774,availability,state,states,774,"> ... this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. As for mangling (as part of ABI): as long as the API of the standard library and the ABI used by the compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not int",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:2321,availability,avail,available,2321," to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with? My opinion is to allow this, even if it is not recommended. As mentioned above, issues result from cross standards are mainly caused by changes in the header API. If ROOT has confidence in the compatibility of header files across standards, I don't think it is necessary to worry about mixing standards. If there are still some po",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:159,deployability,version,versions,159,"> ... this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. As for mangling (as part of ABI): as long as the API of the standard library and the ABI used by the compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not int",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:218,deployability,API,API,218,"> ... this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. As for mangling (as part of ABI): as long as the API of the standard library and the ABI used by the compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not int",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:458,deployability,API,API,458,"> ... this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. As for mangling (as part of ABI): as long as the API of the standard library and the ABI used by the compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not int",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:807,deployability,API,API,807,"> ... this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. As for mangling (as part of ABI): as long as the API of the standard library and the ABI used by the compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not int",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:852,deployability,version,versions,852,"> ... this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. As for mangling (as part of ABI): as long as the API of the standard library and the ABI used by the compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not int",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1730,deployability,version,version,1730,"he same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `s",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:2177,deployability,upgrad,upgrade,2177,"s compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with? My opinion is to allow this, even if it is not recommended. As mentioned above, issues result from cross standards are mainly caused by changes in the header API. If ROOT has confidence",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:2197,deployability,version,version,2197,"uaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with? My opinion is to allow this, even if it is not recommended. As mentioned above, issues result from cross standards are mainly caused by changes in the header API. If ROOT has confidence in the compatibilit",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:3154,deployability,API,API,3154," same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with? My opinion is to allow this, even if it is not recommended. As mentioned above, issues result from cross standards are mainly caused by changes in the header API. If ROOT has confidence in the compatibility of header files across standards, I don't think it is necessary to worry about mixing standards. If there are still some potential issues, I think it is beneficial to . firstly ensure successful compilation when mixing standards.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1460,energy efficiency,current,current,1460," the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasibl",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:159,integrability,version,versions,159,"> ... this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. As for mangling (as part of ABI): as long as the API of the standard library and the ABI used by the compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not int",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:218,integrability,API,API,218,"> ... this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. As for mangling (as part of ABI): as long as the API of the standard library and the ABI used by the compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not int",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:458,integrability,API,API,458,"> ... this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. As for mangling (as part of ABI): as long as the API of the standard library and the ABI used by the compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not int",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:774,integrability,state,states,774,"> ... this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. As for mangling (as part of ABI): as long as the API of the standard library and the ABI used by the compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not int",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:807,integrability,API,API,807,"> ... this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. As for mangling (as part of ABI): as long as the API of the standard library and the ABI used by the compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not int",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:852,integrability,version,versions,852,"> ... this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. As for mangling (as part of ABI): as long as the API of the standard library and the ABI used by the compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not int",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1730,integrability,version,version,1730,"he same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `s",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1874,integrability,interfac,interface,1874,"t found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:2166,integrability,sub,subsequent,2166,"k that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with? My opinion is to allow this, even if it is not recommended. As mentioned above, issues result from cross standards are mainly caused by changes in the header API. If ROOT has ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:2197,integrability,version,version,2197,"uaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with? My opinion is to allow this, even if it is not recommended. As mentioned above, issues result from cross standards are mainly caused by changes in the header API. If ROOT has confidence in the compatibilit",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:3154,integrability,API,API,3154," same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with? My opinion is to allow this, even if it is not recommended. As mentioned above, issues result from cross standards are mainly caused by changes in the header API. If ROOT has confidence in the compatibility of header files across standards, I don't think it is necessary to worry about mixing standards. If there are still some potential issues, I think it is beneficial to . firstly ensure successful compilation when mixing standards.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:150,interoperability,standard,standard,150,"> ... this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. As for mangling (as part of ABI): as long as the API of the standard library and the ABI used by the compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not int",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:218,interoperability,API,API,218,"> ... this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. As for mangling (as part of ABI): as long as the API of the standard library and the ABI used by the compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not int",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:229,interoperability,standard,standard,229,"> ... this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. As for mangling (as part of ABI): as long as the API of the standard library and the ABI used by the compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not int",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:458,interoperability,API,API,458,"> ... this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. As for mangling (as part of ABI): as long as the API of the standard library and the ABI used by the compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not int",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:469,interoperability,standard,standard,469,"> ... this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. As for mangling (as part of ABI): as long as the API of the standard library and the ABI used by the compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not int",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:504,interoperability,standard,standards,504,"> ... this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. As for mangling (as part of ABI): as long as the API of the standard library and the ABI used by the compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not int",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:519,interoperability,compatib,compatibility,519,"> ... this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. As for mangling (as part of ABI): as long as the API of the standard library and the ABI used by the compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not int",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:601,interoperability,standard,standard,601,"> ... this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. As for mangling (as part of ABI): as long as the API of the standard library and the ABI used by the compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not int",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:807,interoperability,API,API,807,"> ... this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. As for mangling (as part of ABI): as long as the API of the standard library and the ABI used by the compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not int",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:814,interoperability,compatib,compatible,814,"> ... this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. As for mangling (as part of ABI): as long as the API of the standard library and the ABI used by the compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not int",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:843,interoperability,standard,standard,843,"> ... this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. As for mangling (as part of ABI): as long as the API of the standard library and the ABI used by the compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not int",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:913,interoperability,standard,standard,913,"> ... this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. As for mangling (as part of ABI): as long as the API of the standard library and the ABI used by the compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not int",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1001,interoperability,standard,standards,1001,"this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. As for mangling (as part of ABI): as long as the API of the standard library and the ABI used by the compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1039,interoperability,compatib,compatibility,1039,"s deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. As for mangling (as part of ABI): as long as the API of the standard library and the ABI used by the compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::sp",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1088,interoperability,compatib,compatibility,1088," guaranteed, for instance mangling has changed between standard versions. As for mangling (as part of ABI): as long as the API of the standard library and the ABI used by the compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1113,interoperability,standard,standard,1113,"nce mangling has changed between standard versions. As for mangling (as part of ABI): as long as the API of the standard library and the ABI used by the compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation fro",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1183,interoperability,compatib,compatibility,1183,"art of ABI): as long as the API of the standard library and the ABI used by the compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1438,interoperability,standard,standard,1438," as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standar",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1590,interoperability,standard,standards,1590,"r the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allo",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1642,interoperability,standard,standard,1642,"e, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, othe",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1707,interoperability,conflict,conflict,1707,"same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT intern",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1791,interoperability,conflict,conflict,1791," and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1874,interoperability,interfac,interface,1874,"t found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1903,interoperability,standard,standard,1903,"on of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my question: should we just fo",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1963,interoperability,standard,standards,1963,"y do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't matc",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:2216,interoperability,standard,standard,2216,"oes require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with? My opinion is to allow this, even if it is not recommended. As mentioned above, issues result from cross standards are mainly caused by changes in the header API. If ROOT has confidence in the compatibility of header files a",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:2350,interoperability,conflict,conflict,2350,"b `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with? My opinion is to allow this, even if it is not recommended. As mentioned above, issues result from cross standards are mainly caused by changes in the header API. If ROOT has confidence in the compatibility of header files across standards, I don't think it is necessary to worry about mixing standards. If there are still some potential issues, I think it i",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:2375,interoperability,standard,standard,2375,"eir stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with? My opinion is to allow this, even if it is not recommended. As mentioned above, issues result from cross standards are mainly caused by changes in the header API. If ROOT has confidence in the compatibility of header files across standards, I don't think it is necessary to worry about mixing standards. If there are still some potential issues, I think it is beneficial to . firstly",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:2435,interoperability,standard,standard,2435," same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with? My opinion is to allow this, even if it is not recommended. As mentioned above, issues result from cross standards are mainly caused by changes in the header API. If ROOT has confidence in the compatibility of header files across standards, I don't think it is necessary to worry about mixing standards. If there are still some potential issues, I think it is beneficial to . firstly ensure successful compilation when mixing standards.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:2615,interoperability,standard,standard,2615," same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with? My opinion is to allow this, even if it is not recommended. As mentioned above, issues result from cross standards are mainly caused by changes in the header API. If ROOT has confidence in the compatibility of header files across standards, I don't think it is necessary to worry about mixing standards. If there are still some potential issues, I think it is beneficial to . firstly ensure successful compilation when mixing standards.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:2797,interoperability,compatib,compatibility,2797," same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with? My opinion is to allow this, even if it is not recommended. As mentioned above, issues result from cross standards are mainly caused by changes in the header API. If ROOT has confidence in the compatibility of header files across standards, I don't think it is necessary to worry about mixing standards. If there are still some potential issues, I think it is beneficial to . firstly ensure successful compilation when mixing standards.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:2942,interoperability,standard,standard,2942," same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with? My opinion is to allow this, even if it is not recommended. As mentioned above, issues result from cross standards are mainly caused by changes in the header API. If ROOT has confidence in the compatibility of header files across standards, I don't think it is necessary to worry about mixing standards. If there are still some potential issues, I think it is beneficial to . firstly ensure successful compilation when mixing standards.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:3101,interoperability,standard,standards,3101," same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with? My opinion is to allow this, even if it is not recommended. As mentioned above, issues result from cross standards are mainly caused by changes in the header API. If ROOT has confidence in the compatibility of header files across standards, I don't think it is necessary to worry about mixing standards. If there are still some potential issues, I think it is beneficial to . firstly ensure successful compilation when mixing standards.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:3154,interoperability,API,API,3154," same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with? My opinion is to allow this, even if it is not recommended. As mentioned above, issues result from cross standards are mainly caused by changes in the header API. If ROOT has confidence in the compatibility of header files across standards, I don't think it is necessary to worry about mixing standards. If there are still some potential issues, I think it is beneficial to . firstly ensure successful compilation when mixing standards.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:3189,interoperability,compatib,compatibility,3189," same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with? My opinion is to allow this, even if it is not recommended. As mentioned above, issues result from cross standards are mainly caused by changes in the header API. If ROOT has confidence in the compatibility of header files across standards, I don't think it is necessary to worry about mixing standards. If there are still some potential issues, I think it is beneficial to . firstly ensure successful compilation when mixing standards.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:3226,interoperability,standard,standards,3226," same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with? My opinion is to allow this, even if it is not recommended. As mentioned above, issues result from cross standards are mainly caused by changes in the header API. If ROOT has confidence in the compatibility of header files across standards, I don't think it is necessary to worry about mixing standards. If there are still some potential issues, I think it is beneficial to . firstly ensure successful compilation when mixing standards.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:3289,interoperability,standard,standards,3289," same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with? My opinion is to allow this, even if it is not recommended. As mentioned above, issues result from cross standards are mainly caused by changes in the header API. If ROOT has confidence in the compatibility of header files across standards, I don't think it is necessary to worry about mixing standards. If there are still some potential issues, I think it is beneficial to . firstly ensure successful compilation when mixing standards.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:3422,interoperability,standard,standards,3422," same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with? My opinion is to allow this, even if it is not recommended. As mentioned above, issues result from cross standards are mainly caused by changes in the header API. If ROOT has confidence in the compatibility of header files across standards, I don't think it is necessary to worry about mixing standards. If there are still some potential issues, I think it is beneficial to . firstly ensure successful compilation when mixing standards.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:159,modifiability,version,versions,159,"> ... this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. As for mangling (as part of ABI): as long as the API of the standard library and the ABI used by the compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not int",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:852,modifiability,version,versions,852,"> ... this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. As for mangling (as part of ABI): as long as the API of the standard library and the ABI used by the compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not int",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1730,modifiability,version,version,1730,"he same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `s",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1874,modifiability,interfac,interface,1874,"t found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:2177,modifiability,upgrad,upgrade,2177,"s compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with? My opinion is to allow this, even if it is not recommended. As mentioned above, issues result from cross standards are mainly caused by changes in the header API. If ROOT has confidence",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:2197,modifiability,version,version,2197,"uaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with? My opinion is to allow this, even if it is not recommended. As mentioned above, issues result from cross standards are mainly caused by changes in the header API. If ROOT has confidence in the compatibilit",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:624,reliability,stabil,stabilized,624,"> ... this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. As for mangling (as part of ABI): as long as the API of the standard library and the ABI used by the compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not int",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1219,reliability,doe,does,1219," of the standard library and the ABI used by the compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ stand",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:2321,reliability,availab,available,2321," to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with? My opinion is to allow this, even if it is not recommended. As mentioned above, issues result from cross standards are mainly caused by changes in the header API. If ROOT has confidence in the compatibility of header files across standards, I don't think it is necessary to worry about mixing standards. If there are still some po",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:2956,reliability,doe,doesn,2956," same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with? My opinion is to allow this, even if it is not recommended. As mentioned above, issues result from cross standards are mainly caused by changes in the header API. If ROOT has confidence in the compatibility of header files across standards, I don't think it is necessary to worry about mixing standards. If there are still some potential issues, I think it is beneficial to . firstly ensure successful compilation when mixing standards.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:2321,safety,avail,available,2321," to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with? My opinion is to allow this, even if it is not recommended. As mentioned above, issues result from cross standards are mainly caused by changes in the header API. If ROOT has confidence in the compatibility of header files across standards, I don't think it is necessary to worry about mixing standards. If there are still some po",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:2336,safety,prevent,prevents,2336," use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with? My opinion is to allow this, even if it is not recommended. As mentioned above, issues result from cross standards are mainly caused by changes in the header API. If ROOT has confidence in the compatibility of header files across standards, I don't think it is necessary to worry about mixing standards. If there are still some potential issues",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:2472,safety,compl,complie,2472," same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with? My opinion is to allow this, even if it is not recommended. As mentioned above, issues result from cross standards are mainly caused by changes in the header API. If ROOT has confidence in the compatibility of header files across standards, I don't think it is necessary to worry about mixing standards. If there are still some potential issues, I think it is beneficial to . firstly ensure successful compilation when mixing standards.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1695,security,expos,exposed,1695,"ling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:2321,security,availab,available,2321," to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with? My opinion is to allow this, even if it is not recommended. As mentioned above, issues result from cross standards are mainly caused by changes in the header API. If ROOT has confidence in the compatibility of header files across standards, I don't think it is necessary to worry about mixing standards. If there are still some po",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:2336,security,preven,prevents,2336," use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with? My opinion is to allow this, even if it is not recommended. As mentioned above, issues result from cross standards are mainly caused by changes in the header API. If ROOT has confidence in the compatibility of header files across standards, I don't think it is necessary to worry about mixing standards. If there are still some potential issues",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:2472,security,compl,complie,2472," same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with? My opinion is to allow this, even if it is not recommended. As mentioned above, issues result from cross standards are mainly caused by changes in the header API. If ROOT has confidence in the compatibility of header files across standards, I don't think it is necessary to worry about mixing standards. If there are still some potential issues, I think it is beneficial to . firstly ensure successful compilation when mixing standards.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1262,testability,understand,understand,1262,"he compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementatio",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:37,usability,support,support,37,"> ... this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. As for mangling (as part of ABI): as long as the API of the standard library and the ABI used by the compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not int",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:936,usability,document,documents,936,"> ... this is only the case once the support is deemed stable. To my knowledge even this is not guaranteed, for instance mangling has changed between standard versions. As for mangling (as part of ABI): as long as the API of the standard library and the ABI used by the compiler remain unchanged, the final mangling is the same. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not int",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1321,usability,user,users,1321,"ame. For the latter, the compiler ABI is the same on the same compiler, so the mangling rules are the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not ava",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1419,usability,user,user,1419," the same. Therefore, as long as the API of the standard library is stable between standards, ABI compatibility can be guaranteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std:",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1541,usability,user,users,1541,"anteed. In my opinion, this should be guaranteed for the standard that has been stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std:",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:1619,usability,user,user,1619,"en stabilized (for example, conservatively, no matter C++11 or C++17, the mangling of the same entity should be the same). > Can you point out where GCC states that their ABI and stdlib API is compatible for different C++ standard versions? So far, I have not found any direct description of standard mixing in GCC documents, but it seems that they do not point out that changing standards will lead to changes in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standa",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:2027,usability,user,users,2027,"s in ABI compatibility (If so, it means that the backward compatibility of the C++ standard is violated, which seems serious). I tend to think that this compatibility is guaranteed, but it does require more evidence. > I also don't understand how `cxx20::span` would solve anything: we want users to be able to use the stdlib `span` with ROOT, if their stdlib provides it. In fact, if the user uses the same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with? My opinion is to allow this, even ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:2576,usability,user,user,2576," same standard as ROOT, the current situation is very good. I propose to change the name on the premise that users are allowed to link to ROOT with different standards. Typically, if the user is using a higher standard, the `std::span` in the std library will be exposed and conflict with the ROOT version `std::(inline)__ROOT::span`. In order to resolve the conflict, we have to take the second place: if we use `cxx20::span` and provide an interface to convert from/to standard `std::span`, then even if there are differences in standards, the two sides will not interfere with each other. If users have `std::span`, they can use it; If not, they should not get an implementation from ROOT in the std namespace (which affects their subsequent upgrade to a higher version of the C++ standard). All in all, it provides an implementation independent of std when the true `std::span` is not available, and prevents name conflict when mixing the standard. Of course, if want ROOT to use `std::span` of the standard library when feasible (e.g. complie with C++20), we can just use `cxx20::span` as the alias of `std::span`. However, after then the user cannot be allowed to go back to a standard lower than C++20, otherwise `span` will missing in the header file, and the ROOT internal implementation of `span` should not be use as the fallback - if so, there may be a compatibility problem, caused by the so-called ODR violation. > To come back to my question: should we just forbid compiling ROOT headers with a standard that doesn't match what ROOT was built with? My opinion is to allow this, even if it is not recommended. As mentioned above, issues result from cross standards are mainly caused by changes in the header API. If ROOT has confidence in the compatibility of header files across standards, I don't think it is necessary to worry about mixing standards. If there are still some potential issues, I think it is beneficial to . firstly ensure successful compilation when mixing standards.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:416,deployability,version,versions,416,"> I propose to change the name on the premise that users are allowed to link to ROOT with different standards. That's a misconception; they are not allowed to do that. We prefer that people can use the stdlib types (including their documentation) and thus intentionally use the same spelling. ROOT's ""backports"" are really only meant to exist for cases where the stdlib does not provide these types; mixing language versions does obviously not work with that.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:416,integrability,version,versions,416,"> I propose to change the name on the premise that users are allowed to link to ROOT with different standards. That's a misconception; they are not allowed to do that. We prefer that people can use the stdlib types (including their documentation) and thus intentionally use the same spelling. ROOT's ""backports"" are really only meant to exist for cases where the stdlib does not provide these types; mixing language versions does obviously not work with that.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:100,interoperability,standard,standards,100,"> I propose to change the name on the premise that users are allowed to link to ROOT with different standards. That's a misconception; they are not allowed to do that. We prefer that people can use the stdlib types (including their documentation) and thus intentionally use the same spelling. ROOT's ""backports"" are really only meant to exist for cases where the stdlib does not provide these types; mixing language versions does obviously not work with that.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:416,modifiability,version,versions,416,"> I propose to change the name on the premise that users are allowed to link to ROOT with different standards. That's a misconception; they are not allowed to do that. We prefer that people can use the stdlib types (including their documentation) and thus intentionally use the same spelling. ROOT's ""backports"" are really only meant to exist for cases where the stdlib does not provide these types; mixing language versions does obviously not work with that.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:370,reliability,doe,does,370,"> I propose to change the name on the premise that users are allowed to link to ROOT with different standards. That's a misconception; they are not allowed to do that. We prefer that people can use the stdlib types (including their documentation) and thus intentionally use the same spelling. ROOT's ""backports"" are really only meant to exist for cases where the stdlib does not provide these types; mixing language versions does obviously not work with that.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:425,reliability,doe,does,425,"> I propose to change the name on the premise that users are allowed to link to ROOT with different standards. That's a misconception; they are not allowed to do that. We prefer that people can use the stdlib types (including their documentation) and thus intentionally use the same spelling. ROOT's ""backports"" are really only meant to exist for cases where the stdlib does not provide these types; mixing language versions does obviously not work with that.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:51,usability,user,users,51,"> I propose to change the name on the premise that users are allowed to link to ROOT with different standards. That's a misconception; they are not allowed to do that. We prefer that people can use the stdlib types (including their documentation) and thus intentionally use the same spelling. ROOT's ""backports"" are really only meant to exist for cases where the stdlib does not provide these types; mixing language versions does obviously not work with that.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:171,usability,prefer,prefer,171,"> I propose to change the name on the premise that users are allowed to link to ROOT with different standards. That's a misconception; they are not allowed to do that. We prefer that people can use the stdlib types (including their documentation) and thus intentionally use the same spelling. ROOT's ""backports"" are really only meant to exist for cases where the stdlib does not provide these types; mixing language versions does obviously not work with that.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:232,usability,document,documentation,232,"> I propose to change the name on the premise that users are allowed to link to ROOT with different standards. That's a misconception; they are not allowed to do that. We prefer that people can use the stdlib types (including their documentation) and thus intentionally use the same spelling. ROOT's ""backports"" are really only meant to exist for cases where the stdlib does not provide these types; mixing language versions does obviously not work with that.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:160,usability,confirm,confirm,160,"Anyway, back to this PR: the motivation is the same as https://github.com/root-project/root/commit/ff95b036a75e9c9b33223907ba32862dce0e55f7. At least I want to confirm whether it is appropriate.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:172,availability,error,errors,172,"We don't want to change the spelling of the std types. The implementation can be in whatever namespace as long as it's different from the stdlib namespace (to cause linker errors if `std::foo` is passed to a ROOT-backport `std::foo`). I suppose that's still the case here, so: all good!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:172,performance,error,errors,172,"We don't want to change the spelling of the std types. The implementation can be in whatever namespace as long as it's different from the stdlib namespace (to cause linker errors if `std::foo` is passed to a ROOT-backport `std::foo`). I suppose that's still the case here, so: all good!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:172,safety,error,errors,172,"We don't want to change the spelling of the std types. The implementation can be in whatever namespace as long as it's different from the stdlib namespace (to cause linker errors if `std::foo` is passed to a ROOT-backport `std::foo`). I suppose that's still the case here, so: all good!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:172,usability,error,errors,172,"We don't want to change the spelling of the std types. The implementation can be in whatever namespace as long as it's different from the stdlib namespace (to cause linker errors if `std::foo` is passed to a ROOT-backport `std::foo`). I suppose that's still the case here, so: all good!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:3,safety,compl,completed,3,"CI completed with MSVC ""heap overflow"".",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:3,security,compl,completed,3,"CI completed with MSVC ""heap overflow"".",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:11,deployability,build,build,11,@phsft-bot build just on windows10/cxx14,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:193,deployability,manag,manage,193,Apologies for letting this sit way too long. I think what we need is:. - get rid of `R__HAS_STD_SPAN` (incl the CMake code). - remove the option of `experimental::span` (incl CMake) as I don't manage to find any incarnation of this anyway. - use the feature test macro `__cpp_lib_span`. I would totally understand if you'd find this unreasonable to update this PR at this point. Please let me know and I will close this PR and implement myself what I suggest here.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:349,deployability,updat,update,349,Apologies for letting this sit way too long. I think what we need is:. - get rid of `R__HAS_STD_SPAN` (incl the CMake code). - remove the option of `experimental::span` (incl CMake) as I don't manage to find any incarnation of this anyway. - use the feature test macro `__cpp_lib_span`. I would totally understand if you'd find this unreasonable to update this PR at this point. Please let me know and I will close this PR and implement myself what I suggest here.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:193,energy efficiency,manag,manage,193,Apologies for letting this sit way too long. I think what we need is:. - get rid of `R__HAS_STD_SPAN` (incl the CMake code). - remove the option of `experimental::span` (incl CMake) as I don't manage to find any incarnation of this anyway. - use the feature test macro `__cpp_lib_span`. I would totally understand if you'd find this unreasonable to update this PR at this point. Please let me know and I will close this PR and implement myself what I suggest here.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:193,safety,manag,manage,193,Apologies for letting this sit way too long. I think what we need is:. - get rid of `R__HAS_STD_SPAN` (incl the CMake code). - remove the option of `experimental::span` (incl CMake) as I don't manage to find any incarnation of this anyway. - use the feature test macro `__cpp_lib_span`. I would totally understand if you'd find this unreasonable to update this PR at this point. Please let me know and I will close this PR and implement myself what I suggest here.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:258,safety,test,test,258,Apologies for letting this sit way too long. I think what we need is:. - get rid of `R__HAS_STD_SPAN` (incl the CMake code). - remove the option of `experimental::span` (incl CMake) as I don't manage to find any incarnation of this anyway. - use the feature test macro `__cpp_lib_span`. I would totally understand if you'd find this unreasonable to update this PR at this point. Please let me know and I will close this PR and implement myself what I suggest here.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:349,safety,updat,update,349,Apologies for letting this sit way too long. I think what we need is:. - get rid of `R__HAS_STD_SPAN` (incl the CMake code). - remove the option of `experimental::span` (incl CMake) as I don't manage to find any incarnation of this anyway. - use the feature test macro `__cpp_lib_span`. I would totally understand if you'd find this unreasonable to update this PR at this point. Please let me know and I will close this PR and implement myself what I suggest here.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:349,security,updat,update,349,Apologies for letting this sit way too long. I think what we need is:. - get rid of `R__HAS_STD_SPAN` (incl the CMake code). - remove the option of `experimental::span` (incl CMake) as I don't manage to find any incarnation of this anyway. - use the feature test macro `__cpp_lib_span`. I would totally understand if you'd find this unreasonable to update this PR at this point. Please let me know and I will close this PR and implement myself what I suggest here.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:258,testability,test,test,258,Apologies for letting this sit way too long. I think what we need is:. - get rid of `R__HAS_STD_SPAN` (incl the CMake code). - remove the option of `experimental::span` (incl CMake) as I don't manage to find any incarnation of this anyway. - use the feature test macro `__cpp_lib_span`. I would totally understand if you'd find this unreasonable to update this PR at this point. Please let me know and I will close this PR and implement myself what I suggest here.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:303,testability,understand,understand,303,Apologies for letting this sit way too long. I think what we need is:. - get rid of `R__HAS_STD_SPAN` (incl the CMake code). - remove the option of `experimental::span` (incl CMake) as I don't manage to find any incarnation of this anyway. - use the feature test macro `__cpp_lib_span`. I would totally understand if you'd find this unreasonable to update this PR at this point. Please let me know and I will close this PR and implement myself what I suggest here.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:409,usability,close,close,409,Apologies for letting this sit way too long. I think what we need is:. - get rid of `R__HAS_STD_SPAN` (incl the CMake code). - remove the option of `experimental::span` (incl CMake) as I don't manage to find any incarnation of this anyway. - use the feature test macro `__cpp_lib_span`. I would totally understand if you'd find this unreasonable to update this PR at this point. Please let me know and I will close this PR and implement myself what I suggest here.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:41,usability,support,support,41,Turns out I *need* to fix this for C++20 support in ROOT - I'm on it.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:8,energy efficiency,current,currently,8,That's (currently) [`4ac5bb4` (#11874)](https://github.com/root-project/root/pull/11874/commits/4ac5bb437e47ad8f6ccc9fc21778a56bcfd4d257),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:203,deployability,manag,manage,203,"> Apologies for letting this sit way too long. I think what we need is:. > . > * get rid of `R__HAS_STD_SPAN` (incl the CMake code). > * remove the option of `experimental::span` (incl CMake) as I don't manage to find any incarnation of this anyway. > * use the feature test macro `__cpp_lib_span`. > . > . > I would totally understand if you'd find this unreasonable to update this PR at this point. Please let me know and I will close this PR and implement myself what I suggest here. Never mind! I prefer to follow your suggestion as a more appropriate solution. After all, what I want is exactly ""Add support for building ROOT with C++20"". I believe you have a better understanding of how this works. If there is not much to do on this PR, it can be closed whenever appropriate.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:371,deployability,updat,update,371,"> Apologies for letting this sit way too long. I think what we need is:. > . > * get rid of `R__HAS_STD_SPAN` (incl the CMake code). > * remove the option of `experimental::span` (incl CMake) as I don't manage to find any incarnation of this anyway. > * use the feature test macro `__cpp_lib_span`. > . > . > I would totally understand if you'd find this unreasonable to update this PR at this point. Please let me know and I will close this PR and implement myself what I suggest here. Never mind! I prefer to follow your suggestion as a more appropriate solution. After all, what I want is exactly ""Add support for building ROOT with C++20"". I believe you have a better understanding of how this works. If there is not much to do on this PR, it can be closed whenever appropriate.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:617,deployability,build,building,617,"> Apologies for letting this sit way too long. I think what we need is:. > . > * get rid of `R__HAS_STD_SPAN` (incl the CMake code). > * remove the option of `experimental::span` (incl CMake) as I don't manage to find any incarnation of this anyway. > * use the feature test macro `__cpp_lib_span`. > . > . > I would totally understand if you'd find this unreasonable to update this PR at this point. Please let me know and I will close this PR and implement myself what I suggest here. Never mind! I prefer to follow your suggestion as a more appropriate solution. After all, what I want is exactly ""Add support for building ROOT with C++20"". I believe you have a better understanding of how this works. If there is not much to do on this PR, it can be closed whenever appropriate.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:203,energy efficiency,manag,manage,203,"> Apologies for letting this sit way too long. I think what we need is:. > . > * get rid of `R__HAS_STD_SPAN` (incl the CMake code). > * remove the option of `experimental::span` (incl CMake) as I don't manage to find any incarnation of this anyway. > * use the feature test macro `__cpp_lib_span`. > . > . > I would totally understand if you'd find this unreasonable to update this PR at this point. Please let me know and I will close this PR and implement myself what I suggest here. Never mind! I prefer to follow your suggestion as a more appropriate solution. After all, what I want is exactly ""Add support for building ROOT with C++20"". I believe you have a better understanding of how this works. If there is not much to do on this PR, it can be closed whenever appropriate.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:203,safety,manag,manage,203,"> Apologies for letting this sit way too long. I think what we need is:. > . > * get rid of `R__HAS_STD_SPAN` (incl the CMake code). > * remove the option of `experimental::span` (incl CMake) as I don't manage to find any incarnation of this anyway. > * use the feature test macro `__cpp_lib_span`. > . > . > I would totally understand if you'd find this unreasonable to update this PR at this point. Please let me know and I will close this PR and implement myself what I suggest here. Never mind! I prefer to follow your suggestion as a more appropriate solution. After all, what I want is exactly ""Add support for building ROOT with C++20"". I believe you have a better understanding of how this works. If there is not much to do on this PR, it can be closed whenever appropriate.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:270,safety,test,test,270,"> Apologies for letting this sit way too long. I think what we need is:. > . > * get rid of `R__HAS_STD_SPAN` (incl the CMake code). > * remove the option of `experimental::span` (incl CMake) as I don't manage to find any incarnation of this anyway. > * use the feature test macro `__cpp_lib_span`. > . > . > I would totally understand if you'd find this unreasonable to update this PR at this point. Please let me know and I will close this PR and implement myself what I suggest here. Never mind! I prefer to follow your suggestion as a more appropriate solution. After all, what I want is exactly ""Add support for building ROOT with C++20"". I believe you have a better understanding of how this works. If there is not much to do on this PR, it can be closed whenever appropriate.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:371,safety,updat,update,371,"> Apologies for letting this sit way too long. I think what we need is:. > . > * get rid of `R__HAS_STD_SPAN` (incl the CMake code). > * remove the option of `experimental::span` (incl CMake) as I don't manage to find any incarnation of this anyway. > * use the feature test macro `__cpp_lib_span`. > . > . > I would totally understand if you'd find this unreasonable to update this PR at this point. Please let me know and I will close this PR and implement myself what I suggest here. Never mind! I prefer to follow your suggestion as a more appropriate solution. After all, what I want is exactly ""Add support for building ROOT with C++20"". I believe you have a better understanding of how this works. If there is not much to do on this PR, it can be closed whenever appropriate.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:371,security,updat,update,371,"> Apologies for letting this sit way too long. I think what we need is:. > . > * get rid of `R__HAS_STD_SPAN` (incl the CMake code). > * remove the option of `experimental::span` (incl CMake) as I don't manage to find any incarnation of this anyway. > * use the feature test macro `__cpp_lib_span`. > . > . > I would totally understand if you'd find this unreasonable to update this PR at this point. Please let me know and I will close this PR and implement myself what I suggest here. Never mind! I prefer to follow your suggestion as a more appropriate solution. After all, what I want is exactly ""Add support for building ROOT with C++20"". I believe you have a better understanding of how this works. If there is not much to do on this PR, it can be closed whenever appropriate.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:270,testability,test,test,270,"> Apologies for letting this sit way too long. I think what we need is:. > . > * get rid of `R__HAS_STD_SPAN` (incl the CMake code). > * remove the option of `experimental::span` (incl CMake) as I don't manage to find any incarnation of this anyway. > * use the feature test macro `__cpp_lib_span`. > . > . > I would totally understand if you'd find this unreasonable to update this PR at this point. Please let me know and I will close this PR and implement myself what I suggest here. Never mind! I prefer to follow your suggestion as a more appropriate solution. After all, what I want is exactly ""Add support for building ROOT with C++20"". I believe you have a better understanding of how this works. If there is not much to do on this PR, it can be closed whenever appropriate.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:325,testability,understand,understand,325,"> Apologies for letting this sit way too long. I think what we need is:. > . > * get rid of `R__HAS_STD_SPAN` (incl the CMake code). > * remove the option of `experimental::span` (incl CMake) as I don't manage to find any incarnation of this anyway. > * use the feature test macro `__cpp_lib_span`. > . > . > I would totally understand if you'd find this unreasonable to update this PR at this point. Please let me know and I will close this PR and implement myself what I suggest here. Never mind! I prefer to follow your suggestion as a more appropriate solution. After all, what I want is exactly ""Add support for building ROOT with C++20"". I believe you have a better understanding of how this works. If there is not much to do on this PR, it can be closed whenever appropriate.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:672,testability,understand,understanding,672,"> Apologies for letting this sit way too long. I think what we need is:. > . > * get rid of `R__HAS_STD_SPAN` (incl the CMake code). > * remove the option of `experimental::span` (incl CMake) as I don't manage to find any incarnation of this anyway. > * use the feature test macro `__cpp_lib_span`. > . > . > I would totally understand if you'd find this unreasonable to update this PR at this point. Please let me know and I will close this PR and implement myself what I suggest here. Never mind! I prefer to follow your suggestion as a more appropriate solution. After all, what I want is exactly ""Add support for building ROOT with C++20"". I believe you have a better understanding of how this works. If there is not much to do on this PR, it can be closed whenever appropriate.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:431,usability,close,close,431,"> Apologies for letting this sit way too long. I think what we need is:. > . > * get rid of `R__HAS_STD_SPAN` (incl the CMake code). > * remove the option of `experimental::span` (incl CMake) as I don't manage to find any incarnation of this anyway. > * use the feature test macro `__cpp_lib_span`. > . > . > I would totally understand if you'd find this unreasonable to update this PR at this point. Please let me know and I will close this PR and implement myself what I suggest here. Never mind! I prefer to follow your suggestion as a more appropriate solution. After all, what I want is exactly ""Add support for building ROOT with C++20"". I believe you have a better understanding of how this works. If there is not much to do on this PR, it can be closed whenever appropriate.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:501,usability,prefer,prefer,501,"> Apologies for letting this sit way too long. I think what we need is:. > . > * get rid of `R__HAS_STD_SPAN` (incl the CMake code). > * remove the option of `experimental::span` (incl CMake) as I don't manage to find any incarnation of this anyway. > * use the feature test macro `__cpp_lib_span`. > . > . > I would totally understand if you'd find this unreasonable to update this PR at this point. Please let me know and I will close this PR and implement myself what I suggest here. Never mind! I prefer to follow your suggestion as a more appropriate solution. After all, what I want is exactly ""Add support for building ROOT with C++20"". I believe you have a better understanding of how this works. If there is not much to do on this PR, it can be closed whenever appropriate.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:605,usability,support,support,605,"> Apologies for letting this sit way too long. I think what we need is:. > . > * get rid of `R__HAS_STD_SPAN` (incl the CMake code). > * remove the option of `experimental::span` (incl CMake) as I don't manage to find any incarnation of this anyway. > * use the feature test macro `__cpp_lib_span`. > . > . > I would totally understand if you'd find this unreasonable to update this PR at this point. Please let me know and I will close this PR and implement myself what I suggest here. Never mind! I prefer to follow your suggestion as a more appropriate solution. After all, what I want is exactly ""Add support for building ROOT with C++20"". I believe you have a better understanding of how this works. If there is not much to do on this PR, it can be closed whenever appropriate.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:754,usability,close,closed,754,"> Apologies for letting this sit way too long. I think what we need is:. > . > * get rid of `R__HAS_STD_SPAN` (incl the CMake code). > * remove the option of `experimental::span` (incl CMake) as I don't manage to find any incarnation of this anyway. > * use the feature test macro `__cpp_lib_span`. > . > . > I would totally understand if you'd find this unreasonable to update this PR at this point. Please let me know and I will close this PR and implement myself what I suggest here. Never mind! I prefer to follow your suggestion as a more appropriate solution. After all, what I want is exactly ""Add support for building ROOT with C++20"". I believe you have a better understanding of how this works. If there is not much to do on this PR, it can be closed whenever appropriate.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:138,usability,support,support,138,Closing this now that https://github.com/root-project/root/pull/11874 is merged. Note that we're not there yet; some parts for full C++20 support are still missing. I expect that 6.28/04 will finally provide C++20 support.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:214,usability,support,support,214,Closing this now that https://github.com/root-project/root/pull/11874 is merged. Note that we're not there yet; some parts for full C++20 support are still missing. I expect that 6.28/04 will finally provide C++20 support.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:99,usability,support,support,99,> Closing this now that #11874 is merged. Note that we're not there yet; some parts for full C++20 support are still missing. I expect that 6.28/04 will finally provide C++20 support. Thanks!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/pull/11311:175,usability,support,support,175,> Closing this now that #11874 is merged. Note that we're not there yet; some parts for full C++20 support are still missing. I expect that 6.28/04 will finally provide C++20 support. Thanks!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11311
https://github.com/root-project/root/issues/11312:29,deployability,patch,patch,29,"Yes, it is albeit as similar patch still needs to be applied to the genreflex code path in ROOT's cmake.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11312
https://github.com/root-project/root/issues/11312:29,safety,patch,patch,29,"Yes, it is albeit as similar patch still needs to be applied to the genreflex code path in ROOT's cmake.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11312
https://github.com/root-project/root/issues/11312:29,security,patch,patch,29,"Yes, it is albeit as similar patch still needs to be applied to the genreflex code path in ROOT's cmake.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11312
https://github.com/root-project/root/issues/11312:91,deployability,contain,contains,91,"On the surface the issue is that cmake produce rootcling command line for G__RIO.cxx which contains:. ```. -writeEmptyRootPCM -D -compilerI/Application. ```. Note the -D followed by nothing. We noted this problem with a Spack build which is building ROOT with no builtin. The one option on the cmake command line that triggered the problem is:. ```. -DCMAKE_PREFIX_PATH:STRING=""....//nlohmann-json-3.11.2-rasey7y53ec7uab3r6dhiktct52doyti"". ```. Inside nlohmann the line of nlohmann_jsonTargets.cmake that caused the problem is:. ```. INTERFACE_COMPILE_DEFINITIONS ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0>;\$<\$<BOOL:OFF>:JSON_DISABLE_ENUM_SERIALIZATION=1>;\$<\$<BOOL:OFF>:JSON_DIAGNOSTICS=1>;\$<\$<BOOL:OFF>:JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON=1>"". ```. This information is used in ROOT in ROOT_GENERATE_DICTIONARY:. ```. set(module_defs $<TARGET_PROPERTY:${ARG_MODULE},COMPILE_DEFINITIONS>). ... ${definitions} ""$<$<BOOL:${module_defs}>:-D$<JOIN:${module_defs},;-D>>"". ```. Experimentally having INTERFACE_COMPILE_DEFINITIONS contains a single value:. ```. ""SOMETHING"". ```. or a value plus one or more 'empty' generator expressions:. ```. ""SOMETHING;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>"". ```. or a single 'empy' generator expressions:. ```. ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>"". ```. However if INTERFACE_COMPILE_DEFINITIONS contains 2 or more 'empty' generator. expressions and no other values:. ```. ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0>;\$<\$<BOOL:OFF>:JSON_DISABLE_ENUM_SERIALIZATION=1>;\$<\$<BOOL:OFF>:JSON_DIAGNOSTICS=1>;\$<\$<BOOL:OFF>:JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON=1>"". ```. It also appears to works if you don't quote the expressions:. ```. $<$<NOT:$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0> $<$<NOT:$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0> .. ```. However since those lines of cmake are generated by CMake as part of th",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11312
https://github.com/root-project/root/issues/11312:226,deployability,build,build,226,"On the surface the issue is that cmake produce rootcling command line for G__RIO.cxx which contains:. ```. -writeEmptyRootPCM -D -compilerI/Application. ```. Note the -D followed by nothing. We noted this problem with a Spack build which is building ROOT with no builtin. The one option on the cmake command line that triggered the problem is:. ```. -DCMAKE_PREFIX_PATH:STRING=""....//nlohmann-json-3.11.2-rasey7y53ec7uab3r6dhiktct52doyti"". ```. Inside nlohmann the line of nlohmann_jsonTargets.cmake that caused the problem is:. ```. INTERFACE_COMPILE_DEFINITIONS ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0>;\$<\$<BOOL:OFF>:JSON_DISABLE_ENUM_SERIALIZATION=1>;\$<\$<BOOL:OFF>:JSON_DIAGNOSTICS=1>;\$<\$<BOOL:OFF>:JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON=1>"". ```. This information is used in ROOT in ROOT_GENERATE_DICTIONARY:. ```. set(module_defs $<TARGET_PROPERTY:${ARG_MODULE},COMPILE_DEFINITIONS>). ... ${definitions} ""$<$<BOOL:${module_defs}>:-D$<JOIN:${module_defs},;-D>>"". ```. Experimentally having INTERFACE_COMPILE_DEFINITIONS contains a single value:. ```. ""SOMETHING"". ```. or a value plus one or more 'empty' generator expressions:. ```. ""SOMETHING;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>"". ```. or a single 'empy' generator expressions:. ```. ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>"". ```. However if INTERFACE_COMPILE_DEFINITIONS contains 2 or more 'empty' generator. expressions and no other values:. ```. ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0>;\$<\$<BOOL:OFF>:JSON_DISABLE_ENUM_SERIALIZATION=1>;\$<\$<BOOL:OFF>:JSON_DIAGNOSTICS=1>;\$<\$<BOOL:OFF>:JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON=1>"". ```. It also appears to works if you don't quote the expressions:. ```. $<$<NOT:$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0> $<$<NOT:$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0> .. ```. However since those lines of cmake are generated by CMake as part of th",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11312
https://github.com/root-project/root/issues/11312:241,deployability,build,building,241,"On the surface the issue is that cmake produce rootcling command line for G__RIO.cxx which contains:. ```. -writeEmptyRootPCM -D -compilerI/Application. ```. Note the -D followed by nothing. We noted this problem with a Spack build which is building ROOT with no builtin. The one option on the cmake command line that triggered the problem is:. ```. -DCMAKE_PREFIX_PATH:STRING=""....//nlohmann-json-3.11.2-rasey7y53ec7uab3r6dhiktct52doyti"". ```. Inside nlohmann the line of nlohmann_jsonTargets.cmake that caused the problem is:. ```. INTERFACE_COMPILE_DEFINITIONS ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0>;\$<\$<BOOL:OFF>:JSON_DISABLE_ENUM_SERIALIZATION=1>;\$<\$<BOOL:OFF>:JSON_DIAGNOSTICS=1>;\$<\$<BOOL:OFF>:JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON=1>"". ```. This information is used in ROOT in ROOT_GENERATE_DICTIONARY:. ```. set(module_defs $<TARGET_PROPERTY:${ARG_MODULE},COMPILE_DEFINITIONS>). ... ${definitions} ""$<$<BOOL:${module_defs}>:-D$<JOIN:${module_defs},;-D>>"". ```. Experimentally having INTERFACE_COMPILE_DEFINITIONS contains a single value:. ```. ""SOMETHING"". ```. or a value plus one or more 'empty' generator expressions:. ```. ""SOMETHING;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>"". ```. or a single 'empy' generator expressions:. ```. ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>"". ```. However if INTERFACE_COMPILE_DEFINITIONS contains 2 or more 'empty' generator. expressions and no other values:. ```. ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0>;\$<\$<BOOL:OFF>:JSON_DISABLE_ENUM_SERIALIZATION=1>;\$<\$<BOOL:OFF>:JSON_DIAGNOSTICS=1>;\$<\$<BOOL:OFF>:JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON=1>"". ```. It also appears to works if you don't quote the expressions:. ```. $<$<NOT:$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0> $<$<NOT:$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0> .. ```. However since those lines of cmake are generated by CMake as part of th",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11312
https://github.com/root-project/root/issues/11312:1097,deployability,contain,contains,1097," ```. -writeEmptyRootPCM -D -compilerI/Application. ```. Note the -D followed by nothing. We noted this problem with a Spack build which is building ROOT with no builtin. The one option on the cmake command line that triggered the problem is:. ```. -DCMAKE_PREFIX_PATH:STRING=""....//nlohmann-json-3.11.2-rasey7y53ec7uab3r6dhiktct52doyti"". ```. Inside nlohmann the line of nlohmann_jsonTargets.cmake that caused the problem is:. ```. INTERFACE_COMPILE_DEFINITIONS ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0>;\$<\$<BOOL:OFF>:JSON_DISABLE_ENUM_SERIALIZATION=1>;\$<\$<BOOL:OFF>:JSON_DIAGNOSTICS=1>;\$<\$<BOOL:OFF>:JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON=1>"". ```. This information is used in ROOT in ROOT_GENERATE_DICTIONARY:. ```. set(module_defs $<TARGET_PROPERTY:${ARG_MODULE},COMPILE_DEFINITIONS>). ... ${definitions} ""$<$<BOOL:${module_defs}>:-D$<JOIN:${module_defs},;-D>>"". ```. Experimentally having INTERFACE_COMPILE_DEFINITIONS contains a single value:. ```. ""SOMETHING"". ```. or a value plus one or more 'empty' generator expressions:. ```. ""SOMETHING;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>"". ```. or a single 'empy' generator expressions:. ```. ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>"". ```. However if INTERFACE_COMPILE_DEFINITIONS contains 2 or more 'empty' generator. expressions and no other values:. ```. ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0>;\$<\$<BOOL:OFF>:JSON_DISABLE_ENUM_SERIALIZATION=1>;\$<\$<BOOL:OFF>:JSON_DIAGNOSTICS=1>;\$<\$<BOOL:OFF>:JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON=1>"". ```. It also appears to works if you don't quote the expressions:. ```. $<$<NOT:$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0> $<$<NOT:$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0> .. ```. However since those lines of cmake are generated by CMake as part of the install,. we have to deal with the way they are.CMake. It is fixed on the ROOT side with:. ```. com",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11312
https://github.com/root-project/root/issues/11312:1420,deployability,contain,contains,1420,"hiktct52doyti"". ```. Inside nlohmann the line of nlohmann_jsonTargets.cmake that caused the problem is:. ```. INTERFACE_COMPILE_DEFINITIONS ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0>;\$<\$<BOOL:OFF>:JSON_DISABLE_ENUM_SERIALIZATION=1>;\$<\$<BOOL:OFF>:JSON_DIAGNOSTICS=1>;\$<\$<BOOL:OFF>:JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON=1>"". ```. This information is used in ROOT in ROOT_GENERATE_DICTIONARY:. ```. set(module_defs $<TARGET_PROPERTY:${ARG_MODULE},COMPILE_DEFINITIONS>). ... ${definitions} ""$<$<BOOL:${module_defs}>:-D$<JOIN:${module_defs},;-D>>"". ```. Experimentally having INTERFACE_COMPILE_DEFINITIONS contains a single value:. ```. ""SOMETHING"". ```. or a value plus one or more 'empty' generator expressions:. ```. ""SOMETHING;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>"". ```. or a single 'empy' generator expressions:. ```. ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>"". ```. However if INTERFACE_COMPILE_DEFINITIONS contains 2 or more 'empty' generator. expressions and no other values:. ```. ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0>;\$<\$<BOOL:OFF>:JSON_DISABLE_ENUM_SERIALIZATION=1>;\$<\$<BOOL:OFF>:JSON_DIAGNOSTICS=1>;\$<\$<BOOL:OFF>:JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON=1>"". ```. It also appears to works if you don't quote the expressions:. ```. $<$<NOT:$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0> $<$<NOT:$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0> .. ```. However since those lines of cmake are generated by CMake as part of the install,. we have to deal with the way they are.CMake. It is fixed on the ROOT side with:. ```. commit 08ab7e03061e551647d707637957252d121f9c39 (HEAD). Author: Jonas Rembser <jonas.rembser@cern.ch>. Date: Tue Sep 21 15:15:17 2021 +0200. [cmake] Protect against empty `COMPILE_DEFINITIONS` in rootcint command. ```. but it should be applied also to REFLEX_GENERATE_DICTIONARY:. ```. diff --git a/cmake/modules/RootMacros.cm",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11312
https://github.com/root-project/root/issues/11312:2002,deployability,instal,install,2002,">:-D$<JOIN:${module_defs},;-D>>"". ```. Experimentally having INTERFACE_COMPILE_DEFINITIONS contains a single value:. ```. ""SOMETHING"". ```. or a value plus one or more 'empty' generator expressions:. ```. ""SOMETHING;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>"". ```. or a single 'empy' generator expressions:. ```. ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>"". ```. However if INTERFACE_COMPILE_DEFINITIONS contains 2 or more 'empty' generator. expressions and no other values:. ```. ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0>;\$<\$<BOOL:OFF>:JSON_DISABLE_ENUM_SERIALIZATION=1>;\$<\$<BOOL:OFF>:JSON_DIAGNOSTICS=1>;\$<\$<BOOL:OFF>:JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON=1>"". ```. It also appears to works if you don't quote the expressions:. ```. $<$<NOT:$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0> $<$<NOT:$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0> .. ```. However since those lines of cmake are generated by CMake as part of the install,. we have to deal with the way they are.CMake. It is fixed on the ROOT side with:. ```. commit 08ab7e03061e551647d707637957252d121f9c39 (HEAD). Author: Jonas Rembser <jonas.rembser@cern.ch>. Date: Tue Sep 21 15:15:17 2021 +0200. [cmake] Protect against empty `COMPILE_DEFINITIONS` in rootcint command. ```. but it should be applied also to REFLEX_GENERATE_DICTIONARY:. ```. diff --git a/cmake/modules/RootMacros.cmake b/cmake/modules/RootMacros.cmake. index a19ee4e363..22816fdc8e 100644. --- a/cmake/modules/RootMacros.cmake. +++ b/cmake/modules/RootMacros.cmake. @@ -174,12 +174,16 @@ function(REFLEX_GENERATE_DICTIONARY dictionary). get_directory_property(defs COMPILE_DEFINITIONS). foreach( d ${defs}). + # Note: should we check for empty definitions here? list(APPEND definitions ${d}). endforeach(). IF(TARGET ${dictionary}). LIST(APPEND include_dirs $<TARGET_PROPERTY:${dictionary},INCLUDE_DIRECTORIES>). - LIST(APPEND definitions $<TARGET_PROPERTY:${dictionary},COMPILE_DEFINITIONS>). + #",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11312
https://github.com/root-project/root/issues/11312:2403,deployability,modul,modules,2403,"N>>:JSON_USE_GLOBAL_UDLS=0>"". ```. However if INTERFACE_COMPILE_DEFINITIONS contains 2 or more 'empty' generator. expressions and no other values:. ```. ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0>;\$<\$<BOOL:OFF>:JSON_DISABLE_ENUM_SERIALIZATION=1>;\$<\$<BOOL:OFF>:JSON_DIAGNOSTICS=1>;\$<\$<BOOL:OFF>:JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON=1>"". ```. It also appears to works if you don't quote the expressions:. ```. $<$<NOT:$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0> $<$<NOT:$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0> .. ```. However since those lines of cmake are generated by CMake as part of the install,. we have to deal with the way they are.CMake. It is fixed on the ROOT side with:. ```. commit 08ab7e03061e551647d707637957252d121f9c39 (HEAD). Author: Jonas Rembser <jonas.rembser@cern.ch>. Date: Tue Sep 21 15:15:17 2021 +0200. [cmake] Protect against empty `COMPILE_DEFINITIONS` in rootcint command. ```. but it should be applied also to REFLEX_GENERATE_DICTIONARY:. ```. diff --git a/cmake/modules/RootMacros.cmake b/cmake/modules/RootMacros.cmake. index a19ee4e363..22816fdc8e 100644. --- a/cmake/modules/RootMacros.cmake. +++ b/cmake/modules/RootMacros.cmake. @@ -174,12 +174,16 @@ function(REFLEX_GENERATE_DICTIONARY dictionary). get_directory_property(defs COMPILE_DEFINITIONS). foreach( d ${defs}). + # Note: should we check for empty definitions here? list(APPEND definitions ${d}). endforeach(). IF(TARGET ${dictionary}). LIST(APPEND include_dirs $<TARGET_PROPERTY:${dictionary},INCLUDE_DIRECTORIES>). - LIST(APPEND definitions $<TARGET_PROPERTY:${dictionary},COMPILE_DEFINITIONS>). + # The COMPILE_DEFINITIONS list might contain empty elements. These are. + # removed with the FILTER generator expression, excluding elements that. + # match the ^$ regexp (only matches empty strings). + LIST(APPEND definitions ""$<FILTER:$<TARGET_PROPERTY:${ARG_MODULE},COMPILE_DEFINITIONS>,EXCLUDE,^$>""). ENDIF(). add_custom_command(. ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11312
https://github.com/root-project/root/issues/11312:2436,deployability,modul,modules,2436,"N>>:JSON_USE_GLOBAL_UDLS=0>"". ```. However if INTERFACE_COMPILE_DEFINITIONS contains 2 or more 'empty' generator. expressions and no other values:. ```. ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0>;\$<\$<BOOL:OFF>:JSON_DISABLE_ENUM_SERIALIZATION=1>;\$<\$<BOOL:OFF>:JSON_DIAGNOSTICS=1>;\$<\$<BOOL:OFF>:JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON=1>"". ```. It also appears to works if you don't quote the expressions:. ```. $<$<NOT:$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0> $<$<NOT:$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0> .. ```. However since those lines of cmake are generated by CMake as part of the install,. we have to deal with the way they are.CMake. It is fixed on the ROOT side with:. ```. commit 08ab7e03061e551647d707637957252d121f9c39 (HEAD). Author: Jonas Rembser <jonas.rembser@cern.ch>. Date: Tue Sep 21 15:15:17 2021 +0200. [cmake] Protect against empty `COMPILE_DEFINITIONS` in rootcint command. ```. but it should be applied also to REFLEX_GENERATE_DICTIONARY:. ```. diff --git a/cmake/modules/RootMacros.cmake b/cmake/modules/RootMacros.cmake. index a19ee4e363..22816fdc8e 100644. --- a/cmake/modules/RootMacros.cmake. +++ b/cmake/modules/RootMacros.cmake. @@ -174,12 +174,16 @@ function(REFLEX_GENERATE_DICTIONARY dictionary). get_directory_property(defs COMPILE_DEFINITIONS). foreach( d ${defs}). + # Note: should we check for empty definitions here? list(APPEND definitions ${d}). endforeach(). IF(TARGET ${dictionary}). LIST(APPEND include_dirs $<TARGET_PROPERTY:${dictionary},INCLUDE_DIRECTORIES>). - LIST(APPEND definitions $<TARGET_PROPERTY:${dictionary},COMPILE_DEFINITIONS>). + # The COMPILE_DEFINITIONS list might contain empty elements. These are. + # removed with the FILTER generator expression, excluding elements that. + # match the ^$ regexp (only matches empty strings). + LIST(APPEND definitions ""$<FILTER:$<TARGET_PROPERTY:${ARG_MODULE},COMPILE_DEFINITIONS>,EXCLUDE,^$>""). ENDIF(). add_custom_command(. ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11312
https://github.com/root-project/root/issues/11312:2511,deployability,modul,modules,2511,"N>>:JSON_USE_GLOBAL_UDLS=0>"". ```. However if INTERFACE_COMPILE_DEFINITIONS contains 2 or more 'empty' generator. expressions and no other values:. ```. ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0>;\$<\$<BOOL:OFF>:JSON_DISABLE_ENUM_SERIALIZATION=1>;\$<\$<BOOL:OFF>:JSON_DIAGNOSTICS=1>;\$<\$<BOOL:OFF>:JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON=1>"". ```. It also appears to works if you don't quote the expressions:. ```. $<$<NOT:$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0> $<$<NOT:$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0> .. ```. However since those lines of cmake are generated by CMake as part of the install,. we have to deal with the way they are.CMake. It is fixed on the ROOT side with:. ```. commit 08ab7e03061e551647d707637957252d121f9c39 (HEAD). Author: Jonas Rembser <jonas.rembser@cern.ch>. Date: Tue Sep 21 15:15:17 2021 +0200. [cmake] Protect against empty `COMPILE_DEFINITIONS` in rootcint command. ```. but it should be applied also to REFLEX_GENERATE_DICTIONARY:. ```. diff --git a/cmake/modules/RootMacros.cmake b/cmake/modules/RootMacros.cmake. index a19ee4e363..22816fdc8e 100644. --- a/cmake/modules/RootMacros.cmake. +++ b/cmake/modules/RootMacros.cmake. @@ -174,12 +174,16 @@ function(REFLEX_GENERATE_DICTIONARY dictionary). get_directory_property(defs COMPILE_DEFINITIONS). foreach( d ${defs}). + # Note: should we check for empty definitions here? list(APPEND definitions ${d}). endforeach(). IF(TARGET ${dictionary}). LIST(APPEND include_dirs $<TARGET_PROPERTY:${dictionary},INCLUDE_DIRECTORIES>). - LIST(APPEND definitions $<TARGET_PROPERTY:${dictionary},COMPILE_DEFINITIONS>). + # The COMPILE_DEFINITIONS list might contain empty elements. These are. + # removed with the FILTER generator expression, excluding elements that. + # match the ^$ regexp (only matches empty strings). + LIST(APPEND definitions ""$<FILTER:$<TARGET_PROPERTY:${ARG_MODULE},COMPILE_DEFINITIONS>,EXCLUDE,^$>""). ENDIF(). add_custom_command(. ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11312
https://github.com/root-project/root/issues/11312:2549,deployability,modul,modules,2549,"N>>:JSON_USE_GLOBAL_UDLS=0>"". ```. However if INTERFACE_COMPILE_DEFINITIONS contains 2 or more 'empty' generator. expressions and no other values:. ```. ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0>;\$<\$<BOOL:OFF>:JSON_DISABLE_ENUM_SERIALIZATION=1>;\$<\$<BOOL:OFF>:JSON_DIAGNOSTICS=1>;\$<\$<BOOL:OFF>:JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON=1>"". ```. It also appears to works if you don't quote the expressions:. ```. $<$<NOT:$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0> $<$<NOT:$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0> .. ```. However since those lines of cmake are generated by CMake as part of the install,. we have to deal with the way they are.CMake. It is fixed on the ROOT side with:. ```. commit 08ab7e03061e551647d707637957252d121f9c39 (HEAD). Author: Jonas Rembser <jonas.rembser@cern.ch>. Date: Tue Sep 21 15:15:17 2021 +0200. [cmake] Protect against empty `COMPILE_DEFINITIONS` in rootcint command. ```. but it should be applied also to REFLEX_GENERATE_DICTIONARY:. ```. diff --git a/cmake/modules/RootMacros.cmake b/cmake/modules/RootMacros.cmake. index a19ee4e363..22816fdc8e 100644. --- a/cmake/modules/RootMacros.cmake. +++ b/cmake/modules/RootMacros.cmake. @@ -174,12 +174,16 @@ function(REFLEX_GENERATE_DICTIONARY dictionary). get_directory_property(defs COMPILE_DEFINITIONS). foreach( d ${defs}). + # Note: should we check for empty definitions here? list(APPEND definitions ${d}). endforeach(). IF(TARGET ${dictionary}). LIST(APPEND include_dirs $<TARGET_PROPERTY:${dictionary},INCLUDE_DIRECTORIES>). - LIST(APPEND definitions $<TARGET_PROPERTY:${dictionary},COMPILE_DEFINITIONS>). + # The COMPILE_DEFINITIONS list might contain empty elements. These are. + # removed with the FILTER generator expression, excluding elements that. + # match the ^$ regexp (only matches empty strings). + LIST(APPEND definitions ""$<FILTER:$<TARGET_PROPERTY:${ARG_MODULE},COMPILE_DEFINITIONS>,EXCLUDE,^$>""). ENDIF(). add_custom_command(. ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11312
https://github.com/root-project/root/issues/11312:3042,deployability,contain,contain,3042,"N>>:JSON_USE_GLOBAL_UDLS=0>"". ```. However if INTERFACE_COMPILE_DEFINITIONS contains 2 or more 'empty' generator. expressions and no other values:. ```. ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0>;\$<\$<BOOL:OFF>:JSON_DISABLE_ENUM_SERIALIZATION=1>;\$<\$<BOOL:OFF>:JSON_DIAGNOSTICS=1>;\$<\$<BOOL:OFF>:JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON=1>"". ```. It also appears to works if you don't quote the expressions:. ```. $<$<NOT:$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0> $<$<NOT:$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0> .. ```. However since those lines of cmake are generated by CMake as part of the install,. we have to deal with the way they are.CMake. It is fixed on the ROOT side with:. ```. commit 08ab7e03061e551647d707637957252d121f9c39 (HEAD). Author: Jonas Rembser <jonas.rembser@cern.ch>. Date: Tue Sep 21 15:15:17 2021 +0200. [cmake] Protect against empty `COMPILE_DEFINITIONS` in rootcint command. ```. but it should be applied also to REFLEX_GENERATE_DICTIONARY:. ```. diff --git a/cmake/modules/RootMacros.cmake b/cmake/modules/RootMacros.cmake. index a19ee4e363..22816fdc8e 100644. --- a/cmake/modules/RootMacros.cmake. +++ b/cmake/modules/RootMacros.cmake. @@ -174,12 +174,16 @@ function(REFLEX_GENERATE_DICTIONARY dictionary). get_directory_property(defs COMPILE_DEFINITIONS). foreach( d ${defs}). + # Note: should we check for empty definitions here? list(APPEND definitions ${d}). endforeach(). IF(TARGET ${dictionary}). LIST(APPEND include_dirs $<TARGET_PROPERTY:${dictionary},INCLUDE_DIRECTORIES>). - LIST(APPEND definitions $<TARGET_PROPERTY:${dictionary},COMPILE_DEFINITIONS>). + # The COMPILE_DEFINITIONS list might contain empty elements. These are. + # removed with the FILTER generator expression, excluding elements that. + # match the ^$ regexp (only matches empty strings). + LIST(APPEND definitions ""$<FILTER:$<TARGET_PROPERTY:${ARG_MODULE},COMPILE_DEFINITIONS>,EXCLUDE,^$>""). ENDIF(). add_custom_command(. ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11312
https://github.com/root-project/root/issues/11312:3098,integrability,FILTER,FILTER,3098,"N>>:JSON_USE_GLOBAL_UDLS=0>"". ```. However if INTERFACE_COMPILE_DEFINITIONS contains 2 or more 'empty' generator. expressions and no other values:. ```. ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0>;\$<\$<BOOL:OFF>:JSON_DISABLE_ENUM_SERIALIZATION=1>;\$<\$<BOOL:OFF>:JSON_DIAGNOSTICS=1>;\$<\$<BOOL:OFF>:JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON=1>"". ```. It also appears to works if you don't quote the expressions:. ```. $<$<NOT:$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0> $<$<NOT:$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0> .. ```. However since those lines of cmake are generated by CMake as part of the install,. we have to deal with the way they are.CMake. It is fixed on the ROOT side with:. ```. commit 08ab7e03061e551647d707637957252d121f9c39 (HEAD). Author: Jonas Rembser <jonas.rembser@cern.ch>. Date: Tue Sep 21 15:15:17 2021 +0200. [cmake] Protect against empty `COMPILE_DEFINITIONS` in rootcint command. ```. but it should be applied also to REFLEX_GENERATE_DICTIONARY:. ```. diff --git a/cmake/modules/RootMacros.cmake b/cmake/modules/RootMacros.cmake. index a19ee4e363..22816fdc8e 100644. --- a/cmake/modules/RootMacros.cmake. +++ b/cmake/modules/RootMacros.cmake. @@ -174,12 +174,16 @@ function(REFLEX_GENERATE_DICTIONARY dictionary). get_directory_property(defs COMPILE_DEFINITIONS). foreach( d ${defs}). + # Note: should we check for empty definitions here? list(APPEND definitions ${d}). endforeach(). IF(TARGET ${dictionary}). LIST(APPEND include_dirs $<TARGET_PROPERTY:${dictionary},INCLUDE_DIRECTORIES>). - LIST(APPEND definitions $<TARGET_PROPERTY:${dictionary},COMPILE_DEFINITIONS>). + # The COMPILE_DEFINITIONS list might contain empty elements. These are. + # removed with the FILTER generator expression, excluding elements that. + # match the ^$ regexp (only matches empty strings). + LIST(APPEND definitions ""$<FILTER:$<TARGET_PROPERTY:${ARG_MODULE},COMPILE_DEFINITIONS>,EXCLUDE,^$>""). ENDIF(). add_custom_command(. ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11312
https://github.com/root-project/root/issues/11312:3235,integrability,FILTER,FILTER,3235,"N>>:JSON_USE_GLOBAL_UDLS=0>"". ```. However if INTERFACE_COMPILE_DEFINITIONS contains 2 or more 'empty' generator. expressions and no other values:. ```. ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0>;\$<\$<BOOL:OFF>:JSON_DISABLE_ENUM_SERIALIZATION=1>;\$<\$<BOOL:OFF>:JSON_DIAGNOSTICS=1>;\$<\$<BOOL:OFF>:JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON=1>"". ```. It also appears to works if you don't quote the expressions:. ```. $<$<NOT:$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0> $<$<NOT:$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0> .. ```. However since those lines of cmake are generated by CMake as part of the install,. we have to deal with the way they are.CMake. It is fixed on the ROOT side with:. ```. commit 08ab7e03061e551647d707637957252d121f9c39 (HEAD). Author: Jonas Rembser <jonas.rembser@cern.ch>. Date: Tue Sep 21 15:15:17 2021 +0200. [cmake] Protect against empty `COMPILE_DEFINITIONS` in rootcint command. ```. but it should be applied also to REFLEX_GENERATE_DICTIONARY:. ```. diff --git a/cmake/modules/RootMacros.cmake b/cmake/modules/RootMacros.cmake. index a19ee4e363..22816fdc8e 100644. --- a/cmake/modules/RootMacros.cmake. +++ b/cmake/modules/RootMacros.cmake. @@ -174,12 +174,16 @@ function(REFLEX_GENERATE_DICTIONARY dictionary). get_directory_property(defs COMPILE_DEFINITIONS). foreach( d ${defs}). + # Note: should we check for empty definitions here? list(APPEND definitions ${d}). endforeach(). IF(TARGET ${dictionary}). LIST(APPEND include_dirs $<TARGET_PROPERTY:${dictionary},INCLUDE_DIRECTORIES>). - LIST(APPEND definitions $<TARGET_PROPERTY:${dictionary},COMPILE_DEFINITIONS>). + # The COMPILE_DEFINITIONS list might contain empty elements. These are. + # removed with the FILTER generator expression, excluding elements that. + # match the ^$ regexp (only matches empty strings). + LIST(APPEND definitions ""$<FILTER:$<TARGET_PROPERTY:${ARG_MODULE},COMPILE_DEFINITIONS>,EXCLUDE,^$>""). ENDIF(). add_custom_command(. ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11312
https://github.com/root-project/root/issues/11312:2403,modifiability,modul,modules,2403,"N>>:JSON_USE_GLOBAL_UDLS=0>"". ```. However if INTERFACE_COMPILE_DEFINITIONS contains 2 or more 'empty' generator. expressions and no other values:. ```. ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0>;\$<\$<BOOL:OFF>:JSON_DISABLE_ENUM_SERIALIZATION=1>;\$<\$<BOOL:OFF>:JSON_DIAGNOSTICS=1>;\$<\$<BOOL:OFF>:JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON=1>"". ```. It also appears to works if you don't quote the expressions:. ```. $<$<NOT:$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0> $<$<NOT:$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0> .. ```. However since those lines of cmake are generated by CMake as part of the install,. we have to deal with the way they are.CMake. It is fixed on the ROOT side with:. ```. commit 08ab7e03061e551647d707637957252d121f9c39 (HEAD). Author: Jonas Rembser <jonas.rembser@cern.ch>. Date: Tue Sep 21 15:15:17 2021 +0200. [cmake] Protect against empty `COMPILE_DEFINITIONS` in rootcint command. ```. but it should be applied also to REFLEX_GENERATE_DICTIONARY:. ```. diff --git a/cmake/modules/RootMacros.cmake b/cmake/modules/RootMacros.cmake. index a19ee4e363..22816fdc8e 100644. --- a/cmake/modules/RootMacros.cmake. +++ b/cmake/modules/RootMacros.cmake. @@ -174,12 +174,16 @@ function(REFLEX_GENERATE_DICTIONARY dictionary). get_directory_property(defs COMPILE_DEFINITIONS). foreach( d ${defs}). + # Note: should we check for empty definitions here? list(APPEND definitions ${d}). endforeach(). IF(TARGET ${dictionary}). LIST(APPEND include_dirs $<TARGET_PROPERTY:${dictionary},INCLUDE_DIRECTORIES>). - LIST(APPEND definitions $<TARGET_PROPERTY:${dictionary},COMPILE_DEFINITIONS>). + # The COMPILE_DEFINITIONS list might contain empty elements. These are. + # removed with the FILTER generator expression, excluding elements that. + # match the ^$ regexp (only matches empty strings). + LIST(APPEND definitions ""$<FILTER:$<TARGET_PROPERTY:${ARG_MODULE},COMPILE_DEFINITIONS>,EXCLUDE,^$>""). ENDIF(). add_custom_command(. ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11312
https://github.com/root-project/root/issues/11312:2436,modifiability,modul,modules,2436,"N>>:JSON_USE_GLOBAL_UDLS=0>"". ```. However if INTERFACE_COMPILE_DEFINITIONS contains 2 or more 'empty' generator. expressions and no other values:. ```. ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0>;\$<\$<BOOL:OFF>:JSON_DISABLE_ENUM_SERIALIZATION=1>;\$<\$<BOOL:OFF>:JSON_DIAGNOSTICS=1>;\$<\$<BOOL:OFF>:JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON=1>"". ```. It also appears to works if you don't quote the expressions:. ```. $<$<NOT:$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0> $<$<NOT:$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0> .. ```. However since those lines of cmake are generated by CMake as part of the install,. we have to deal with the way they are.CMake. It is fixed on the ROOT side with:. ```. commit 08ab7e03061e551647d707637957252d121f9c39 (HEAD). Author: Jonas Rembser <jonas.rembser@cern.ch>. Date: Tue Sep 21 15:15:17 2021 +0200. [cmake] Protect against empty `COMPILE_DEFINITIONS` in rootcint command. ```. but it should be applied also to REFLEX_GENERATE_DICTIONARY:. ```. diff --git a/cmake/modules/RootMacros.cmake b/cmake/modules/RootMacros.cmake. index a19ee4e363..22816fdc8e 100644. --- a/cmake/modules/RootMacros.cmake. +++ b/cmake/modules/RootMacros.cmake. @@ -174,12 +174,16 @@ function(REFLEX_GENERATE_DICTIONARY dictionary). get_directory_property(defs COMPILE_DEFINITIONS). foreach( d ${defs}). + # Note: should we check for empty definitions here? list(APPEND definitions ${d}). endforeach(). IF(TARGET ${dictionary}). LIST(APPEND include_dirs $<TARGET_PROPERTY:${dictionary},INCLUDE_DIRECTORIES>). - LIST(APPEND definitions $<TARGET_PROPERTY:${dictionary},COMPILE_DEFINITIONS>). + # The COMPILE_DEFINITIONS list might contain empty elements. These are. + # removed with the FILTER generator expression, excluding elements that. + # match the ^$ regexp (only matches empty strings). + LIST(APPEND definitions ""$<FILTER:$<TARGET_PROPERTY:${ARG_MODULE},COMPILE_DEFINITIONS>,EXCLUDE,^$>""). ENDIF(). add_custom_command(. ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11312
https://github.com/root-project/root/issues/11312:2511,modifiability,modul,modules,2511,"N>>:JSON_USE_GLOBAL_UDLS=0>"". ```. However if INTERFACE_COMPILE_DEFINITIONS contains 2 or more 'empty' generator. expressions and no other values:. ```. ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0>;\$<\$<BOOL:OFF>:JSON_DISABLE_ENUM_SERIALIZATION=1>;\$<\$<BOOL:OFF>:JSON_DIAGNOSTICS=1>;\$<\$<BOOL:OFF>:JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON=1>"". ```. It also appears to works if you don't quote the expressions:. ```. $<$<NOT:$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0> $<$<NOT:$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0> .. ```. However since those lines of cmake are generated by CMake as part of the install,. we have to deal with the way they are.CMake. It is fixed on the ROOT side with:. ```. commit 08ab7e03061e551647d707637957252d121f9c39 (HEAD). Author: Jonas Rembser <jonas.rembser@cern.ch>. Date: Tue Sep 21 15:15:17 2021 +0200. [cmake] Protect against empty `COMPILE_DEFINITIONS` in rootcint command. ```. but it should be applied also to REFLEX_GENERATE_DICTIONARY:. ```. diff --git a/cmake/modules/RootMacros.cmake b/cmake/modules/RootMacros.cmake. index a19ee4e363..22816fdc8e 100644. --- a/cmake/modules/RootMacros.cmake. +++ b/cmake/modules/RootMacros.cmake. @@ -174,12 +174,16 @@ function(REFLEX_GENERATE_DICTIONARY dictionary). get_directory_property(defs COMPILE_DEFINITIONS). foreach( d ${defs}). + # Note: should we check for empty definitions here? list(APPEND definitions ${d}). endforeach(). IF(TARGET ${dictionary}). LIST(APPEND include_dirs $<TARGET_PROPERTY:${dictionary},INCLUDE_DIRECTORIES>). - LIST(APPEND definitions $<TARGET_PROPERTY:${dictionary},COMPILE_DEFINITIONS>). + # The COMPILE_DEFINITIONS list might contain empty elements. These are. + # removed with the FILTER generator expression, excluding elements that. + # match the ^$ regexp (only matches empty strings). + LIST(APPEND definitions ""$<FILTER:$<TARGET_PROPERTY:${ARG_MODULE},COMPILE_DEFINITIONS>,EXCLUDE,^$>""). ENDIF(). add_custom_command(. ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11312
https://github.com/root-project/root/issues/11312:2549,modifiability,modul,modules,2549,"N>>:JSON_USE_GLOBAL_UDLS=0>"". ```. However if INTERFACE_COMPILE_DEFINITIONS contains 2 or more 'empty' generator. expressions and no other values:. ```. ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0>;\$<\$<BOOL:OFF>:JSON_DISABLE_ENUM_SERIALIZATION=1>;\$<\$<BOOL:OFF>:JSON_DIAGNOSTICS=1>;\$<\$<BOOL:OFF>:JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON=1>"". ```. It also appears to works if you don't quote the expressions:. ```. $<$<NOT:$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0> $<$<NOT:$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0> .. ```. However since those lines of cmake are generated by CMake as part of the install,. we have to deal with the way they are.CMake. It is fixed on the ROOT side with:. ```. commit 08ab7e03061e551647d707637957252d121f9c39 (HEAD). Author: Jonas Rembser <jonas.rembser@cern.ch>. Date: Tue Sep 21 15:15:17 2021 +0200. [cmake] Protect against empty `COMPILE_DEFINITIONS` in rootcint command. ```. but it should be applied also to REFLEX_GENERATE_DICTIONARY:. ```. diff --git a/cmake/modules/RootMacros.cmake b/cmake/modules/RootMacros.cmake. index a19ee4e363..22816fdc8e 100644. --- a/cmake/modules/RootMacros.cmake. +++ b/cmake/modules/RootMacros.cmake. @@ -174,12 +174,16 @@ function(REFLEX_GENERATE_DICTIONARY dictionary). get_directory_property(defs COMPILE_DEFINITIONS). foreach( d ${defs}). + # Note: should we check for empty definitions here? list(APPEND definitions ${d}). endforeach(). IF(TARGET ${dictionary}). LIST(APPEND include_dirs $<TARGET_PROPERTY:${dictionary},INCLUDE_DIRECTORIES>). - LIST(APPEND definitions $<TARGET_PROPERTY:${dictionary},COMPILE_DEFINITIONS>). + # The COMPILE_DEFINITIONS list might contain empty elements. These are. + # removed with the FILTER generator expression, excluding elements that. + # match the ^$ regexp (only matches empty strings). + LIST(APPEND definitions ""$<FILTER:$<TARGET_PROPERTY:${ARG_MODULE},COMPILE_DEFINITIONS>,EXCLUDE,^$>""). ENDIF(). add_custom_command(. ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11312
https://github.com/root-project/root/issues/11312:2403,safety,modul,modules,2403,"N>>:JSON_USE_GLOBAL_UDLS=0>"". ```. However if INTERFACE_COMPILE_DEFINITIONS contains 2 or more 'empty' generator. expressions and no other values:. ```. ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0>;\$<\$<BOOL:OFF>:JSON_DISABLE_ENUM_SERIALIZATION=1>;\$<\$<BOOL:OFF>:JSON_DIAGNOSTICS=1>;\$<\$<BOOL:OFF>:JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON=1>"". ```. It also appears to works if you don't quote the expressions:. ```. $<$<NOT:$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0> $<$<NOT:$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0> .. ```. However since those lines of cmake are generated by CMake as part of the install,. we have to deal with the way they are.CMake. It is fixed on the ROOT side with:. ```. commit 08ab7e03061e551647d707637957252d121f9c39 (HEAD). Author: Jonas Rembser <jonas.rembser@cern.ch>. Date: Tue Sep 21 15:15:17 2021 +0200. [cmake] Protect against empty `COMPILE_DEFINITIONS` in rootcint command. ```. but it should be applied also to REFLEX_GENERATE_DICTIONARY:. ```. diff --git a/cmake/modules/RootMacros.cmake b/cmake/modules/RootMacros.cmake. index a19ee4e363..22816fdc8e 100644. --- a/cmake/modules/RootMacros.cmake. +++ b/cmake/modules/RootMacros.cmake. @@ -174,12 +174,16 @@ function(REFLEX_GENERATE_DICTIONARY dictionary). get_directory_property(defs COMPILE_DEFINITIONS). foreach( d ${defs}). + # Note: should we check for empty definitions here? list(APPEND definitions ${d}). endforeach(). IF(TARGET ${dictionary}). LIST(APPEND include_dirs $<TARGET_PROPERTY:${dictionary},INCLUDE_DIRECTORIES>). - LIST(APPEND definitions $<TARGET_PROPERTY:${dictionary},COMPILE_DEFINITIONS>). + # The COMPILE_DEFINITIONS list might contain empty elements. These are. + # removed with the FILTER generator expression, excluding elements that. + # match the ^$ regexp (only matches empty strings). + LIST(APPEND definitions ""$<FILTER:$<TARGET_PROPERTY:${ARG_MODULE},COMPILE_DEFINITIONS>,EXCLUDE,^$>""). ENDIF(). add_custom_command(. ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11312
https://github.com/root-project/root/issues/11312:2436,safety,modul,modules,2436,"N>>:JSON_USE_GLOBAL_UDLS=0>"". ```. However if INTERFACE_COMPILE_DEFINITIONS contains 2 or more 'empty' generator. expressions and no other values:. ```. ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0>;\$<\$<BOOL:OFF>:JSON_DISABLE_ENUM_SERIALIZATION=1>;\$<\$<BOOL:OFF>:JSON_DIAGNOSTICS=1>;\$<\$<BOOL:OFF>:JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON=1>"". ```. It also appears to works if you don't quote the expressions:. ```. $<$<NOT:$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0> $<$<NOT:$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0> .. ```. However since those lines of cmake are generated by CMake as part of the install,. we have to deal with the way they are.CMake. It is fixed on the ROOT side with:. ```. commit 08ab7e03061e551647d707637957252d121f9c39 (HEAD). Author: Jonas Rembser <jonas.rembser@cern.ch>. Date: Tue Sep 21 15:15:17 2021 +0200. [cmake] Protect against empty `COMPILE_DEFINITIONS` in rootcint command. ```. but it should be applied also to REFLEX_GENERATE_DICTIONARY:. ```. diff --git a/cmake/modules/RootMacros.cmake b/cmake/modules/RootMacros.cmake. index a19ee4e363..22816fdc8e 100644. --- a/cmake/modules/RootMacros.cmake. +++ b/cmake/modules/RootMacros.cmake. @@ -174,12 +174,16 @@ function(REFLEX_GENERATE_DICTIONARY dictionary). get_directory_property(defs COMPILE_DEFINITIONS). foreach( d ${defs}). + # Note: should we check for empty definitions here? list(APPEND definitions ${d}). endforeach(). IF(TARGET ${dictionary}). LIST(APPEND include_dirs $<TARGET_PROPERTY:${dictionary},INCLUDE_DIRECTORIES>). - LIST(APPEND definitions $<TARGET_PROPERTY:${dictionary},COMPILE_DEFINITIONS>). + # The COMPILE_DEFINITIONS list might contain empty elements. These are. + # removed with the FILTER generator expression, excluding elements that. + # match the ^$ regexp (only matches empty strings). + LIST(APPEND definitions ""$<FILTER:$<TARGET_PROPERTY:${ARG_MODULE},COMPILE_DEFINITIONS>,EXCLUDE,^$>""). ENDIF(). add_custom_command(. ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11312
https://github.com/root-project/root/issues/11312:2511,safety,modul,modules,2511,"N>>:JSON_USE_GLOBAL_UDLS=0>"". ```. However if INTERFACE_COMPILE_DEFINITIONS contains 2 or more 'empty' generator. expressions and no other values:. ```. ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0>;\$<\$<BOOL:OFF>:JSON_DISABLE_ENUM_SERIALIZATION=1>;\$<\$<BOOL:OFF>:JSON_DIAGNOSTICS=1>;\$<\$<BOOL:OFF>:JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON=1>"". ```. It also appears to works if you don't quote the expressions:. ```. $<$<NOT:$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0> $<$<NOT:$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0> .. ```. However since those lines of cmake are generated by CMake as part of the install,. we have to deal with the way they are.CMake. It is fixed on the ROOT side with:. ```. commit 08ab7e03061e551647d707637957252d121f9c39 (HEAD). Author: Jonas Rembser <jonas.rembser@cern.ch>. Date: Tue Sep 21 15:15:17 2021 +0200. [cmake] Protect against empty `COMPILE_DEFINITIONS` in rootcint command. ```. but it should be applied also to REFLEX_GENERATE_DICTIONARY:. ```. diff --git a/cmake/modules/RootMacros.cmake b/cmake/modules/RootMacros.cmake. index a19ee4e363..22816fdc8e 100644. --- a/cmake/modules/RootMacros.cmake. +++ b/cmake/modules/RootMacros.cmake. @@ -174,12 +174,16 @@ function(REFLEX_GENERATE_DICTIONARY dictionary). get_directory_property(defs COMPILE_DEFINITIONS). foreach( d ${defs}). + # Note: should we check for empty definitions here? list(APPEND definitions ${d}). endforeach(). IF(TARGET ${dictionary}). LIST(APPEND include_dirs $<TARGET_PROPERTY:${dictionary},INCLUDE_DIRECTORIES>). - LIST(APPEND definitions $<TARGET_PROPERTY:${dictionary},COMPILE_DEFINITIONS>). + # The COMPILE_DEFINITIONS list might contain empty elements. These are. + # removed with the FILTER generator expression, excluding elements that. + # match the ^$ regexp (only matches empty strings). + LIST(APPEND definitions ""$<FILTER:$<TARGET_PROPERTY:${ARG_MODULE},COMPILE_DEFINITIONS>,EXCLUDE,^$>""). ENDIF(). add_custom_command(. ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11312
https://github.com/root-project/root/issues/11312:2549,safety,modul,modules,2549,"N>>:JSON_USE_GLOBAL_UDLS=0>"". ```. However if INTERFACE_COMPILE_DEFINITIONS contains 2 or more 'empty' generator. expressions and no other values:. ```. ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0>;\$<\$<BOOL:OFF>:JSON_DISABLE_ENUM_SERIALIZATION=1>;\$<\$<BOOL:OFF>:JSON_DIAGNOSTICS=1>;\$<\$<BOOL:OFF>:JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON=1>"". ```. It also appears to works if you don't quote the expressions:. ```. $<$<NOT:$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0> $<$<NOT:$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0> .. ```. However since those lines of cmake are generated by CMake as part of the install,. we have to deal with the way they are.CMake. It is fixed on the ROOT side with:. ```. commit 08ab7e03061e551647d707637957252d121f9c39 (HEAD). Author: Jonas Rembser <jonas.rembser@cern.ch>. Date: Tue Sep 21 15:15:17 2021 +0200. [cmake] Protect against empty `COMPILE_DEFINITIONS` in rootcint command. ```. but it should be applied also to REFLEX_GENERATE_DICTIONARY:. ```. diff --git a/cmake/modules/RootMacros.cmake b/cmake/modules/RootMacros.cmake. index a19ee4e363..22816fdc8e 100644. --- a/cmake/modules/RootMacros.cmake. +++ b/cmake/modules/RootMacros.cmake. @@ -174,12 +174,16 @@ function(REFLEX_GENERATE_DICTIONARY dictionary). get_directory_property(defs COMPILE_DEFINITIONS). foreach( d ${defs}). + # Note: should we check for empty definitions here? list(APPEND definitions ${d}). endforeach(). IF(TARGET ${dictionary}). LIST(APPEND include_dirs $<TARGET_PROPERTY:${dictionary},INCLUDE_DIRECTORIES>). - LIST(APPEND definitions $<TARGET_PROPERTY:${dictionary},COMPILE_DEFINITIONS>). + # The COMPILE_DEFINITIONS list might contain empty elements. These are. + # removed with the FILTER generator expression, excluding elements that. + # match the ^$ regexp (only matches empty strings). + LIST(APPEND definitions ""$<FILTER:$<TARGET_PROPERTY:${ARG_MODULE},COMPILE_DEFINITIONS>,EXCLUDE,^$>""). ENDIF(). add_custom_command(. ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11312
https://github.com/root-project/root/issues/11312:2154,security,Auth,Author,2154,"plus one or more 'empty' generator expressions:. ```. ""SOMETHING;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>"". ```. or a single 'empy' generator expressions:. ```. ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>"". ```. However if INTERFACE_COMPILE_DEFINITIONS contains 2 or more 'empty' generator. expressions and no other values:. ```. ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0>;\$<\$<BOOL:OFF>:JSON_DISABLE_ENUM_SERIALIZATION=1>;\$<\$<BOOL:OFF>:JSON_DIAGNOSTICS=1>;\$<\$<BOOL:OFF>:JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON=1>"". ```. It also appears to works if you don't quote the expressions:. ```. $<$<NOT:$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0> $<$<NOT:$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0> .. ```. However since those lines of cmake are generated by CMake as part of the install,. we have to deal with the way they are.CMake. It is fixed on the ROOT side with:. ```. commit 08ab7e03061e551647d707637957252d121f9c39 (HEAD). Author: Jonas Rembser <jonas.rembser@cern.ch>. Date: Tue Sep 21 15:15:17 2021 +0200. [cmake] Protect against empty `COMPILE_DEFINITIONS` in rootcint command. ```. but it should be applied also to REFLEX_GENERATE_DICTIONARY:. ```. diff --git a/cmake/modules/RootMacros.cmake b/cmake/modules/RootMacros.cmake. index a19ee4e363..22816fdc8e 100644. --- a/cmake/modules/RootMacros.cmake. +++ b/cmake/modules/RootMacros.cmake. @@ -174,12 +174,16 @@ function(REFLEX_GENERATE_DICTIONARY dictionary). get_directory_property(defs COMPILE_DEFINITIONS). foreach( d ${defs}). + # Note: should we check for empty definitions here? list(APPEND definitions ${d}). endforeach(). IF(TARGET ${dictionary}). LIST(APPEND include_dirs $<TARGET_PROPERTY:${dictionary},INCLUDE_DIRECTORIES>). - LIST(APPEND definitions $<TARGET_PROPERTY:${dictionary},COMPILE_DEFINITIONS>). + # The COMPILE_DEFINITIONS list might contain empty elements. These are. + # removed with the FILTER generator expression, excluding elements that. + # m",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11312
https://github.com/root-project/root/issues/11312:57,usability,command,command,57,"On the surface the issue is that cmake produce rootcling command line for G__RIO.cxx which contains:. ```. -writeEmptyRootPCM -D -compilerI/Application. ```. Note the -D followed by nothing. We noted this problem with a Spack build which is building ROOT with no builtin. The one option on the cmake command line that triggered the problem is:. ```. -DCMAKE_PREFIX_PATH:STRING=""....//nlohmann-json-3.11.2-rasey7y53ec7uab3r6dhiktct52doyti"". ```. Inside nlohmann the line of nlohmann_jsonTargets.cmake that caused the problem is:. ```. INTERFACE_COMPILE_DEFINITIONS ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0>;\$<\$<BOOL:OFF>:JSON_DISABLE_ENUM_SERIALIZATION=1>;\$<\$<BOOL:OFF>:JSON_DIAGNOSTICS=1>;\$<\$<BOOL:OFF>:JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON=1>"". ```. This information is used in ROOT in ROOT_GENERATE_DICTIONARY:. ```. set(module_defs $<TARGET_PROPERTY:${ARG_MODULE},COMPILE_DEFINITIONS>). ... ${definitions} ""$<$<BOOL:${module_defs}>:-D$<JOIN:${module_defs},;-D>>"". ```. Experimentally having INTERFACE_COMPILE_DEFINITIONS contains a single value:. ```. ""SOMETHING"". ```. or a value plus one or more 'empty' generator expressions:. ```. ""SOMETHING;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>"". ```. or a single 'empy' generator expressions:. ```. ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>"". ```. However if INTERFACE_COMPILE_DEFINITIONS contains 2 or more 'empty' generator. expressions and no other values:. ```. ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0>;\$<\$<BOOL:OFF>:JSON_DISABLE_ENUM_SERIALIZATION=1>;\$<\$<BOOL:OFF>:JSON_DIAGNOSTICS=1>;\$<\$<BOOL:OFF>:JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON=1>"". ```. It also appears to works if you don't quote the expressions:. ```. $<$<NOT:$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0> $<$<NOT:$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0> .. ```. However since those lines of cmake are generated by CMake as part of th",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11312
https://github.com/root-project/root/issues/11312:300,usability,command,command,300,"On the surface the issue is that cmake produce rootcling command line for G__RIO.cxx which contains:. ```. -writeEmptyRootPCM -D -compilerI/Application. ```. Note the -D followed by nothing. We noted this problem with a Spack build which is building ROOT with no builtin. The one option on the cmake command line that triggered the problem is:. ```. -DCMAKE_PREFIX_PATH:STRING=""....//nlohmann-json-3.11.2-rasey7y53ec7uab3r6dhiktct52doyti"". ```. Inside nlohmann the line of nlohmann_jsonTargets.cmake that caused the problem is:. ```. INTERFACE_COMPILE_DEFINITIONS ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0>;\$<\$<BOOL:OFF>:JSON_DISABLE_ENUM_SERIALIZATION=1>;\$<\$<BOOL:OFF>:JSON_DIAGNOSTICS=1>;\$<\$<BOOL:OFF>:JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON=1>"". ```. This information is used in ROOT in ROOT_GENERATE_DICTIONARY:. ```. set(module_defs $<TARGET_PROPERTY:${ARG_MODULE},COMPILE_DEFINITIONS>). ... ${definitions} ""$<$<BOOL:${module_defs}>:-D$<JOIN:${module_defs},;-D>>"". ```. Experimentally having INTERFACE_COMPILE_DEFINITIONS contains a single value:. ```. ""SOMETHING"". ```. or a value plus one or more 'empty' generator expressions:. ```. ""SOMETHING;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>"". ```. or a single 'empy' generator expressions:. ```. ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>"". ```. However if INTERFACE_COMPILE_DEFINITIONS contains 2 or more 'empty' generator. expressions and no other values:. ```. ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0>;\$<\$<BOOL:OFF>:JSON_DISABLE_ENUM_SERIALIZATION=1>;\$<\$<BOOL:OFF>:JSON_DIAGNOSTICS=1>;\$<\$<BOOL:OFF>:JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON=1>"". ```. It also appears to works if you don't quote the expressions:. ```. $<$<NOT:$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0> $<$<NOT:$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0> .. ```. However since those lines of cmake are generated by CMake as part of th",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11312
https://github.com/root-project/root/issues/11312:2303,usability,command,command,2303,"pressions:. ```. ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>"". ```. However if INTERFACE_COMPILE_DEFINITIONS contains 2 or more 'empty' generator. expressions and no other values:. ```. ""\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0>;\$<\$<NOT:\$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0>;\$<\$<BOOL:OFF>:JSON_DISABLE_ENUM_SERIALIZATION=1>;\$<\$<BOOL:OFF>:JSON_DIAGNOSTICS=1>;\$<\$<BOOL:OFF>:JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON=1>"". ```. It also appears to works if you don't quote the expressions:. ```. $<$<NOT:$<BOOL:ON>>:JSON_USE_GLOBAL_UDLS=0> $<$<NOT:$<BOOL:ON>>:JSON_USE_IMPLICIT_CONVERSIONS=0> .. ```. However since those lines of cmake are generated by CMake as part of the install,. we have to deal with the way they are.CMake. It is fixed on the ROOT side with:. ```. commit 08ab7e03061e551647d707637957252d121f9c39 (HEAD). Author: Jonas Rembser <jonas.rembser@cern.ch>. Date: Tue Sep 21 15:15:17 2021 +0200. [cmake] Protect against empty `COMPILE_DEFINITIONS` in rootcint command. ```. but it should be applied also to REFLEX_GENERATE_DICTIONARY:. ```. diff --git a/cmake/modules/RootMacros.cmake b/cmake/modules/RootMacros.cmake. index a19ee4e363..22816fdc8e 100644. --- a/cmake/modules/RootMacros.cmake. +++ b/cmake/modules/RootMacros.cmake. @@ -174,12 +174,16 @@ function(REFLEX_GENERATE_DICTIONARY dictionary). get_directory_property(defs COMPILE_DEFINITIONS). foreach( d ${defs}). + # Note: should we check for empty definitions here? list(APPEND definitions ${d}). endforeach(). IF(TARGET ${dictionary}). LIST(APPEND include_dirs $<TARGET_PROPERTY:${dictionary},INCLUDE_DIRECTORIES>). - LIST(APPEND definitions $<TARGET_PROPERTY:${dictionary},COMPILE_DEFINITIONS>). + # The COMPILE_DEFINITIONS list might contain empty elements. These are. + # removed with the FILTER generator expression, excluding elements that. + # match the ^$ regexp (only matches empty strings). + LIST(APPEND definitions ""$<FILTER:$<TARGET_PROPERTY:${ARG_MODULE},COMPILE_DEFINITIONS>,EXCLUDE,^$>""",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11312
https://github.com/root-project/root/issues/11312:364,deployability,patch,patch,364,Additional notes:. nlohmann_json v3.9 only had one COMPILE_DEFINITIONS so it was working. nlohmann_json v3.10.5 had two COMPILE_DEFINITIONS but one of them defaulted to ON. nlohmann_json v3.11.0 increase to 5 BUT more importantly they are now ALL off. the option that default to ON still default to on but now lead to a define only when OFF. So ROOT without Jonas patch should be working with v3.10.5 and older but not with. v3.11.0 and newer.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11312
https://github.com/root-project/root/issues/11312:364,safety,patch,patch,364,Additional notes:. nlohmann_json v3.9 only had one COMPILE_DEFINITIONS so it was working. nlohmann_json v3.10.5 had two COMPILE_DEFINITIONS but one of them defaulted to ON. nlohmann_json v3.11.0 increase to 5 BUT more importantly they are now ALL off. the option that default to ON still default to on but now lead to a define only when OFF. So ROOT without Jonas patch should be working with v3.10.5 and older but not with. v3.11.0 and newer.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11312
https://github.com/root-project/root/issues/11312:364,security,patch,patch,364,Additional notes:. nlohmann_json v3.9 only had one COMPILE_DEFINITIONS so it was working. nlohmann_json v3.10.5 had two COMPILE_DEFINITIONS but one of them defaulted to ON. nlohmann_json v3.11.0 increase to 5 BUT more importantly they are now ALL off. the option that default to ON still default to on but now lead to a define only when OFF. So ROOT without Jonas patch should be working with v3.10.5 and older but not with. v3.11.0 and newer.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11312
https://github.com/root-project/root/pull/11313:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11313
https://github.com/root-project/root/pull/11313:215,energy efficiency,current,current,215,"@will-cern Given that my idea didn't work, can we clean up the commit history using an interactive rebase or `git reset --hard <commit-hash>` to make the two extra commits disappear? It's safe to force-push to your current branch, so we merge only the first commit.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11313
https://github.com/root-project/root/pull/11313:188,safety,safe,safe,188,"@will-cern Given that my idea didn't work, can we clean up the commit history using an interactive rebase or `git reset --hard <commit-hash>` to make the two extra commits disappear? It's safe to force-push to your current branch, so we merge only the first commit.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11313
https://github.com/root-project/root/pull/11313:135,security,hash,hash,135,"@will-cern Given that my idea didn't work, can we clean up the commit history using an interactive rebase or `git reset --hard <commit-hash>` to make the two extra commits disappear? It's safe to force-push to your current branch, so we merge only the first commit.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11313
https://github.com/root-project/root/pull/11313:87,usability,interact,interactive,87,"@will-cern Given that my idea didn't work, can we clean up the commit history using an interactive rebase or `git reset --hard <commit-hash>` to make the two extra commits disappear? It's safe to force-push to your current branch, so we merge only the first commit.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11313
https://github.com/root-project/root/pull/11314:15,interoperability,conflict,conflicts,15,"Rebased to fix conflicts. The first commit is proposed separately, in https://github.com/root-project/root/pull/11320 , which I'll merge before this one.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11314
https://github.com/root-project/root/pull/11314:33,safety,review,review,33,"Alright, this should be ready to review/merge.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11314
https://github.com/root-project/root/pull/11314:33,testability,review,review,33,"Alright, this should be ready to review/merge.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11314
https://github.com/root-project/root/pull/11314:12,availability,failur,failure,12,The windows failure is unrelated to this PR (and extremely weird).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11314
https://github.com/root-project/root/pull/11314:12,deployability,fail,failure,12,The windows failure is unrelated to this PR (and extremely weird).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11314
https://github.com/root-project/root/pull/11314:12,performance,failur,failure,12,The windows failure is unrelated to this PR (and extremely weird).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11314
https://github.com/root-project/root/pull/11314:12,reliability,fail,failure,12,The windows failure is unrelated to this PR (and extremely weird).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11314
https://github.com/root-project/root/pull/11315:186,energy efficiency,current,current,186,"I am not in favor to introduce yet a new keyword. The `legacy` keyword, seems to me, is the right one. Maybe the message should be improved a bit. Just a matter of taste. Let see... The current message is:. _TSpectrum is a legacy interface: it is not recommended to use it in new code. There will be no bug fixes nor new developments._. The ""key"" word here is: ""not recommended to use it in NEW code"". reading between the lines it means: you can still use this class but it is not recommended to base new development on it. That's exactly what it is. You propose:. _TSpectrum is a legacy interface: you can use it, as there is no one-to-one replacement interface planned/known. There will be no bug fixes nor new developments._. You removed the fact we do not recommend using it in new code, I do not think it is a good idea, and you add the info that there is ""no known replacement""... fine. But this can be said in the body of the doc. No need for the new keyword `unmaintained`. I am afraid a such new keyword will be used only for TSpectrum. That will add complexity for no real gain.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:113,integrability,messag,message,113,"I am not in favor to introduce yet a new keyword. The `legacy` keyword, seems to me, is the right one. Maybe the message should be improved a bit. Just a matter of taste. Let see... The current message is:. _TSpectrum is a legacy interface: it is not recommended to use it in new code. There will be no bug fixes nor new developments._. The ""key"" word here is: ""not recommended to use it in NEW code"". reading between the lines it means: you can still use this class but it is not recommended to base new development on it. That's exactly what it is. You propose:. _TSpectrum is a legacy interface: you can use it, as there is no one-to-one replacement interface planned/known. There will be no bug fixes nor new developments._. You removed the fact we do not recommend using it in new code, I do not think it is a good idea, and you add the info that there is ""no known replacement""... fine. But this can be said in the body of the doc. No need for the new keyword `unmaintained`. I am afraid a such new keyword will be used only for TSpectrum. That will add complexity for no real gain.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:194,integrability,messag,message,194,"I am not in favor to introduce yet a new keyword. The `legacy` keyword, seems to me, is the right one. Maybe the message should be improved a bit. Just a matter of taste. Let see... The current message is:. _TSpectrum is a legacy interface: it is not recommended to use it in new code. There will be no bug fixes nor new developments._. The ""key"" word here is: ""not recommended to use it in NEW code"". reading between the lines it means: you can still use this class but it is not recommended to base new development on it. That's exactly what it is. You propose:. _TSpectrum is a legacy interface: you can use it, as there is no one-to-one replacement interface planned/known. There will be no bug fixes nor new developments._. You removed the fact we do not recommend using it in new code, I do not think it is a good idea, and you add the info that there is ""no known replacement""... fine. But this can be said in the body of the doc. No need for the new keyword `unmaintained`. I am afraid a such new keyword will be used only for TSpectrum. That will add complexity for no real gain.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:230,integrability,interfac,interface,230,"I am not in favor to introduce yet a new keyword. The `legacy` keyword, seems to me, is the right one. Maybe the message should be improved a bit. Just a matter of taste. Let see... The current message is:. _TSpectrum is a legacy interface: it is not recommended to use it in new code. There will be no bug fixes nor new developments._. The ""key"" word here is: ""not recommended to use it in NEW code"". reading between the lines it means: you can still use this class but it is not recommended to base new development on it. That's exactly what it is. You propose:. _TSpectrum is a legacy interface: you can use it, as there is no one-to-one replacement interface planned/known. There will be no bug fixes nor new developments._. You removed the fact we do not recommend using it in new code, I do not think it is a good idea, and you add the info that there is ""no known replacement""... fine. But this can be said in the body of the doc. No need for the new keyword `unmaintained`. I am afraid a such new keyword will be used only for TSpectrum. That will add complexity for no real gain.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:588,integrability,interfac,interface,588,"I am not in favor to introduce yet a new keyword. The `legacy` keyword, seems to me, is the right one. Maybe the message should be improved a bit. Just a matter of taste. Let see... The current message is:. _TSpectrum is a legacy interface: it is not recommended to use it in new code. There will be no bug fixes nor new developments._. The ""key"" word here is: ""not recommended to use it in NEW code"". reading between the lines it means: you can still use this class but it is not recommended to base new development on it. That's exactly what it is. You propose:. _TSpectrum is a legacy interface: you can use it, as there is no one-to-one replacement interface planned/known. There will be no bug fixes nor new developments._. You removed the fact we do not recommend using it in new code, I do not think it is a good idea, and you add the info that there is ""no known replacement""... fine. But this can be said in the body of the doc. No need for the new keyword `unmaintained`. I am afraid a such new keyword will be used only for TSpectrum. That will add complexity for no real gain.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:653,integrability,interfac,interface,653,"I am not in favor to introduce yet a new keyword. The `legacy` keyword, seems to me, is the right one. Maybe the message should be improved a bit. Just a matter of taste. Let see... The current message is:. _TSpectrum is a legacy interface: it is not recommended to use it in new code. There will be no bug fixes nor new developments._. The ""key"" word here is: ""not recommended to use it in NEW code"". reading between the lines it means: you can still use this class but it is not recommended to base new development on it. That's exactly what it is. You propose:. _TSpectrum is a legacy interface: you can use it, as there is no one-to-one replacement interface planned/known. There will be no bug fixes nor new developments._. You removed the fact we do not recommend using it in new code, I do not think it is a good idea, and you add the info that there is ""no known replacement""... fine. But this can be said in the body of the doc. No need for the new keyword `unmaintained`. I am afraid a such new keyword will be used only for TSpectrum. That will add complexity for no real gain.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:113,interoperability,messag,message,113,"I am not in favor to introduce yet a new keyword. The `legacy` keyword, seems to me, is the right one. Maybe the message should be improved a bit. Just a matter of taste. Let see... The current message is:. _TSpectrum is a legacy interface: it is not recommended to use it in new code. There will be no bug fixes nor new developments._. The ""key"" word here is: ""not recommended to use it in NEW code"". reading between the lines it means: you can still use this class but it is not recommended to base new development on it. That's exactly what it is. You propose:. _TSpectrum is a legacy interface: you can use it, as there is no one-to-one replacement interface planned/known. There will be no bug fixes nor new developments._. You removed the fact we do not recommend using it in new code, I do not think it is a good idea, and you add the info that there is ""no known replacement""... fine. But this can be said in the body of the doc. No need for the new keyword `unmaintained`. I am afraid a such new keyword will be used only for TSpectrum. That will add complexity for no real gain.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:194,interoperability,messag,message,194,"I am not in favor to introduce yet a new keyword. The `legacy` keyword, seems to me, is the right one. Maybe the message should be improved a bit. Just a matter of taste. Let see... The current message is:. _TSpectrum is a legacy interface: it is not recommended to use it in new code. There will be no bug fixes nor new developments._. The ""key"" word here is: ""not recommended to use it in NEW code"". reading between the lines it means: you can still use this class but it is not recommended to base new development on it. That's exactly what it is. You propose:. _TSpectrum is a legacy interface: you can use it, as there is no one-to-one replacement interface planned/known. There will be no bug fixes nor new developments._. You removed the fact we do not recommend using it in new code, I do not think it is a good idea, and you add the info that there is ""no known replacement""... fine. But this can be said in the body of the doc. No need for the new keyword `unmaintained`. I am afraid a such new keyword will be used only for TSpectrum. That will add complexity for no real gain.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:230,interoperability,interfac,interface,230,"I am not in favor to introduce yet a new keyword. The `legacy` keyword, seems to me, is the right one. Maybe the message should be improved a bit. Just a matter of taste. Let see... The current message is:. _TSpectrum is a legacy interface: it is not recommended to use it in new code. There will be no bug fixes nor new developments._. The ""key"" word here is: ""not recommended to use it in NEW code"". reading between the lines it means: you can still use this class but it is not recommended to base new development on it. That's exactly what it is. You propose:. _TSpectrum is a legacy interface: you can use it, as there is no one-to-one replacement interface planned/known. There will be no bug fixes nor new developments._. You removed the fact we do not recommend using it in new code, I do not think it is a good idea, and you add the info that there is ""no known replacement""... fine. But this can be said in the body of the doc. No need for the new keyword `unmaintained`. I am afraid a such new keyword will be used only for TSpectrum. That will add complexity for no real gain.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:588,interoperability,interfac,interface,588,"I am not in favor to introduce yet a new keyword. The `legacy` keyword, seems to me, is the right one. Maybe the message should be improved a bit. Just a matter of taste. Let see... The current message is:. _TSpectrum is a legacy interface: it is not recommended to use it in new code. There will be no bug fixes nor new developments._. The ""key"" word here is: ""not recommended to use it in NEW code"". reading between the lines it means: you can still use this class but it is not recommended to base new development on it. That's exactly what it is. You propose:. _TSpectrum is a legacy interface: you can use it, as there is no one-to-one replacement interface planned/known. There will be no bug fixes nor new developments._. You removed the fact we do not recommend using it in new code, I do not think it is a good idea, and you add the info that there is ""no known replacement""... fine. But this can be said in the body of the doc. No need for the new keyword `unmaintained`. I am afraid a such new keyword will be used only for TSpectrum. That will add complexity for no real gain.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:653,interoperability,interfac,interface,653,"I am not in favor to introduce yet a new keyword. The `legacy` keyword, seems to me, is the right one. Maybe the message should be improved a bit. Just a matter of taste. Let see... The current message is:. _TSpectrum is a legacy interface: it is not recommended to use it in new code. There will be no bug fixes nor new developments._. The ""key"" word here is: ""not recommended to use it in NEW code"". reading between the lines it means: you can still use this class but it is not recommended to base new development on it. That's exactly what it is. You propose:. _TSpectrum is a legacy interface: you can use it, as there is no one-to-one replacement interface planned/known. There will be no bug fixes nor new developments._. You removed the fact we do not recommend using it in new code, I do not think it is a good idea, and you add the info that there is ""no known replacement""... fine. But this can be said in the body of the doc. No need for the new keyword `unmaintained`. I am afraid a such new keyword will be used only for TSpectrum. That will add complexity for no real gain.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:230,modifiability,interfac,interface,230,"I am not in favor to introduce yet a new keyword. The `legacy` keyword, seems to me, is the right one. Maybe the message should be improved a bit. Just a matter of taste. Let see... The current message is:. _TSpectrum is a legacy interface: it is not recommended to use it in new code. There will be no bug fixes nor new developments._. The ""key"" word here is: ""not recommended to use it in NEW code"". reading between the lines it means: you can still use this class but it is not recommended to base new development on it. That's exactly what it is. You propose:. _TSpectrum is a legacy interface: you can use it, as there is no one-to-one replacement interface planned/known. There will be no bug fixes nor new developments._. You removed the fact we do not recommend using it in new code, I do not think it is a good idea, and you add the info that there is ""no known replacement""... fine. But this can be said in the body of the doc. No need for the new keyword `unmaintained`. I am afraid a such new keyword will be used only for TSpectrum. That will add complexity for no real gain.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:588,modifiability,interfac,interface,588,"I am not in favor to introduce yet a new keyword. The `legacy` keyword, seems to me, is the right one. Maybe the message should be improved a bit. Just a matter of taste. Let see... The current message is:. _TSpectrum is a legacy interface: it is not recommended to use it in new code. There will be no bug fixes nor new developments._. The ""key"" word here is: ""not recommended to use it in NEW code"". reading between the lines it means: you can still use this class but it is not recommended to base new development on it. That's exactly what it is. You propose:. _TSpectrum is a legacy interface: you can use it, as there is no one-to-one replacement interface planned/known. There will be no bug fixes nor new developments._. You removed the fact we do not recommend using it in new code, I do not think it is a good idea, and you add the info that there is ""no known replacement""... fine. But this can be said in the body of the doc. No need for the new keyword `unmaintained`. I am afraid a such new keyword will be used only for TSpectrum. That will add complexity for no real gain.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:653,modifiability,interfac,interface,653,"I am not in favor to introduce yet a new keyword. The `legacy` keyword, seems to me, is the right one. Maybe the message should be improved a bit. Just a matter of taste. Let see... The current message is:. _TSpectrum is a legacy interface: it is not recommended to use it in new code. There will be no bug fixes nor new developments._. The ""key"" word here is: ""not recommended to use it in NEW code"". reading between the lines it means: you can still use this class but it is not recommended to base new development on it. That's exactly what it is. You propose:. _TSpectrum is a legacy interface: you can use it, as there is no one-to-one replacement interface planned/known. There will be no bug fixes nor new developments._. You removed the fact we do not recommend using it in new code, I do not think it is a good idea, and you add the info that there is ""no known replacement""... fine. But this can be said in the body of the doc. No need for the new keyword `unmaintained`. I am afraid a such new keyword will be used only for TSpectrum. That will add complexity for no real gain.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:1060,safety,compl,complexity,1060,"I am not in favor to introduce yet a new keyword. The `legacy` keyword, seems to me, is the right one. Maybe the message should be improved a bit. Just a matter of taste. Let see... The current message is:. _TSpectrum is a legacy interface: it is not recommended to use it in new code. There will be no bug fixes nor new developments._. The ""key"" word here is: ""not recommended to use it in NEW code"". reading between the lines it means: you can still use this class but it is not recommended to base new development on it. That's exactly what it is. You propose:. _TSpectrum is a legacy interface: you can use it, as there is no one-to-one replacement interface planned/known. There will be no bug fixes nor new developments._. You removed the fact we do not recommend using it in new code, I do not think it is a good idea, and you add the info that there is ""no known replacement""... fine. But this can be said in the body of the doc. No need for the new keyword `unmaintained`. I am afraid a such new keyword will be used only for TSpectrum. That will add complexity for no real gain.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:1060,security,compl,complexity,1060,"I am not in favor to introduce yet a new keyword. The `legacy` keyword, seems to me, is the right one. Maybe the message should be improved a bit. Just a matter of taste. Let see... The current message is:. _TSpectrum is a legacy interface: it is not recommended to use it in new code. There will be no bug fixes nor new developments._. The ""key"" word here is: ""not recommended to use it in NEW code"". reading between the lines it means: you can still use this class but it is not recommended to base new development on it. That's exactly what it is. You propose:. _TSpectrum is a legacy interface: you can use it, as there is no one-to-one replacement interface planned/known. There will be no bug fixes nor new developments._. You removed the fact we do not recommend using it in new code, I do not think it is a good idea, and you add the info that there is ""no known replacement""... fine. But this can be said in the body of the doc. No need for the new keyword `unmaintained`. I am afraid a such new keyword will be used only for TSpectrum. That will add complexity for no real gain.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:663,testability,plan,planned,663,"I am not in favor to introduce yet a new keyword. The `legacy` keyword, seems to me, is the right one. Maybe the message should be improved a bit. Just a matter of taste. Let see... The current message is:. _TSpectrum is a legacy interface: it is not recommended to use it in new code. There will be no bug fixes nor new developments._. The ""key"" word here is: ""not recommended to use it in NEW code"". reading between the lines it means: you can still use this class but it is not recommended to base new development on it. That's exactly what it is. You propose:. _TSpectrum is a legacy interface: you can use it, as there is no one-to-one replacement interface planned/known. There will be no bug fixes nor new developments._. You removed the fact we do not recommend using it in new code, I do not think it is a good idea, and you add the info that there is ""no known replacement""... fine. But this can be said in the body of the doc. No need for the new keyword `unmaintained`. I am afraid a such new keyword will be used only for TSpectrum. That will add complexity for no real gain.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:206,integrability,messag,message,206,"I understand your point from the developer point of view. But from the user point of view:. There have been so many many users asking this question. When so many people ask this question, it means that the message is ambiguous. It's not a one-case. https://root-forum.cern.ch/t/which-package-or-class-supersede-the-tspectrum-for-searching-peaks/51459. https://root-forum.cern.ch/t/if-tspectrum-class-is-legacy-code-another-code-for-tspectrum/50833. https://root-forum.cern.ch/t/question-about-tspectrum-alternatives/48447. https://root-forum.cern.ch/t/question-about-tspectrum-alternatives/48447. https://root-forum.cern.ch/t/alternative-for-tspectrum/49984. Also, saying that it is not recommended is a bit aggressive when there is no replacement for it, which is why in my opinion so many people ask the question. The result is that developers lose most time answering the questions in the forum. If one would say, do not use TTreeReaderArray, use RDataFrame, that would be fine. In any case, I agree with your point of adding more info in the body doc, as you commented here: https://root-forum.cern.ch/t/alternative-for-tspectrum/49984/3?u=ferhue. Still, my opinion is that the wording could be fixed on the first place. If the label were just 'interface will not receive new bug fixes', instead of 'not recommended', it would be less ambiguous and no one would ask further questions in the forum. And as a user, I still use TSpectrum in new developments. There is no alternative to it for my use cases.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:1249,integrability,interfac,interface,1249,"I understand your point from the developer point of view. But from the user point of view:. There have been so many many users asking this question. When so many people ask this question, it means that the message is ambiguous. It's not a one-case. https://root-forum.cern.ch/t/which-package-or-class-supersede-the-tspectrum-for-searching-peaks/51459. https://root-forum.cern.ch/t/if-tspectrum-class-is-legacy-code-another-code-for-tspectrum/50833. https://root-forum.cern.ch/t/question-about-tspectrum-alternatives/48447. https://root-forum.cern.ch/t/question-about-tspectrum-alternatives/48447. https://root-forum.cern.ch/t/alternative-for-tspectrum/49984. Also, saying that it is not recommended is a bit aggressive when there is no replacement for it, which is why in my opinion so many people ask the question. The result is that developers lose most time answering the questions in the forum. If one would say, do not use TTreeReaderArray, use RDataFrame, that would be fine. In any case, I agree with your point of adding more info in the body doc, as you commented here: https://root-forum.cern.ch/t/alternative-for-tspectrum/49984/3?u=ferhue. Still, my opinion is that the wording could be fixed on the first place. If the label were just 'interface will not receive new bug fixes', instead of 'not recommended', it would be less ambiguous and no one would ask further questions in the forum. And as a user, I still use TSpectrum in new developments. There is no alternative to it for my use cases.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:206,interoperability,messag,message,206,"I understand your point from the developer point of view. But from the user point of view:. There have been so many many users asking this question. When so many people ask this question, it means that the message is ambiguous. It's not a one-case. https://root-forum.cern.ch/t/which-package-or-class-supersede-the-tspectrum-for-searching-peaks/51459. https://root-forum.cern.ch/t/if-tspectrum-class-is-legacy-code-another-code-for-tspectrum/50833. https://root-forum.cern.ch/t/question-about-tspectrum-alternatives/48447. https://root-forum.cern.ch/t/question-about-tspectrum-alternatives/48447. https://root-forum.cern.ch/t/alternative-for-tspectrum/49984. Also, saying that it is not recommended is a bit aggressive when there is no replacement for it, which is why in my opinion so many people ask the question. The result is that developers lose most time answering the questions in the forum. If one would say, do not use TTreeReaderArray, use RDataFrame, that would be fine. In any case, I agree with your point of adding more info in the body doc, as you commented here: https://root-forum.cern.ch/t/alternative-for-tspectrum/49984/3?u=ferhue. Still, my opinion is that the wording could be fixed on the first place. If the label were just 'interface will not receive new bug fixes', instead of 'not recommended', it would be less ambiguous and no one would ask further questions in the forum. And as a user, I still use TSpectrum in new developments. There is no alternative to it for my use cases.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:1249,interoperability,interfac,interface,1249,"I understand your point from the developer point of view. But from the user point of view:. There have been so many many users asking this question. When so many people ask this question, it means that the message is ambiguous. It's not a one-case. https://root-forum.cern.ch/t/which-package-or-class-supersede-the-tspectrum-for-searching-peaks/51459. https://root-forum.cern.ch/t/if-tspectrum-class-is-legacy-code-another-code-for-tspectrum/50833. https://root-forum.cern.ch/t/question-about-tspectrum-alternatives/48447. https://root-forum.cern.ch/t/question-about-tspectrum-alternatives/48447. https://root-forum.cern.ch/t/alternative-for-tspectrum/49984. Also, saying that it is not recommended is a bit aggressive when there is no replacement for it, which is why in my opinion so many people ask the question. The result is that developers lose most time answering the questions in the forum. If one would say, do not use TTreeReaderArray, use RDataFrame, that would be fine. In any case, I agree with your point of adding more info in the body doc, as you commented here: https://root-forum.cern.ch/t/alternative-for-tspectrum/49984/3?u=ferhue. Still, my opinion is that the wording could be fixed on the first place. If the label were just 'interface will not receive new bug fixes', instead of 'not recommended', it would be less ambiguous and no one would ask further questions in the forum. And as a user, I still use TSpectrum in new developments. There is no alternative to it for my use cases.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:284,modifiability,pac,package-or-class-supersede-the-tspectrum-for-searching-peaks,284,"I understand your point from the developer point of view. But from the user point of view:. There have been so many many users asking this question. When so many people ask this question, it means that the message is ambiguous. It's not a one-case. https://root-forum.cern.ch/t/which-package-or-class-supersede-the-tspectrum-for-searching-peaks/51459. https://root-forum.cern.ch/t/if-tspectrum-class-is-legacy-code-another-code-for-tspectrum/50833. https://root-forum.cern.ch/t/question-about-tspectrum-alternatives/48447. https://root-forum.cern.ch/t/question-about-tspectrum-alternatives/48447. https://root-forum.cern.ch/t/alternative-for-tspectrum/49984. Also, saying that it is not recommended is a bit aggressive when there is no replacement for it, which is why in my opinion so many people ask the question. The result is that developers lose most time answering the questions in the forum. If one would say, do not use TTreeReaderArray, use RDataFrame, that would be fine. In any case, I agree with your point of adding more info in the body doc, as you commented here: https://root-forum.cern.ch/t/alternative-for-tspectrum/49984/3?u=ferhue. Still, my opinion is that the wording could be fixed on the first place. If the label were just 'interface will not receive new bug fixes', instead of 'not recommended', it would be less ambiguous and no one would ask further questions in the forum. And as a user, I still use TSpectrum in new developments. There is no alternative to it for my use cases.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:1249,modifiability,interfac,interface,1249,"I understand your point from the developer point of view. But from the user point of view:. There have been so many many users asking this question. When so many people ask this question, it means that the message is ambiguous. It's not a one-case. https://root-forum.cern.ch/t/which-package-or-class-supersede-the-tspectrum-for-searching-peaks/51459. https://root-forum.cern.ch/t/if-tspectrum-class-is-legacy-code-another-code-for-tspectrum/50833. https://root-forum.cern.ch/t/question-about-tspectrum-alternatives/48447. https://root-forum.cern.ch/t/question-about-tspectrum-alternatives/48447. https://root-forum.cern.ch/t/alternative-for-tspectrum/49984. Also, saying that it is not recommended is a bit aggressive when there is no replacement for it, which is why in my opinion so many people ask the question. The result is that developers lose most time answering the questions in the forum. If one would say, do not use TTreeReaderArray, use RDataFrame, that would be fine. In any case, I agree with your point of adding more info in the body doc, as you commented here: https://root-forum.cern.ch/t/alternative-for-tspectrum/49984/3?u=ferhue. Still, my opinion is that the wording could be fixed on the first place. If the label were just 'interface will not receive new bug fixes', instead of 'not recommended', it would be less ambiguous and no one would ask further questions in the forum. And as a user, I still use TSpectrum in new developments. There is no alternative to it for my use cases.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:856,performance,time,time,856,"I understand your point from the developer point of view. But from the user point of view:. There have been so many many users asking this question. When so many people ask this question, it means that the message is ambiguous. It's not a one-case. https://root-forum.cern.ch/t/which-package-or-class-supersede-the-tspectrum-for-searching-peaks/51459. https://root-forum.cern.ch/t/if-tspectrum-class-is-legacy-code-another-code-for-tspectrum/50833. https://root-forum.cern.ch/t/question-about-tspectrum-alternatives/48447. https://root-forum.cern.ch/t/question-about-tspectrum-alternatives/48447. https://root-forum.cern.ch/t/alternative-for-tspectrum/49984. Also, saying that it is not recommended is a bit aggressive when there is no replacement for it, which is why in my opinion so many people ask the question. The result is that developers lose most time answering the questions in the forum. If one would say, do not use TTreeReaderArray, use RDataFrame, that would be fine. In any case, I agree with your point of adding more info in the body doc, as you commented here: https://root-forum.cern.ch/t/alternative-for-tspectrum/49984/3?u=ferhue. Still, my opinion is that the wording could be fixed on the first place. If the label were just 'interface will not receive new bug fixes', instead of 'not recommended', it would be less ambiguous and no one would ask further questions in the forum. And as a user, I still use TSpectrum in new developments. There is no alternative to it for my use cases.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:2,testability,understand,understand,2,"I understand your point from the developer point of view. But from the user point of view:. There have been so many many users asking this question. When so many people ask this question, it means that the message is ambiguous. It's not a one-case. https://root-forum.cern.ch/t/which-package-or-class-supersede-the-tspectrum-for-searching-peaks/51459. https://root-forum.cern.ch/t/if-tspectrum-class-is-legacy-code-another-code-for-tspectrum/50833. https://root-forum.cern.ch/t/question-about-tspectrum-alternatives/48447. https://root-forum.cern.ch/t/question-about-tspectrum-alternatives/48447. https://root-forum.cern.ch/t/alternative-for-tspectrum/49984. Also, saying that it is not recommended is a bit aggressive when there is no replacement for it, which is why in my opinion so many people ask the question. The result is that developers lose most time answering the questions in the forum. If one would say, do not use TTreeReaderArray, use RDataFrame, that would be fine. In any case, I agree with your point of adding more info in the body doc, as you commented here: https://root-forum.cern.ch/t/alternative-for-tspectrum/49984/3?u=ferhue. Still, my opinion is that the wording could be fixed on the first place. If the label were just 'interface will not receive new bug fixes', instead of 'not recommended', it would be less ambiguous and no one would ask further questions in the forum. And as a user, I still use TSpectrum in new developments. There is no alternative to it for my use cases.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:71,usability,user,user,71,"I understand your point from the developer point of view. But from the user point of view:. There have been so many many users asking this question. When so many people ask this question, it means that the message is ambiguous. It's not a one-case. https://root-forum.cern.ch/t/which-package-or-class-supersede-the-tspectrum-for-searching-peaks/51459. https://root-forum.cern.ch/t/if-tspectrum-class-is-legacy-code-another-code-for-tspectrum/50833. https://root-forum.cern.ch/t/question-about-tspectrum-alternatives/48447. https://root-forum.cern.ch/t/question-about-tspectrum-alternatives/48447. https://root-forum.cern.ch/t/alternative-for-tspectrum/49984. Also, saying that it is not recommended is a bit aggressive when there is no replacement for it, which is why in my opinion so many people ask the question. The result is that developers lose most time answering the questions in the forum. If one would say, do not use TTreeReaderArray, use RDataFrame, that would be fine. In any case, I agree with your point of adding more info in the body doc, as you commented here: https://root-forum.cern.ch/t/alternative-for-tspectrum/49984/3?u=ferhue. Still, my opinion is that the wording could be fixed on the first place. If the label were just 'interface will not receive new bug fixes', instead of 'not recommended', it would be less ambiguous and no one would ask further questions in the forum. And as a user, I still use TSpectrum in new developments. There is no alternative to it for my use cases.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:121,usability,user,users,121,"I understand your point from the developer point of view. But from the user point of view:. There have been so many many users asking this question. When so many people ask this question, it means that the message is ambiguous. It's not a one-case. https://root-forum.cern.ch/t/which-package-or-class-supersede-the-tspectrum-for-searching-peaks/51459. https://root-forum.cern.ch/t/if-tspectrum-class-is-legacy-code-another-code-for-tspectrum/50833. https://root-forum.cern.ch/t/question-about-tspectrum-alternatives/48447. https://root-forum.cern.ch/t/question-about-tspectrum-alternatives/48447. https://root-forum.cern.ch/t/alternative-for-tspectrum/49984. Also, saying that it is not recommended is a bit aggressive when there is no replacement for it, which is why in my opinion so many people ask the question. The result is that developers lose most time answering the questions in the forum. If one would say, do not use TTreeReaderArray, use RDataFrame, that would be fine. In any case, I agree with your point of adding more info in the body doc, as you commented here: https://root-forum.cern.ch/t/alternative-for-tspectrum/49984/3?u=ferhue. Still, my opinion is that the wording could be fixed on the first place. If the label were just 'interface will not receive new bug fixes', instead of 'not recommended', it would be less ambiguous and no one would ask further questions in the forum. And as a user, I still use TSpectrum in new developments. There is no alternative to it for my use cases.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:1411,usability,user,user,1411,"I understand your point from the developer point of view. But from the user point of view:. There have been so many many users asking this question. When so many people ask this question, it means that the message is ambiguous. It's not a one-case. https://root-forum.cern.ch/t/which-package-or-class-supersede-the-tspectrum-for-searching-peaks/51459. https://root-forum.cern.ch/t/if-tspectrum-class-is-legacy-code-another-code-for-tspectrum/50833. https://root-forum.cern.ch/t/question-about-tspectrum-alternatives/48447. https://root-forum.cern.ch/t/question-about-tspectrum-alternatives/48447. https://root-forum.cern.ch/t/alternative-for-tspectrum/49984. Also, saying that it is not recommended is a bit aggressive when there is no replacement for it, which is why in my opinion so many people ask the question. The result is that developers lose most time answering the questions in the forum. If one would say, do not use TTreeReaderArray, use RDataFrame, that would be fine. In any case, I agree with your point of adding more info in the body doc, as you commented here: https://root-forum.cern.ch/t/alternative-for-tspectrum/49984/3?u=ferhue. Still, my opinion is that the wording could be fixed on the first place. If the label were just 'interface will not receive new bug fixes', instead of 'not recommended', it would be less ambiguous and no one would ask further questions in the forum. And as a user, I still use TSpectrum in new developments. There is no alternative to it for my use cases.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:41,deployability,contain,contain,41,"One idea: Maybe the 'legacy' alias could contain two arguments {1}{2}. 2 could be something like ""There is no known replacement"" or """" or ""See RDataFrame for replacement"".",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:171,deployability,depend,depending,171,"What about:. _TXXX is a legacy interface, there will be no bug fixes nor new developments, therefore it is not recommended to use it in new long-term production code. But depending on the context using TXXX might still be a valid solution._. ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:31,integrability,interfac,interface,31,"What about:. _TXXX is a legacy interface, there will be no bug fixes nor new developments, therefore it is not recommended to use it in new long-term production code. But depending on the context using TXXX might still be a valid solution._. ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:171,integrability,depend,depending,171,"What about:. _TXXX is a legacy interface, there will be no bug fixes nor new developments, therefore it is not recommended to use it in new long-term production code. But depending on the context using TXXX might still be a valid solution._. ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:31,interoperability,interfac,interface,31,"What about:. _TXXX is a legacy interface, there will be no bug fixes nor new developments, therefore it is not recommended to use it in new long-term production code. But depending on the context using TXXX might still be a valid solution._. ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:31,modifiability,interfac,interface,31,"What about:. _TXXX is a legacy interface, there will be no bug fixes nor new developments, therefore it is not recommended to use it in new long-term production code. But depending on the context using TXXX might still be a valid solution._. ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:171,modifiability,depend,depending,171,"What about:. _TXXX is a legacy interface, there will be no bug fixes nor new developments, therefore it is not recommended to use it in new long-term production code. But depending on the context using TXXX might still be a valid solution._. ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:171,safety,depend,depending,171,"What about:. _TXXX is a legacy interface, there will be no bug fixes nor new developments, therefore it is not recommended to use it in new long-term production code. But depending on the context using TXXX might still be a valid solution._. ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:224,safety,valid,valid,224,"What about:. _TXXX is a legacy interface, there will be no bug fixes nor new developments, therefore it is not recommended to use it in new long-term production code. But depending on the context using TXXX might still be a valid solution._. ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:171,testability,depend,depending,171,"What about:. _TXXX is a legacy interface, there will be no bug fixes nor new developments, therefore it is not recommended to use it in new long-term production code. But depending on the context using TXXX might still be a valid solution._. ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:188,testability,context,context,188,"What about:. _TXXX is a legacy interface, there will be no bug fixes nor new developments, therefore it is not recommended to use it in new long-term production code. But depending on the context using TXXX might still be a valid solution._. ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:179,deployability,depend,depending,179,"> What about:. > . > _TXXX is a legacy interface, there will be no bug fixes nor new developments, therefore it is not recommended to use it in new long-term production code. But depending on the context using TXXX might still be a valid solution._. > . > ? sounds perfect :). Pointing to what alternatives there are, if any, either through the legacy alias, or in the body doc, would be additionally helpful.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:39,integrability,interfac,interface,39,"> What about:. > . > _TXXX is a legacy interface, there will be no bug fixes nor new developments, therefore it is not recommended to use it in new long-term production code. But depending on the context using TXXX might still be a valid solution._. > . > ? sounds perfect :). Pointing to what alternatives there are, if any, either through the legacy alias, or in the body doc, would be additionally helpful.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:179,integrability,depend,depending,179,"> What about:. > . > _TXXX is a legacy interface, there will be no bug fixes nor new developments, therefore it is not recommended to use it in new long-term production code. But depending on the context using TXXX might still be a valid solution._. > . > ? sounds perfect :). Pointing to what alternatives there are, if any, either through the legacy alias, or in the body doc, would be additionally helpful.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:39,interoperability,interfac,interface,39,"> What about:. > . > _TXXX is a legacy interface, there will be no bug fixes nor new developments, therefore it is not recommended to use it in new long-term production code. But depending on the context using TXXX might still be a valid solution._. > . > ? sounds perfect :). Pointing to what alternatives there are, if any, either through the legacy alias, or in the body doc, would be additionally helpful.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:39,modifiability,interfac,interface,39,"> What about:. > . > _TXXX is a legacy interface, there will be no bug fixes nor new developments, therefore it is not recommended to use it in new long-term production code. But depending on the context using TXXX might still be a valid solution._. > . > ? sounds perfect :). Pointing to what alternatives there are, if any, either through the legacy alias, or in the body doc, would be additionally helpful.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:179,modifiability,depend,depending,179,"> What about:. > . > _TXXX is a legacy interface, there will be no bug fixes nor new developments, therefore it is not recommended to use it in new long-term production code. But depending on the context using TXXX might still be a valid solution._. > . > ? sounds perfect :). Pointing to what alternatives there are, if any, either through the legacy alias, or in the body doc, would be additionally helpful.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:179,safety,depend,depending,179,"> What about:. > . > _TXXX is a legacy interface, there will be no bug fixes nor new developments, therefore it is not recommended to use it in new long-term production code. But depending on the context using TXXX might still be a valid solution._. > . > ? sounds perfect :). Pointing to what alternatives there are, if any, either through the legacy alias, or in the body doc, would be additionally helpful.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:232,safety,valid,valid,232,"> What about:. > . > _TXXX is a legacy interface, there will be no bug fixes nor new developments, therefore it is not recommended to use it in new long-term production code. But depending on the context using TXXX might still be a valid solution._. > . > ? sounds perfect :). Pointing to what alternatives there are, if any, either through the legacy alias, or in the body doc, would be additionally helpful.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:179,testability,depend,depending,179,"> What about:. > . > _TXXX is a legacy interface, there will be no bug fixes nor new developments, therefore it is not recommended to use it in new long-term production code. But depending on the context using TXXX might still be a valid solution._. > . > ? sounds perfect :). Pointing to what alternatives there are, if any, either through the legacy alias, or in the body doc, would be additionally helpful.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:196,testability,context,context,196,"> What about:. > . > _TXXX is a legacy interface, there will be no bug fixes nor new developments, therefore it is not recommended to use it in new long-term production code. But depending on the context using TXXX might still be a valid solution._. > . > ? sounds perfect :). Pointing to what alternatives there are, if any, either through the legacy alias, or in the body doc, would be additionally helpful.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:401,usability,help,helpful,401,"> What about:. > . > _TXXX is a legacy interface, there will be no bug fixes nor new developments, therefore it is not recommended to use it in new long-term production code. But depending on the context using TXXX might still be a valid solution._. > . > ? sounds perfect :). Pointing to what alternatives there are, if any, either through the legacy alias, or in the body doc, would be additionally helpful.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:178,modifiability,variab,variable,178,"> Pointing to what alternatives there are, if any, either through the legacy alias, or in > the body doc, would be additionally helpful. We cannot test the existence of an input variable in an alias therefore we cannot handle with the same alias the case where there is another solution and the case where there is not. I guess if there are possible alternatives they should be mentioned in the body of the class documentation.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:147,safety,test,test,147,"> Pointing to what alternatives there are, if any, either through the legacy alias, or in > the body doc, would be additionally helpful. We cannot test the existence of an input variable in an alias therefore we cannot handle with the same alias the case where there is another solution and the case where there is not. I guess if there are possible alternatives they should be mentioned in the body of the class documentation.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:172,safety,input,input,172,"> Pointing to what alternatives there are, if any, either through the legacy alias, or in > the body doc, would be additionally helpful. We cannot test the existence of an input variable in an alias therefore we cannot handle with the same alias the case where there is another solution and the case where there is not. I guess if there are possible alternatives they should be mentioned in the body of the class documentation.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:147,testability,test,test,147,"> Pointing to what alternatives there are, if any, either through the legacy alias, or in > the body doc, would be additionally helpful. We cannot test the existence of an input variable in an alias therefore we cannot handle with the same alias the case where there is another solution and the case where there is not. I guess if there are possible alternatives they should be mentioned in the body of the class documentation.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:128,usability,help,helpful,128,"> Pointing to what alternatives there are, if any, either through the legacy alias, or in > the body doc, would be additionally helpful. We cannot test the existence of an input variable in an alias therefore we cannot handle with the same alias the case where there is another solution and the case where there is not. I guess if there are possible alternatives they should be mentioned in the body of the class documentation.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:172,usability,input,input,172,"> Pointing to what alternatives there are, if any, either through the legacy alias, or in > the body doc, would be additionally helpful. We cannot test the existence of an input variable in an alias therefore we cannot handle with the same alias the case where there is another solution and the case where there is not. I guess if there are possible alternatives they should be mentioned in the body of the class documentation.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:413,usability,document,documentation,413,"> Pointing to what alternatives there are, if any, either through the legacy alias, or in > the body doc, would be additionally helpful. We cannot test the existence of an input variable in an alias therefore we cannot handle with the same alias the case where there is another solution and the case where there is not. I guess if there are possible alternatives they should be mentioned in the body of the class documentation.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:616,deployability,depend,depending,616,"> > Pointing to what alternatives there are, if any, either through the legacy alias, or in > the body doc, would be additionally helpful. > . > We cannot test the existence of an input variable in an alias therefore we cannot handle with the same alias the case where there is another solution and the case where there is not. I guess if there are possible alternatives they should be mentioned in the body of the class documentation. I guess one could use:. `ALIASES = ""legacy{2}=\htmlonly<div class=\""legacybox\""><h2>Legacy Code</h2> \1 is a legacy interface: there will be no bug fixes nor new developments. But depending on the context using \1 might still be a valid solution. \2</div>\endhtmlonly"". `. and then e.g.:. `\legacy{TSpectrum,Some parts of this class are superseded by RooFit.}`. or:. `\legacy{TTreeReader,RDataFrame is recommended as replacement.}`. Second argument can be also left empty `{TTreeReader,}`",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:552,integrability,interfac,interface,552,"> > Pointing to what alternatives there are, if any, either through the legacy alias, or in > the body doc, would be additionally helpful. > . > We cannot test the existence of an input variable in an alias therefore we cannot handle with the same alias the case where there is another solution and the case where there is not. I guess if there are possible alternatives they should be mentioned in the body of the class documentation. I guess one could use:. `ALIASES = ""legacy{2}=\htmlonly<div class=\""legacybox\""><h2>Legacy Code</h2> \1 is a legacy interface: there will be no bug fixes nor new developments. But depending on the context using \1 might still be a valid solution. \2</div>\endhtmlonly"". `. and then e.g.:. `\legacy{TSpectrum,Some parts of this class are superseded by RooFit.}`. or:. `\legacy{TTreeReader,RDataFrame is recommended as replacement.}`. Second argument can be also left empty `{TTreeReader,}`",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:616,integrability,depend,depending,616,"> > Pointing to what alternatives there are, if any, either through the legacy alias, or in > the body doc, would be additionally helpful. > . > We cannot test the existence of an input variable in an alias therefore we cannot handle with the same alias the case where there is another solution and the case where there is not. I guess if there are possible alternatives they should be mentioned in the body of the class documentation. I guess one could use:. `ALIASES = ""legacy{2}=\htmlonly<div class=\""legacybox\""><h2>Legacy Code</h2> \1 is a legacy interface: there will be no bug fixes nor new developments. But depending on the context using \1 might still be a valid solution. \2</div>\endhtmlonly"". `. and then e.g.:. `\legacy{TSpectrum,Some parts of this class are superseded by RooFit.}`. or:. `\legacy{TTreeReader,RDataFrame is recommended as replacement.}`. Second argument can be also left empty `{TTreeReader,}`",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:552,interoperability,interfac,interface,552,"> > Pointing to what alternatives there are, if any, either through the legacy alias, or in > the body doc, would be additionally helpful. > . > We cannot test the existence of an input variable in an alias therefore we cannot handle with the same alias the case where there is another solution and the case where there is not. I guess if there are possible alternatives they should be mentioned in the body of the class documentation. I guess one could use:. `ALIASES = ""legacy{2}=\htmlonly<div class=\""legacybox\""><h2>Legacy Code</h2> \1 is a legacy interface: there will be no bug fixes nor new developments. But depending on the context using \1 might still be a valid solution. \2</div>\endhtmlonly"". `. and then e.g.:. `\legacy{TSpectrum,Some parts of this class are superseded by RooFit.}`. or:. `\legacy{TTreeReader,RDataFrame is recommended as replacement.}`. Second argument can be also left empty `{TTreeReader,}`",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:186,modifiability,variab,variable,186,"> > Pointing to what alternatives there are, if any, either through the legacy alias, or in > the body doc, would be additionally helpful. > . > We cannot test the existence of an input variable in an alias therefore we cannot handle with the same alias the case where there is another solution and the case where there is not. I guess if there are possible alternatives they should be mentioned in the body of the class documentation. I guess one could use:. `ALIASES = ""legacy{2}=\htmlonly<div class=\""legacybox\""><h2>Legacy Code</h2> \1 is a legacy interface: there will be no bug fixes nor new developments. But depending on the context using \1 might still be a valid solution. \2</div>\endhtmlonly"". `. and then e.g.:. `\legacy{TSpectrum,Some parts of this class are superseded by RooFit.}`. or:. `\legacy{TTreeReader,RDataFrame is recommended as replacement.}`. Second argument can be also left empty `{TTreeReader,}`",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:552,modifiability,interfac,interface,552,"> > Pointing to what alternatives there are, if any, either through the legacy alias, or in > the body doc, would be additionally helpful. > . > We cannot test the existence of an input variable in an alias therefore we cannot handle with the same alias the case where there is another solution and the case where there is not. I guess if there are possible alternatives they should be mentioned in the body of the class documentation. I guess one could use:. `ALIASES = ""legacy{2}=\htmlonly<div class=\""legacybox\""><h2>Legacy Code</h2> \1 is a legacy interface: there will be no bug fixes nor new developments. But depending on the context using \1 might still be a valid solution. \2</div>\endhtmlonly"". `. and then e.g.:. `\legacy{TSpectrum,Some parts of this class are superseded by RooFit.}`. or:. `\legacy{TTreeReader,RDataFrame is recommended as replacement.}`. Second argument can be also left empty `{TTreeReader,}`",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:616,modifiability,depend,depending,616,"> > Pointing to what alternatives there are, if any, either through the legacy alias, or in > the body doc, would be additionally helpful. > . > We cannot test the existence of an input variable in an alias therefore we cannot handle with the same alias the case where there is another solution and the case where there is not. I guess if there are possible alternatives they should be mentioned in the body of the class documentation. I guess one could use:. `ALIASES = ""legacy{2}=\htmlonly<div class=\""legacybox\""><h2>Legacy Code</h2> \1 is a legacy interface: there will be no bug fixes nor new developments. But depending on the context using \1 might still be a valid solution. \2</div>\endhtmlonly"". `. and then e.g.:. `\legacy{TSpectrum,Some parts of this class are superseded by RooFit.}`. or:. `\legacy{TTreeReader,RDataFrame is recommended as replacement.}`. Second argument can be also left empty `{TTreeReader,}`",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:155,safety,test,test,155,"> > Pointing to what alternatives there are, if any, either through the legacy alias, or in > the body doc, would be additionally helpful. > . > We cannot test the existence of an input variable in an alias therefore we cannot handle with the same alias the case where there is another solution and the case where there is not. I guess if there are possible alternatives they should be mentioned in the body of the class documentation. I guess one could use:. `ALIASES = ""legacy{2}=\htmlonly<div class=\""legacybox\""><h2>Legacy Code</h2> \1 is a legacy interface: there will be no bug fixes nor new developments. But depending on the context using \1 might still be a valid solution. \2</div>\endhtmlonly"". `. and then e.g.:. `\legacy{TSpectrum,Some parts of this class are superseded by RooFit.}`. or:. `\legacy{TTreeReader,RDataFrame is recommended as replacement.}`. Second argument can be also left empty `{TTreeReader,}`",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:180,safety,input,input,180,"> > Pointing to what alternatives there are, if any, either through the legacy alias, or in > the body doc, would be additionally helpful. > . > We cannot test the existence of an input variable in an alias therefore we cannot handle with the same alias the case where there is another solution and the case where there is not. I guess if there are possible alternatives they should be mentioned in the body of the class documentation. I guess one could use:. `ALIASES = ""legacy{2}=\htmlonly<div class=\""legacybox\""><h2>Legacy Code</h2> \1 is a legacy interface: there will be no bug fixes nor new developments. But depending on the context using \1 might still be a valid solution. \2</div>\endhtmlonly"". `. and then e.g.:. `\legacy{TSpectrum,Some parts of this class are superseded by RooFit.}`. or:. `\legacy{TTreeReader,RDataFrame is recommended as replacement.}`. Second argument can be also left empty `{TTreeReader,}`",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:616,safety,depend,depending,616,"> > Pointing to what alternatives there are, if any, either through the legacy alias, or in > the body doc, would be additionally helpful. > . > We cannot test the existence of an input variable in an alias therefore we cannot handle with the same alias the case where there is another solution and the case where there is not. I guess if there are possible alternatives they should be mentioned in the body of the class documentation. I guess one could use:. `ALIASES = ""legacy{2}=\htmlonly<div class=\""legacybox\""><h2>Legacy Code</h2> \1 is a legacy interface: there will be no bug fixes nor new developments. But depending on the context using \1 might still be a valid solution. \2</div>\endhtmlonly"". `. and then e.g.:. `\legacy{TSpectrum,Some parts of this class are superseded by RooFit.}`. or:. `\legacy{TTreeReader,RDataFrame is recommended as replacement.}`. Second argument can be also left empty `{TTreeReader,}`",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:667,safety,valid,valid,667,"> > Pointing to what alternatives there are, if any, either through the legacy alias, or in > the body doc, would be additionally helpful. > . > We cannot test the existence of an input variable in an alias therefore we cannot handle with the same alias the case where there is another solution and the case where there is not. I guess if there are possible alternatives they should be mentioned in the body of the class documentation. I guess one could use:. `ALIASES = ""legacy{2}=\htmlonly<div class=\""legacybox\""><h2>Legacy Code</h2> \1 is a legacy interface: there will be no bug fixes nor new developments. But depending on the context using \1 might still be a valid solution. \2</div>\endhtmlonly"". `. and then e.g.:. `\legacy{TSpectrum,Some parts of this class are superseded by RooFit.}`. or:. `\legacy{TTreeReader,RDataFrame is recommended as replacement.}`. Second argument can be also left empty `{TTreeReader,}`",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:155,testability,test,test,155,"> > Pointing to what alternatives there are, if any, either through the legacy alias, or in > the body doc, would be additionally helpful. > . > We cannot test the existence of an input variable in an alias therefore we cannot handle with the same alias the case where there is another solution and the case where there is not. I guess if there are possible alternatives they should be mentioned in the body of the class documentation. I guess one could use:. `ALIASES = ""legacy{2}=\htmlonly<div class=\""legacybox\""><h2>Legacy Code</h2> \1 is a legacy interface: there will be no bug fixes nor new developments. But depending on the context using \1 might still be a valid solution. \2</div>\endhtmlonly"". `. and then e.g.:. `\legacy{TSpectrum,Some parts of this class are superseded by RooFit.}`. or:. `\legacy{TTreeReader,RDataFrame is recommended as replacement.}`. Second argument can be also left empty `{TTreeReader,}`",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:616,testability,depend,depending,616,"> > Pointing to what alternatives there are, if any, either through the legacy alias, or in > the body doc, would be additionally helpful. > . > We cannot test the existence of an input variable in an alias therefore we cannot handle with the same alias the case where there is another solution and the case where there is not. I guess if there are possible alternatives they should be mentioned in the body of the class documentation. I guess one could use:. `ALIASES = ""legacy{2}=\htmlonly<div class=\""legacybox\""><h2>Legacy Code</h2> \1 is a legacy interface: there will be no bug fixes nor new developments. But depending on the context using \1 might still be a valid solution. \2</div>\endhtmlonly"". `. and then e.g.:. `\legacy{TSpectrum,Some parts of this class are superseded by RooFit.}`. or:. `\legacy{TTreeReader,RDataFrame is recommended as replacement.}`. Second argument can be also left empty `{TTreeReader,}`",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:633,testability,context,context,633,"> > Pointing to what alternatives there are, if any, either through the legacy alias, or in > the body doc, would be additionally helpful. > . > We cannot test the existence of an input variable in an alias therefore we cannot handle with the same alias the case where there is another solution and the case where there is not. I guess if there are possible alternatives they should be mentioned in the body of the class documentation. I guess one could use:. `ALIASES = ""legacy{2}=\htmlonly<div class=\""legacybox\""><h2>Legacy Code</h2> \1 is a legacy interface: there will be no bug fixes nor new developments. But depending on the context using \1 might still be a valid solution. \2</div>\endhtmlonly"". `. and then e.g.:. `\legacy{TSpectrum,Some parts of this class are superseded by RooFit.}`. or:. `\legacy{TTreeReader,RDataFrame is recommended as replacement.}`. Second argument can be also left empty `{TTreeReader,}`",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:130,usability,help,helpful,130,"> > Pointing to what alternatives there are, if any, either through the legacy alias, or in > the body doc, would be additionally helpful. > . > We cannot test the existence of an input variable in an alias therefore we cannot handle with the same alias the case where there is another solution and the case where there is not. I guess if there are possible alternatives they should be mentioned in the body of the class documentation. I guess one could use:. `ALIASES = ""legacy{2}=\htmlonly<div class=\""legacybox\""><h2>Legacy Code</h2> \1 is a legacy interface: there will be no bug fixes nor new developments. But depending on the context using \1 might still be a valid solution. \2</div>\endhtmlonly"". `. and then e.g.:. `\legacy{TSpectrum,Some parts of this class are superseded by RooFit.}`. or:. `\legacy{TTreeReader,RDataFrame is recommended as replacement.}`. Second argument can be also left empty `{TTreeReader,}`",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:180,usability,input,input,180,"> > Pointing to what alternatives there are, if any, either through the legacy alias, or in > the body doc, would be additionally helpful. > . > We cannot test the existence of an input variable in an alias therefore we cannot handle with the same alias the case where there is another solution and the case where there is not. I guess if there are possible alternatives they should be mentioned in the body of the class documentation. I guess one could use:. `ALIASES = ""legacy{2}=\htmlonly<div class=\""legacybox\""><h2>Legacy Code</h2> \1 is a legacy interface: there will be no bug fixes nor new developments. But depending on the context using \1 might still be a valid solution. \2</div>\endhtmlonly"". `. and then e.g.:. `\legacy{TSpectrum,Some parts of this class are superseded by RooFit.}`. or:. `\legacy{TTreeReader,RDataFrame is recommended as replacement.}`. Second argument can be also left empty `{TTreeReader,}`",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:421,usability,document,documentation,421,"> > Pointing to what alternatives there are, if any, either through the legacy alias, or in > the body doc, would be additionally helpful. > . > We cannot test the existence of an input variable in an alias therefore we cannot handle with the same alias the case where there is another solution and the case where there is not. I guess if there are possible alternatives they should be mentioned in the body of the class documentation. I guess one could use:. `ALIASES = ""legacy{2}=\htmlonly<div class=\""legacybox\""><h2>Legacy Code</h2> \1 is a legacy interface: there will be no bug fixes nor new developments. But depending on the context using \1 might still be a valid solution. \2</div>\endhtmlonly"". `. and then e.g.:. `\legacy{TSpectrum,Some parts of this class are superseded by RooFit.}`. or:. `\legacy{TTreeReader,RDataFrame is recommended as replacement.}`. Second argument can be also left empty `{TTreeReader,}`",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:206,deployability,version,version,206,"Thanks! Another mechanism to know if there are one or two arguments would be overloading, but that requires repeating a bit of text when defining the aliases:. ```. Note that you can overload an alias by a version with multiple arguments, for instance:. ALIASES += l{1}=""\ref \1"". ALIASES += l{2}=""\ref \1 \""\2\"""". ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:206,integrability,version,version,206,"Thanks! Another mechanism to know if there are one or two arguments would be overloading, but that requires repeating a bit of text when defining the aliases:. ```. Note that you can overload an alias by a version with multiple arguments, for instance:. ALIASES += l{1}=""\ref \1"". ALIASES += l{2}=""\ref \1 \""\2\"""". ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:206,modifiability,version,version,206,"Thanks! Another mechanism to know if there are one or two arguments would be overloading, but that requires repeating a bit of text when defining the aliases:. ```. Note that you can overload an alias by a version with multiple arguments, for instance:. ALIASES += l{1}=""\ref \1"". ALIASES += l{2}=""\ref \1 \""\2\"""". ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:60,security,modif,modify,60,"I guess it is better if I do a new PR, Or would you like to modify this one to implement the new way?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:13,usability,close,close,13,"Sure, I will close this one :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11315:12,reliability,doe,does,12,TTreeReader does not have the `\legacy` banner right now. https://root.cern/doc/master/classTTreeReader.html,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11315
https://github.com/root-project/root/pull/11317:11,deployability,build,build,11,@phsft-bot build just on ROOT-ubuntu2204/default with flags -Dtmva-sofie=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11317
https://github.com/root-project/root/pull/11317:11,deployability,build,build,11,@phsft-bot build just on ROOT-ubuntu2204/default with flags -Dtmva-sofie=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11317
https://github.com/root-project/root/pull/11321:411,availability,failur,failure,411,"Using the file `""http://root.cern.ch/files/h1/dstarmb.root""` and (when `xrootd` in enabled) `""root://eospublic.cern.ch//eos/root-eos/h1/dstarmb.root""` maybe something like:. ```. bool tester(const char *filename) {. auto f = TFile::Open(filename, ""READ_WITHOUT_GLOBALREGISTRATION"");. if (f && ! f->IsZombie() && nullptr == gROOT->GetListOfFiles()->FindObject(filename)) {. delete f;. return true;. } else {. // failure;. return false;. }. }. ```. (possibly separating all 3 failures types).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11321
https://github.com/root-project/root/pull/11321:474,availability,failur,failures,474,"Using the file `""http://root.cern.ch/files/h1/dstarmb.root""` and (when `xrootd` in enabled) `""root://eospublic.cern.ch//eos/root-eos/h1/dstarmb.root""` maybe something like:. ```. bool tester(const char *filename) {. auto f = TFile::Open(filename, ""READ_WITHOUT_GLOBALREGISTRATION"");. if (f && ! f->IsZombie() && nullptr == gROOT->GetListOfFiles()->FindObject(filename)) {. delete f;. return true;. } else {. // failure;. return false;. }. }. ```. (possibly separating all 3 failures types).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11321
https://github.com/root-project/root/pull/11321:411,deployability,fail,failure,411,"Using the file `""http://root.cern.ch/files/h1/dstarmb.root""` and (when `xrootd` in enabled) `""root://eospublic.cern.ch//eos/root-eos/h1/dstarmb.root""` maybe something like:. ```. bool tester(const char *filename) {. auto f = TFile::Open(filename, ""READ_WITHOUT_GLOBALREGISTRATION"");. if (f && ! f->IsZombie() && nullptr == gROOT->GetListOfFiles()->FindObject(filename)) {. delete f;. return true;. } else {. // failure;. return false;. }. }. ```. (possibly separating all 3 failures types).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11321
https://github.com/root-project/root/pull/11321:474,deployability,fail,failures,474,"Using the file `""http://root.cern.ch/files/h1/dstarmb.root""` and (when `xrootd` in enabled) `""root://eospublic.cern.ch//eos/root-eos/h1/dstarmb.root""` maybe something like:. ```. bool tester(const char *filename) {. auto f = TFile::Open(filename, ""READ_WITHOUT_GLOBALREGISTRATION"");. if (f && ! f->IsZombie() && nullptr == gROOT->GetListOfFiles()->FindObject(filename)) {. delete f;. return true;. } else {. // failure;. return false;. }. }. ```. (possibly separating all 3 failures types).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11321
https://github.com/root-project/root/pull/11321:411,performance,failur,failure,411,"Using the file `""http://root.cern.ch/files/h1/dstarmb.root""` and (when `xrootd` in enabled) `""root://eospublic.cern.ch//eos/root-eos/h1/dstarmb.root""` maybe something like:. ```. bool tester(const char *filename) {. auto f = TFile::Open(filename, ""READ_WITHOUT_GLOBALREGISTRATION"");. if (f && ! f->IsZombie() && nullptr == gROOT->GetListOfFiles()->FindObject(filename)) {. delete f;. return true;. } else {. // failure;. return false;. }. }. ```. (possibly separating all 3 failures types).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11321
https://github.com/root-project/root/pull/11321:474,performance,failur,failures,474,"Using the file `""http://root.cern.ch/files/h1/dstarmb.root""` and (when `xrootd` in enabled) `""root://eospublic.cern.ch//eos/root-eos/h1/dstarmb.root""` maybe something like:. ```. bool tester(const char *filename) {. auto f = TFile::Open(filename, ""READ_WITHOUT_GLOBALREGISTRATION"");. if (f && ! f->IsZombie() && nullptr == gROOT->GetListOfFiles()->FindObject(filename)) {. delete f;. return true;. } else {. // failure;. return false;. }. }. ```. (possibly separating all 3 failures types).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11321
https://github.com/root-project/root/pull/11321:411,reliability,fail,failure,411,"Using the file `""http://root.cern.ch/files/h1/dstarmb.root""` and (when `xrootd` in enabled) `""root://eospublic.cern.ch//eos/root-eos/h1/dstarmb.root""` maybe something like:. ```. bool tester(const char *filename) {. auto f = TFile::Open(filename, ""READ_WITHOUT_GLOBALREGISTRATION"");. if (f && ! f->IsZombie() && nullptr == gROOT->GetListOfFiles()->FindObject(filename)) {. delete f;. return true;. } else {. // failure;. return false;. }. }. ```. (possibly separating all 3 failures types).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11321
https://github.com/root-project/root/pull/11321:474,reliability,fail,failures,474,"Using the file `""http://root.cern.ch/files/h1/dstarmb.root""` and (when `xrootd` in enabled) `""root://eospublic.cern.ch//eos/root-eos/h1/dstarmb.root""` maybe something like:. ```. bool tester(const char *filename) {. auto f = TFile::Open(filename, ""READ_WITHOUT_GLOBALREGISTRATION"");. if (f && ! f->IsZombie() && nullptr == gROOT->GetListOfFiles()->FindObject(filename)) {. delete f;. return true;. } else {. // failure;. return false;. }. }. ```. (possibly separating all 3 failures types).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11321
https://github.com/root-project/root/pull/11321:184,safety,test,tester,184,"Using the file `""http://root.cern.ch/files/h1/dstarmb.root""` and (when `xrootd` in enabled) `""root://eospublic.cern.ch//eos/root-eos/h1/dstarmb.root""` maybe something like:. ```. bool tester(const char *filename) {. auto f = TFile::Open(filename, ""READ_WITHOUT_GLOBALREGISTRATION"");. if (f && ! f->IsZombie() && nullptr == gROOT->GetListOfFiles()->FindObject(filename)) {. delete f;. return true;. } else {. // failure;. return false;. }. }. ```. (possibly separating all 3 failures types).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11321
https://github.com/root-project/root/pull/11321:184,testability,test,tester,184,"Using the file `""http://root.cern.ch/files/h1/dstarmb.root""` and (when `xrootd` in enabled) `""root://eospublic.cern.ch//eos/root-eos/h1/dstarmb.root""` maybe something like:. ```. bool tester(const char *filename) {. auto f = TFile::Open(filename, ""READ_WITHOUT_GLOBALREGISTRATION"");. if (f && ! f->IsZombie() && nullptr == gROOT->GetListOfFiles()->FindObject(filename)) {. delete f;. return true;. } else {. // failure;. return false;. }. }. ```. (possibly separating all 3 failures types).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11321
https://github.com/root-project/root/pull/11321:158,deployability,patch,patching,158,"The problem with the test is that on those platforms `TDavixFile` is used, while on my laptop `TWebFile` is used instead so I only applied the fix there. Now patching `TDavixFile`",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11321
https://github.com/root-project/root/pull/11321:43,interoperability,platform,platforms,43,"The problem with the test is that on those platforms `TDavixFile` is used, while on my laptop `TWebFile` is used instead so I only applied the fix there. Now patching `TDavixFile`",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11321
https://github.com/root-project/root/pull/11321:21,safety,test,test,21,"The problem with the test is that on those platforms `TDavixFile` is used, while on my laptop `TWebFile` is used instead so I only applied the fix there. Now patching `TDavixFile`",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11321
https://github.com/root-project/root/pull/11321:158,safety,patch,patching,158,"The problem with the test is that on those platforms `TDavixFile` is used, while on my laptop `TWebFile` is used instead so I only applied the fix there. Now patching `TDavixFile`",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11321
https://github.com/root-project/root/pull/11321:158,security,patch,patching,158,"The problem with the test is that on those platforms `TDavixFile` is used, while on my laptop `TWebFile` is used instead so I only applied the fix there. Now patching `TDavixFile`",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11321
https://github.com/root-project/root/pull/11321:21,testability,test,test,21,"The problem with the test is that on those platforms `TDavixFile` is used, while on my laptop `TWebFile` is used instead so I only applied the fix there. Now patching `TDavixFile`",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11321
https://github.com/root-project/root/pull/11321:4,availability,failur,failures,4,The failures are unrelated.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11321
https://github.com/root-project/root/pull/11321:4,deployability,fail,failures,4,The failures are unrelated.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11321
https://github.com/root-project/root/pull/11321:4,performance,failur,failures,4,The failures are unrelated.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11321
https://github.com/root-project/root/pull/11321:4,reliability,fail,failures,4,The failures are unrelated.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11321
https://github.com/root-project/root/pull/11322:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11322
https://github.com/root-project/root/pull/11325:11,deployability,build,build,11,@phsft-bot build just on ROOT-ubuntu2204/default with flags -Dtmva-sofie=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11325
https://github.com/root-project/root/pull/11325:11,deployability,build,build,11,@phsft-bot build just on ROOT-ubuntu2204/default with flags -DCTEST_TEST_EXCLUDE_NONE=On -Dtmva-sofie=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11325
https://github.com/root-project/root/pull/11325:11,deployability,build,build,11,@phsft-bot build just on ROOT-ubuntu2204/default with flags -DCTEST_TEST_EXCLUDE_NONE=On -Dtmva-sofie=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11325
https://github.com/root-project/root/pull/11325:11,deployability,build,build,11,@phsft-bot build just on ROOT-ubuntu2204/default with flags -DCTEST_TEST_EXCLUDE_NONE=On -Dtmva-sofie=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11325
https://github.com/root-project/root/pull/11326:11,deployability,build,build,11,@phsft-bot build just on windows10/cxx14,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11326
https://github.com/root-project/root/pull/11326:11,deployability,build,build,11,@phsft-bot build just on windows10/cxx14,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11326
https://github.com/root-project/root/pull/11326:11,deployability,build,build,11,@phsft-bot build just on windows10/cxx14,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11326
https://github.com/root-project/root/pull/11326:11,deployability,build,build,11,@phsft-bot build just on windows10/cxx14,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11326
https://github.com/root-project/root/pull/11327:48,integrability,coupl,couple,48,"Thanks! EDIT: Sorry I misread, all fine. Just a couple of unimportant space/typos.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11327
https://github.com/root-project/root/pull/11327:48,modifiability,coupl,couple,48,"Thanks! EDIT: Sorry I misread, all fine. Just a couple of unimportant space/typos.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11327
https://github.com/root-project/root/pull/11327:48,testability,coupl,couple,48,"Thanks! EDIT: Sorry I misread, all fine. Just a couple of unimportant space/typos.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11327
https://github.com/root-project/root/pull/11328:11,deployability,build,build,11,@phsft-bot build just on mac1015/cxx17,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11328
https://github.com/root-project/root/pull/11328:42,safety,review,review,42,CI is passing so this should be ready for review now.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11328
https://github.com/root-project/root/pull/11328:42,testability,review,review,42,CI is passing so this should be ready for review now.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11328
https://github.com/root-project/root/pull/11328:118,safety,review,review,118,"> Bertrand (who I assume would know) is on leave. @Axel-Naumann @andresailer given the above, can I get one of you to review this PR (and then it's backport in PR #11358)?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11328
https://github.com/root-project/root/pull/11328:118,testability,review,review,118,"> Bertrand (who I assume would know) is on leave. @Axel-Naumann @andresailer given the above, can I get one of you to review this PR (and then it's backport in PR #11358)?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11328
https://github.com/root-project/root/issues/11329:6,deployability,observ,observation,6,"A few observation:. * it works without -cxxmodule . * it fails with -cxxmodule (and the other argument to suppress warning about automatically generating modules). * without -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<int>. * * vector<ROOT::Interna::TSchemaHelper>. * * both are seen twice. * with -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<double>. * * vector<ROOT::Interna::TSchemaHelper>. * * vector<unsigned int>. * * vector<std::__cxx11::basic_string<char>>. * * each are seen twice. * * there is no vector<int>. If I dump the translation unit I see:. ```. grep push_back | grep 1276. | | | |-CXXMethodDecl 0xa59e3a8 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector::value_type &)'. | | | |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. ```. in the successful case. 	. In the failing case I see:. ```. | | | |-CXXMethodDecl 0",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:57,deployability,fail,fails,57,"A few observation:. * it works without -cxxmodule . * it fails with -cxxmodule (and the other argument to suppress warning about automatically generating modules). * without -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<int>. * * vector<ROOT::Interna::TSchemaHelper>. * * both are seen twice. * with -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<double>. * * vector<ROOT::Interna::TSchemaHelper>. * * vector<unsigned int>. * * vector<std::__cxx11::basic_string<char>>. * * each are seen twice. * * there is no vector<int>. If I dump the translation unit I see:. ```. grep push_back | grep 1276. | | | |-CXXMethodDecl 0xa59e3a8 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector::value_type &)'. | | | |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. ```. in the successful case. 	. In the failing case I see:. ```. | | | |-CXXMethodDecl 0",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:129,deployability,automat,automatically,129,"A few observation:. * it works without -cxxmodule . * it fails with -cxxmodule (and the other argument to suppress warning about automatically generating modules). * without -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<int>. * * vector<ROOT::Interna::TSchemaHelper>. * * both are seen twice. * with -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<double>. * * vector<ROOT::Interna::TSchemaHelper>. * * vector<unsigned int>. * * vector<std::__cxx11::basic_string<char>>. * * each are seen twice. * * there is no vector<int>. If I dump the translation unit I see:. ```. grep push_back | grep 1276. | | | |-CXXMethodDecl 0xa59e3a8 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector::value_type &)'. | | | |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. ```. in the successful case. 	. In the failing case I see:. ```. | | | |-CXXMethodDecl 0",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:154,deployability,modul,modules,154,"A few observation:. * it works without -cxxmodule . * it fails with -cxxmodule (and the other argument to suppress warning about automatically generating modules). * without -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<int>. * * vector<ROOT::Interna::TSchemaHelper>. * * both are seen twice. * with -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<double>. * * vector<ROOT::Interna::TSchemaHelper>. * * vector<unsigned int>. * * vector<std::__cxx11::basic_string<char>>. * * each are seen twice. * * there is no vector<int>. If I dump the translation unit I see:. ```. grep push_back | grep 1276. | | | |-CXXMethodDecl 0xa59e3a8 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector::value_type &)'. | | | |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. ```. in the successful case. 	. In the failing case I see:. ```. | | | |-CXXMethodDecl 0",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:1951,deployability,fail,failing,1951,"sh_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. ```. in the successful case. 	. In the failing case I see:. ```. | | | |-CXXMethodDecl 0xed02b08 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector::value_type &)'. | | | |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | | |-CXXMethodDecl 0xb33a8c8 <line:1275:7, line:1288:7> line:1276:7 imported in std.regex hidden push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. | | | |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. | | | |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. | | | |-CXXMethodDecl 0xeebc838 <line:1275:7, ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:4941,deployability,observ,observations,4941,"aHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::__cxx11::basic_string<char> > >::value_type &)'. |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::. ```. several observations:. a. They are all imported from a module except for std::vector<ROOT::Internal::TSchemaHelper>. b. we see the string, unsigned int and double as expected. c. we also see vector<int> ... but it does not get to the selector code. d. we also see vector<unsigned long> that is not seen by the selector code. e. the one seen by the selector are marked with imported in std.vector hidden. f. the one NOT seen by the selector are marked with imported in std.regex hidden. g. the one NOT seen by the selector are mentioned only once in the output instead of 3 times for the others.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:4988,deployability,modul,module,4988,"aHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::__cxx11::basic_string<char> > >::value_type &)'. |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::. ```. several observations:. a. They are all imported from a module except for std::vector<ROOT::Internal::TSchemaHelper>. b. we see the string, unsigned int and double as expected. c. we also see vector<int> ... but it does not get to the selector code. d. we also see vector<unsigned long> that is not seen by the selector code. e. the one seen by the selector are marked with imported in std.vector hidden. f. the one NOT seen by the selector are marked with imported in std.regex hidden. g. the one NOT seen by the selector are mentioned only once in the output instead of 3 times for the others.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:1024,energy efficiency,alloc,allocator,1024,"s without -cxxmodule . * it fails with -cxxmodule (and the other argument to suppress warning about automatically generating modules). * without -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<int>. * * vector<ROOT::Interna::TSchemaHelper>. * * both are seen twice. * with -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<double>. * * vector<ROOT::Interna::TSchemaHelper>. * * vector<unsigned int>. * * vector<std::__cxx11::basic_string<char>>. * * each are seen twice. * * there is no vector<int>. If I dump the translation unit I see:. ```. grep push_back | grep 1276. | | | |-CXXMethodDecl 0xa59e3a8 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector::value_type &)'. | | | |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. ```. in the successful case. 	. In the failing case I see:. ```. | | | |-CXXMethodDecl 0xed02b08 <line:1275:7, line:1",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:1198,energy efficiency,alloc,allocator,1198,"verse the the translation unit to try to match decls with the selections patterns sees. * * vector<int>. * * vector<ROOT::Interna::TSchemaHelper>. * * both are seen twice. * with -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<double>. * * vector<ROOT::Interna::TSchemaHelper>. * * vector<unsigned int>. * * vector<std::__cxx11::basic_string<char>>. * * each are seen twice. * * there is no vector<int>. If I dump the translation unit I see:. ```. grep push_back | grep 1276. | | | |-CXXMethodDecl 0xa59e3a8 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector::value_type &)'. | | | |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. ```. in the successful case. 	. In the failing case I see:. ```. | | | |-CXXMethodDecl 0xed02b08 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector::value_type &)'. | | | |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:1368,energy efficiency,alloc,allocator,1368,". * with -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<double>. * * vector<ROOT::Interna::TSchemaHelper>. * * vector<unsigned int>. * * vector<std::__cxx11::basic_string<char>>. * * each are seen twice. * * there is no vector<int>. If I dump the translation unit I see:. ```. grep push_back | grep 1276. | | | |-CXXMethodDecl 0xa59e3a8 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector::value_type &)'. | | | |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. ```. in the successful case. 	. In the failing case I see:. ```. | | | |-CXXMethodDecl 0xed02b08 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector::value_type &)'. | | | |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | | |-CXXMethodDecl 0xb33",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:1538,energy efficiency,alloc,allocator,1538,"::TSchemaHelper>. * * vector<unsigned int>. * * vector<std::__cxx11::basic_string<char>>. * * each are seen twice. * * there is no vector<int>. If I dump the translation unit I see:. ```. grep push_back | grep 1276. | | | |-CXXMethodDecl 0xa59e3a8 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector::value_type &)'. | | | |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. ```. in the successful case. 	. In the failing case I see:. ```. | | | |-CXXMethodDecl 0xed02b08 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector::value_type &)'. | | | |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | | |-CXXMethodDecl 0xb33a8c8 <line:1275:7, line:1288:7> line:1276:7 imported in std.regex hidden push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. | | | |-CXXMethodD",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:1708,energy efficiency,alloc,allocator,1708,"unit I see:. ```. grep push_back | grep 1276. | | | |-CXXMethodDecl 0xa59e3a8 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector::value_type &)'. | | | |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. ```. in the successful case. 	. In the failing case I see:. ```. | | | |-CXXMethodDecl 0xed02b08 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector::value_type &)'. | | | |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | | |-CXXMethodDecl 0xb33a8c8 <line:1275:7, line:1288:7> line:1276:7 imported in std.regex hidden push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. | | | |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. | ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:1878,energy efficiency,alloc,allocator,1878," | | |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. ```. in the successful case. 	. In the failing case I see:. ```. | | | |-CXXMethodDecl 0xed02b08 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector::value_type &)'. | | | |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | | |-CXXMethodDecl 0xb33a8c8 <line:1275:7, line:1288:7> line:1276:7 imported in std.regex hidden push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. | | | |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. | | | |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigne",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:2286,energy efficiency,alloc,allocator,2286,"276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. ```. in the successful case. 	. In the failing case I see:. ```. | | | |-CXXMethodDecl 0xed02b08 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector::value_type &)'. | | | |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | | |-CXXMethodDecl 0xb33a8c8 <line:1275:7, line:1288:7> line:1276:7 imported in std.regex hidden push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. | | | |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. | | | |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. | | | |-CXXMethodDecl 0xeebc838 <line:1275:7, line:1288:7> line:1276:7 imported in std.regex hidden push_back 'void (const std::vector<unsigned long, std::allocator<unsigned long> >::value_type &)'. | | |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:2491,energy efficiency,alloc,allocator,2491,"h_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. ```. in the successful case. 	. In the failing case I see:. ```. | | | |-CXXMethodDecl 0xed02b08 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector::value_type &)'. | | | |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | | |-CXXMethodDecl 0xb33a8c8 <line:1275:7, line:1288:7> line:1276:7 imported in std.regex hidden push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. | | | |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. | | | |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. | | | |-CXXMethodDecl 0xeebc838 <line:1275:7, line:1288:7> line:1276:7 imported in std.regex hidden push_back 'void (const std::vector<unsigned long, std::allocator<unsigned long> >::value_type &)'. | | |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::__cxx11::basic_string<char> > >::value_type &)'. |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::a",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:2674,energy efficiency,alloc,allocator,2674,"nternal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. ```. in the successful case. 	. In the failing case I see:. ```. | | | |-CXXMethodDecl 0xed02b08 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector::value_type &)'. | | | |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | | |-CXXMethodDecl 0xb33a8c8 <line:1275:7, line:1288:7> line:1276:7 imported in std.regex hidden push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. | | | |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. | | | |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. | | | |-CXXMethodDecl 0xeebc838 <line:1275:7, line:1288:7> line:1276:7 imported in std.regex hidden push_back 'void (const std::vector<unsigned long, std::allocator<unsigned long> >::value_type &)'. | | |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::__cxx11::basic_string<char> > >::value_type &)'. |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::v",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:2866,energy efficiency,alloc,allocator,2866,", std::allocator<int> >::value_type &)'. ```. in the successful case. 	. In the failing case I see:. ```. | | | |-CXXMethodDecl 0xed02b08 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector::value_type &)'. | | | |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | | |-CXXMethodDecl 0xb33a8c8 <line:1275:7, line:1288:7> line:1276:7 imported in std.regex hidden push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. | | | |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. | | | |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. | | | |-CXXMethodDecl 0xeebc838 <line:1275:7, line:1288:7> line:1276:7 imported in std.regex hidden push_back 'void (const std::vector<unsigned long, std::allocator<unsigned long> >::value_type &)'. | | |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::__cxx11::basic_string<char> > >::value_type &)'. |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsign",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:3064,energy efficiency,alloc,allocator,3064,"r hidden push_back 'void (const std::vector::value_type &)'. | | | |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | | |-CXXMethodDecl 0xb33a8c8 <line:1275:7, line:1288:7> line:1276:7 imported in std.regex hidden push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. | | | |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. | | | |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. | | | |-CXXMethodDecl 0xeebc838 <line:1275:7, line:1288:7> line:1276:7 imported in std.regex hidden push_back 'void (const std::vector<unsigned long, std::allocator<unsigned long> >::value_type &)'. | | |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::__cxx11::basic_string<char> > >::value_type &)'. |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:3281,energy efficiency,alloc,allocator,3281,"allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | | |-CXXMethodDecl 0xb33a8c8 <line:1275:7, line:1288:7> line:1276:7 imported in std.regex hidden push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. | | | |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. | | | |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. | | | |-CXXMethodDecl 0xeebc838 <line:1275:7, line:1288:7> line:1276:7 imported in std.regex hidden push_back 'void (const std::vector<unsigned long, std::allocator<unsigned long> >::value_type &)'. | | |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::__cxx11::basic_string<char> > >::value_type &)'. |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::__cxx11::basic_string<char> > >::value_type &)'. |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Intern",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:3495,energy efficiency,alloc,allocator,3495,"<int> >::value_type &)'. | | | |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. | | | |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. | | | |-CXXMethodDecl 0xeebc838 <line:1275:7, line:1288:7> line:1276:7 imported in std.regex hidden push_back 'void (const std::vector<unsigned long, std::allocator<unsigned long> >::value_type &)'. | | |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::__cxx11::basic_string<char> > >::value_type &)'. |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::__cxx11::basic_string<char> > >::value_type &)'. |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:3698,energy efficiency,alloc,allocator,3698,"pe &)'. | | | |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. | | | |-CXXMethodDecl 0xeebc838 <line:1275:7, line:1288:7> line:1276:7 imported in std.regex hidden push_back 'void (const std::vector<unsigned long, std::allocator<unsigned long> >::value_type &)'. | | |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::__cxx11::basic_string<char> > >::value_type &)'. |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::__cxx11::basic_string<char> > >::value_type &)'. |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allo",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:3884,energy efficiency,alloc,allocator,3884," >::value_type &)'. | | | |-CXXMethodDecl 0xeebc838 <line:1275:7, line:1288:7> line:1276:7 imported in std.regex hidden push_back 'void (const std::vector<unsigned long, std::allocator<unsigned long> >::value_type &)'. | | |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::__cxx11::basic_string<char> > >::value_type &)'. |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::__cxx11::basic_string<char> > >::value_type &)'. |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::bas",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:4096,energy efficiency,alloc,allocator,4096,"e &)'. | | |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::__cxx11::basic_string<char> > >::value_type &)'. |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::__cxx11::basic_string<char> > >::value_type &)'. |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::. ```. several observations:. a. They are all imported from a module except for std::vector<ROOT::Internal::TSchemaHelper>. b. we see the string, unsigned int and double as ex",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:4310,energy efficiency,alloc,allocator,4310,"ng<char> > >::value_type &)'. |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::__cxx11::basic_string<char> > >::value_type &)'. |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::. ```. several observations:. a. They are all imported from a module except for std::vector<ROOT::Internal::TSchemaHelper>. b. we see the string, unsigned int and double as expected. c. we also see vector<int> ... but it does not get to the selector code. d. we also see vector<unsigned long> that is not seen by the selector code. e. the one seen by the selector are marked with imported ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:4513,energy efficiency,alloc,allocator,4513,"l::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::__cxx11::basic_string<char> > >::value_type &)'. |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::. ```. several observations:. a. They are all imported from a module except for std::vector<ROOT::Internal::TSchemaHelper>. b. we see the string, unsigned int and double as expected. c. we also see vector<int> ... but it does not get to the selector code. d. we also see vector<unsigned long> that is not seen by the selector code. e. the one seen by the selector are marked with imported in std.vector hidden. f. the one NOT seen by the selector are marked with imported in std.regex hidden. g. the one NOT seen by the selector are mentioned only once in the output instead of 3 times for th",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:4699,energy efficiency,alloc,allocator,4699,"aHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::__cxx11::basic_string<char> > >::value_type &)'. |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::. ```. several observations:. a. They are all imported from a module except for std::vector<ROOT::Internal::TSchemaHelper>. b. we see the string, unsigned int and double as expected. c. we also see vector<int> ... but it does not get to the selector code. d. we also see vector<unsigned long> that is not seen by the selector code. e. the one seen by the selector are marked with imported in std.vector hidden. f. the one NOT seen by the selector are marked with imported in std.regex hidden. g. the one NOT seen by the selector are mentioned only once in the output instead of 3 times for the others.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:4911,energy efficiency,alloc,allocator,4911,"aHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::__cxx11::basic_string<char> > >::value_type &)'. |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::. ```. several observations:. a. They are all imported from a module except for std::vector<ROOT::Internal::TSchemaHelper>. b. we see the string, unsigned int and double as expected. c. we also see vector<int> ... but it does not get to the selector code. d. we also see vector<unsigned long> that is not seen by the selector code. e. the one seen by the selector are marked with imported in std.vector hidden. f. the one NOT seen by the selector are marked with imported in std.regex hidden. g. the one NOT seen by the selector are mentioned only once in the output instead of 3 times for the others.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:217,integrability,translat,translation,217,"A few observation:. * it works without -cxxmodule . * it fails with -cxxmodule (and the other argument to suppress warning about automatically generating modules). * without -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<int>. * * vector<ROOT::Interna::TSchemaHelper>. * * both are seen twice. * with -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<double>. * * vector<ROOT::Interna::TSchemaHelper>. * * vector<unsigned int>. * * vector<std::__cxx11::basic_string<char>>. * * each are seen twice. * * there is no vector<int>. If I dump the translation unit I see:. ```. grep push_back | grep 1276. | | | |-CXXMethodDecl 0xa59e3a8 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector::value_type &)'. | | | |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. ```. in the successful case. 	. In the failing case I see:. ```. | | | |-CXXMethodDecl 0",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:425,integrability,translat,translation,425,"A few observation:. * it works without -cxxmodule . * it fails with -cxxmodule (and the other argument to suppress warning about automatically generating modules). * without -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<int>. * * vector<ROOT::Interna::TSchemaHelper>. * * both are seen twice. * with -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<double>. * * vector<ROOT::Interna::TSchemaHelper>. * * vector<unsigned int>. * * vector<std::__cxx11::basic_string<char>>. * * each are seen twice. * * there is no vector<int>. If I dump the translation unit I see:. ```. grep push_back | grep 1276. | | | |-CXXMethodDecl 0xa59e3a8 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector::value_type &)'. | | | |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. ```. in the successful case. 	. In the failing case I see:. ```. | | | |-CXXMethodDecl 0",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:701,integrability,translat,translation,701,"A few observation:. * it works without -cxxmodule . * it fails with -cxxmodule (and the other argument to suppress warning about automatically generating modules). * without -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<int>. * * vector<ROOT::Interna::TSchemaHelper>. * * both are seen twice. * with -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<double>. * * vector<ROOT::Interna::TSchemaHelper>. * * vector<unsigned int>. * * vector<std::__cxx11::basic_string<char>>. * * each are seen twice. * * there is no vector<int>. If I dump the translation unit I see:. ```. grep push_back | grep 1276. | | | |-CXXMethodDecl 0xa59e3a8 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector::value_type &)'. | | | |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. ```. in the successful case. 	. In the failing case I see:. ```. | | | |-CXXMethodDecl 0",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:217,interoperability,translat,translation,217,"A few observation:. * it works without -cxxmodule . * it fails with -cxxmodule (and the other argument to suppress warning about automatically generating modules). * without -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<int>. * * vector<ROOT::Interna::TSchemaHelper>. * * both are seen twice. * with -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<double>. * * vector<ROOT::Interna::TSchemaHelper>. * * vector<unsigned int>. * * vector<std::__cxx11::basic_string<char>>. * * each are seen twice. * * there is no vector<int>. If I dump the translation unit I see:. ```. grep push_back | grep 1276. | | | |-CXXMethodDecl 0xa59e3a8 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector::value_type &)'. | | | |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. ```. in the successful case. 	. In the failing case I see:. ```. | | | |-CXXMethodDecl 0",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:425,interoperability,translat,translation,425,"A few observation:. * it works without -cxxmodule . * it fails with -cxxmodule (and the other argument to suppress warning about automatically generating modules). * without -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<int>. * * vector<ROOT::Interna::TSchemaHelper>. * * both are seen twice. * with -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<double>. * * vector<ROOT::Interna::TSchemaHelper>. * * vector<unsigned int>. * * vector<std::__cxx11::basic_string<char>>. * * each are seen twice. * * there is no vector<int>. If I dump the translation unit I see:. ```. grep push_back | grep 1276. | | | |-CXXMethodDecl 0xa59e3a8 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector::value_type &)'. | | | |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. ```. in the successful case. 	. In the failing case I see:. ```. | | | |-CXXMethodDecl 0",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:701,interoperability,translat,translation,701,"A few observation:. * it works without -cxxmodule . * it fails with -cxxmodule (and the other argument to suppress warning about automatically generating modules). * without -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<int>. * * vector<ROOT::Interna::TSchemaHelper>. * * both are seen twice. * with -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<double>. * * vector<ROOT::Interna::TSchemaHelper>. * * vector<unsigned int>. * * vector<std::__cxx11::basic_string<char>>. * * each are seen twice. * * there is no vector<int>. If I dump the translation unit I see:. ```. grep push_back | grep 1276. | | | |-CXXMethodDecl 0xa59e3a8 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector::value_type &)'. | | | |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. ```. in the successful case. 	. In the failing case I see:. ```. | | | |-CXXMethodDecl 0",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:154,modifiability,modul,modules,154,"A few observation:. * it works without -cxxmodule . * it fails with -cxxmodule (and the other argument to suppress warning about automatically generating modules). * without -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<int>. * * vector<ROOT::Interna::TSchemaHelper>. * * both are seen twice. * with -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<double>. * * vector<ROOT::Interna::TSchemaHelper>. * * vector<unsigned int>. * * vector<std::__cxx11::basic_string<char>>. * * each are seen twice. * * there is no vector<int>. If I dump the translation unit I see:. ```. grep push_back | grep 1276. | | | |-CXXMethodDecl 0xa59e3a8 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector::value_type &)'. | | | |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. ```. in the successful case. 	. In the failing case I see:. ```. | | | |-CXXMethodDecl 0",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:4988,modifiability,modul,module,4988,"aHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::__cxx11::basic_string<char> > >::value_type &)'. |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::. ```. several observations:. a. They are all imported from a module except for std::vector<ROOT::Internal::TSchemaHelper>. b. we see the string, unsigned int and double as expected. c. we also see vector<int> ... but it does not get to the selector code. d. we also see vector<unsigned long> that is not seen by the selector code. e. the one seen by the selector are marked with imported in std.vector hidden. f. the one NOT seen by the selector are marked with imported in std.regex hidden. g. the one NOT seen by the selector are mentioned only once in the output instead of 3 times for the others.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:5506,performance,time,times,5506,"aHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::__cxx11::basic_string<char> > >::value_type &)'. |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::. ```. several observations:. a. They are all imported from a module except for std::vector<ROOT::Internal::TSchemaHelper>. b. we see the string, unsigned int and double as expected. c. we also see vector<int> ... but it does not get to the selector code. d. we also see vector<unsigned long> that is not seen by the selector code. e. the one seen by the selector are marked with imported in std.vector hidden. f. the one NOT seen by the selector are marked with imported in std.regex hidden. g. the one NOT seen by the selector are mentioned only once in the output instead of 3 times for the others.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:57,reliability,fail,fails,57,"A few observation:. * it works without -cxxmodule . * it fails with -cxxmodule (and the other argument to suppress warning about automatically generating modules). * without -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<int>. * * vector<ROOT::Interna::TSchemaHelper>. * * both are seen twice. * with -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<double>. * * vector<ROOT::Interna::TSchemaHelper>. * * vector<unsigned int>. * * vector<std::__cxx11::basic_string<char>>. * * each are seen twice. * * there is no vector<int>. If I dump the translation unit I see:. ```. grep push_back | grep 1276. | | | |-CXXMethodDecl 0xa59e3a8 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector::value_type &)'. | | | |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. ```. in the successful case. 	. In the failing case I see:. ```. | | | |-CXXMethodDecl 0",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:1951,reliability,fail,failing,1951,"sh_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. ```. in the successful case. 	. In the failing case I see:. ```. | | | |-CXXMethodDecl 0xed02b08 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector::value_type &)'. | | | |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | | |-CXXMethodDecl 0xb33a8c8 <line:1275:7, line:1288:7> line:1276:7 imported in std.regex hidden push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. | | | |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. | | | |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. | | | |-CXXMethodDecl 0xeebc838 <line:1275:7, ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:5147,reliability,doe,does,5147,"aHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::__cxx11::basic_string<char> > >::value_type &)'. |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::. ```. several observations:. a. They are all imported from a module except for std::vector<ROOT::Internal::TSchemaHelper>. b. we see the string, unsigned int and double as expected. c. we also see vector<int> ... but it does not get to the selector code. d. we also see vector<unsigned long> that is not seen by the selector code. e. the one seen by the selector are marked with imported in std.vector hidden. f. the one NOT seen by the selector are marked with imported in std.regex hidden. g. the one NOT seen by the selector are mentioned only once in the output instead of 3 times for the others.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:154,safety,modul,modules,154,"A few observation:. * it works without -cxxmodule . * it fails with -cxxmodule (and the other argument to suppress warning about automatically generating modules). * without -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<int>. * * vector<ROOT::Interna::TSchemaHelper>. * * both are seen twice. * with -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<double>. * * vector<ROOT::Interna::TSchemaHelper>. * * vector<unsigned int>. * * vector<std::__cxx11::basic_string<char>>. * * each are seen twice. * * there is no vector<int>. If I dump the translation unit I see:. ```. grep push_back | grep 1276. | | | |-CXXMethodDecl 0xa59e3a8 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector::value_type &)'. | | | |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. ```. in the successful case. 	. In the failing case I see:. ```. | | | |-CXXMethodDecl 0",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:4988,safety,modul,module,4988,"aHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::__cxx11::basic_string<char> > >::value_type &)'. |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::. ```. several observations:. a. They are all imported from a module except for std::vector<ROOT::Internal::TSchemaHelper>. b. we see the string, unsigned int and double as expected. c. we also see vector<int> ... but it does not get to the selector code. d. we also see vector<unsigned long> that is not seen by the selector code. e. the one seen by the selector are marked with imported in std.vector hidden. f. the one NOT seen by the selector are marked with imported in std.regex hidden. g. the one NOT seen by the selector are mentioned only once in the output instead of 3 times for the others.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:4995,safety,except,except,4995,"aHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::__cxx11::basic_string<char> > >::value_type &)'. |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::. ```. several observations:. a. They are all imported from a module except for std::vector<ROOT::Internal::TSchemaHelper>. b. we see the string, unsigned int and double as expected. c. we also see vector<int> ... but it does not get to the selector code. d. we also see vector<unsigned long> that is not seen by the selector code. e. the one seen by the selector are marked with imported in std.vector hidden. f. the one NOT seen by the selector are marked with imported in std.regex hidden. g. the one NOT seen by the selector are mentioned only once in the output instead of 3 times for the others.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:6,testability,observ,observation,6,"A few observation:. * it works without -cxxmodule . * it fails with -cxxmodule (and the other argument to suppress warning about automatically generating modules). * without -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<int>. * * vector<ROOT::Interna::TSchemaHelper>. * * both are seen twice. * with -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<double>. * * vector<ROOT::Interna::TSchemaHelper>. * * vector<unsigned int>. * * vector<std::__cxx11::basic_string<char>>. * * each are seen twice. * * there is no vector<int>. If I dump the translation unit I see:. ```. grep push_back | grep 1276. | | | |-CXXMethodDecl 0xa59e3a8 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector::value_type &)'. | | | |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. ```. in the successful case. 	. In the failing case I see:. ```. | | | |-CXXMethodDecl 0",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:129,testability,automat,automatically,129,"A few observation:. * it works without -cxxmodule . * it fails with -cxxmodule (and the other argument to suppress warning about automatically generating modules). * without -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<int>. * * vector<ROOT::Interna::TSchemaHelper>. * * both are seen twice. * with -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<double>. * * vector<ROOT::Interna::TSchemaHelper>. * * vector<unsigned int>. * * vector<std::__cxx11::basic_string<char>>. * * each are seen twice. * * there is no vector<int>. If I dump the translation unit I see:. ```. grep push_back | grep 1276. | | | |-CXXMethodDecl 0xa59e3a8 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector::value_type &)'. | | | |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. ```. in the successful case. 	. In the failing case I see:. ```. | | | |-CXXMethodDecl 0",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:229,testability,unit,unit,229,"A few observation:. * it works without -cxxmodule . * it fails with -cxxmodule (and the other argument to suppress warning about automatically generating modules). * without -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<int>. * * vector<ROOT::Interna::TSchemaHelper>. * * both are seen twice. * with -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<double>. * * vector<ROOT::Interna::TSchemaHelper>. * * vector<unsigned int>. * * vector<std::__cxx11::basic_string<char>>. * * each are seen twice. * * there is no vector<int>. If I dump the translation unit I see:. ```. grep push_back | grep 1276. | | | |-CXXMethodDecl 0xa59e3a8 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector::value_type &)'. | | | |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. ```. in the successful case. 	. In the failing case I see:. ```. | | | |-CXXMethodDecl 0",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:437,testability,unit,unit,437,"A few observation:. * it works without -cxxmodule . * it fails with -cxxmodule (and the other argument to suppress warning about automatically generating modules). * without -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<int>. * * vector<ROOT::Interna::TSchemaHelper>. * * both are seen twice. * with -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<double>. * * vector<ROOT::Interna::TSchemaHelper>. * * vector<unsigned int>. * * vector<std::__cxx11::basic_string<char>>. * * each are seen twice. * * there is no vector<int>. If I dump the translation unit I see:. ```. grep push_back | grep 1276. | | | |-CXXMethodDecl 0xa59e3a8 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector::value_type &)'. | | | |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. ```. in the successful case. 	. In the failing case I see:. ```. | | | |-CXXMethodDecl 0",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:713,testability,unit,unit,713,"A few observation:. * it works without -cxxmodule . * it fails with -cxxmodule (and the other argument to suppress warning about automatically generating modules). * without -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<int>. * * vector<ROOT::Interna::TSchemaHelper>. * * both are seen twice. * with -cxxmodule, the code that traverse the the translation unit to try to match decls with the selections patterns sees. * * vector<double>. * * vector<ROOT::Interna::TSchemaHelper>. * * vector<unsigned int>. * * vector<std::__cxx11::basic_string<char>>. * * each are seen twice. * * there is no vector<int>. If I dump the translation unit I see:. ```. grep push_back | grep 1276. | | | |-CXXMethodDecl 0xa59e3a8 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector::value_type &)'. | | | |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. | | |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. |-CXXMethodDecl 0xa675e98 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xa7bde58 <line:1275:7, line:1288:7> line:1276:7 push_back 'void (const std::vector<int, std::allocator<int> >::value_type &)'. ```. in the successful case. 	. In the failing case I see:. ```. | | | |-CXXMethodDecl 0",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:4941,testability,observ,observations,4941,"aHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::__cxx11::basic_string<char> > >::value_type &)'. |-CXXMethodDecl 0xa1b9830 <line:1275:7, line:1288:7> line:1276:7 in std.vector push_back 'void (const std::vector<ROOT::Internal::TSchemaHelper, std::allocator<ROOT::Internal::TSchemaHelper> >::value_type &)'. |-CXXMethodDecl 0xee92b98 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<double, std::allocator<double> >::value_type &)'. |-CXXMethodDecl 0xeea7768 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<unsigned int, std::allocator<unsigned int> >::value_type &)'. |-CXXMethodDecl 0xc995488 <line:1275:7, line:1288:7> line:1276:7 imported in std.vector hidden push_back 'void (const std::vector<std::__cxx11::basic_string<char>, std::allocator<std::. ```. several observations:. a. They are all imported from a module except for std::vector<ROOT::Internal::TSchemaHelper>. b. we see the string, unsigned int and double as expected. c. we also see vector<int> ... but it does not get to the selector code. d. we also see vector<unsigned long> that is not seen by the selector code. e. the one seen by the selector are marked with imported in std.vector hidden. f. the one NOT seen by the selector are marked with imported in std.regex hidden. g. the one NOT seen by the selector are mentioned only once in the output instead of 3 times for the others.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:204,deployability,build,build,204,"The backtrace of the traversal code that does not see the decl for `std::vector<int>` is : . ```. #0 RScanner::TreatRecordDeclOrTypedefNameDecl (this=0x7fffffffb5c0, typeDecl=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:677. #1 0x00000000005d7f16 in RScanner::VisitRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:527. #2 0x00000000005efaf4 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:253. #3 0x00000000005efbc6 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromCXXRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:257. #4 0x00000000005efd06 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #5 0x00000000005e38f2 in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1891. #6 0x00000000005dd442 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #7 0x00000000005ef1f7 in clang::RecursiveASTVisitor<RScanner>::TraverseTemplateInstantiations (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1670. #8 0x00000000005e2c6c in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/inte",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:360,deployability,build,build,360,"The backtrace of the traversal code that does not see the decl for `std::vector<int>` is : . ```. #0 RScanner::TreatRecordDeclOrTypedefNameDecl (this=0x7fffffffb5c0, typeDecl=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:677. #1 0x00000000005d7f16 in RScanner::VisitRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:527. #2 0x00000000005efaf4 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:253. #3 0x00000000005efbc6 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromCXXRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:257. #4 0x00000000005efd06 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #5 0x00000000005e38f2 in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1891. #6 0x00000000005dd442 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #7 0x00000000005ef1f7 in clang::RecursiveASTVisitor<RScanner>::TraverseTemplateInstantiations (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1670. #8 0x00000000005e2c6c in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/inte",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:550,deployability,build,build,550,"The backtrace of the traversal code that does not see the decl for `std::vector<int>` is : . ```. #0 RScanner::TreatRecordDeclOrTypedefNameDecl (this=0x7fffffffb5c0, typeDecl=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:677. #1 0x00000000005d7f16 in RScanner::VisitRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:527. #2 0x00000000005efaf4 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:253. #3 0x00000000005efbc6 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromCXXRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:257. #4 0x00000000005efd06 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #5 0x00000000005e38f2 in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1891. #6 0x00000000005dd442 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #7 0x00000000005ef1f7 in clang::RecursiveASTVisitor<RScanner>::TraverseTemplateInstantiations (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1670. #8 0x00000000005e2c6c in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/inte",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:563,deployability,build,build,563,"The backtrace of the traversal code that does not see the decl for `std::vector<int>` is : . ```. #0 RScanner::TreatRecordDeclOrTypedefNameDecl (this=0x7fffffffb5c0, typeDecl=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:677. #1 0x00000000005d7f16 in RScanner::VisitRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:527. #2 0x00000000005efaf4 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:253. #3 0x00000000005efbc6 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromCXXRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:257. #4 0x00000000005efd06 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #5 0x00000000005e38f2 in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1891. #6 0x00000000005dd442 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #7 0x00000000005ef1f7 in clang::RecursiveASTVisitor<RScanner>::TraverseTemplateInstantiations (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1670. #8 0x00000000005e2c6c in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/inte",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:780,deployability,build,build,780,"The backtrace of the traversal code that does not see the decl for `std::vector<int>` is : . ```. #0 RScanner::TreatRecordDeclOrTypedefNameDecl (this=0x7fffffffb5c0, typeDecl=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:677. #1 0x00000000005d7f16 in RScanner::VisitRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:527. #2 0x00000000005efaf4 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:253. #3 0x00000000005efbc6 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromCXXRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:257. #4 0x00000000005efd06 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #5 0x00000000005e38f2 in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1891. #6 0x00000000005dd442 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #7 0x00000000005ef1f7 in clang::RecursiveASTVisitor<RScanner>::TraverseTemplateInstantiations (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1670. #8 0x00000000005e2c6c in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/inte",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:793,deployability,build,build,793,"The backtrace of the traversal code that does not see the decl for `std::vector<int>` is : . ```. #0 RScanner::TreatRecordDeclOrTypedefNameDecl (this=0x7fffffffb5c0, typeDecl=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:677. #1 0x00000000005d7f16 in RScanner::VisitRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:527. #2 0x00000000005efaf4 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:253. #3 0x00000000005efbc6 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromCXXRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:257. #4 0x00000000005efd06 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #5 0x00000000005e38f2 in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1891. #6 0x00000000005dd442 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #7 0x00000000005ef1f7 in clang::RecursiveASTVisitor<RScanner>::TraverseTemplateInstantiations (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1670. #8 0x00000000005e2c6c in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/inte",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:1028,deployability,build,build,1028,"code that does not see the decl for `std::vector<int>` is : . ```. #0 RScanner::TreatRecordDeclOrTypedefNameDecl (this=0x7fffffffb5c0, typeDecl=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:677. #1 0x00000000005d7f16 in RScanner::VisitRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:527. #2 0x00000000005efaf4 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:253. #3 0x00000000005efbc6 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromCXXRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:257. #4 0x00000000005efd06 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #5 0x00000000005e38f2 in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1891. #6 0x00000000005dd442 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #7 0x00000000005ef1f7 in clang::RecursiveASTVisitor<RScanner>::TraverseTemplateInstantiations (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1670. #8 0x00000000005e2c6c in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/in",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:1041,deployability,build,build,1041,"s not see the decl for `std::vector<int>` is : . ```. #0 RScanner::TreatRecordDeclOrTypedefNameDecl (this=0x7fffffffb5c0, typeDecl=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:677. #1 0x00000000005d7f16 in RScanner::VisitRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:527. #2 0x00000000005efaf4 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:253. #3 0x00000000005efbc6 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromCXXRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:257. #4 0x00000000005efd06 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #5 0x00000000005e38f2 in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1891. #6 0x00000000005dd442 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #7 0x00000000005ef1f7 in clang::RecursiveASTVisitor<RScanner>::TraverseTemplateInstantiations (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1670. #8 0x00000000005e2c6c in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/A",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:1274,deployability,build,build,1274," in RScanner::VisitRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:527. #2 0x00000000005efaf4 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:253. #3 0x00000000005efbc6 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromCXXRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:257. #4 0x00000000005efd06 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #5 0x00000000005e38f2 in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1891. #6 0x00000000005dd442 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #7 0x00000000005ef1f7 in clang::RecursiveASTVisitor<RScanner>::TraverseTemplateInstantiations (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1670. #8 0x00000000005e2c6c in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1762. #9 0x00000000005dd2aa in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/De",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:1501,deployability,build,build,1501,"7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:253. #3 0x00000000005efbc6 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromCXXRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:257. #4 0x00000000005efd06 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #5 0x00000000005e38f2 in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1891. #6 0x00000000005dd442 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #7 0x00000000005ef1f7 in clang::RecursiveASTVisitor<RScanner>::TraverseTemplateInstantiations (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1670. #8 0x00000000005e2c6c in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1762. #9 0x00000000005dd2aa in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x9dd5c50) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #11 0x00000000005e1b29 in clang::Recursive",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:1514,deployability,build,build,1514," D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:253. #3 0x00000000005efbc6 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromCXXRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:257. #4 0x00000000005efd06 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #5 0x00000000005e38f2 in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1891. #6 0x00000000005dd442 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #7 0x00000000005ef1f7 in clang::RecursiveASTVisitor<RScanner>::TraverseTemplateInstantiations (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1670. #8 0x00000000005e2c6c in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1762. #9 0x00000000005dd2aa in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x9dd5c50) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #11 0x00000000005e1b29 in clang::RecursiveASTVisitor<RS",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:1738,deployability,build,build,1738,"fb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:257. #4 0x00000000005efd06 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #5 0x00000000005e38f2 in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1891. #6 0x00000000005dd442 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #7 0x00000000005ef1f7 in clang::RecursiveASTVisitor<RScanner>::TraverseTemplateInstantiations (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1670. #8 0x00000000005e2c6c in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1762. #9 0x00000000005dd2aa in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x9dd5c50) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #11 0x00000000005e1b29 in clang::RecursiveASTVisitor<RScanner>::TraverseNamespaceDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1513. #12 0x00000000005dd046 in clang::Recursive",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:1978,deployability,build,build,1978,"x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #5 0x00000000005e38f2 in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1891. #6 0x00000000005dd442 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #7 0x00000000005ef1f7 in clang::RecursiveASTVisitor<RScanner>::TraverseTemplateInstantiations (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1670. #8 0x00000000005e2c6c in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1762. #9 0x00000000005dd2aa in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x9dd5c50) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #11 0x00000000005e1b29 in clang::RecursiveASTVisitor<RScanner>::TraverseNamespaceDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1513. #12 0x00000000005dd046 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:105. #13 0x00000000005d9991 in RScanner::TraverseDeclContextHelper ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:2205,deployability,build,build,2205,"izationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1891. #6 0x00000000005dd442 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #7 0x00000000005ef1f7 in clang::RecursiveASTVisitor<RScanner>::TraverseTemplateInstantiations (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1670. #8 0x00000000005e2c6c in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1762. #9 0x00000000005dd2aa in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x9dd5c50) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #11 0x00000000005e1b29 in clang::RecursiveASTVisitor<RScanner>::TraverseNamespaceDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1513. #12 0x00000000005dd046 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:105. #13 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x863dcd0) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #14 0x00000000005e73f3 in clang::RecursiveASTVisitor<RScanner>::TraverseTranslationUnitDecl (this=0x7fffffffb5c0, D=0x863",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:2218,deployability,build,build,2218,"this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1891. #6 0x00000000005dd442 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #7 0x00000000005ef1f7 in clang::RecursiveASTVisitor<RScanner>::TraverseTemplateInstantiations (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1670. #8 0x00000000005e2c6c in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1762. #9 0x00000000005dd2aa in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x9dd5c50) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #11 0x00000000005e1b29 in clang::RecursiveASTVisitor<RScanner>::TraverseNamespaceDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1513. #12 0x00000000005dd046 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:105. #13 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x863dcd0) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #14 0x00000000005e73f3 in clang::RecursiveASTVisitor<RScanner>::TraverseTranslationUnitDecl (this=0x7fffffffb5c0, D=0x863dca8). at /ho",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:2410,deployability,build,build,2410,"STVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #7 0x00000000005ef1f7 in clang::RecursiveASTVisitor<RScanner>::TraverseTemplateInstantiations (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1670. #8 0x00000000005e2c6c in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1762. #9 0x00000000005dd2aa in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x9dd5c50) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #11 0x00000000005e1b29 in clang::RecursiveASTVisitor<RScanner>::TraverseNamespaceDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1513. #12 0x00000000005dd046 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:105. #13 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x863dcd0) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #14 0x00000000005e73f3 in clang::RecursiveASTVisitor<RScanner>::TraverseTranslationUnitDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1489. #15 0x00000000005ddccb in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:2602,deployability,build,build,2602,"5ef1f7 in clang::RecursiveASTVisitor<RScanner>::TraverseTemplateInstantiations (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1670. #8 0x00000000005e2c6c in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1762. #9 0x00000000005dd2aa in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x9dd5c50) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #11 0x00000000005e1b29 in clang::RecursiveASTVisitor<RScanner>::TraverseNamespaceDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1513. #12 0x00000000005dd046 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:105. #13 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x863dcd0) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #14 0x00000000005e73f3 in clang::RecursiveASTVisitor<RScanner>::TraverseTranslationUnitDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1489. #15 0x00000000005ddccb in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:577. #16 0x00000000005d9f5c in RScanner::Scan (this=0x7fffff",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:2830,deployability,build,build,2830,". #8 0x00000000005e2c6c in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1762. #9 0x00000000005dd2aa in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x9dd5c50) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #11 0x00000000005e1b29 in clang::RecursiveASTVisitor<RScanner>::TraverseNamespaceDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1513. #12 0x00000000005dd046 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:105. #13 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x863dcd0) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #14 0x00000000005e73f3 in clang::RecursiveASTVisitor<RScanner>::TraverseTranslationUnitDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1489. #15 0x00000000005ddccb in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:577. #16 0x00000000005d9f5c in RScanner::Scan (this=0x7fffffffb5c0, C=...) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:1058. #17 0x00000000005a99a0 in RootClingMain (argc=19, argv=0x7fffffffe028, isGenreflex=false) at /home/sftnight/build/manual/root/core/dictgen/src",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:2843,deployability,build,build,2843,"00005e2c6c in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1762. #9 0x00000000005dd2aa in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x9dd5c50) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #11 0x00000000005e1b29 in clang::RecursiveASTVisitor<RScanner>::TraverseNamespaceDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1513. #12 0x00000000005dd046 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:105. #13 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x863dcd0) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #14 0x00000000005e73f3 in clang::RecursiveASTVisitor<RScanner>::TraverseTranslationUnitDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1489. #15 0x00000000005ddccb in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:577. #16 0x00000000005d9f5c in RScanner::Scan (this=0x7fffffffb5c0, C=...) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:1058. #17 0x00000000005a99a0 in RootClingMain (argc=19, argv=0x7fffffffe028, isGenreflex=false) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_im",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:3035,deployability,build,build,3035,"lang/AST/RecursiveASTVisitor.h:1762. #9 0x00000000005dd2aa in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x9dd5c50) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #11 0x00000000005e1b29 in clang::RecursiveASTVisitor<RScanner>::TraverseNamespaceDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1513. #12 0x00000000005dd046 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:105. #13 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x863dcd0) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #14 0x00000000005e73f3 in clang::RecursiveASTVisitor<RScanner>::TraverseTranslationUnitDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1489. #15 0x00000000005ddccb in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:577. #16 0x00000000005d9f5c in RScanner::Scan (this=0x7fffffffb5c0, C=...) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:1058. #17 0x00000000005a99a0 in RootClingMain (argc=19, argv=0x7fffffffe028, isGenreflex=false) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_impl.cxx:4806. #18 0x00000000005afd6a in ROOT_rootcling_Driver (argc=19, argv=0x7fffffffe028, config=...) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_impl.cxx:6147. #19 0x0000",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:3233,deployability,build,build,3233,"8b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x9dd5c50) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #11 0x00000000005e1b29 in clang::RecursiveASTVisitor<RScanner>::TraverseNamespaceDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1513. #12 0x00000000005dd046 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:105. #13 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x863dcd0) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #14 0x00000000005e73f3 in clang::RecursiveASTVisitor<RScanner>::TraverseTranslationUnitDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1489. #15 0x00000000005ddccb in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:577. #16 0x00000000005d9f5c in RScanner::Scan (this=0x7fffffffb5c0, C=...) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:1058. #17 0x00000000005a99a0 in RootClingMain (argc=19, argv=0x7fffffffe028, isGenreflex=false) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_impl.cxx:4806. #18 0x00000000005afd6a in ROOT_rootcling_Driver (argc=19, argv=0x7fffffffe028, config=...) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_impl.cxx:6147. #19 0x00000000004a4f75 in main (argc=19, argv=0x7fffffffe028) at /home/sftnight/build/manual/root/core/rootcling_stage1/src/rootcling_stage1.cxx:46. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:3461,deployability,build,build,3461,"8b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x9dd5c50) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #11 0x00000000005e1b29 in clang::RecursiveASTVisitor<RScanner>::TraverseNamespaceDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1513. #12 0x00000000005dd046 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:105. #13 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x863dcd0) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #14 0x00000000005e73f3 in clang::RecursiveASTVisitor<RScanner>::TraverseTranslationUnitDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1489. #15 0x00000000005ddccb in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:577. #16 0x00000000005d9f5c in RScanner::Scan (this=0x7fffffffb5c0, C=...) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:1058. #17 0x00000000005a99a0 in RootClingMain (argc=19, argv=0x7fffffffe028, isGenreflex=false) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_impl.cxx:4806. #18 0x00000000005afd6a in ROOT_rootcling_Driver (argc=19, argv=0x7fffffffe028, config=...) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_impl.cxx:6147. #19 0x00000000004a4f75 in main (argc=19, argv=0x7fffffffe028) at /home/sftnight/build/manual/root/core/rootcling_stage1/src/rootcling_stage1.cxx:46. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:3474,deployability,build,build,3474,"8b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x9dd5c50) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #11 0x00000000005e1b29 in clang::RecursiveASTVisitor<RScanner>::TraverseNamespaceDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1513. #12 0x00000000005dd046 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:105. #13 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x863dcd0) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #14 0x00000000005e73f3 in clang::RecursiveASTVisitor<RScanner>::TraverseTranslationUnitDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1489. #15 0x00000000005ddccb in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:577. #16 0x00000000005d9f5c in RScanner::Scan (this=0x7fffffffb5c0, C=...) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:1058. #17 0x00000000005a99a0 in RootClingMain (argc=19, argv=0x7fffffffe028, isGenreflex=false) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_impl.cxx:4806. #18 0x00000000005afd6a in ROOT_rootcling_Driver (argc=19, argv=0x7fffffffe028, config=...) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_impl.cxx:6147. #19 0x00000000004a4f75 in main (argc=19, argv=0x7fffffffe028) at /home/sftnight/build/manual/root/core/rootcling_stage1/src/rootcling_stage1.cxx:46. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:3638,deployability,build,build,3638,"8b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x9dd5c50) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #11 0x00000000005e1b29 in clang::RecursiveASTVisitor<RScanner>::TraverseNamespaceDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1513. #12 0x00000000005dd046 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:105. #13 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x863dcd0) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #14 0x00000000005e73f3 in clang::RecursiveASTVisitor<RScanner>::TraverseTranslationUnitDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1489. #15 0x00000000005ddccb in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:577. #16 0x00000000005d9f5c in RScanner::Scan (this=0x7fffffffb5c0, C=...) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:1058. #17 0x00000000005a99a0 in RootClingMain (argc=19, argv=0x7fffffffe028, isGenreflex=false) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_impl.cxx:4806. #18 0x00000000005afd6a in ROOT_rootcling_Driver (argc=19, argv=0x7fffffffe028, config=...) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_impl.cxx:6147. #19 0x00000000004a4f75 in main (argc=19, argv=0x7fffffffe028) at /home/sftnight/build/manual/root/core/rootcling_stage1/src/rootcling_stage1.cxx:46. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:3799,deployability,build,build,3799,"8b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x9dd5c50) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #11 0x00000000005e1b29 in clang::RecursiveASTVisitor<RScanner>::TraverseNamespaceDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1513. #12 0x00000000005dd046 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:105. #13 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x863dcd0) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #14 0x00000000005e73f3 in clang::RecursiveASTVisitor<RScanner>::TraverseTranslationUnitDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1489. #15 0x00000000005ddccb in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:577. #16 0x00000000005d9f5c in RScanner::Scan (this=0x7fffffffb5c0, C=...) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:1058. #17 0x00000000005a99a0 in RootClingMain (argc=19, argv=0x7fffffffe028, isGenreflex=false) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_impl.cxx:4806. #18 0x00000000005afd6a in ROOT_rootcling_Driver (argc=19, argv=0x7fffffffe028, config=...) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_impl.cxx:6147. #19 0x00000000004a4f75 in main (argc=19, argv=0x7fffffffe028) at /home/sftnight/build/manual/root/core/rootcling_stage1/src/rootcling_stage1.cxx:46. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:3968,deployability,build,build,3968,"8b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x9dd5c50) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #11 0x00000000005e1b29 in clang::RecursiveASTVisitor<RScanner>::TraverseNamespaceDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1513. #12 0x00000000005dd046 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:105. #13 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x863dcd0) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #14 0x00000000005e73f3 in clang::RecursiveASTVisitor<RScanner>::TraverseTranslationUnitDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1489. #15 0x00000000005ddccb in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:577. #16 0x00000000005d9f5c in RScanner::Scan (this=0x7fffffffb5c0, C=...) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:1058. #17 0x00000000005a99a0 in RootClingMain (argc=19, argv=0x7fffffffe028, isGenreflex=false) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_impl.cxx:4806. #18 0x00000000005afd6a in ROOT_rootcling_Driver (argc=19, argv=0x7fffffffe028, config=...) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_impl.cxx:6147. #19 0x00000000004a4f75 in main (argc=19, argv=0x7fffffffe028) at /home/sftnight/build/manual/root/core/rootcling_stage1/src/rootcling_stage1.cxx:46. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:4108,deployability,build,build,4108,"8b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x9dd5c50) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #11 0x00000000005e1b29 in clang::RecursiveASTVisitor<RScanner>::TraverseNamespaceDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1513. #12 0x00000000005dd046 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:105. #13 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x863dcd0) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #14 0x00000000005e73f3 in clang::RecursiveASTVisitor<RScanner>::TraverseTranslationUnitDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1489. #15 0x00000000005ddccb in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:577. #16 0x00000000005d9f5c in RScanner::Scan (this=0x7fffffffb5c0, C=...) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:1058. #17 0x00000000005a99a0 in RootClingMain (argc=19, argv=0x7fffffffe028, isGenreflex=false) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_impl.cxx:4806. #18 0x00000000005afd6a in ROOT_rootcling_Driver (argc=19, argv=0x7fffffffe028, config=...) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_impl.cxx:6147. #19 0x00000000004a4f75 in main (argc=19, argv=0x7fffffffe028) at /home/sftnight/build/manual/root/core/rootcling_stage1/src/rootcling_stage1.cxx:46. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:222,energy efficiency,core,core,222,"The backtrace of the traversal code that does not see the decl for `std::vector<int>` is : . ```. #0 RScanner::TreatRecordDeclOrTypedefNameDecl (this=0x7fffffffb5c0, typeDecl=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:677. #1 0x00000000005d7f16 in RScanner::VisitRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:527. #2 0x00000000005efaf4 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:253. #3 0x00000000005efbc6 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromCXXRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:257. #4 0x00000000005efd06 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #5 0x00000000005e38f2 in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1891. #6 0x00000000005dd442 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #7 0x00000000005ef1f7 in clang::RecursiveASTVisitor<RScanner>::TraverseTemplateInstantiations (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1670. #8 0x00000000005e2c6c in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/inte",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:378,energy efficiency,core,core,378,"The backtrace of the traversal code that does not see the decl for `std::vector<int>` is : . ```. #0 RScanner::TreatRecordDeclOrTypedefNameDecl (this=0x7fffffffb5c0, typeDecl=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:677. #1 0x00000000005d7f16 in RScanner::VisitRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:527. #2 0x00000000005efaf4 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:253. #3 0x00000000005efbc6 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromCXXRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:257. #4 0x00000000005efd06 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #5 0x00000000005e38f2 in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1891. #6 0x00000000005dd442 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #7 0x00000000005ef1f7 in clang::RecursiveASTVisitor<RScanner>::TraverseTemplateInstantiations (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1670. #8 0x00000000005e2c6c in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/inte",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:2428,energy efficiency,core,core,2428,"r>::TraverseDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #7 0x00000000005ef1f7 in clang::RecursiveASTVisitor<RScanner>::TraverseTemplateInstantiations (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1670. #8 0x00000000005e2c6c in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1762. #9 0x00000000005dd2aa in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x9dd5c50) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #11 0x00000000005e1b29 in clang::RecursiveASTVisitor<RScanner>::TraverseNamespaceDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1513. #12 0x00000000005dd046 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:105. #13 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x863dcd0) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #14 0x00000000005e73f3 in clang::RecursiveASTVisitor<RScanner>::TraverseTranslationUnitDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1489. #15 0x00000000005ddccb in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:3053,energy efficiency,core,core,3053,"eASTVisitor.h:1762. #9 0x00000000005dd2aa in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x9dd5c50) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #11 0x00000000005e1b29 in clang::RecursiveASTVisitor<RScanner>::TraverseNamespaceDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1513. #12 0x00000000005dd046 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:105. #13 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x863dcd0) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #14 0x00000000005e73f3 in clang::RecursiveASTVisitor<RScanner>::TraverseTranslationUnitDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1489. #15 0x00000000005ddccb in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:577. #16 0x00000000005d9f5c in RScanner::Scan (this=0x7fffffffb5c0, C=...) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:1058. #17 0x00000000005a99a0 in RootClingMain (argc=19, argv=0x7fffffffe028, isGenreflex=false) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_impl.cxx:4806. #18 0x00000000005afd6a in ROOT_rootcling_Driver (argc=19, argv=0x7fffffffe028, config=...) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_impl.cxx:6147. #19 0x00000000004a4f75 in m",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:3656,energy efficiency,core,core,3656,"8b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x9dd5c50) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #11 0x00000000005e1b29 in clang::RecursiveASTVisitor<RScanner>::TraverseNamespaceDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1513. #12 0x00000000005dd046 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:105. #13 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x863dcd0) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #14 0x00000000005e73f3 in clang::RecursiveASTVisitor<RScanner>::TraverseTranslationUnitDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1489. #15 0x00000000005ddccb in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:577. #16 0x00000000005d9f5c in RScanner::Scan (this=0x7fffffffb5c0, C=...) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:1058. #17 0x00000000005a99a0 in RootClingMain (argc=19, argv=0x7fffffffe028, isGenreflex=false) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_impl.cxx:4806. #18 0x00000000005afd6a in ROOT_rootcling_Driver (argc=19, argv=0x7fffffffe028, config=...) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_impl.cxx:6147. #19 0x00000000004a4f75 in main (argc=19, argv=0x7fffffffe028) at /home/sftnight/build/manual/root/core/rootcling_stage1/src/rootcling_stage1.cxx:46. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:3817,energy efficiency,core,core,3817,"8b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x9dd5c50) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #11 0x00000000005e1b29 in clang::RecursiveASTVisitor<RScanner>::TraverseNamespaceDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1513. #12 0x00000000005dd046 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:105. #13 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x863dcd0) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #14 0x00000000005e73f3 in clang::RecursiveASTVisitor<RScanner>::TraverseTranslationUnitDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1489. #15 0x00000000005ddccb in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:577. #16 0x00000000005d9f5c in RScanner::Scan (this=0x7fffffffb5c0, C=...) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:1058. #17 0x00000000005a99a0 in RootClingMain (argc=19, argv=0x7fffffffe028, isGenreflex=false) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_impl.cxx:4806. #18 0x00000000005afd6a in ROOT_rootcling_Driver (argc=19, argv=0x7fffffffe028, config=...) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_impl.cxx:6147. #19 0x00000000004a4f75 in main (argc=19, argv=0x7fffffffe028) at /home/sftnight/build/manual/root/core/rootcling_stage1/src/rootcling_stage1.cxx:46. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:3986,energy efficiency,core,core,3986,"8b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x9dd5c50) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #11 0x00000000005e1b29 in clang::RecursiveASTVisitor<RScanner>::TraverseNamespaceDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1513. #12 0x00000000005dd046 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:105. #13 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x863dcd0) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #14 0x00000000005e73f3 in clang::RecursiveASTVisitor<RScanner>::TraverseTranslationUnitDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1489. #15 0x00000000005ddccb in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:577. #16 0x00000000005d9f5c in RScanner::Scan (this=0x7fffffffb5c0, C=...) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:1058. #17 0x00000000005a99a0 in RootClingMain (argc=19, argv=0x7fffffffe028, isGenreflex=false) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_impl.cxx:4806. #18 0x00000000005afd6a in ROOT_rootcling_Driver (argc=19, argv=0x7fffffffe028, config=...) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_impl.cxx:6147. #19 0x00000000004a4f75 in main (argc=19, argv=0x7fffffffe028) at /home/sftnight/build/manual/root/core/rootcling_stage1/src/rootcling_stage1.cxx:46. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:4126,energy efficiency,core,core,4126,"8b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x9dd5c50) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #11 0x00000000005e1b29 in clang::RecursiveASTVisitor<RScanner>::TraverseNamespaceDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1513. #12 0x00000000005dd046 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:105. #13 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x863dcd0) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #14 0x00000000005e73f3 in clang::RecursiveASTVisitor<RScanner>::TraverseTranslationUnitDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1489. #15 0x00000000005ddccb in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:577. #16 0x00000000005d9f5c in RScanner::Scan (this=0x7fffffffb5c0, C=...) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:1058. #17 0x00000000005a99a0 in RootClingMain (argc=19, argv=0x7fffffffe028, isGenreflex=false) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_impl.cxx:4806. #18 0x00000000005afd6a in ROOT_rootcling_Driver (argc=19, argv=0x7fffffffe028, config=...) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_impl.cxx:6147. #19 0x00000000004a4f75 in main (argc=19, argv=0x7fffffffe028) at /home/sftnight/build/manual/root/core/rootcling_stage1/src/rootcling_stage1.cxx:46. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:41,reliability,doe,does,41,"The backtrace of the traversal code that does not see the decl for `std::vector<int>` is : . ```. #0 RScanner::TreatRecordDeclOrTypedefNameDecl (this=0x7fffffffb5c0, typeDecl=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:677. #1 0x00000000005d7f16 in RScanner::VisitRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:527. #2 0x00000000005efaf4 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:253. #3 0x00000000005efbc6 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromCXXRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:257. #4 0x00000000005efd06 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #5 0x00000000005e38f2 in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1891. #6 0x00000000005dd442 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #7 0x00000000005ef1f7 in clang::RecursiveASTVisitor<RScanner>::TraverseTemplateInstantiations (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1670. #8 0x00000000005e2c6c in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/inte",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:239,security,Scanner,Scanner,239,"The backtrace of the traversal code that does not see the decl for `std::vector<int>` is : . ```. #0 RScanner::TreatRecordDeclOrTypedefNameDecl (this=0x7fffffffb5c0, typeDecl=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:677. #1 0x00000000005d7f16 in RScanner::VisitRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:527. #2 0x00000000005efaf4 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:253. #3 0x00000000005efbc6 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromCXXRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:257. #4 0x00000000005efd06 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #5 0x00000000005e38f2 in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1891. #6 0x00000000005dd442 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #7 0x00000000005ef1f7 in clang::RecursiveASTVisitor<RScanner>::TraverseTemplateInstantiations (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1670. #8 0x00000000005e2c6c in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/inte",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:395,security,Scanner,Scanner,395,"The backtrace of the traversal code that does not see the decl for `std::vector<int>` is : . ```. #0 RScanner::TreatRecordDeclOrTypedefNameDecl (this=0x7fffffffb5c0, typeDecl=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:677. #1 0x00000000005d7f16 in RScanner::VisitRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:527. #2 0x00000000005efaf4 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:253. #3 0x00000000005efbc6 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromCXXRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:257. #4 0x00000000005efd06 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #5 0x00000000005e38f2 in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1891. #6 0x00000000005dd442 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #7 0x00000000005ef1f7 in clang::RecursiveASTVisitor<RScanner>::TraverseTemplateInstantiations (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1670. #8 0x00000000005e2c6c in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/inte",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:2445,security,Scanner,Scanner,2445,"his=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #7 0x00000000005ef1f7 in clang::RecursiveASTVisitor<RScanner>::TraverseTemplateInstantiations (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1670. #8 0x00000000005e2c6c in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1762. #9 0x00000000005dd2aa in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x9dd5c50) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #11 0x00000000005e1b29 in clang::RecursiveASTVisitor<RScanner>::TraverseNamespaceDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1513. #12 0x00000000005dd046 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:105. #13 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x863dcd0) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #14 0x00000000005e73f3 in clang::RecursiveASTVisitor<RScanner>::TraverseTranslationUnitDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1489. #15 0x00000000005ddccb in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x863dca8). at /ho",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:3070,security,Scanner,Scanner,3070," #9 0x00000000005dd2aa in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x9dd5c50) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #11 0x00000000005e1b29 in clang::RecursiveASTVisitor<RScanner>::TraverseNamespaceDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1513. #12 0x00000000005dd046 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:105. #13 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x863dcd0) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #14 0x00000000005e73f3 in clang::RecursiveASTVisitor<RScanner>::TraverseTranslationUnitDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1489. #15 0x00000000005ddccb in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:577. #16 0x00000000005d9f5c in RScanner::Scan (this=0x7fffffffb5c0, C=...) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:1058. #17 0x00000000005a99a0 in RootClingMain (argc=19, argv=0x7fffffffe028, isGenreflex=false) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_impl.cxx:4806. #18 0x00000000005afd6a in ROOT_rootcling_Driver (argc=19, argv=0x7fffffffe028, config=...) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_impl.cxx:6147. #19 0x00000000004a4f75 in main (argc=19, argv=",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:3673,security,Scanner,Scanner,3673,"8b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x9dd5c50) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #11 0x00000000005e1b29 in clang::RecursiveASTVisitor<RScanner>::TraverseNamespaceDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1513. #12 0x00000000005dd046 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:105. #13 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x863dcd0) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #14 0x00000000005e73f3 in clang::RecursiveASTVisitor<RScanner>::TraverseTranslationUnitDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1489. #15 0x00000000005ddccb in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:577. #16 0x00000000005d9f5c in RScanner::Scan (this=0x7fffffffb5c0, C=...) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:1058. #17 0x00000000005a99a0 in RootClingMain (argc=19, argv=0x7fffffffe028, isGenreflex=false) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_impl.cxx:4806. #18 0x00000000005afd6a in ROOT_rootcling_Driver (argc=19, argv=0x7fffffffe028, config=...) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_impl.cxx:6147. #19 0x00000000004a4f75 in main (argc=19, argv=0x7fffffffe028) at /home/sftnight/build/manual/root/core/rootcling_stage1/src/rootcling_stage1.cxx:46. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:590,usability,tool,tools,590,"The backtrace of the traversal code that does not see the decl for `std::vector<int>` is : . ```. #0 RScanner::TreatRecordDeclOrTypedefNameDecl (this=0x7fffffffb5c0, typeDecl=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:677. #1 0x00000000005d7f16 in RScanner::VisitRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:527. #2 0x00000000005efaf4 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:253. #3 0x00000000005efbc6 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromCXXRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:257. #4 0x00000000005efd06 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #5 0x00000000005e38f2 in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1891. #6 0x00000000005dd442 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #7 0x00000000005ef1f7 in clang::RecursiveASTVisitor<RScanner>::TraverseTemplateInstantiations (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1670. #8 0x00000000005e2c6c in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/inte",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:820,usability,tool,tools,820,"The backtrace of the traversal code that does not see the decl for `std::vector<int>` is : . ```. #0 RScanner::TreatRecordDeclOrTypedefNameDecl (this=0x7fffffffb5c0, typeDecl=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:677. #1 0x00000000005d7f16 in RScanner::VisitRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:527. #2 0x00000000005efaf4 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:253. #3 0x00000000005efbc6 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromCXXRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:257. #4 0x00000000005efd06 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #5 0x00000000005e38f2 in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1891. #6 0x00000000005dd442 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #7 0x00000000005ef1f7 in clang::RecursiveASTVisitor<RScanner>::TraverseTemplateInstantiations (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1670. #8 0x00000000005e2c6c in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/inte",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:1068,usability,tool,tools,1068,"::vector<int>` is : . ```. #0 RScanner::TreatRecordDeclOrTypedefNameDecl (this=0x7fffffffb5c0, typeDecl=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:677. #1 0x00000000005d7f16 in RScanner::VisitRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:527. #2 0x00000000005efaf4 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:253. #3 0x00000000005efbc6 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromCXXRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:257. #4 0x00000000005efd06 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #5 0x00000000005e38f2 in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1891. #6 0x00000000005dd442 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #7 0x00000000005ef1f7 in clang::RecursiveASTVisitor<RScanner>::TraverseTemplateInstantiations (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1670. #8 0x00000000005e2c6c in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:17",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:1313,usability,tool,tools,1313,"fffffffb5c0, D=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:527. #2 0x00000000005efaf4 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:253. #3 0x00000000005efbc6 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromCXXRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:257. #4 0x00000000005efd06 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #5 0x00000000005e38f2 in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1891. #6 0x00000000005dd442 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #7 0x00000000005ef1f7 in clang::RecursiveASTVisitor<RScanner>::TraverseTemplateInstantiations (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1670. #8 0x00000000005e2c6c in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1762. #9 0x00000000005dd2aa in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:1541,usability,tool,tools,1541,"night/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:253. #3 0x00000000005efbc6 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromCXXRecordDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:257. #4 0x00000000005efd06 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #5 0x00000000005e38f2 in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1891. #6 0x00000000005dd442 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #7 0x00000000005ef1f7 in clang::RecursiveASTVisitor<RScanner>::TraverseTemplateInstantiations (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1670. #8 0x00000000005e2c6c in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1762. #9 0x00000000005dd2aa in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x9dd5c50) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #11 0x00000000005e1b29 in clang::RecursiveASTVisitor<RScanner>::TraverseNamespaceD",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:1777,usability,tool,tools,1777,"build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:257. #4 0x00000000005efd06 in clang::RecursiveASTVisitor<RScanner>::WalkUpFromClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #5 0x00000000005e38f2 in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1891. #6 0x00000000005dd442 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #7 0x00000000005ef1f7 in clang::RecursiveASTVisitor<RScanner>::TraverseTemplateInstantiations (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1670. #8 0x00000000005e2c6c in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1762. #9 0x00000000005dd2aa in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x9dd5c50) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #11 0x00000000005e1b29 in clang::RecursiveASTVisitor<RScanner>::TraverseNamespaceDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1513. #12 0x00000000005dd046 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (thi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:2017,usability,tool,tools,2017,"ftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #5 0x00000000005e38f2 in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateSpecializationDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1891. #6 0x00000000005dd442 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #7 0x00000000005ef1f7 in clang::RecursiveASTVisitor<RScanner>::TraverseTemplateInstantiations (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1670. #8 0x00000000005e2c6c in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1762. #9 0x00000000005dd2aa in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x9dd5c50) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #11 0x00000000005e1b29 in clang::RecursiveASTVisitor<RScanner>::TraverseNamespaceDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1513. #12 0x00000000005dd046 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:105. #13 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x863dcd0) at ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:2245,usability,tool,tools,2245,"d5918). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1891. #6 0x00000000005dd442 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0xa1d5918). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:261. #7 0x00000000005ef1f7 in clang::RecursiveASTVisitor<RScanner>::TraverseTemplateInstantiations (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1670. #8 0x00000000005e2c6c in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1762. #9 0x00000000005dd2aa in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x9dd5c50) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #11 0x00000000005e1b29 in clang::RecursiveASTVisitor<RScanner>::TraverseNamespaceDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1513. #12 0x00000000005dd046 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:105. #13 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x863dcd0) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #14 0x00000000005e73f3 in clang::RecursiveASTVisitor<RScanner>::TraverseTranslationUnitDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/ro",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:2641,usability,tool,tools,2641,"canner>::TraverseTemplateInstantiations (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1670. #8 0x00000000005e2c6c in clang::RecursiveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1762. #9 0x00000000005dd2aa in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x9dd5c50) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #11 0x00000000005e1b29 in clang::RecursiveASTVisitor<RScanner>::TraverseNamespaceDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1513. #12 0x00000000005dd046 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:105. #13 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x863dcd0) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #14 0x00000000005e73f3 in clang::RecursiveASTVisitor<RScanner>::TraverseTranslationUnitDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1489. #15 0x00000000005ddccb in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:577. #16 0x00000000005d9f5c in RScanner::Scan (this=0x7fffffffb5c0, C=...) at /home/sftnight/build/",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:2870,usability,tool,tools,2870,"iveASTVisitor<RScanner>::TraverseClassTemplateDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1762. #9 0x00000000005dd2aa in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9828b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x9dd5c50) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #11 0x00000000005e1b29 in clang::RecursiveASTVisitor<RScanner>::TraverseNamespaceDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1513. #12 0x00000000005dd046 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:105. #13 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x863dcd0) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #14 0x00000000005e73f3 in clang::RecursiveASTVisitor<RScanner>::TraverseTranslationUnitDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1489. #15 0x00000000005ddccb in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:577. #16 0x00000000005d9f5c in RScanner::Scan (this=0x7fffffffb5c0, C=...) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:1058. #17 0x00000000005a99a0 in RootClingMain (argc=19, argv=0x7fffffffe028, isGenreflex=false) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_impl.cxx:4806. #18 0x00000000",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:3272,usability,tool,tools,3272,"8b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x9dd5c50) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #11 0x00000000005e1b29 in clang::RecursiveASTVisitor<RScanner>::TraverseNamespaceDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1513. #12 0x00000000005dd046 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:105. #13 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x863dcd0) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #14 0x00000000005e73f3 in clang::RecursiveASTVisitor<RScanner>::TraverseTranslationUnitDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1489. #15 0x00000000005ddccb in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:577. #16 0x00000000005d9f5c in RScanner::Scan (this=0x7fffffffb5c0, C=...) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:1058. #17 0x00000000005a99a0 in RootClingMain (argc=19, argv=0x7fffffffe028, isGenreflex=false) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_impl.cxx:4806. #18 0x00000000005afd6a in ROOT_rootcling_Driver (argc=19, argv=0x7fffffffe028, config=...) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_impl.cxx:6147. #19 0x00000000004a4f75 in main (argc=19, argv=0x7fffffffe028) at /home/sftnight/build/manual/root/core/rootcling_stage1/src/rootcling_stage1.cxx:46. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:3501,usability,tool,tools,3501,"8b70). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:201. #10 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x9dd5c50) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #11 0x00000000005e1b29 in clang::RecursiveASTVisitor<RScanner>::TraverseNamespaceDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1513. #12 0x00000000005dd046 in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x9dd5c20). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:105. #13 0x00000000005d9991 in RScanner::TraverseDeclContextHelper (this=0x7fffffffb5c0, DC=0x863dcd0) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:970. #14 0x00000000005e73f3 in clang::RecursiveASTVisitor<RScanner>::TraverseTranslationUnitDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/root/interpreter/llvm/src/tools/clang/include/clang/AST/RecursiveASTVisitor.h:1489. #15 0x00000000005ddccb in clang::RecursiveASTVisitor<RScanner>::TraverseDecl (this=0x7fffffffb5c0, D=0x863dca8). at /home/sftnight/build/manual/build/interpreter/llvm/src/tools/clang/include/clang/AST/DeclNodes.inc:577. #16 0x00000000005d9f5c in RScanner::Scan (this=0x7fffffffb5c0, C=...) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:1058. #17 0x00000000005a99a0 in RootClingMain (argc=19, argv=0x7fffffffe028, isGenreflex=false) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_impl.cxx:4806. #18 0x00000000005afd6a in ROOT_rootcling_Driver (argc=19, argv=0x7fffffffe028, config=...) at /home/sftnight/build/manual/root/core/dictgen/src/rootcling_impl.cxx:6147. #19 0x00000000004a4f75 in main (argc=19, argv=0x7fffffffe028) at /home/sftnight/build/manual/root/core/rootcling_stage1/src/rootcling_stage1.cxx:46. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:63,deployability,build,build,63,The problem reproduces on `root-fedora36-2` in `/home/sftnight/build/manual/build` with. ```. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx a.h aLinkDef.h # good. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/sftnight/build/manual/build/lib/libCore.so -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes a.h aLinkDef.h # bad. ```. I commented out the printing of the translation unit decl at the moment; the printed translation unit decl are in : rs.bad.04.log rs.good.04.log.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:76,deployability,build,build,76,The problem reproduces on `root-fedora36-2` in `/home/sftnight/build/manual/build` with. ```. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx a.h aLinkDef.h # good. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/sftnight/build/manual/build/lib/libCore.so -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes a.h aLinkDef.h # bad. ```. I commented out the printing of the translation unit decl at the moment; the printed translation unit decl are in : rs.bad.04.log rs.good.04.log.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:109,deployability,build,build,109,The problem reproduces on `root-fedora36-2` in `/home/sftnight/build/manual/build` with. ```. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx a.h aLinkDef.h # good. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/sftnight/build/manual/build/lib/libCore.so -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes a.h aLinkDef.h # bad. ```. I commented out the printing of the translation unit decl at the moment; the printed translation unit decl are in : rs.bad.04.log rs.good.04.log.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:122,deployability,build,build,122,The problem reproduces on `root-fedora36-2` in `/home/sftnight/build/manual/build` with. ```. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx a.h aLinkDef.h # good. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/sftnight/build/manual/build/lib/libCore.so -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes a.h aLinkDef.h # bad. ```. I commented out the printing of the translation unit decl at the moment; the printed translation unit decl are in : rs.bad.04.log rs.good.04.log.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:228,deployability,build,build,228,The problem reproduces on `root-fedora36-2` in `/home/sftnight/build/manual/build` with. ```. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx a.h aLinkDef.h # good. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/sftnight/build/manual/build/lib/libCore.so -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes a.h aLinkDef.h # bad. ```. I commented out the printing of the translation unit decl at the moment; the printed translation unit decl are in : rs.bad.04.log rs.good.04.log.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:241,deployability,build,build,241,The problem reproduces on `root-fedora36-2` in `/home/sftnight/build/manual/build` with. ```. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx a.h aLinkDef.h # good. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/sftnight/build/manual/build/lib/libCore.so -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes a.h aLinkDef.h # bad. ```. I commented out the printing of the translation unit decl at the moment; the printed translation unit decl are in : rs.bad.04.log rs.good.04.log.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:338,deployability,build,build,338,The problem reproduces on `root-fedora36-2` in `/home/sftnight/build/manual/build` with. ```. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx a.h aLinkDef.h # good. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/sftnight/build/manual/build/lib/libCore.so -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes a.h aLinkDef.h # bad. ```. I commented out the printing of the translation unit decl at the moment; the printed translation unit decl are in : rs.bad.04.log rs.good.04.log.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:351,deployability,build,build,351,The problem reproduces on `root-fedora36-2` in `/home/sftnight/build/manual/build` with. ```. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx a.h aLinkDef.h # good. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/sftnight/build/manual/build/lib/libCore.so -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes a.h aLinkDef.h # bad. ```. I commented out the printing of the translation unit decl at the moment; the printed translation unit decl are in : rs.bad.04.log rs.good.04.log.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:676,deployability,log,log,676,The problem reproduces on `root-fedora36-2` in `/home/sftnight/build/manual/build` with. ```. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx a.h aLinkDef.h # good. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/sftnight/build/manual/build/lib/libCore.so -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes a.h aLinkDef.h # bad. ```. I commented out the printing of the translation unit decl at the moment; the printed translation unit decl are in : rs.bad.04.log rs.good.04.log.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:691,deployability,log,log,691,The problem reproduces on `root-fedora36-2` in `/home/sftnight/build/manual/build` with. ```. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx a.h aLinkDef.h # good. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/sftnight/build/manual/build/lib/libCore.so -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes a.h aLinkDef.h # bad. ```. I commented out the printing of the translation unit decl at the moment; the printed translation unit decl are in : rs.bad.04.log rs.good.04.log.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:128,energy efficiency,core,core,128,The problem reproduces on `root-fedora36-2` in `/home/sftnight/build/manual/build` with. ```. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx a.h aLinkDef.h # good. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/sftnight/build/manual/build/lib/libCore.so -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes a.h aLinkDef.h # bad. ```. I commented out the printing of the translation unit decl at the moment; the printed translation unit decl are in : rs.bad.04.log rs.good.04.log.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:247,energy efficiency,core,core,247,The problem reproduces on `root-fedora36-2` in `/home/sftnight/build/manual/build` with. ```. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx a.h aLinkDef.h # good. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/sftnight/build/manual/build/lib/libCore.so -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes a.h aLinkDef.h # bad. ```. I commented out the printing of the translation unit decl at the moment; the printed translation unit decl are in : rs.bad.04.log rs.good.04.log.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:586,integrability,translat,translation,586,The problem reproduces on `root-fedora36-2` in `/home/sftnight/build/manual/build` with. ```. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx a.h aLinkDef.h # good. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/sftnight/build/manual/build/lib/libCore.so -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes a.h aLinkDef.h # bad. ```. I commented out the printing of the translation unit decl at the moment; the printed translation unit decl are in : rs.bad.04.log rs.good.04.log.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:635,integrability,translat,translation,635,The problem reproduces on `root-fedora36-2` in `/home/sftnight/build/manual/build` with. ```. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx a.h aLinkDef.h # good. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/sftnight/build/manual/build/lib/libCore.so -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes a.h aLinkDef.h # bad. ```. I commented out the printing of the translation unit decl at the moment; the printed translation unit decl are in : rs.bad.04.log rs.good.04.log.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:586,interoperability,translat,translation,586,The problem reproduces on `root-fedora36-2` in `/home/sftnight/build/manual/build` with. ```. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx a.h aLinkDef.h # good. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/sftnight/build/manual/build/lib/libCore.so -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes a.h aLinkDef.h # bad. ```. I commented out the printing of the translation unit decl at the moment; the printed translation unit decl are in : rs.bad.04.log rs.good.04.log.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:635,interoperability,translat,translation,635,The problem reproduces on `root-fedora36-2` in `/home/sftnight/build/manual/build` with. ```. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx a.h aLinkDef.h # good. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/sftnight/build/manual/build/lib/libCore.so -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes a.h aLinkDef.h # bad. ```. I commented out the printing of the translation unit decl at the moment; the printed translation unit decl are in : rs.bad.04.log rs.good.04.log.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:676,safety,log,log,676,The problem reproduces on `root-fedora36-2` in `/home/sftnight/build/manual/build` with. ```. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx a.h aLinkDef.h # good. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/sftnight/build/manual/build/lib/libCore.so -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes a.h aLinkDef.h # bad. ```. I commented out the printing of the translation unit decl at the moment; the printed translation unit decl are in : rs.bad.04.log rs.good.04.log.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:691,safety,log,log,691,The problem reproduces on `root-fedora36-2` in `/home/sftnight/build/manual/build` with. ```. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx a.h aLinkDef.h # good. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/sftnight/build/manual/build/lib/libCore.so -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes a.h aLinkDef.h # bad. ```. I commented out the printing of the translation unit decl at the moment; the printed translation unit decl are in : rs.bad.04.log rs.good.04.log.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:676,security,log,log,676,The problem reproduces on `root-fedora36-2` in `/home/sftnight/build/manual/build` with. ```. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx a.h aLinkDef.h # good. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/sftnight/build/manual/build/lib/libCore.so -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes a.h aLinkDef.h # bad. ```. I commented out the printing of the translation unit decl at the moment; the printed translation unit decl are in : rs.bad.04.log rs.good.04.log.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:691,security,log,log,691,The problem reproduces on `root-fedora36-2` in `/home/sftnight/build/manual/build` with. ```. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx a.h aLinkDef.h # good. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/sftnight/build/manual/build/lib/libCore.so -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes a.h aLinkDef.h # bad. ```. I commented out the printing of the translation unit decl at the moment; the printed translation unit decl are in : rs.bad.04.log rs.good.04.log.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:598,testability,unit,unit,598,The problem reproduces on `root-fedora36-2` in `/home/sftnight/build/manual/build` with. ```. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx a.h aLinkDef.h # good. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/sftnight/build/manual/build/lib/libCore.so -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes a.h aLinkDef.h # bad. ```. I commented out the printing of the translation unit decl at the moment; the printed translation unit decl are in : rs.bad.04.log rs.good.04.log.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:647,testability,unit,unit,647,The problem reproduces on `root-fedora36-2` in `/home/sftnight/build/manual/build` with. ```. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx a.h aLinkDef.h # good. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/sftnight/build/manual/build/lib/libCore.so -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes a.h aLinkDef.h # bad. ```. I commented out the printing of the translation unit decl at the moment; the printed translation unit decl are in : rs.bad.04.log rs.good.04.log.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:676,testability,log,log,676,The problem reproduces on `root-fedora36-2` in `/home/sftnight/build/manual/build` with. ```. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx a.h aLinkDef.h # good. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/sftnight/build/manual/build/lib/libCore.so -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes a.h aLinkDef.h # bad. ```. I commented out the printing of the translation unit decl at the moment; the printed translation unit decl are in : rs.bad.04.log rs.good.04.log.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:691,testability,log,log,691,The problem reproduces on `root-fedora36-2` in `/home/sftnight/build/manual/build` with. ```. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx a.h aLinkDef.h # good. /home/sftnight/build/manual/build/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/sftnight/build/manual/build/lib/libCore.so -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes a.h aLinkDef.h # bad. ```. I commented out the printing of the translation unit decl at the moment; the printed translation unit decl are in : rs.bad.04.log rs.good.04.log.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:213,deployability,build,build,213,"> The backtrace of the traversal code that does not see the decl for `std::vector<int>` is :. > . > ```. > #0 RScanner::TreatRecordDeclOrTypedefNameDecl (this=0x7fffffffb5c0, typeDecl=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:677. > ```. Does `RScanner::shouldVisitDecl` return `false` for `std::vector<int>`? I guess we need to understand what makes this declaration not visible for gcc12...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:231,energy efficiency,core,core,231,"> The backtrace of the traversal code that does not see the decl for `std::vector<int>` is :. > . > ```. > #0 RScanner::TreatRecordDeclOrTypedefNameDecl (this=0x7fffffffb5c0, typeDecl=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:677. > ```. Does `RScanner::shouldVisitDecl` return `false` for `std::vector<int>`? I guess we need to understand what makes this declaration not visible for gcc12...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:43,reliability,doe,does,43,"> The backtrace of the traversal code that does not see the decl for `std::vector<int>` is :. > . > ```. > #0 RScanner::TreatRecordDeclOrTypedefNameDecl (this=0x7fffffffb5c0, typeDecl=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:677. > ```. Does `RScanner::shouldVisitDecl` return `false` for `std::vector<int>`? I guess we need to understand what makes this declaration not visible for gcc12...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:272,reliability,Doe,Does,272,"> The backtrace of the traversal code that does not see the decl for `std::vector<int>` is :. > . > ```. > #0 RScanner::TreatRecordDeclOrTypedefNameDecl (this=0x7fffffffb5c0, typeDecl=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:677. > ```. Does `RScanner::shouldVisitDecl` return `false` for `std::vector<int>`? I guess we need to understand what makes this declaration not visible for gcc12...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:248,security,Scanner,Scanner,248,"> The backtrace of the traversal code that does not see the decl for `std::vector<int>` is :. > . > ```. > #0 RScanner::TreatRecordDeclOrTypedefNameDecl (this=0x7fffffffb5c0, typeDecl=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:677. > ```. Does `RScanner::shouldVisitDecl` return `false` for `std::vector<int>`? I guess we need to understand what makes this declaration not visible for gcc12...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:363,testability,understand,understand,363,"> The backtrace of the traversal code that does not see the decl for `std::vector<int>` is :. > . > ```. > #0 RScanner::TreatRecordDeclOrTypedefNameDecl (this=0x7fffffffb5c0, typeDecl=0xa1d5918) at /home/sftnight/build/manual/root/core/dictgen/src/Scanner.cxx:677. > ```. Does `RScanner::shouldVisitDecl` return `false` for `std::vector<int>`? I guess we need to understand what makes this declaration not visible for gcc12...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:284,deployability,modul,modules,284,"I think I understand what happens. gcc 12 has a template instantiation coming from the `regex` header file. That means we do not reinstantiate but deserialize the instantiation upon use but it is still hidden. However, `RScanner::shouldVisitDecl` ignores declarations from unimported modules which are marked hidden. If I add `#include <regex>` to `a.h` the printout is still unhappy but the warning goes away. I am not sure what'd be the right fix, however, when we use a hidden declaration in a cling::Transaction we should probably make it visible even if we did not have a corresponding include. The alternative is to remove the `shouldVisit` as I am not sure if I understand well the intent of a785402a88599fe43c8d6ef35de8bc0d39e10585 however removing it would probably be a headache.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:284,modifiability,modul,modules,284,"I think I understand what happens. gcc 12 has a template instantiation coming from the `regex` header file. That means we do not reinstantiate but deserialize the instantiation upon use but it is still hidden. However, `RScanner::shouldVisitDecl` ignores declarations from unimported modules which are marked hidden. If I add `#include <regex>` to `a.h` the printout is still unhappy but the warning goes away. I am not sure what'd be the right fix, however, when we use a hidden declaration in a cling::Transaction we should probably make it visible even if we did not have a corresponding include. The alternative is to remove the `shouldVisit` as I am not sure if I understand well the intent of a785402a88599fe43c8d6ef35de8bc0d39e10585 however removing it would probably be a headache.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:284,safety,modul,modules,284,"I think I understand what happens. gcc 12 has a template instantiation coming from the `regex` header file. That means we do not reinstantiate but deserialize the instantiation upon use but it is still hidden. However, `RScanner::shouldVisitDecl` ignores declarations from unimported modules which are marked hidden. If I add `#include <regex>` to `a.h` the printout is still unhappy but the warning goes away. I am not sure what'd be the right fix, however, when we use a hidden declaration in a cling::Transaction we should probably make it visible even if we did not have a corresponding include. The alternative is to remove the `shouldVisit` as I am not sure if I understand well the intent of a785402a88599fe43c8d6ef35de8bc0d39e10585 however removing it would probably be a headache.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:10,testability,understand,understand,10,"I think I understand what happens. gcc 12 has a template instantiation coming from the `regex` header file. That means we do not reinstantiate but deserialize the instantiation upon use but it is still hidden. However, `RScanner::shouldVisitDecl` ignores declarations from unimported modules which are marked hidden. If I add `#include <regex>` to `a.h` the printout is still unhappy but the warning goes away. I am not sure what'd be the right fix, however, when we use a hidden declaration in a cling::Transaction we should probably make it visible even if we did not have a corresponding include. The alternative is to remove the `shouldVisit` as I am not sure if I understand well the intent of a785402a88599fe43c8d6ef35de8bc0d39e10585 however removing it would probably be a headache.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:669,testability,understand,understand,669,"I think I understand what happens. gcc 12 has a template instantiation coming from the `regex` header file. That means we do not reinstantiate but deserialize the instantiation upon use but it is still hidden. However, `RScanner::shouldVisitDecl` ignores declarations from unimported modules which are marked hidden. If I add `#include <regex>` to `a.h` the printout is still unhappy but the warning goes away. I am not sure what'd be the right fix, however, when we use a hidden declaration in a cling::Transaction we should probably make it visible even if we did not have a corresponding include. The alternative is to remove the `shouldVisit` as I am not sure if I understand well the intent of a785402a88599fe43c8d6ef35de8bc0d39e10585 however removing it would probably be a headache.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:214,deployability,contain,contains,214,"One thing I don't understand is what does ""invisible"" mean in this context and/or why is the invisible decl hidding the visible decl (i.e. The header for vector is explicitly included in my example) and the header contains 2 different way to 'explicitly' instantiate the template).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:37,reliability,doe,does,37,"One thing I don't understand is what does ""invisible"" mean in this context and/or why is the invisible decl hidding the visible decl (i.e. The header for vector is explicitly included in my example) and the header contains 2 different way to 'explicitly' instantiate the template).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:18,testability,understand,understand,18,"One thing I don't understand is what does ""invisible"" mean in this context and/or why is the invisible decl hidding the visible decl (i.e. The header for vector is explicitly included in my example) and the header contains 2 different way to 'explicitly' instantiate the template).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:67,testability,context,context,67,"One thing I don't understand is what does ""invisible"" mean in this context and/or why is the invisible decl hidding the visible decl (i.e. The header for vector is explicitly included in my example) and the header contains 2 different way to 'explicitly' instantiate the template).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:170,availability,reliab,reliable,170,I think I added a fix in the build that you used and it might work around this issue. The warning is gone. Can you check if that fixes the issue? I don't think my fix is reliable in the general case but might be good enough...,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:29,deployability,build,build,29,I think I added a fix in the build that you used and it might work around this issue. The warning is gone. Can you check if that fixes the issue? I don't think my fix is reliable in the general case but might be good enough...,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11329:170,reliability,reliab,reliable,170,I think I added a fix in the build that you used and it might work around this issue. The warning is gone. Can you check if that fixes the issue? I don't think my fix is reliable in the general case but might be good enough...,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11329
https://github.com/root-project/root/issues/11332:80,integrability,Batch,BatchMode,80,"Thank you very much for reporting this, it's great that you are testing the new BatchMode like this and report on this feature regression!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11332
https://github.com/root-project/root/issues/11332:80,performance,Batch,BatchMode,80,"Thank you very much for reporting this, it's great that you are testing the new BatchMode like this and report on this feature regression!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11332
https://github.com/root-project/root/issues/11332:64,safety,test,testing,64,"Thank you very much for reporting this, it's great that you are testing the new BatchMode like this and report on this feature regression!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11332
https://github.com/root-project/root/issues/11332:64,testability,test,testing,64,"Thank you very much for reporting this, it's great that you are testing the new BatchMode like this and report on this feature regression!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11332
https://github.com/root-project/root/issues/11332:127,testability,regress,regression,127,"Thank you very much for reporting this, it's great that you are testing the new BatchMode like this and report on this feature regression!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11332
https://github.com/root-project/root/issues/11333:58,deployability,scale,scale,58,"@lmoneta in CMS we are using THnSparse for a fairly large-scale analysis, so any suggestions of viable fixes or workarounds that we can easily implement would be very appreciated!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11333
https://github.com/root-project/root/issues/11333:58,energy efficiency,scale,scale,58,"@lmoneta in CMS we are using THnSparse for a fairly large-scale analysis, so any suggestions of viable fixes or workarounds that we can easily implement would be very appreciated!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11333
https://github.com/root-project/root/issues/11333:58,modifiability,scal,scale,58,"@lmoneta in CMS we are using THnSparse for a fairly large-scale analysis, so any suggestions of viable fixes or workarounds that we can easily implement would be very appreciated!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11333
https://github.com/root-project/root/issues/11333:58,performance,scale,scale,58,"@lmoneta in CMS we are using THnSparse for a fairly large-scale analysis, so any suggestions of viable fixes or workarounds that we can easily implement would be very appreciated!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11333
https://github.com/root-project/root/issues/11333:108,availability,error,error,108,"Thank you to report this problem and the test to reproduce. The problem is to be not in the bin content and error of the resulting histograms but in the sum of all bin contents and errors, e.g. `h->GetWeightSum()`. I will provide soon a PR fixing this",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11333
https://github.com/root-project/root/issues/11333:181,availability,error,errors,181,"Thank you to report this problem and the test to reproduce. The problem is to be not in the bin content and error of the resulting histograms but in the sum of all bin contents and errors, e.g. `h->GetWeightSum()`. I will provide soon a PR fixing this",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11333
https://github.com/root-project/root/issues/11333:96,performance,content,content,96,"Thank you to report this problem and the test to reproduce. The problem is to be not in the bin content and error of the resulting histograms but in the sum of all bin contents and errors, e.g. `h->GetWeightSum()`. I will provide soon a PR fixing this",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11333
https://github.com/root-project/root/issues/11333:108,performance,error,error,108,"Thank you to report this problem and the test to reproduce. The problem is to be not in the bin content and error of the resulting histograms but in the sum of all bin contents and errors, e.g. `h->GetWeightSum()`. I will provide soon a PR fixing this",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11333
https://github.com/root-project/root/issues/11333:168,performance,content,contents,168,"Thank you to report this problem and the test to reproduce. The problem is to be not in the bin content and error of the resulting histograms but in the sum of all bin contents and errors, e.g. `h->GetWeightSum()`. I will provide soon a PR fixing this",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11333
https://github.com/root-project/root/issues/11333:181,performance,error,errors,181,"Thank you to report this problem and the test to reproduce. The problem is to be not in the bin content and error of the resulting histograms but in the sum of all bin contents and errors, e.g. `h->GetWeightSum()`. I will provide soon a PR fixing this",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11333
https://github.com/root-project/root/issues/11333:41,safety,test,test,41,"Thank you to report this problem and the test to reproduce. The problem is to be not in the bin content and error of the resulting histograms but in the sum of all bin contents and errors, e.g. `h->GetWeightSum()`. I will provide soon a PR fixing this",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11333
https://github.com/root-project/root/issues/11333:108,safety,error,error,108,"Thank you to report this problem and the test to reproduce. The problem is to be not in the bin content and error of the resulting histograms but in the sum of all bin contents and errors, e.g. `h->GetWeightSum()`. I will provide soon a PR fixing this",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11333
https://github.com/root-project/root/issues/11333:181,safety,error,errors,181,"Thank you to report this problem and the test to reproduce. The problem is to be not in the bin content and error of the resulting histograms but in the sum of all bin contents and errors, e.g. `h->GetWeightSum()`. I will provide soon a PR fixing this",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11333
https://github.com/root-project/root/issues/11333:41,testability,test,test,41,"Thank you to report this problem and the test to reproduce. The problem is to be not in the bin content and error of the resulting histograms but in the sum of all bin contents and errors, e.g. `h->GetWeightSum()`. I will provide soon a PR fixing this",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11333
https://github.com/root-project/root/issues/11333:108,usability,error,error,108,"Thank you to report this problem and the test to reproduce. The problem is to be not in the bin content and error of the resulting histograms but in the sum of all bin contents and errors, e.g. `h->GetWeightSum()`. I will provide soon a PR fixing this",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11333
https://github.com/root-project/root/issues/11333:181,usability,error,errors,181,"Thank you to report this problem and the test to reproduce. The problem is to be not in the bin content and error of the resulting histograms but in the sum of all bin contents and errors, e.g. `h->GetWeightSum()`. I will provide soon a PR fixing this",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11333
https://github.com/root-project/root/pull/11334:11,deployability,build,build,11,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11334
https://github.com/root-project/root/pull/11334:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11334
https://github.com/root-project/root/pull/11334:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11334
https://github.com/root-project/root/pull/11334:13,availability,failur,failure,13,All the test failure left are pre-existing.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11334
https://github.com/root-project/root/pull/11334:13,deployability,fail,failure,13,All the test failure left are pre-existing.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11334
https://github.com/root-project/root/pull/11334:13,performance,failur,failure,13,All the test failure left are pre-existing.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11334
https://github.com/root-project/root/pull/11334:13,reliability,fail,failure,13,All the test failure left are pre-existing.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11334
https://github.com/root-project/root/pull/11334:8,safety,test,test,8,All the test failure left are pre-existing.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11334
https://github.com/root-project/root/pull/11334:8,testability,test,test,8,All the test failure left are pre-existing.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11334
https://github.com/root-project/root/pull/11334:13,deployability,updat,updated,13,The code was updated to replace the `MockTObject` with friendship.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11334
https://github.com/root-project/root/pull/11334:13,safety,updat,updated,13,The code was updated to replace the `MockTObject` with friendship.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11334
https://github.com/root-project/root/pull/11334:13,security,updat,updated,13,The code was updated to replace the `MockTObject` with friendship.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11334
https://github.com/root-project/root/pull/11334:37,testability,Mock,MockTObject,37,The code was updated to replace the `MockTObject` with friendship.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11334
https://github.com/root-project/root/pull/11334:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11334
https://github.com/root-project/root/pull/11334:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11334
https://github.com/root-project/root/pull/11335:11,deployability,build,build,11,@phsft-bot build just on ROOT-ubuntu2204/default with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11335
https://github.com/root-project/root/pull/11335:11,deployability,build,build,11,@phsft-bot build just on ROOT-ubuntu2204/default with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11335
https://github.com/root-project/root/pull/11335:11,deployability,build,build,11,@phsft-bot build just on ROOT-ubuntu2204/default with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11335
https://github.com/root-project/root/pull/11335:11,deployability,build,build,11,@phsft-bot build just on ROOT-ubuntu2204/default with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11335
https://github.com/root-project/root/issues/11338:31,modifiability,pac,package,31,"Hi @edmondium ,. the ROOT snap package is not maintained by the ROOT developers, please contact the Snap packagers here: https://github.com/MrCarroll/root-snap/issues . Cheers,. Enrico. cc: @MrCarroll",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11338
https://github.com/root-project/root/issues/11338:46,modifiability,maintain,maintained,46,"Hi @edmondium ,. the ROOT snap package is not maintained by the ROOT developers, please contact the Snap packagers here: https://github.com/MrCarroll/root-snap/issues . Cheers,. Enrico. cc: @MrCarroll",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11338
https://github.com/root-project/root/issues/11338:105,modifiability,pac,packagers,105,"Hi @edmondium ,. the ROOT snap package is not maintained by the ROOT developers, please contact the Snap packagers here: https://github.com/MrCarroll/root-snap/issues . Cheers,. Enrico. cc: @MrCarroll",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11338
https://github.com/root-project/root/issues/11338:46,safety,maintain,maintained,46,"Hi @edmondium ,. the ROOT snap package is not maintained by the ROOT developers, please contact the Snap packagers here: https://github.com/MrCarroll/root-snap/issues . Cheers,. Enrico. cc: @MrCarroll",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11338
https://github.com/root-project/root/pull/11342:15,interoperability,conflict,conflicts,15,Rebased to fix conflicts.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11342
https://github.com/root-project/root/pull/11342:11,deployability,build,build,11,@phsft-bot build please,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11342
https://github.com/root-project/root/pull/11343:73,safety,test,test,73,"Hello, thank you for the PR! Just a comment, I think the comments in the test in testRooProdPdf.cxx are leftover from the original reproducer macro, as they do not match what is happening in the test",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11343
https://github.com/root-project/root/pull/11343:81,safety,test,testRooProdPdf,81,"Hello, thank you for the PR! Just a comment, I think the comments in the test in testRooProdPdf.cxx are leftover from the original reproducer macro, as they do not match what is happening in the test",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11343
https://github.com/root-project/root/pull/11343:195,safety,test,test,195,"Hello, thank you for the PR! Just a comment, I think the comments in the test in testRooProdPdf.cxx are leftover from the original reproducer macro, as they do not match what is happening in the test",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11343
https://github.com/root-project/root/pull/11343:73,testability,test,test,73,"Hello, thank you for the PR! Just a comment, I think the comments in the test in testRooProdPdf.cxx are leftover from the original reproducer macro, as they do not match what is happening in the test",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11343
https://github.com/root-project/root/pull/11343:81,testability,test,testRooProdPdf,81,"Hello, thank you for the PR! Just a comment, I think the comments in the test in testRooProdPdf.cxx are leftover from the original reproducer macro, as they do not match what is happening in the test",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11343
https://github.com/root-project/root/pull/11343:195,testability,test,test,195,"Hello, thank you for the PR! Just a comment, I think the comments in the test in testRooProdPdf.cxx are leftover from the original reproducer macro, as they do not match what is happening in the test",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11343
https://github.com/root-project/root/pull/11343:207,modifiability,paramet,parameter,207,"I don't know. Why this option exists. I agree, it is confusing. I think what we can do is to merge this PR, do the backport as a bugfix, and then only in ROOT `master` do a follow-up where the `depsAreCond` parameter is removed.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11343
https://github.com/root-project/root/pull/11347:11,deployability,build,build,11,@phsft-bot build just on ROOT-performance-centos8-multicore/cxx17 with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11347
https://github.com/root-project/root/pull/11347:30,performance,perform,performance-,30,@phsft-bot build just on ROOT-performance-centos8-multicore/cxx17 with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11347
https://github.com/root-project/root/pull/11347:30,usability,perform,performance-,30,@phsft-bot build just on ROOT-performance-centos8-multicore/cxx17 with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11347
https://github.com/root-project/root/pull/11350:106,deployability,upgrad,upgrade,106,Could you move the changes in `clingutils` and `dictgen` into a separate PR that we look at once the llvm upgrade is in? I'm afraid of the conflicts we get from this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11350
https://github.com/root-project/root/pull/11350:139,interoperability,conflict,conflicts,139,Could you move the changes in `clingutils` and `dictgen` into a separate PR that we look at once the llvm upgrade is in? I'm afraid of the conflicts we get from this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11350
https://github.com/root-project/root/pull/11350:106,modifiability,upgrad,upgrade,106,Could you move the changes in `clingutils` and `dictgen` into a separate PR that we look at once the llvm upgrade is in? I'm afraid of the conflicts we get from this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11350
https://github.com/root-project/root/pull/11351:85,deployability,upgrad,upgrade,85,I'd really like to avoid having to deal with the conflicts between this and the llvm upgrade. Can we close this and have a new version once the llvm upgrade is in?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11351
https://github.com/root-project/root/pull/11351:127,deployability,version,version,127,I'd really like to avoid having to deal with the conflicts between this and the llvm upgrade. Can we close this and have a new version once the llvm upgrade is in?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11351
https://github.com/root-project/root/pull/11351:149,deployability,upgrad,upgrade,149,I'd really like to avoid having to deal with the conflicts between this and the llvm upgrade. Can we close this and have a new version once the llvm upgrade is in?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11351
https://github.com/root-project/root/pull/11351:127,integrability,version,version,127,I'd really like to avoid having to deal with the conflicts between this and the llvm upgrade. Can we close this and have a new version once the llvm upgrade is in?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11351
https://github.com/root-project/root/pull/11351:49,interoperability,conflict,conflicts,49,I'd really like to avoid having to deal with the conflicts between this and the llvm upgrade. Can we close this and have a new version once the llvm upgrade is in?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11351
https://github.com/root-project/root/pull/11351:85,modifiability,upgrad,upgrade,85,I'd really like to avoid having to deal with the conflicts between this and the llvm upgrade. Can we close this and have a new version once the llvm upgrade is in?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11351
https://github.com/root-project/root/pull/11351:127,modifiability,version,version,127,I'd really like to avoid having to deal with the conflicts between this and the llvm upgrade. Can we close this and have a new version once the llvm upgrade is in?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11351
https://github.com/root-project/root/pull/11351:149,modifiability,upgrad,upgrade,149,I'd really like to avoid having to deal with the conflicts between this and the llvm upgrade. Can we close this and have a new version once the llvm upgrade is in?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11351
https://github.com/root-project/root/pull/11351:19,safety,avoid,avoid,19,I'd really like to avoid having to deal with the conflicts between this and the llvm upgrade. Can we close this and have a new version once the llvm upgrade is in?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11351
https://github.com/root-project/root/pull/11351:101,usability,close,close,101,I'd really like to avoid having to deal with the conflicts between this and the llvm upgrade. Can we close this and have a new version once the llvm upgrade is in?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11351
https://github.com/root-project/root/pull/11351:122,deployability,upgrad,upgrade,122,I would like to keep it open - just to have possibility to test against current master. We can return to the PR once LLVM upgrade done.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11351
https://github.com/root-project/root/pull/11351:72,energy efficiency,current,current,72,I would like to keep it open - just to have possibility to test against current master. We can return to the PR once LLVM upgrade done.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11351
https://github.com/root-project/root/pull/11351:122,modifiability,upgrad,upgrade,122,I would like to keep it open - just to have possibility to test against current master. We can return to the PR once LLVM upgrade done.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11351
https://github.com/root-project/root/pull/11351:59,safety,test,test,59,I would like to keep it open - just to have possibility to test against current master. We can return to the PR once LLVM upgrade done.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11351
https://github.com/root-project/root/pull/11351:59,testability,test,test,59,I would like to keep it open - just to have possibility to test against current master. We can return to the PR once LLVM upgrade done.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11351
https://github.com/root-project/root/pull/11351:8,usability,prefer,prefer,8,I would prefer merging #12116 before this change.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11351
https://github.com/root-project/root/issues/11353:143,availability,error,error,143,"Can you try with a more recent ROOT version? I do not get a crash there. The problem however persists, even if linking with lNew, it raises an error:. ```. Error in <TMapFile::TMapFile>: no memory mapped file capability available. Use rootn.exe or link application against ""-lNew"". Memory mapped file: hsimple.map. Title: Memory Mapped Hist. Option: file closed. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11353
https://github.com/root-project/root/issues/11353:156,availability,Error,Error,156,"Can you try with a more recent ROOT version? I do not get a crash there. The problem however persists, even if linking with lNew, it raises an error:. ```. Error in <TMapFile::TMapFile>: no memory mapped file capability available. Use rootn.exe or link application against ""-lNew"". Memory mapped file: hsimple.map. Title: Memory Mapped Hist. Option: file closed. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11353
https://github.com/root-project/root/issues/11353:220,availability,avail,available,220,"Can you try with a more recent ROOT version? I do not get a crash there. The problem however persists, even if linking with lNew, it raises an error:. ```. Error in <TMapFile::TMapFile>: no memory mapped file capability available. Use rootn.exe or link application against ""-lNew"". Memory mapped file: hsimple.map. Title: Memory Mapped Hist. Option: file closed. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11353
https://github.com/root-project/root/issues/11353:36,deployability,version,version,36,"Can you try with a more recent ROOT version? I do not get a crash there. The problem however persists, even if linking with lNew, it raises an error:. ```. Error in <TMapFile::TMapFile>: no memory mapped file capability available. Use rootn.exe or link application against ""-lNew"". Memory mapped file: hsimple.map. Title: Memory Mapped Hist. Option: file closed. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11353
https://github.com/root-project/root/issues/11353:36,integrability,version,version,36,"Can you try with a more recent ROOT version? I do not get a crash there. The problem however persists, even if linking with lNew, it raises an error:. ```. Error in <TMapFile::TMapFile>: no memory mapped file capability available. Use rootn.exe or link application against ""-lNew"". Memory mapped file: hsimple.map. Title: Memory Mapped Hist. Option: file closed. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11353
https://github.com/root-project/root/issues/11353:36,modifiability,version,version,36,"Can you try with a more recent ROOT version? I do not get a crash there. The problem however persists, even if linking with lNew, it raises an error:. ```. Error in <TMapFile::TMapFile>: no memory mapped file capability available. Use rootn.exe or link application against ""-lNew"". Memory mapped file: hsimple.map. Title: Memory Mapped Hist. Option: file closed. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11353
https://github.com/root-project/root/issues/11353:143,performance,error,error,143,"Can you try with a more recent ROOT version? I do not get a crash there. The problem however persists, even if linking with lNew, it raises an error:. ```. Error in <TMapFile::TMapFile>: no memory mapped file capability available. Use rootn.exe or link application against ""-lNew"". Memory mapped file: hsimple.map. Title: Memory Mapped Hist. Option: file closed. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11353
https://github.com/root-project/root/issues/11353:156,performance,Error,Error,156,"Can you try with a more recent ROOT version? I do not get a crash there. The problem however persists, even if linking with lNew, it raises an error:. ```. Error in <TMapFile::TMapFile>: no memory mapped file capability available. Use rootn.exe or link application against ""-lNew"". Memory mapped file: hsimple.map. Title: Memory Mapped Hist. Option: file closed. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11353
https://github.com/root-project/root/issues/11353:190,performance,memor,memory,190,"Can you try with a more recent ROOT version? I do not get a crash there. The problem however persists, even if linking with lNew, it raises an error:. ```. Error in <TMapFile::TMapFile>: no memory mapped file capability available. Use rootn.exe or link application against ""-lNew"". Memory mapped file: hsimple.map. Title: Memory Mapped Hist. Option: file closed. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11353
https://github.com/root-project/root/issues/11353:282,performance,Memor,Memory,282,"Can you try with a more recent ROOT version? I do not get a crash there. The problem however persists, even if linking with lNew, it raises an error:. ```. Error in <TMapFile::TMapFile>: no memory mapped file capability available. Use rootn.exe or link application against ""-lNew"". Memory mapped file: hsimple.map. Title: Memory Mapped Hist. Option: file closed. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11353
https://github.com/root-project/root/issues/11353:322,performance,Memor,Memory,322,"Can you try with a more recent ROOT version? I do not get a crash there. The problem however persists, even if linking with lNew, it raises an error:. ```. Error in <TMapFile::TMapFile>: no memory mapped file capability available. Use rootn.exe or link application against ""-lNew"". Memory mapped file: hsimple.map. Title: Memory Mapped Hist. Option: file closed. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11353
https://github.com/root-project/root/issues/11353:220,reliability,availab,available,220,"Can you try with a more recent ROOT version? I do not get a crash there. The problem however persists, even if linking with lNew, it raises an error:. ```. Error in <TMapFile::TMapFile>: no memory mapped file capability available. Use rootn.exe or link application against ""-lNew"". Memory mapped file: hsimple.map. Title: Memory Mapped Hist. Option: file closed. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11353
https://github.com/root-project/root/issues/11353:143,safety,error,error,143,"Can you try with a more recent ROOT version? I do not get a crash there. The problem however persists, even if linking with lNew, it raises an error:. ```. Error in <TMapFile::TMapFile>: no memory mapped file capability available. Use rootn.exe or link application against ""-lNew"". Memory mapped file: hsimple.map. Title: Memory Mapped Hist. Option: file closed. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11353
https://github.com/root-project/root/issues/11353:156,safety,Error,Error,156,"Can you try with a more recent ROOT version? I do not get a crash there. The problem however persists, even if linking with lNew, it raises an error:. ```. Error in <TMapFile::TMapFile>: no memory mapped file capability available. Use rootn.exe or link application against ""-lNew"". Memory mapped file: hsimple.map. Title: Memory Mapped Hist. Option: file closed. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11353
https://github.com/root-project/root/issues/11353:220,safety,avail,available,220,"Can you try with a more recent ROOT version? I do not get a crash there. The problem however persists, even if linking with lNew, it raises an error:. ```. Error in <TMapFile::TMapFile>: no memory mapped file capability available. Use rootn.exe or link application against ""-lNew"". Memory mapped file: hsimple.map. Title: Memory Mapped Hist. Option: file closed. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11353
https://github.com/root-project/root/issues/11353:220,security,availab,available,220,"Can you try with a more recent ROOT version? I do not get a crash there. The problem however persists, even if linking with lNew, it raises an error:. ```. Error in <TMapFile::TMapFile>: no memory mapped file capability available. Use rootn.exe or link application against ""-lNew"". Memory mapped file: hsimple.map. Title: Memory Mapped Hist. Option: file closed. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11353
https://github.com/root-project/root/issues/11353:143,usability,error,error,143,"Can you try with a more recent ROOT version? I do not get a crash there. The problem however persists, even if linking with lNew, it raises an error:. ```. Error in <TMapFile::TMapFile>: no memory mapped file capability available. Use rootn.exe or link application against ""-lNew"". Memory mapped file: hsimple.map. Title: Memory Mapped Hist. Option: file closed. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11353
https://github.com/root-project/root/issues/11353:156,usability,Error,Error,156,"Can you try with a more recent ROOT version? I do not get a crash there. The problem however persists, even if linking with lNew, it raises an error:. ```. Error in <TMapFile::TMapFile>: no memory mapped file capability available. Use rootn.exe or link application against ""-lNew"". Memory mapped file: hsimple.map. Title: Memory Mapped Hist. Option: file closed. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11353
https://github.com/root-project/root/issues/11353:190,usability,memor,memory,190,"Can you try with a more recent ROOT version? I do not get a crash there. The problem however persists, even if linking with lNew, it raises an error:. ```. Error in <TMapFile::TMapFile>: no memory mapped file capability available. Use rootn.exe or link application against ""-lNew"". Memory mapped file: hsimple.map. Title: Memory Mapped Hist. Option: file closed. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11353
https://github.com/root-project/root/issues/11353:282,usability,Memor,Memory,282,"Can you try with a more recent ROOT version? I do not get a crash there. The problem however persists, even if linking with lNew, it raises an error:. ```. Error in <TMapFile::TMapFile>: no memory mapped file capability available. Use rootn.exe or link application against ""-lNew"". Memory mapped file: hsimple.map. Title: Memory Mapped Hist. Option: file closed. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11353
https://github.com/root-project/root/issues/11353:322,usability,Memor,Memory,322,"Can you try with a more recent ROOT version? I do not get a crash there. The problem however persists, even if linking with lNew, it raises an error:. ```. Error in <TMapFile::TMapFile>: no memory mapped file capability available. Use rootn.exe or link application against ""-lNew"". Memory mapped file: hsimple.map. Title: Memory Mapped Hist. Option: file closed. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11353
https://github.com/root-project/root/issues/11353:355,usability,close,closed,355,"Can you try with a more recent ROOT version? I do not get a crash there. The problem however persists, even if linking with lNew, it raises an error:. ```. Error in <TMapFile::TMapFile>: no memory mapped file capability available. Use rootn.exe or link application against ""-lNew"". Memory mapped file: hsimple.map. Title: Memory Mapped Hist. Option: file closed. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11353
https://github.com/root-project/root/pull/11355:5,availability,failur,failures,5,"Test failures are unrelated, merging.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11355
https://github.com/root-project/root/pull/11355:5,deployability,fail,failures,5,"Test failures are unrelated, merging.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11355
https://github.com/root-project/root/pull/11355:5,performance,failur,failures,5,"Test failures are unrelated, merging.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11355
https://github.com/root-project/root/pull/11355:5,reliability,fail,failures,5,"Test failures are unrelated, merging.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11355
https://github.com/root-project/root/pull/11355:0,safety,Test,Test,0,"Test failures are unrelated, merging.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11355
https://github.com/root-project/root/pull/11355:0,testability,Test,Test,0,"Test failures are unrelated, merging.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11355
https://github.com/root-project/root/pull/11357:206,deployability,updat,update,206,"@etejedor Sir, . Can you kindly review this PR. Also, there seems to be an issue with the TGraph constructor pythoniztion and the GetAsNumpy methods. Please post any changes or additions I can make. I will update the PR soon accordingly based on your inputs and suggestions. Thank you. Here's a [link](https://gist.github.com/lmoneta/31912af47c65bb7549bdc7c765e75c02) to the github gist for your reference.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:32,safety,review,review,32,"@etejedor Sir, . Can you kindly review this PR. Also, there seems to be an issue with the TGraph constructor pythoniztion and the GetAsNumpy methods. Please post any changes or additions I can make. I will update the PR soon accordingly based on your inputs and suggestions. Thank you. Here's a [link](https://gist.github.com/lmoneta/31912af47c65bb7549bdc7c765e75c02) to the github gist for your reference.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:206,safety,updat,update,206,"@etejedor Sir, . Can you kindly review this PR. Also, there seems to be an issue with the TGraph constructor pythoniztion and the GetAsNumpy methods. Please post any changes or additions I can make. I will update the PR soon accordingly based on your inputs and suggestions. Thank you. Here's a [link](https://gist.github.com/lmoneta/31912af47c65bb7549bdc7c765e75c02) to the github gist for your reference.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:251,safety,input,inputs,251,"@etejedor Sir, . Can you kindly review this PR. Also, there seems to be an issue with the TGraph constructor pythoniztion and the GetAsNumpy methods. Please post any changes or additions I can make. I will update the PR soon accordingly based on your inputs and suggestions. Thank you. Here's a [link](https://gist.github.com/lmoneta/31912af47c65bb7549bdc7c765e75c02) to the github gist for your reference.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:206,security,updat,update,206,"@etejedor Sir, . Can you kindly review this PR. Also, there seems to be an issue with the TGraph constructor pythoniztion and the GetAsNumpy methods. Please post any changes or additions I can make. I will update the PR soon accordingly based on your inputs and suggestions. Thank you. Here's a [link](https://gist.github.com/lmoneta/31912af47c65bb7549bdc7c765e75c02) to the github gist for your reference.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:32,testability,review,review,32,"@etejedor Sir, . Can you kindly review this PR. Also, there seems to be an issue with the TGraph constructor pythoniztion and the GetAsNumpy methods. Please post any changes or additions I can make. I will update the PR soon accordingly based on your inputs and suggestions. Thank you. Here's a [link](https://gist.github.com/lmoneta/31912af47c65bb7549bdc7c765e75c02) to the github gist for your reference.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:251,usability,input,inputs,251,"@etejedor Sir, . Can you kindly review this PR. Also, there seems to be an issue with the TGraph constructor pythoniztion and the GetAsNumpy methods. Please post any changes or additions I can make. I will update the PR soon accordingly based on your inputs and suggestions. Thank you. Here's a [link](https://gist.github.com/lmoneta/31912af47c65bb7549bdc7c765e75c02) to the github gist for your reference.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:86,availability,error,errors,86,"@etejedor Can you also please review the GetAsNumpy method, so that I can resolve the errors",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:86,performance,error,errors,86,"@etejedor Can you also please review the GetAsNumpy method, so that I can resolve the errors",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:30,safety,review,review,30,"@etejedor Can you also please review the GetAsNumpy method, so that I can resolve the errors",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:86,safety,error,errors,86,"@etejedor Can you also please review the GetAsNumpy method, so that I can resolve the errors",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:30,testability,review,review,30,"@etejedor Can you also please review the GetAsNumpy method, so that I can resolve the errors",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:86,usability,error,errors,86,"@etejedor Can you also please review the GetAsNumpy method, so that I can resolve the errors",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:88,availability,error,errors,88,"> @etejedor Can you also please review the GetAsNumpy method, so that I can resolve the errors. What kind of errors do you get?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:109,availability,error,errors,109,"> @etejedor Can you also please review the GetAsNumpy method, so that I can resolve the errors. What kind of errors do you get?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:88,performance,error,errors,88,"> @etejedor Can you also please review the GetAsNumpy method, so that I can resolve the errors. What kind of errors do you get?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:109,performance,error,errors,109,"> @etejedor Can you also please review the GetAsNumpy method, so that I can resolve the errors. What kind of errors do you get?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:32,safety,review,review,32,"> @etejedor Can you also please review the GetAsNumpy method, so that I can resolve the errors. What kind of errors do you get?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:88,safety,error,errors,88,"> @etejedor Can you also please review the GetAsNumpy method, so that I can resolve the errors. What kind of errors do you get?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:109,safety,error,errors,109,"> @etejedor Can you also please review the GetAsNumpy method, so that I can resolve the errors. What kind of errors do you get?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:32,testability,review,review,32,"> @etejedor Can you also please review the GetAsNumpy method, so that I can resolve the errors. What kind of errors do you get?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:88,usability,error,errors,88,"> @etejedor Can you also please review the GetAsNumpy method, so that I can resolve the errors. What kind of errors do you get?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:109,usability,error,errors,109,"> @etejedor Can you also please review the GetAsNumpy method, so that I can resolve the errors. What kind of errors do you get?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:15,availability,error,errors,15,"> What kind of errors do you get? @etejedor Thank you sir, both errors are resolved, Kindly review the PR if possible. Regards.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:64,availability,error,errors,64,"> What kind of errors do you get? @etejedor Thank you sir, both errors are resolved, Kindly review the PR if possible. Regards.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:15,performance,error,errors,15,"> What kind of errors do you get? @etejedor Thank you sir, both errors are resolved, Kindly review the PR if possible. Regards.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:64,performance,error,errors,64,"> What kind of errors do you get? @etejedor Thank you sir, both errors are resolved, Kindly review the PR if possible. Regards.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:15,safety,error,errors,15,"> What kind of errors do you get? @etejedor Thank you sir, both errors are resolved, Kindly review the PR if possible. Regards.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:64,safety,error,errors,64,"> What kind of errors do you get? @etejedor Thank you sir, both errors are resolved, Kindly review the PR if possible. Regards.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:92,safety,review,review,92,"> What kind of errors do you get? @etejedor Thank you sir, both errors are resolved, Kindly review the PR if possible. Regards.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:92,testability,review,review,92,"> What kind of errors do you get? @etejedor Thank you sir, both errors are resolved, Kindly review the PR if possible. Regards.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:15,usability,error,errors,15,"> What kind of errors do you get? @etejedor Thank you sir, both errors are resolved, Kindly review the PR if possible. Regards.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:64,usability,error,errors,64,"> What kind of errors do you get? @etejedor Thank you sir, both errors are resolved, Kindly review the PR if possible. Regards.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:35,deployability,updat,updated,35,"@lmoneta @sanjibansg @omazapa . PR updated. Kindly review, I will update the fixes/changes, if any, asap. Thanks.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:66,deployability,updat,update,66,"@lmoneta @sanjibansg @omazapa . PR updated. Kindly review, I will update the fixes/changes, if any, asap. Thanks.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:35,safety,updat,updated,35,"@lmoneta @sanjibansg @omazapa . PR updated. Kindly review, I will update the fixes/changes, if any, asap. Thanks.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:51,safety,review,review,51,"@lmoneta @sanjibansg @omazapa . PR updated. Kindly review, I will update the fixes/changes, if any, asap. Thanks.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:66,safety,updat,update,66,"@lmoneta @sanjibansg @omazapa . PR updated. Kindly review, I will update the fixes/changes, if any, asap. Thanks.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:35,security,updat,updated,35,"@lmoneta @sanjibansg @omazapa . PR updated. Kindly review, I will update the fixes/changes, if any, asap. Thanks.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:66,security,updat,update,66,"@lmoneta @sanjibansg @omazapa . PR updated. Kindly review, I will update the fixes/changes, if any, asap. Thanks.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:51,testability,review,review,51,"@lmoneta @sanjibansg @omazapa . PR updated. Kindly review, I will update the fixes/changes, if any, asap. Thanks.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:289,deployability,automat,automatically,289,"@guitargeek We have already `FillN` to fill a numpy array in an histogram. . I think is good to have a function creating and filling histogram directly from Numpy passing the array and the other c'tor arguments (number of bins, min and max), or just number of bins and compute min and max automatically.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11357:289,testability,automat,automatically,289,"@guitargeek We have already `FillN` to fill a numpy array in an histogram. . I think is good to have a function creating and filling histogram directly from Numpy passing the array and the other c'tor arguments (number of bins, min and max), or just number of bins and compute min and max automatically.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11357
https://github.com/root-project/root/pull/11358:28,safety,review,review,28,@bellenot this is ready for review.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11358
https://github.com/root-project/root/pull/11358:28,testability,review,review,28,@bellenot this is ready for review.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11358
https://github.com/root-project/root/pull/11360:52,testability,coverag,coverage,52,We don't need a ci check for this as we do not have coverage.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11360
https://github.com/root-project/root/pull/11360:153,deployability,contain,contains,153,"Should we have this in a dedicated directory, say `interpreter/cling/docs/sphinx` or `interpreter/cling/sphinx-docs`? `interpreter/cling/docs` currently contains doxygen files, release notes, and `CMakeLists.txt`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11360
https://github.com/root-project/root/pull/11360:177,deployability,releas,release,177,"Should we have this in a dedicated directory, say `interpreter/cling/docs/sphinx` or `interpreter/cling/sphinx-docs`? `interpreter/cling/docs` currently contains doxygen files, release notes, and `CMakeLists.txt`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11360
https://github.com/root-project/root/pull/11360:143,energy efficiency,current,currently,143,"Should we have this in a dedicated directory, say `interpreter/cling/docs/sphinx` or `interpreter/cling/sphinx-docs`? `interpreter/cling/docs` currently contains doxygen files, release notes, and `CMakeLists.txt`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11360
https://github.com/root-project/root/pull/11360:155,deployability,contain,contains,155,"> Should we have this in a dedicated directory, say `interpreter/cling/docs/sphinx` or `interpreter/cling/sphinx-docs`? `interpreter/cling/docs` currently contains doxygen files, release notes, and `CMakeLists.txt`. It looks like `interpreter/llvm/src/tools/clang` have the same structure. I'd rather keep it like that as we are reusing documentation settings and build rules which then we will have to tweak and maintain ourselves.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11360
https://github.com/root-project/root/pull/11360:179,deployability,releas,release,179,"> Should we have this in a dedicated directory, say `interpreter/cling/docs/sphinx` or `interpreter/cling/sphinx-docs`? `interpreter/cling/docs` currently contains doxygen files, release notes, and `CMakeLists.txt`. It looks like `interpreter/llvm/src/tools/clang` have the same structure. I'd rather keep it like that as we are reusing documentation settings and build rules which then we will have to tweak and maintain ourselves.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11360
https://github.com/root-project/root/pull/11360:364,deployability,build,build,364,"> Should we have this in a dedicated directory, say `interpreter/cling/docs/sphinx` or `interpreter/cling/sphinx-docs`? `interpreter/cling/docs` currently contains doxygen files, release notes, and `CMakeLists.txt`. It looks like `interpreter/llvm/src/tools/clang` have the same structure. I'd rather keep it like that as we are reusing documentation settings and build rules which then we will have to tweak and maintain ourselves.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11360
https://github.com/root-project/root/pull/11360:145,energy efficiency,current,currently,145,"> Should we have this in a dedicated directory, say `interpreter/cling/docs/sphinx` or `interpreter/cling/sphinx-docs`? `interpreter/cling/docs` currently contains doxygen files, release notes, and `CMakeLists.txt`. It looks like `interpreter/llvm/src/tools/clang` have the same structure. I'd rather keep it like that as we are reusing documentation settings and build rules which then we will have to tweak and maintain ourselves.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11360
https://github.com/root-project/root/pull/11360:329,modifiability,reu,reusing,329,"> Should we have this in a dedicated directory, say `interpreter/cling/docs/sphinx` or `interpreter/cling/sphinx-docs`? `interpreter/cling/docs` currently contains doxygen files, release notes, and `CMakeLists.txt`. It looks like `interpreter/llvm/src/tools/clang` have the same structure. I'd rather keep it like that as we are reusing documentation settings and build rules which then we will have to tweak and maintain ourselves.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11360
https://github.com/root-project/root/pull/11360:413,modifiability,maintain,maintain,413,"> Should we have this in a dedicated directory, say `interpreter/cling/docs/sphinx` or `interpreter/cling/sphinx-docs`? `interpreter/cling/docs` currently contains doxygen files, release notes, and `CMakeLists.txt`. It looks like `interpreter/llvm/src/tools/clang` have the same structure. I'd rather keep it like that as we are reusing documentation settings and build rules which then we will have to tweak and maintain ourselves.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11360
https://github.com/root-project/root/pull/11360:413,safety,maintain,maintain,413,"> Should we have this in a dedicated directory, say `interpreter/cling/docs/sphinx` or `interpreter/cling/sphinx-docs`? `interpreter/cling/docs` currently contains doxygen files, release notes, and `CMakeLists.txt`. It looks like `interpreter/llvm/src/tools/clang` have the same structure. I'd rather keep it like that as we are reusing documentation settings and build rules which then we will have to tweak and maintain ourselves.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11360
