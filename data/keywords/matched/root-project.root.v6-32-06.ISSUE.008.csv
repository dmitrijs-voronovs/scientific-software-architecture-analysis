id,quality_attribute,keyword,matched_word,match_idx,sentence,source,author,repo,version,wiki,url
https://github.com/root-project/root/pull/1907:0,security,Updat,Update,0,"Update builtin Davix back to version 0.6.7; This reverts commit 2ecf45e5a37ab3f1108c5a9068b3cf330242b9dd, and makes some extra adjustments for Davix 0.6.7 to build or provide a clear error if something is missing in the system.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1907
https://github.com/root-project/root/pull/1907:177,usability,clear,clear,177,"Update builtin Davix back to version 0.6.7; This reverts commit 2ecf45e5a37ab3f1108c5a9068b3cf330242b9dd, and makes some extra adjustments for Davix 0.6.7 to build or provide a clear error if something is missing in the system.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1907
https://github.com/root-project/root/pull/1907:183,usability,error,error,183,"Update builtin Davix back to version 0.6.7; This reverts commit 2ecf45e5a37ab3f1108c5a9068b3cf330242b9dd, and makes some extra adjustments for Davix 0.6.7 to build or provide a clear error if something is missing in the system.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1907
https://github.com/root-project/root/pull/1909:146,availability,state,stated,146,[PyROOT] Fix swapped return values for TTree.AsMatrix with return_labels; Swapped the return values for enabled `return_labels` (now it's done as stated in the docs).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1909
https://github.com/root-project/root/pull/1909:146,integrability,state,stated,146,[PyROOT] Fix swapped return values for TTree.AsMatrix with return_labels; Swapped the return values for enabled `return_labels` (now it's done as stated in the docs).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1909
https://github.com/root-project/root/pull/1914:91,availability,failur,failure,91,"[PyROOT] Maintain correct type for index_sequence_for on 32bit; Fixes probably (**!**) the failure here: http://cdash.cern.ch/viewTest.php?onlyfailed&buildid=494701. I've enforced `unsigned long` as type for `index_sequence_for`, which seems not to hold true on 32bit. `std::size_t` should resolve to the correct type on all systems ([Doc](http://en.cppreference.com/w/cpp/utility/integer_sequence)).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1914
https://github.com/root-project/root/pull/1914:91,deployability,fail,failure,91,"[PyROOT] Maintain correct type for index_sequence_for on 32bit; Fixes probably (**!**) the failure here: http://cdash.cern.ch/viewTest.php?onlyfailed&buildid=494701. I've enforced `unsigned long` as type for `index_sequence_for`, which seems not to hold true on 32bit. `std::size_t` should resolve to the correct type on all systems ([Doc](http://en.cppreference.com/w/cpp/utility/integer_sequence)).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1914
https://github.com/root-project/root/pull/1914:150,deployability,build,buildid,150,"[PyROOT] Maintain correct type for index_sequence_for on 32bit; Fixes probably (**!**) the failure here: http://cdash.cern.ch/viewTest.php?onlyfailed&buildid=494701. I've enforced `unsigned long` as type for `index_sequence_for`, which seems not to hold true on 32bit. `std::size_t` should resolve to the correct type on all systems ([Doc](http://en.cppreference.com/w/cpp/utility/integer_sequence)).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1914
https://github.com/root-project/root/pull/1914:9,modifiability,Maintain,Maintain,9,"[PyROOT] Maintain correct type for index_sequence_for on 32bit; Fixes probably (**!**) the failure here: http://cdash.cern.ch/viewTest.php?onlyfailed&buildid=494701. I've enforced `unsigned long` as type for `index_sequence_for`, which seems not to hold true on 32bit. `std::size_t` should resolve to the correct type on all systems ([Doc](http://en.cppreference.com/w/cpp/utility/integer_sequence)).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1914
https://github.com/root-project/root/pull/1914:91,performance,failur,failure,91,"[PyROOT] Maintain correct type for index_sequence_for on 32bit; Fixes probably (**!**) the failure here: http://cdash.cern.ch/viewTest.php?onlyfailed&buildid=494701. I've enforced `unsigned long` as type for `index_sequence_for`, which seems not to hold true on 32bit. `std::size_t` should resolve to the correct type on all systems ([Doc](http://en.cppreference.com/w/cpp/utility/integer_sequence)).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1914
https://github.com/root-project/root/pull/1914:91,reliability,fail,failure,91,"[PyROOT] Maintain correct type for index_sequence_for on 32bit; Fixes probably (**!**) the failure here: http://cdash.cern.ch/viewTest.php?onlyfailed&buildid=494701. I've enforced `unsigned long` as type for `index_sequence_for`, which seems not to hold true on 32bit. `std::size_t` should resolve to the correct type on all systems ([Doc](http://en.cppreference.com/w/cpp/utility/integer_sequence)).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1914
https://github.com/root-project/root/pull/1914:9,safety,Maintain,Maintain,9,"[PyROOT] Maintain correct type for index_sequence_for on 32bit; Fixes probably (**!**) the failure here: http://cdash.cern.ch/viewTest.php?onlyfailed&buildid=494701. I've enforced `unsigned long` as type for `index_sequence_for`, which seems not to hold true on 32bit. `std::size_t` should resolve to the correct type on all systems ([Doc](http://en.cppreference.com/w/cpp/utility/integer_sequence)).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1914
https://github.com/root-project/root/pull/1915:101,availability,error,errors,101,"Use TPadPos in TLine; The line.cxx example has been modified accordingly. But when executed it gives errors messages like:. error: no matching literal operator for call to 'operator""""_normal'",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1915
https://github.com/root-project/root/pull/1915:124,availability,error,error,124,"Use TPadPos in TLine; The line.cxx example has been modified accordingly. But when executed it gives errors messages like:. error: no matching literal operator for call to 'operator""""_normal'",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1915
https://github.com/root-project/root/pull/1915:151,availability,operat,operator,151,"Use TPadPos in TLine; The line.cxx example has been modified accordingly. But when executed it gives errors messages like:. error: no matching literal operator for call to 'operator""""_normal'",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1915
https://github.com/root-project/root/pull/1915:173,availability,operat,operator,173,"Use TPadPos in TLine; The line.cxx example has been modified accordingly. But when executed it gives errors messages like:. error: no matching literal operator for call to 'operator""""_normal'",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1915
https://github.com/root-project/root/pull/1915:108,integrability,messag,messages,108,"Use TPadPos in TLine; The line.cxx example has been modified accordingly. But when executed it gives errors messages like:. error: no matching literal operator for call to 'operator""""_normal'",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1915
https://github.com/root-project/root/pull/1915:108,interoperability,messag,messages,108,"Use TPadPos in TLine; The line.cxx example has been modified accordingly. But when executed it gives errors messages like:. error: no matching literal operator for call to 'operator""""_normal'",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1915
https://github.com/root-project/root/pull/1915:101,performance,error,errors,101,"Use TPadPos in TLine; The line.cxx example has been modified accordingly. But when executed it gives errors messages like:. error: no matching literal operator for call to 'operator""""_normal'",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1915
https://github.com/root-project/root/pull/1915:124,performance,error,error,124,"Use TPadPos in TLine; The line.cxx example has been modified accordingly. But when executed it gives errors messages like:. error: no matching literal operator for call to 'operator""""_normal'",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1915
https://github.com/root-project/root/pull/1915:101,safety,error,errors,101,"Use TPadPos in TLine; The line.cxx example has been modified accordingly. But when executed it gives errors messages like:. error: no matching literal operator for call to 'operator""""_normal'",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1915
https://github.com/root-project/root/pull/1915:124,safety,error,error,124,"Use TPadPos in TLine; The line.cxx example has been modified accordingly. But when executed it gives errors messages like:. error: no matching literal operator for call to 'operator""""_normal'",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1915
https://github.com/root-project/root/pull/1915:52,security,modif,modified,52,"Use TPadPos in TLine; The line.cxx example has been modified accordingly. But when executed it gives errors messages like:. error: no matching literal operator for call to 'operator""""_normal'",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1915
https://github.com/root-project/root/pull/1915:101,usability,error,errors,101,"Use TPadPos in TLine; The line.cxx example has been modified accordingly. But when executed it gives errors messages like:. error: no matching literal operator for call to 'operator""""_normal'",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1915
https://github.com/root-project/root/pull/1915:124,usability,error,error,124,"Use TPadPos in TLine; The line.cxx example has been modified accordingly. But when executed it gives errors messages like:. error: no matching literal operator for call to 'operator""""_normal'",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1915
https://github.com/root-project/root/pull/1916:331,deployability,observ,observables,331,"critical bugfix in RooFit to avoid last bin getting lost in histogram; We have recently discovered a critical bug in RooFit which (under some arcane circumstances) causes the last bin to go missing from a `RooHistFunc`. Notably, the occurence of this effect is a rounding issue that only happens for some values of upper bounds of observables. . I have attached a python test case that showcases the problem. The assertion in the last line will fail in the current master of ROOT, but will succeed using the bugfix in this MR. import ROOT. from math import pi. . xmin = -25.2. xmax = 6.3. nbins = 35. hfname = ""hists.root"". . histfile = ROOT.TFile.Open(hfname,""RECREATE""). . signalSR = ROOT.TH1F(""signalSR"",""signal"",nbins,xmin,xmax). signalSR.FillRandom(""gaus""). . backgroundSR = ROOT.TH1F(""backgroundSR"",""background"",nbins,xmin,xmax). backgroundSR.FillRandom(""pol0""). . signalCR = ROOT.TH1F(""signalCR"",""signal"",nbins,xmin,xmax). signalCR.FillRandom(""pol0""). . backgroundCR = ROOT.TH1F(""backgroundCR"",""background"",nbins,xmin,xmax). backgroundCR.FillRandom(""pol0""). . histfile.Write(). histfile.Close(). . sigSR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalSR""). sigSR.AddNormFactor(""mu"",1.,0.,10.,False). bkgSR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundSR""). bkgSR.AddNormFactor(""norm"",1.,0.,10.,False). . sr = ROOT.RooStats.HistFactory.Channel(""SR""). sr.AddSample(sigSR). sr.AddSample(bkgSR). . sigCR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalCR""). sigCR.AddNormFactor(""mu"",1.,0.,10.,False). bkgCR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundCR""). bkgCR.AddNormFactor(""norm"",1.,0.,10.,False). . cr = ROOT.RooStats.HistFactory.Channel(""CR""). cr.AddSample(sigCR). cr.AddSample(bkgCR). . . meas = ROOT.RooStats.HistFactory.Measurement(""meas""). meas.AddChannel(sr). meas.AddChannel(cr). . meas.CollectHistograms(). ws = ROOT.RooStats.HistFactory.HistoToWorkspaceFactoryFast.MakeCombinedModel(meas). pdf = ws.pdf(""mod",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:445,deployability,fail,fail,445,"critical bugfix in RooFit to avoid last bin getting lost in histogram; We have recently discovered a critical bug in RooFit which (under some arcane circumstances) causes the last bin to go missing from a `RooHistFunc`. Notably, the occurence of this effect is a rounding issue that only happens for some values of upper bounds of observables. . I have attached a python test case that showcases the problem. The assertion in the last line will fail in the current master of ROOT, but will succeed using the bugfix in this MR. import ROOT. from math import pi. . xmin = -25.2. xmax = 6.3. nbins = 35. hfname = ""hists.root"". . histfile = ROOT.TFile.Open(hfname,""RECREATE""). . signalSR = ROOT.TH1F(""signalSR"",""signal"",nbins,xmin,xmax). signalSR.FillRandom(""gaus""). . backgroundSR = ROOT.TH1F(""backgroundSR"",""background"",nbins,xmin,xmax). backgroundSR.FillRandom(""pol0""). . signalCR = ROOT.TH1F(""signalCR"",""signal"",nbins,xmin,xmax). signalCR.FillRandom(""pol0""). . backgroundCR = ROOT.TH1F(""backgroundCR"",""background"",nbins,xmin,xmax). backgroundCR.FillRandom(""pol0""). . histfile.Write(). histfile.Close(). . sigSR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalSR""). sigSR.AddNormFactor(""mu"",1.,0.,10.,False). bkgSR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundSR""). bkgSR.AddNormFactor(""norm"",1.,0.,10.,False). . sr = ROOT.RooStats.HistFactory.Channel(""SR""). sr.AddSample(sigSR). sr.AddSample(bkgSR). . sigCR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalCR""). sigCR.AddNormFactor(""mu"",1.,0.,10.,False). bkgCR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundCR""). bkgCR.AddNormFactor(""norm"",1.,0.,10.,False). . cr = ROOT.RooStats.HistFactory.Channel(""CR""). cr.AddSample(sigCR). cr.AddSample(bkgCR). . . meas = ROOT.RooStats.HistFactory.Measurement(""meas""). meas.AddChannel(sr). meas.AddChannel(cr). . meas.CollectHistograms(). ws = ROOT.RooStats.HistFactory.HistoToWorkspaceFactoryFast.MakeCombinedModel(meas). pdf = ws.pdf(""mod",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:457,energy efficiency,current,current,457,"critical bugfix in RooFit to avoid last bin getting lost in histogram; We have recently discovered a critical bug in RooFit which (under some arcane circumstances) causes the last bin to go missing from a `RooHistFunc`. Notably, the occurence of this effect is a rounding issue that only happens for some values of upper bounds of observables. . I have attached a python test case that showcases the problem. The assertion in the last line will fail in the current master of ROOT, but will succeed using the bugfix in this MR. import ROOT. from math import pi. . xmin = -25.2. xmax = 6.3. nbins = 35. hfname = ""hists.root"". . histfile = ROOT.TFile.Open(hfname,""RECREATE""). . signalSR = ROOT.TH1F(""signalSR"",""signal"",nbins,xmin,xmax). signalSR.FillRandom(""gaus""). . backgroundSR = ROOT.TH1F(""backgroundSR"",""background"",nbins,xmin,xmax). backgroundSR.FillRandom(""pol0""). . signalCR = ROOT.TH1F(""signalCR"",""signal"",nbins,xmin,xmax). signalCR.FillRandom(""pol0""). . backgroundCR = ROOT.TH1F(""backgroundCR"",""background"",nbins,xmin,xmax). backgroundCR.FillRandom(""pol0""). . histfile.Write(). histfile.Close(). . sigSR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalSR""). sigSR.AddNormFactor(""mu"",1.,0.,10.,False). bkgSR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundSR""). bkgSR.AddNormFactor(""norm"",1.,0.,10.,False). . sr = ROOT.RooStats.HistFactory.Channel(""SR""). sr.AddSample(sigSR). sr.AddSample(bkgSR). . sigCR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalCR""). sigCR.AddNormFactor(""mu"",1.,0.,10.,False). bkgCR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundCR""). bkgCR.AddNormFactor(""norm"",1.,0.,10.,False). . cr = ROOT.RooStats.HistFactory.Channel(""CR""). cr.AddSample(sigCR). cr.AddSample(bkgCR). . . meas = ROOT.RooStats.HistFactory.Measurement(""meas""). meas.AddChannel(sr). meas.AddChannel(cr). . meas.CollectHistograms(). ws = ROOT.RooStats.HistFactory.HistoToWorkspaceFactoryFast.MakeCombinedModel(meas). pdf = ws.pdf(""mod",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:1808,energy efficiency,Measur,Measurement,1808,"e arcane circumstances) causes the last bin to go missing from a `RooHistFunc`. Notably, the occurence of this effect is a rounding issue that only happens for some values of upper bounds of observables. . I have attached a python test case that showcases the problem. The assertion in the last line will fail in the current master of ROOT, but will succeed using the bugfix in this MR. import ROOT. from math import pi. . xmin = -25.2. xmax = 6.3. nbins = 35. hfname = ""hists.root"". . histfile = ROOT.TFile.Open(hfname,""RECREATE""). . signalSR = ROOT.TH1F(""signalSR"",""signal"",nbins,xmin,xmax). signalSR.FillRandom(""gaus""). . backgroundSR = ROOT.TH1F(""backgroundSR"",""background"",nbins,xmin,xmax). backgroundSR.FillRandom(""pol0""). . signalCR = ROOT.TH1F(""signalCR"",""signal"",nbins,xmin,xmax). signalCR.FillRandom(""pol0""). . backgroundCR = ROOT.TH1F(""backgroundCR"",""background"",nbins,xmin,xmax). backgroundCR.FillRandom(""pol0""). . histfile.Write(). histfile.Close(). . sigSR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalSR""). sigSR.AddNormFactor(""mu"",1.,0.,10.,False). bkgSR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundSR""). bkgSR.AddNormFactor(""norm"",1.,0.,10.,False). . sr = ROOT.RooStats.HistFactory.Channel(""SR""). sr.AddSample(sigSR). sr.AddSample(bkgSR). . sigCR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalCR""). sigCR.AddNormFactor(""mu"",1.,0.,10.,False). bkgCR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundCR""). bkgCR.AddNormFactor(""norm"",1.,0.,10.,False). . cr = ROOT.RooStats.HistFactory.Channel(""CR""). cr.AddSample(sigCR). cr.AddSample(bkgCR). . . meas = ROOT.RooStats.HistFactory.Measurement(""meas""). meas.AddChannel(sr). meas.AddChannel(cr). . meas.CollectHistograms(). ws = ROOT.RooStats.HistFactory.HistoToWorkspaceFactoryFast.MakeCombinedModel(meas). pdf = ws.pdf(""model_SR""). obs = ws.var(""obs_x_SR""). hist = pdf.createHistogram(""hist"",obs,ROOT.RooFit.IntrinsicBinning(1)). assert(hist.GetNbinsX() == nbins)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:88,integrability,discover,discovered,88,"critical bugfix in RooFit to avoid last bin getting lost in histogram; We have recently discovered a critical bug in RooFit which (under some arcane circumstances) causes the last bin to go missing from a `RooHistFunc`. Notably, the occurence of this effect is a rounding issue that only happens for some values of upper bounds of observables. . I have attached a python test case that showcases the problem. The assertion in the last line will fail in the current master of ROOT, but will succeed using the bugfix in this MR. import ROOT. from math import pi. . xmin = -25.2. xmax = 6.3. nbins = 35. hfname = ""hists.root"". . histfile = ROOT.TFile.Open(hfname,""RECREATE""). . signalSR = ROOT.TH1F(""signalSR"",""signal"",nbins,xmin,xmax). signalSR.FillRandom(""gaus""). . backgroundSR = ROOT.TH1F(""backgroundSR"",""background"",nbins,xmin,xmax). backgroundSR.FillRandom(""pol0""). . signalCR = ROOT.TH1F(""signalCR"",""signal"",nbins,xmin,xmax). signalCR.FillRandom(""pol0""). . backgroundCR = ROOT.TH1F(""backgroundCR"",""background"",nbins,xmin,xmax). backgroundCR.FillRandom(""pol0""). . histfile.Write(). histfile.Close(). . sigSR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalSR""). sigSR.AddNormFactor(""mu"",1.,0.,10.,False). bkgSR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundSR""). bkgSR.AddNormFactor(""norm"",1.,0.,10.,False). . sr = ROOT.RooStats.HistFactory.Channel(""SR""). sr.AddSample(sigSR). sr.AddSample(bkgSR). . sigCR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalCR""). sigCR.AddNormFactor(""mu"",1.,0.,10.,False). bkgCR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundCR""). bkgCR.AddNormFactor(""norm"",1.,0.,10.,False). . cr = ROOT.RooStats.HistFactory.Channel(""CR""). cr.AddSample(sigCR). cr.AddSample(bkgCR). . . meas = ROOT.RooStats.HistFactory.Measurement(""meas""). meas.AddChannel(sr). meas.AddChannel(cr). . meas.CollectHistograms(). ws = ROOT.RooStats.HistFactory.HistoToWorkspaceFactoryFast.MakeCombinedModel(meas). pdf = ws.pdf(""mod",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:88,interoperability,discover,discovered,88,"critical bugfix in RooFit to avoid last bin getting lost in histogram; We have recently discovered a critical bug in RooFit which (under some arcane circumstances) causes the last bin to go missing from a `RooHistFunc`. Notably, the occurence of this effect is a rounding issue that only happens for some values of upper bounds of observables. . I have attached a python test case that showcases the problem. The assertion in the last line will fail in the current master of ROOT, but will succeed using the bugfix in this MR. import ROOT. from math import pi. . xmin = -25.2. xmax = 6.3. nbins = 35. hfname = ""hists.root"". . histfile = ROOT.TFile.Open(hfname,""RECREATE""). . signalSR = ROOT.TH1F(""signalSR"",""signal"",nbins,xmin,xmax). signalSR.FillRandom(""gaus""). . backgroundSR = ROOT.TH1F(""backgroundSR"",""background"",nbins,xmin,xmax). backgroundSR.FillRandom(""pol0""). . signalCR = ROOT.TH1F(""signalCR"",""signal"",nbins,xmin,xmax). signalCR.FillRandom(""pol0""). . backgroundCR = ROOT.TH1F(""backgroundCR"",""background"",nbins,xmin,xmax). backgroundCR.FillRandom(""pol0""). . histfile.Write(). histfile.Close(). . sigSR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalSR""). sigSR.AddNormFactor(""mu"",1.,0.,10.,False). bkgSR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundSR""). bkgSR.AddNormFactor(""norm"",1.,0.,10.,False). . sr = ROOT.RooStats.HistFactory.Channel(""SR""). sr.AddSample(sigSR). sr.AddSample(bkgSR). . sigCR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalCR""). sigCR.AddNormFactor(""mu"",1.,0.,10.,False). bkgCR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundCR""). bkgCR.AddNormFactor(""norm"",1.,0.,10.,False). . cr = ROOT.RooStats.HistFactory.Channel(""CR""). cr.AddSample(sigCR). cr.AddSample(bkgCR). . . meas = ROOT.RooStats.HistFactory.Measurement(""meas""). meas.AddChannel(sr). meas.AddChannel(cr). . meas.CollectHistograms(). ws = ROOT.RooStats.HistFactory.HistoToWorkspaceFactoryFast.MakeCombinedModel(meas). pdf = ws.pdf(""mod",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:445,reliability,fail,fail,445,"critical bugfix in RooFit to avoid last bin getting lost in histogram; We have recently discovered a critical bug in RooFit which (under some arcane circumstances) causes the last bin to go missing from a `RooHistFunc`. Notably, the occurence of this effect is a rounding issue that only happens for some values of upper bounds of observables. . I have attached a python test case that showcases the problem. The assertion in the last line will fail in the current master of ROOT, but will succeed using the bugfix in this MR. import ROOT. from math import pi. . xmin = -25.2. xmax = 6.3. nbins = 35. hfname = ""hists.root"". . histfile = ROOT.TFile.Open(hfname,""RECREATE""). . signalSR = ROOT.TH1F(""signalSR"",""signal"",nbins,xmin,xmax). signalSR.FillRandom(""gaus""). . backgroundSR = ROOT.TH1F(""backgroundSR"",""background"",nbins,xmin,xmax). backgroundSR.FillRandom(""pol0""). . signalCR = ROOT.TH1F(""signalCR"",""signal"",nbins,xmin,xmax). signalCR.FillRandom(""pol0""). . backgroundCR = ROOT.TH1F(""backgroundCR"",""background"",nbins,xmin,xmax). backgroundCR.FillRandom(""pol0""). . histfile.Write(). histfile.Close(). . sigSR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalSR""). sigSR.AddNormFactor(""mu"",1.,0.,10.,False). bkgSR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundSR""). bkgSR.AddNormFactor(""norm"",1.,0.,10.,False). . sr = ROOT.RooStats.HistFactory.Channel(""SR""). sr.AddSample(sigSR). sr.AddSample(bkgSR). . sigCR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalCR""). sigCR.AddNormFactor(""mu"",1.,0.,10.,False). bkgCR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundCR""). bkgCR.AddNormFactor(""norm"",1.,0.,10.,False). . cr = ROOT.RooStats.HistFactory.Channel(""CR""). cr.AddSample(sigCR). cr.AddSample(bkgCR). . . meas = ROOT.RooStats.HistFactory.Measurement(""meas""). meas.AddChannel(sr). meas.AddChannel(cr). . meas.CollectHistograms(). ws = ROOT.RooStats.HistFactory.HistoToWorkspaceFactoryFast.MakeCombinedModel(meas). pdf = ws.pdf(""mod",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:29,safety,avoid,avoid,29,"critical bugfix in RooFit to avoid last bin getting lost in histogram; We have recently discovered a critical bug in RooFit which (under some arcane circumstances) causes the last bin to go missing from a `RooHistFunc`. Notably, the occurence of this effect is a rounding issue that only happens for some values of upper bounds of observables. . I have attached a python test case that showcases the problem. The assertion in the last line will fail in the current master of ROOT, but will succeed using the bugfix in this MR. import ROOT. from math import pi. . xmin = -25.2. xmax = 6.3. nbins = 35. hfname = ""hists.root"". . histfile = ROOT.TFile.Open(hfname,""RECREATE""). . signalSR = ROOT.TH1F(""signalSR"",""signal"",nbins,xmin,xmax). signalSR.FillRandom(""gaus""). . backgroundSR = ROOT.TH1F(""backgroundSR"",""background"",nbins,xmin,xmax). backgroundSR.FillRandom(""pol0""). . signalCR = ROOT.TH1F(""signalCR"",""signal"",nbins,xmin,xmax). signalCR.FillRandom(""pol0""). . backgroundCR = ROOT.TH1F(""backgroundCR"",""background"",nbins,xmin,xmax). backgroundCR.FillRandom(""pol0""). . histfile.Write(). histfile.Close(). . sigSR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalSR""). sigSR.AddNormFactor(""mu"",1.,0.,10.,False). bkgSR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundSR""). bkgSR.AddNormFactor(""norm"",1.,0.,10.,False). . sr = ROOT.RooStats.HistFactory.Channel(""SR""). sr.AddSample(sigSR). sr.AddSample(bkgSR). . sigCR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalCR""). sigCR.AddNormFactor(""mu"",1.,0.,10.,False). bkgCR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundCR""). bkgCR.AddNormFactor(""norm"",1.,0.,10.,False). . cr = ROOT.RooStats.HistFactory.Channel(""CR""). cr.AddSample(sigCR). cr.AddSample(bkgCR). . . meas = ROOT.RooStats.HistFactory.Measurement(""meas""). meas.AddChannel(sr). meas.AddChannel(cr). . meas.CollectHistograms(). ws = ROOT.RooStats.HistFactory.HistoToWorkspaceFactoryFast.MakeCombinedModel(meas). pdf = ws.pdf(""mod",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:371,safety,test,test,371,"critical bugfix in RooFit to avoid last bin getting lost in histogram; We have recently discovered a critical bug in RooFit which (under some arcane circumstances) causes the last bin to go missing from a `RooHistFunc`. Notably, the occurence of this effect is a rounding issue that only happens for some values of upper bounds of observables. . I have attached a python test case that showcases the problem. The assertion in the last line will fail in the current master of ROOT, but will succeed using the bugfix in this MR. import ROOT. from math import pi. . xmin = -25.2. xmax = 6.3. nbins = 35. hfname = ""hists.root"". . histfile = ROOT.TFile.Open(hfname,""RECREATE""). . signalSR = ROOT.TH1F(""signalSR"",""signal"",nbins,xmin,xmax). signalSR.FillRandom(""gaus""). . backgroundSR = ROOT.TH1F(""backgroundSR"",""background"",nbins,xmin,xmax). backgroundSR.FillRandom(""pol0""). . signalCR = ROOT.TH1F(""signalCR"",""signal"",nbins,xmin,xmax). signalCR.FillRandom(""pol0""). . backgroundCR = ROOT.TH1F(""backgroundCR"",""background"",nbins,xmin,xmax). backgroundCR.FillRandom(""pol0""). . histfile.Write(). histfile.Close(). . sigSR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalSR""). sigSR.AddNormFactor(""mu"",1.,0.,10.,False). bkgSR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundSR""). bkgSR.AddNormFactor(""norm"",1.,0.,10.,False). . sr = ROOT.RooStats.HistFactory.Channel(""SR""). sr.AddSample(sigSR). sr.AddSample(bkgSR). . sigCR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalCR""). sigCR.AddNormFactor(""mu"",1.,0.,10.,False). bkgCR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundCR""). bkgCR.AddNormFactor(""norm"",1.,0.,10.,False). . cr = ROOT.RooStats.HistFactory.Channel(""CR""). cr.AddSample(sigCR). cr.AddSample(bkgCR). . . meas = ROOT.RooStats.HistFactory.Measurement(""meas""). meas.AddChannel(sr). meas.AddChannel(cr). . meas.CollectHistograms(). ws = ROOT.RooStats.HistFactory.HistoToWorkspaceFactoryFast.MakeCombinedModel(meas). pdf = ws.pdf(""mod",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:675,security,sign,signalSR,675,"critical bugfix in RooFit to avoid last bin getting lost in histogram; We have recently discovered a critical bug in RooFit which (under some arcane circumstances) causes the last bin to go missing from a `RooHistFunc`. Notably, the occurence of this effect is a rounding issue that only happens for some values of upper bounds of observables. . I have attached a python test case that showcases the problem. The assertion in the last line will fail in the current master of ROOT, but will succeed using the bugfix in this MR. import ROOT. from math import pi. . xmin = -25.2. xmax = 6.3. nbins = 35. hfname = ""hists.root"". . histfile = ROOT.TFile.Open(hfname,""RECREATE""). . signalSR = ROOT.TH1F(""signalSR"",""signal"",nbins,xmin,xmax). signalSR.FillRandom(""gaus""). . backgroundSR = ROOT.TH1F(""backgroundSR"",""background"",nbins,xmin,xmax). backgroundSR.FillRandom(""pol0""). . signalCR = ROOT.TH1F(""signalCR"",""signal"",nbins,xmin,xmax). signalCR.FillRandom(""pol0""). . backgroundCR = ROOT.TH1F(""backgroundCR"",""background"",nbins,xmin,xmax). backgroundCR.FillRandom(""pol0""). . histfile.Write(). histfile.Close(). . sigSR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalSR""). sigSR.AddNormFactor(""mu"",1.,0.,10.,False). bkgSR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundSR""). bkgSR.AddNormFactor(""norm"",1.,0.,10.,False). . sr = ROOT.RooStats.HistFactory.Channel(""SR""). sr.AddSample(sigSR). sr.AddSample(bkgSR). . sigCR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalCR""). sigCR.AddNormFactor(""mu"",1.,0.,10.,False). bkgCR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundCR""). bkgCR.AddNormFactor(""norm"",1.,0.,10.,False). . cr = ROOT.RooStats.HistFactory.Channel(""CR""). cr.AddSample(sigCR). cr.AddSample(bkgCR). . . meas = ROOT.RooStats.HistFactory.Measurement(""meas""). meas.AddChannel(sr). meas.AddChannel(cr). . meas.CollectHistograms(). ws = ROOT.RooStats.HistFactory.HistoToWorkspaceFactoryFast.MakeCombinedModel(meas). pdf = ws.pdf(""mod",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:697,security,sign,signalSR,697,"critical bugfix in RooFit to avoid last bin getting lost in histogram; We have recently discovered a critical bug in RooFit which (under some arcane circumstances) causes the last bin to go missing from a `RooHistFunc`. Notably, the occurence of this effect is a rounding issue that only happens for some values of upper bounds of observables. . I have attached a python test case that showcases the problem. The assertion in the last line will fail in the current master of ROOT, but will succeed using the bugfix in this MR. import ROOT. from math import pi. . xmin = -25.2. xmax = 6.3. nbins = 35. hfname = ""hists.root"". . histfile = ROOT.TFile.Open(hfname,""RECREATE""). . signalSR = ROOT.TH1F(""signalSR"",""signal"",nbins,xmin,xmax). signalSR.FillRandom(""gaus""). . backgroundSR = ROOT.TH1F(""backgroundSR"",""background"",nbins,xmin,xmax). backgroundSR.FillRandom(""pol0""). . signalCR = ROOT.TH1F(""signalCR"",""signal"",nbins,xmin,xmax). signalCR.FillRandom(""pol0""). . backgroundCR = ROOT.TH1F(""backgroundCR"",""background"",nbins,xmin,xmax). backgroundCR.FillRandom(""pol0""). . histfile.Write(). histfile.Close(). . sigSR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalSR""). sigSR.AddNormFactor(""mu"",1.,0.,10.,False). bkgSR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundSR""). bkgSR.AddNormFactor(""norm"",1.,0.,10.,False). . sr = ROOT.RooStats.HistFactory.Channel(""SR""). sr.AddSample(sigSR). sr.AddSample(bkgSR). . sigCR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalCR""). sigCR.AddNormFactor(""mu"",1.,0.,10.,False). bkgCR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundCR""). bkgCR.AddNormFactor(""norm"",1.,0.,10.,False). . cr = ROOT.RooStats.HistFactory.Channel(""CR""). cr.AddSample(sigCR). cr.AddSample(bkgCR). . . meas = ROOT.RooStats.HistFactory.Measurement(""meas""). meas.AddChannel(sr). meas.AddChannel(cr). . meas.CollectHistograms(). ws = ROOT.RooStats.HistFactory.HistoToWorkspaceFactoryFast.MakeCombinedModel(meas). pdf = ws.pdf(""mod",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:708,security,sign,signal,708,"critical bugfix in RooFit to avoid last bin getting lost in histogram; We have recently discovered a critical bug in RooFit which (under some arcane circumstances) causes the last bin to go missing from a `RooHistFunc`. Notably, the occurence of this effect is a rounding issue that only happens for some values of upper bounds of observables. . I have attached a python test case that showcases the problem. The assertion in the last line will fail in the current master of ROOT, but will succeed using the bugfix in this MR. import ROOT. from math import pi. . xmin = -25.2. xmax = 6.3. nbins = 35. hfname = ""hists.root"". . histfile = ROOT.TFile.Open(hfname,""RECREATE""). . signalSR = ROOT.TH1F(""signalSR"",""signal"",nbins,xmin,xmax). signalSR.FillRandom(""gaus""). . backgroundSR = ROOT.TH1F(""backgroundSR"",""background"",nbins,xmin,xmax). backgroundSR.FillRandom(""pol0""). . signalCR = ROOT.TH1F(""signalCR"",""signal"",nbins,xmin,xmax). signalCR.FillRandom(""pol0""). . backgroundCR = ROOT.TH1F(""backgroundCR"",""background"",nbins,xmin,xmax). backgroundCR.FillRandom(""pol0""). . histfile.Write(). histfile.Close(). . sigSR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalSR""). sigSR.AddNormFactor(""mu"",1.,0.,10.,False). bkgSR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundSR""). bkgSR.AddNormFactor(""norm"",1.,0.,10.,False). . sr = ROOT.RooStats.HistFactory.Channel(""SR""). sr.AddSample(sigSR). sr.AddSample(bkgSR). . sigCR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalCR""). sigCR.AddNormFactor(""mu"",1.,0.,10.,False). bkgCR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundCR""). bkgCR.AddNormFactor(""norm"",1.,0.,10.,False). . cr = ROOT.RooStats.HistFactory.Channel(""CR""). cr.AddSample(sigCR). cr.AddSample(bkgCR). . . meas = ROOT.RooStats.HistFactory.Measurement(""meas""). meas.AddChannel(sr). meas.AddChannel(cr). . meas.CollectHistograms(). ws = ROOT.RooStats.HistFactory.HistoToWorkspaceFactoryFast.MakeCombinedModel(meas). pdf = ws.pdf(""mod",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:734,security,sign,signalSR,734,"critical bugfix in RooFit to avoid last bin getting lost in histogram; We have recently discovered a critical bug in RooFit which (under some arcane circumstances) causes the last bin to go missing from a `RooHistFunc`. Notably, the occurence of this effect is a rounding issue that only happens for some values of upper bounds of observables. . I have attached a python test case that showcases the problem. The assertion in the last line will fail in the current master of ROOT, but will succeed using the bugfix in this MR. import ROOT. from math import pi. . xmin = -25.2. xmax = 6.3. nbins = 35. hfname = ""hists.root"". . histfile = ROOT.TFile.Open(hfname,""RECREATE""). . signalSR = ROOT.TH1F(""signalSR"",""signal"",nbins,xmin,xmax). signalSR.FillRandom(""gaus""). . backgroundSR = ROOT.TH1F(""backgroundSR"",""background"",nbins,xmin,xmax). backgroundSR.FillRandom(""pol0""). . signalCR = ROOT.TH1F(""signalCR"",""signal"",nbins,xmin,xmax). signalCR.FillRandom(""pol0""). . backgroundCR = ROOT.TH1F(""backgroundCR"",""background"",nbins,xmin,xmax). backgroundCR.FillRandom(""pol0""). . histfile.Write(). histfile.Close(). . sigSR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalSR""). sigSR.AddNormFactor(""mu"",1.,0.,10.,False). bkgSR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundSR""). bkgSR.AddNormFactor(""norm"",1.,0.,10.,False). . sr = ROOT.RooStats.HistFactory.Channel(""SR""). sr.AddSample(sigSR). sr.AddSample(bkgSR). . sigCR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalCR""). sigCR.AddNormFactor(""mu"",1.,0.,10.,False). bkgCR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundCR""). bkgCR.AddNormFactor(""norm"",1.,0.,10.,False). . cr = ROOT.RooStats.HistFactory.Channel(""CR""). cr.AddSample(sigCR). cr.AddSample(bkgCR). . . meas = ROOT.RooStats.HistFactory.Measurement(""meas""). meas.AddChannel(sr). meas.AddChannel(cr). . meas.CollectHistograms(). ws = ROOT.RooStats.HistFactory.HistoToWorkspaceFactoryFast.MakeCombinedModel(meas). pdf = ws.pdf(""mod",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:871,security,sign,signalCR,871,"critical bugfix in RooFit to avoid last bin getting lost in histogram; We have recently discovered a critical bug in RooFit which (under some arcane circumstances) causes the last bin to go missing from a `RooHistFunc`. Notably, the occurence of this effect is a rounding issue that only happens for some values of upper bounds of observables. . I have attached a python test case that showcases the problem. The assertion in the last line will fail in the current master of ROOT, but will succeed using the bugfix in this MR. import ROOT. from math import pi. . xmin = -25.2. xmax = 6.3. nbins = 35. hfname = ""hists.root"". . histfile = ROOT.TFile.Open(hfname,""RECREATE""). . signalSR = ROOT.TH1F(""signalSR"",""signal"",nbins,xmin,xmax). signalSR.FillRandom(""gaus""). . backgroundSR = ROOT.TH1F(""backgroundSR"",""background"",nbins,xmin,xmax). backgroundSR.FillRandom(""pol0""). . signalCR = ROOT.TH1F(""signalCR"",""signal"",nbins,xmin,xmax). signalCR.FillRandom(""pol0""). . backgroundCR = ROOT.TH1F(""backgroundCR"",""background"",nbins,xmin,xmax). backgroundCR.FillRandom(""pol0""). . histfile.Write(). histfile.Close(). . sigSR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalSR""). sigSR.AddNormFactor(""mu"",1.,0.,10.,False). bkgSR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundSR""). bkgSR.AddNormFactor(""norm"",1.,0.,10.,False). . sr = ROOT.RooStats.HistFactory.Channel(""SR""). sr.AddSample(sigSR). sr.AddSample(bkgSR). . sigCR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalCR""). sigCR.AddNormFactor(""mu"",1.,0.,10.,False). bkgCR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundCR""). bkgCR.AddNormFactor(""norm"",1.,0.,10.,False). . cr = ROOT.RooStats.HistFactory.Channel(""CR""). cr.AddSample(sigCR). cr.AddSample(bkgCR). . . meas = ROOT.RooStats.HistFactory.Measurement(""meas""). meas.AddChannel(sr). meas.AddChannel(cr). . meas.CollectHistograms(). ws = ROOT.RooStats.HistFactory.HistoToWorkspaceFactoryFast.MakeCombinedModel(meas). pdf = ws.pdf(""mod",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:893,security,sign,signalCR,893,"critical bugfix in RooFit to avoid last bin getting lost in histogram; We have recently discovered a critical bug in RooFit which (under some arcane circumstances) causes the last bin to go missing from a `RooHistFunc`. Notably, the occurence of this effect is a rounding issue that only happens for some values of upper bounds of observables. . I have attached a python test case that showcases the problem. The assertion in the last line will fail in the current master of ROOT, but will succeed using the bugfix in this MR. import ROOT. from math import pi. . xmin = -25.2. xmax = 6.3. nbins = 35. hfname = ""hists.root"". . histfile = ROOT.TFile.Open(hfname,""RECREATE""). . signalSR = ROOT.TH1F(""signalSR"",""signal"",nbins,xmin,xmax). signalSR.FillRandom(""gaus""). . backgroundSR = ROOT.TH1F(""backgroundSR"",""background"",nbins,xmin,xmax). backgroundSR.FillRandom(""pol0""). . signalCR = ROOT.TH1F(""signalCR"",""signal"",nbins,xmin,xmax). signalCR.FillRandom(""pol0""). . backgroundCR = ROOT.TH1F(""backgroundCR"",""background"",nbins,xmin,xmax). backgroundCR.FillRandom(""pol0""). . histfile.Write(). histfile.Close(). . sigSR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalSR""). sigSR.AddNormFactor(""mu"",1.,0.,10.,False). bkgSR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundSR""). bkgSR.AddNormFactor(""norm"",1.,0.,10.,False). . sr = ROOT.RooStats.HistFactory.Channel(""SR""). sr.AddSample(sigSR). sr.AddSample(bkgSR). . sigCR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalCR""). sigCR.AddNormFactor(""mu"",1.,0.,10.,False). bkgCR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundCR""). bkgCR.AddNormFactor(""norm"",1.,0.,10.,False). . cr = ROOT.RooStats.HistFactory.Channel(""CR""). cr.AddSample(sigCR). cr.AddSample(bkgCR). . . meas = ROOT.RooStats.HistFactory.Measurement(""meas""). meas.AddChannel(sr). meas.AddChannel(cr). . meas.CollectHistograms(). ws = ROOT.RooStats.HistFactory.HistoToWorkspaceFactoryFast.MakeCombinedModel(meas). pdf = ws.pdf(""mod",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:904,security,sign,signal,904,"critical bugfix in RooFit to avoid last bin getting lost in histogram; We have recently discovered a critical bug in RooFit which (under some arcane circumstances) causes the last bin to go missing from a `RooHistFunc`. Notably, the occurence of this effect is a rounding issue that only happens for some values of upper bounds of observables. . I have attached a python test case that showcases the problem. The assertion in the last line will fail in the current master of ROOT, but will succeed using the bugfix in this MR. import ROOT. from math import pi. . xmin = -25.2. xmax = 6.3. nbins = 35. hfname = ""hists.root"". . histfile = ROOT.TFile.Open(hfname,""RECREATE""). . signalSR = ROOT.TH1F(""signalSR"",""signal"",nbins,xmin,xmax). signalSR.FillRandom(""gaus""). . backgroundSR = ROOT.TH1F(""backgroundSR"",""background"",nbins,xmin,xmax). backgroundSR.FillRandom(""pol0""). . signalCR = ROOT.TH1F(""signalCR"",""signal"",nbins,xmin,xmax). signalCR.FillRandom(""pol0""). . backgroundCR = ROOT.TH1F(""backgroundCR"",""background"",nbins,xmin,xmax). backgroundCR.FillRandom(""pol0""). . histfile.Write(). histfile.Close(). . sigSR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalSR""). sigSR.AddNormFactor(""mu"",1.,0.,10.,False). bkgSR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundSR""). bkgSR.AddNormFactor(""norm"",1.,0.,10.,False). . sr = ROOT.RooStats.HistFactory.Channel(""SR""). sr.AddSample(sigSR). sr.AddSample(bkgSR). . sigCR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalCR""). sigCR.AddNormFactor(""mu"",1.,0.,10.,False). bkgCR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundCR""). bkgCR.AddNormFactor(""norm"",1.,0.,10.,False). . cr = ROOT.RooStats.HistFactory.Channel(""CR""). cr.AddSample(sigCR). cr.AddSample(bkgCR). . . meas = ROOT.RooStats.HistFactory.Measurement(""meas""). meas.AddChannel(sr). meas.AddChannel(cr). . meas.CollectHistograms(). ws = ROOT.RooStats.HistFactory.HistoToWorkspaceFactoryFast.MakeCombinedModel(meas). pdf = ws.pdf(""mod",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:930,security,sign,signalCR,930,"critical bugfix in RooFit to avoid last bin getting lost in histogram; We have recently discovered a critical bug in RooFit which (under some arcane circumstances) causes the last bin to go missing from a `RooHistFunc`. Notably, the occurence of this effect is a rounding issue that only happens for some values of upper bounds of observables. . I have attached a python test case that showcases the problem. The assertion in the last line will fail in the current master of ROOT, but will succeed using the bugfix in this MR. import ROOT. from math import pi. . xmin = -25.2. xmax = 6.3. nbins = 35. hfname = ""hists.root"". . histfile = ROOT.TFile.Open(hfname,""RECREATE""). . signalSR = ROOT.TH1F(""signalSR"",""signal"",nbins,xmin,xmax). signalSR.FillRandom(""gaus""). . backgroundSR = ROOT.TH1F(""backgroundSR"",""background"",nbins,xmin,xmax). backgroundSR.FillRandom(""pol0""). . signalCR = ROOT.TH1F(""signalCR"",""signal"",nbins,xmin,xmax). signalCR.FillRandom(""pol0""). . backgroundCR = ROOT.TH1F(""backgroundCR"",""background"",nbins,xmin,xmax). backgroundCR.FillRandom(""pol0""). . histfile.Write(). histfile.Close(). . sigSR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalSR""). sigSR.AddNormFactor(""mu"",1.,0.,10.,False). bkgSR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundSR""). bkgSR.AddNormFactor(""norm"",1.,0.,10.,False). . sr = ROOT.RooStats.HistFactory.Channel(""SR""). sr.AddSample(sigSR). sr.AddSample(bkgSR). . sigCR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalCR""). sigCR.AddNormFactor(""mu"",1.,0.,10.,False). bkgCR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundCR""). bkgCR.AddNormFactor(""norm"",1.,0.,10.,False). . cr = ROOT.RooStats.HistFactory.Channel(""CR""). cr.AddSample(sigCR). cr.AddSample(bkgCR). . . meas = ROOT.RooStats.HistFactory.Measurement(""meas""). meas.AddChannel(sr). meas.AddChannel(cr). . meas.CollectHistograms(). ws = ROOT.RooStats.HistFactory.HistoToWorkspaceFactoryFast.MakeCombinedModel(meas). pdf = ws.pdf(""mod",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:1147,security,sign,signal,1147,"e arcane circumstances) causes the last bin to go missing from a `RooHistFunc`. Notably, the occurence of this effect is a rounding issue that only happens for some values of upper bounds of observables. . I have attached a python test case that showcases the problem. The assertion in the last line will fail in the current master of ROOT, but will succeed using the bugfix in this MR. import ROOT. from math import pi. . xmin = -25.2. xmax = 6.3. nbins = 35. hfname = ""hists.root"". . histfile = ROOT.TFile.Open(hfname,""RECREATE""). . signalSR = ROOT.TH1F(""signalSR"",""signal"",nbins,xmin,xmax). signalSR.FillRandom(""gaus""). . backgroundSR = ROOT.TH1F(""backgroundSR"",""background"",nbins,xmin,xmax). backgroundSR.FillRandom(""pol0""). . signalCR = ROOT.TH1F(""signalCR"",""signal"",nbins,xmin,xmax). signalCR.FillRandom(""pol0""). . backgroundCR = ROOT.TH1F(""backgroundCR"",""background"",nbins,xmin,xmax). backgroundCR.FillRandom(""pol0""). . histfile.Write(). histfile.Close(). . sigSR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalSR""). sigSR.AddNormFactor(""mu"",1.,0.,10.,False). bkgSR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundSR""). bkgSR.AddNormFactor(""norm"",1.,0.,10.,False). . sr = ROOT.RooStats.HistFactory.Channel(""SR""). sr.AddSample(sigSR). sr.AddSample(bkgSR). . sigCR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalCR""). sigCR.AddNormFactor(""mu"",1.,0.,10.,False). bkgCR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundCR""). bkgCR.AddNormFactor(""norm"",1.,0.,10.,False). . cr = ROOT.RooStats.HistFactory.Channel(""CR""). cr.AddSample(sigCR). cr.AddSample(bkgCR). . . meas = ROOT.RooStats.HistFactory.Measurement(""meas""). meas.AddChannel(sr). meas.AddChannel(cr). . meas.CollectHistograms(). ws = ROOT.RooStats.HistFactory.HistoToWorkspaceFactoryFast.MakeCombinedModel(meas). pdf = ws.pdf(""model_SR""). obs = ws.var(""obs_x_SR""). hist = pdf.createHistogram(""hist"",obs,ROOT.RooFit.IntrinsicBinning(1)). assert(hist.GetNbinsX() == nbins)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:1166,security,sign,signalSR,1166,"e arcane circumstances) causes the last bin to go missing from a `RooHistFunc`. Notably, the occurence of this effect is a rounding issue that only happens for some values of upper bounds of observables. . I have attached a python test case that showcases the problem. The assertion in the last line will fail in the current master of ROOT, but will succeed using the bugfix in this MR. import ROOT. from math import pi. . xmin = -25.2. xmax = 6.3. nbins = 35. hfname = ""hists.root"". . histfile = ROOT.TFile.Open(hfname,""RECREATE""). . signalSR = ROOT.TH1F(""signalSR"",""signal"",nbins,xmin,xmax). signalSR.FillRandom(""gaus""). . backgroundSR = ROOT.TH1F(""backgroundSR"",""background"",nbins,xmin,xmax). backgroundSR.FillRandom(""pol0""). . signalCR = ROOT.TH1F(""signalCR"",""signal"",nbins,xmin,xmax). signalCR.FillRandom(""pol0""). . backgroundCR = ROOT.TH1F(""backgroundCR"",""background"",nbins,xmin,xmax). backgroundCR.FillRandom(""pol0""). . histfile.Write(). histfile.Close(). . sigSR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalSR""). sigSR.AddNormFactor(""mu"",1.,0.,10.,False). bkgSR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundSR""). bkgSR.AddNormFactor(""norm"",1.,0.,10.,False). . sr = ROOT.RooStats.HistFactory.Channel(""SR""). sr.AddSample(sigSR). sr.AddSample(bkgSR). . sigCR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalCR""). sigCR.AddNormFactor(""mu"",1.,0.,10.,False). bkgCR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundCR""). bkgCR.AddNormFactor(""norm"",1.,0.,10.,False). . cr = ROOT.RooStats.HistFactory.Channel(""CR""). cr.AddSample(sigCR). cr.AddSample(bkgCR). . . meas = ROOT.RooStats.HistFactory.Measurement(""meas""). meas.AddChannel(sr). meas.AddChannel(cr). . meas.CollectHistograms(). ws = ROOT.RooStats.HistFactory.HistoToWorkspaceFactoryFast.MakeCombinedModel(meas). pdf = ws.pdf(""model_SR""). obs = ws.var(""obs_x_SR""). hist = pdf.createHistogram(""hist"",obs,ROOT.RooFit.IntrinsicBinning(1)). assert(hist.GetNbinsX() == nbins)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:1481,security,sign,signal,1481,"e arcane circumstances) causes the last bin to go missing from a `RooHistFunc`. Notably, the occurence of this effect is a rounding issue that only happens for some values of upper bounds of observables. . I have attached a python test case that showcases the problem. The assertion in the last line will fail in the current master of ROOT, but will succeed using the bugfix in this MR. import ROOT. from math import pi. . xmin = -25.2. xmax = 6.3. nbins = 35. hfname = ""hists.root"". . histfile = ROOT.TFile.Open(hfname,""RECREATE""). . signalSR = ROOT.TH1F(""signalSR"",""signal"",nbins,xmin,xmax). signalSR.FillRandom(""gaus""). . backgroundSR = ROOT.TH1F(""backgroundSR"",""background"",nbins,xmin,xmax). backgroundSR.FillRandom(""pol0""). . signalCR = ROOT.TH1F(""signalCR"",""signal"",nbins,xmin,xmax). signalCR.FillRandom(""pol0""). . backgroundCR = ROOT.TH1F(""backgroundCR"",""background"",nbins,xmin,xmax). backgroundCR.FillRandom(""pol0""). . histfile.Write(). histfile.Close(). . sigSR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalSR""). sigSR.AddNormFactor(""mu"",1.,0.,10.,False). bkgSR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundSR""). bkgSR.AddNormFactor(""norm"",1.,0.,10.,False). . sr = ROOT.RooStats.HistFactory.Channel(""SR""). sr.AddSample(sigSR). sr.AddSample(bkgSR). . sigCR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalCR""). sigCR.AddNormFactor(""mu"",1.,0.,10.,False). bkgCR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundCR""). bkgCR.AddNormFactor(""norm"",1.,0.,10.,False). . cr = ROOT.RooStats.HistFactory.Channel(""CR""). cr.AddSample(sigCR). cr.AddSample(bkgCR). . . meas = ROOT.RooStats.HistFactory.Measurement(""meas""). meas.AddChannel(sr). meas.AddChannel(cr). . meas.CollectHistograms(). ws = ROOT.RooStats.HistFactory.HistoToWorkspaceFactoryFast.MakeCombinedModel(meas). pdf = ws.pdf(""model_SR""). obs = ws.var(""obs_x_SR""). hist = pdf.createHistogram(""hist"",obs,ROOT.RooFit.IntrinsicBinning(1)). assert(hist.GetNbinsX() == nbins)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:1500,security,sign,signalCR,1500,"e arcane circumstances) causes the last bin to go missing from a `RooHistFunc`. Notably, the occurence of this effect is a rounding issue that only happens for some values of upper bounds of observables. . I have attached a python test case that showcases the problem. The assertion in the last line will fail in the current master of ROOT, but will succeed using the bugfix in this MR. import ROOT. from math import pi. . xmin = -25.2. xmax = 6.3. nbins = 35. hfname = ""hists.root"". . histfile = ROOT.TFile.Open(hfname,""RECREATE""). . signalSR = ROOT.TH1F(""signalSR"",""signal"",nbins,xmin,xmax). signalSR.FillRandom(""gaus""). . backgroundSR = ROOT.TH1F(""backgroundSR"",""background"",nbins,xmin,xmax). backgroundSR.FillRandom(""pol0""). . signalCR = ROOT.TH1F(""signalCR"",""signal"",nbins,xmin,xmax). signalCR.FillRandom(""pol0""). . backgroundCR = ROOT.TH1F(""backgroundCR"",""background"",nbins,xmin,xmax). backgroundCR.FillRandom(""pol0""). . histfile.Write(). histfile.Close(). . sigSR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalSR""). sigSR.AddNormFactor(""mu"",1.,0.,10.,False). bkgSR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundSR""). bkgSR.AddNormFactor(""norm"",1.,0.,10.,False). . sr = ROOT.RooStats.HistFactory.Channel(""SR""). sr.AddSample(sigSR). sr.AddSample(bkgSR). . sigCR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalCR""). sigCR.AddNormFactor(""mu"",1.,0.,10.,False). bkgCR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundCR""). bkgCR.AddNormFactor(""norm"",1.,0.,10.,False). . cr = ROOT.RooStats.HistFactory.Channel(""CR""). cr.AddSample(sigCR). cr.AddSample(bkgCR). . . meas = ROOT.RooStats.HistFactory.Measurement(""meas""). meas.AddChannel(sr). meas.AddChannel(cr). . meas.CollectHistograms(). ws = ROOT.RooStats.HistFactory.HistoToWorkspaceFactoryFast.MakeCombinedModel(meas). pdf = ws.pdf(""model_SR""). obs = ws.var(""obs_x_SR""). hist = pdf.createHistogram(""hist"",obs,ROOT.RooFit.IntrinsicBinning(1)). assert(hist.GetNbinsX() == nbins)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:331,testability,observ,observables,331,"critical bugfix in RooFit to avoid last bin getting lost in histogram; We have recently discovered a critical bug in RooFit which (under some arcane circumstances) causes the last bin to go missing from a `RooHistFunc`. Notably, the occurence of this effect is a rounding issue that only happens for some values of upper bounds of observables. . I have attached a python test case that showcases the problem. The assertion in the last line will fail in the current master of ROOT, but will succeed using the bugfix in this MR. import ROOT. from math import pi. . xmin = -25.2. xmax = 6.3. nbins = 35. hfname = ""hists.root"". . histfile = ROOT.TFile.Open(hfname,""RECREATE""). . signalSR = ROOT.TH1F(""signalSR"",""signal"",nbins,xmin,xmax). signalSR.FillRandom(""gaus""). . backgroundSR = ROOT.TH1F(""backgroundSR"",""background"",nbins,xmin,xmax). backgroundSR.FillRandom(""pol0""). . signalCR = ROOT.TH1F(""signalCR"",""signal"",nbins,xmin,xmax). signalCR.FillRandom(""pol0""). . backgroundCR = ROOT.TH1F(""backgroundCR"",""background"",nbins,xmin,xmax). backgroundCR.FillRandom(""pol0""). . histfile.Write(). histfile.Close(). . sigSR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalSR""). sigSR.AddNormFactor(""mu"",1.,0.,10.,False). bkgSR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundSR""). bkgSR.AddNormFactor(""norm"",1.,0.,10.,False). . sr = ROOT.RooStats.HistFactory.Channel(""SR""). sr.AddSample(sigSR). sr.AddSample(bkgSR). . sigCR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalCR""). sigCR.AddNormFactor(""mu"",1.,0.,10.,False). bkgCR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundCR""). bkgCR.AddNormFactor(""norm"",1.,0.,10.,False). . cr = ROOT.RooStats.HistFactory.Channel(""CR""). cr.AddSample(sigCR). cr.AddSample(bkgCR). . . meas = ROOT.RooStats.HistFactory.Measurement(""meas""). meas.AddChannel(sr). meas.AddChannel(cr). . meas.CollectHistograms(). ws = ROOT.RooStats.HistFactory.HistoToWorkspaceFactoryFast.MakeCombinedModel(meas). pdf = ws.pdf(""mod",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:371,testability,test,test,371,"critical bugfix in RooFit to avoid last bin getting lost in histogram; We have recently discovered a critical bug in RooFit which (under some arcane circumstances) causes the last bin to go missing from a `RooHistFunc`. Notably, the occurence of this effect is a rounding issue that only happens for some values of upper bounds of observables. . I have attached a python test case that showcases the problem. The assertion in the last line will fail in the current master of ROOT, but will succeed using the bugfix in this MR. import ROOT. from math import pi. . xmin = -25.2. xmax = 6.3. nbins = 35. hfname = ""hists.root"". . histfile = ROOT.TFile.Open(hfname,""RECREATE""). . signalSR = ROOT.TH1F(""signalSR"",""signal"",nbins,xmin,xmax). signalSR.FillRandom(""gaus""). . backgroundSR = ROOT.TH1F(""backgroundSR"",""background"",nbins,xmin,xmax). backgroundSR.FillRandom(""pol0""). . signalCR = ROOT.TH1F(""signalCR"",""signal"",nbins,xmin,xmax). signalCR.FillRandom(""pol0""). . backgroundCR = ROOT.TH1F(""backgroundCR"",""background"",nbins,xmin,xmax). backgroundCR.FillRandom(""pol0""). . histfile.Write(). histfile.Close(). . sigSR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalSR""). sigSR.AddNormFactor(""mu"",1.,0.,10.,False). bkgSR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundSR""). bkgSR.AddNormFactor(""norm"",1.,0.,10.,False). . sr = ROOT.RooStats.HistFactory.Channel(""SR""). sr.AddSample(sigSR). sr.AddSample(bkgSR). . sigCR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalCR""). sigCR.AddNormFactor(""mu"",1.,0.,10.,False). bkgCR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundCR""). bkgCR.AddNormFactor(""norm"",1.,0.,10.,False). . cr = ROOT.RooStats.HistFactory.Channel(""CR""). cr.AddSample(sigCR). cr.AddSample(bkgCR). . . meas = ROOT.RooStats.HistFactory.Measurement(""meas""). meas.AddChannel(sr). meas.AddChannel(cr). . meas.CollectHistograms(). ws = ROOT.RooStats.HistFactory.HistoToWorkspaceFactoryFast.MakeCombinedModel(meas). pdf = ws.pdf(""mod",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:413,testability,assert,assertion,413,"critical bugfix in RooFit to avoid last bin getting lost in histogram; We have recently discovered a critical bug in RooFit which (under some arcane circumstances) causes the last bin to go missing from a `RooHistFunc`. Notably, the occurence of this effect is a rounding issue that only happens for some values of upper bounds of observables. . I have attached a python test case that showcases the problem. The assertion in the last line will fail in the current master of ROOT, but will succeed using the bugfix in this MR. import ROOT. from math import pi. . xmin = -25.2. xmax = 6.3. nbins = 35. hfname = ""hists.root"". . histfile = ROOT.TFile.Open(hfname,""RECREATE""). . signalSR = ROOT.TH1F(""signalSR"",""signal"",nbins,xmin,xmax). signalSR.FillRandom(""gaus""). . backgroundSR = ROOT.TH1F(""backgroundSR"",""background"",nbins,xmin,xmax). backgroundSR.FillRandom(""pol0""). . signalCR = ROOT.TH1F(""signalCR"",""signal"",nbins,xmin,xmax). signalCR.FillRandom(""pol0""). . backgroundCR = ROOT.TH1F(""backgroundCR"",""background"",nbins,xmin,xmax). backgroundCR.FillRandom(""pol0""). . histfile.Write(). histfile.Close(). . sigSR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalSR""). sigSR.AddNormFactor(""mu"",1.,0.,10.,False). bkgSR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundSR""). bkgSR.AddNormFactor(""norm"",1.,0.,10.,False). . sr = ROOT.RooStats.HistFactory.Channel(""SR""). sr.AddSample(sigSR). sr.AddSample(bkgSR). . sigCR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalCR""). sigCR.AddNormFactor(""mu"",1.,0.,10.,False). bkgCR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundCR""). bkgCR.AddNormFactor(""norm"",1.,0.,10.,False). . cr = ROOT.RooStats.HistFactory.Channel(""CR""). cr.AddSample(sigCR). cr.AddSample(bkgCR). . . meas = ROOT.RooStats.HistFactory.Measurement(""meas""). meas.AddChannel(sr). meas.AddChannel(cr). . meas.CollectHistograms(). ws = ROOT.RooStats.HistFactory.HistoToWorkspaceFactoryFast.MakeCombinedModel(meas). pdf = ws.pdf(""mod",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:2107,testability,assert,assert,2107,"e arcane circumstances) causes the last bin to go missing from a `RooHistFunc`. Notably, the occurence of this effect is a rounding issue that only happens for some values of upper bounds of observables. . I have attached a python test case that showcases the problem. The assertion in the last line will fail in the current master of ROOT, but will succeed using the bugfix in this MR. import ROOT. from math import pi. . xmin = -25.2. xmax = 6.3. nbins = 35. hfname = ""hists.root"". . histfile = ROOT.TFile.Open(hfname,""RECREATE""). . signalSR = ROOT.TH1F(""signalSR"",""signal"",nbins,xmin,xmax). signalSR.FillRandom(""gaus""). . backgroundSR = ROOT.TH1F(""backgroundSR"",""background"",nbins,xmin,xmax). backgroundSR.FillRandom(""pol0""). . signalCR = ROOT.TH1F(""signalCR"",""signal"",nbins,xmin,xmax). signalCR.FillRandom(""pol0""). . backgroundCR = ROOT.TH1F(""backgroundCR"",""background"",nbins,xmin,xmax). backgroundCR.FillRandom(""pol0""). . histfile.Write(). histfile.Close(). . sigSR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalSR""). sigSR.AddNormFactor(""mu"",1.,0.,10.,False). bkgSR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundSR""). bkgSR.AddNormFactor(""norm"",1.,0.,10.,False). . sr = ROOT.RooStats.HistFactory.Channel(""SR""). sr.AddSample(sigSR). sr.AddSample(bkgSR). . sigCR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalCR""). sigCR.AddNormFactor(""mu"",1.,0.,10.,False). bkgCR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundCR""). bkgCR.AddNormFactor(""norm"",1.,0.,10.,False). . cr = ROOT.RooStats.HistFactory.Channel(""CR""). cr.AddSample(sigCR). cr.AddSample(bkgCR). . . meas = ROOT.RooStats.HistFactory.Measurement(""meas""). meas.AddChannel(sr). meas.AddChannel(cr). . meas.CollectHistograms(). ws = ROOT.RooStats.HistFactory.HistoToWorkspaceFactoryFast.MakeCombinedModel(meas). pdf = ws.pdf(""model_SR""). obs = ws.var(""obs_x_SR""). hist = pdf.createHistogram(""hist"",obs,ROOT.RooFit.IntrinsicBinning(1)). assert(hist.GetNbinsX() == nbins)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:88,usability,discov,discovered,88,"critical bugfix in RooFit to avoid last bin getting lost in histogram; We have recently discovered a critical bug in RooFit which (under some arcane circumstances) causes the last bin to go missing from a `RooHistFunc`. Notably, the occurence of this effect is a rounding issue that only happens for some values of upper bounds of observables. . I have attached a python test case that showcases the problem. The assertion in the last line will fail in the current master of ROOT, but will succeed using the bugfix in this MR. import ROOT. from math import pi. . xmin = -25.2. xmax = 6.3. nbins = 35. hfname = ""hists.root"". . histfile = ROOT.TFile.Open(hfname,""RECREATE""). . signalSR = ROOT.TH1F(""signalSR"",""signal"",nbins,xmin,xmax). signalSR.FillRandom(""gaus""). . backgroundSR = ROOT.TH1F(""backgroundSR"",""background"",nbins,xmin,xmax). backgroundSR.FillRandom(""pol0""). . signalCR = ROOT.TH1F(""signalCR"",""signal"",nbins,xmin,xmax). signalCR.FillRandom(""pol0""). . backgroundCR = ROOT.TH1F(""backgroundCR"",""background"",nbins,xmin,xmax). backgroundCR.FillRandom(""pol0""). . histfile.Write(). histfile.Close(). . sigSR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalSR""). sigSR.AddNormFactor(""mu"",1.,0.,10.,False). bkgSR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundSR""). bkgSR.AddNormFactor(""norm"",1.,0.,10.,False). . sr = ROOT.RooStats.HistFactory.Channel(""SR""). sr.AddSample(sigSR). sr.AddSample(bkgSR). . sigCR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalCR""). sigCR.AddNormFactor(""mu"",1.,0.,10.,False). bkgCR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundCR""). bkgCR.AddNormFactor(""norm"",1.,0.,10.,False). . cr = ROOT.RooStats.HistFactory.Channel(""CR""). cr.AddSample(sigCR). cr.AddSample(bkgCR). . . meas = ROOT.RooStats.HistFactory.Measurement(""meas""). meas.AddChannel(sr). meas.AddChannel(cr). . meas.CollectHistograms(). ws = ROOT.RooStats.HistFactory.HistoToWorkspaceFactoryFast.MakeCombinedModel(meas). pdf = ws.pdf(""mod",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:1094,usability,Close,Close,1094,"d a critical bug in RooFit which (under some arcane circumstances) causes the last bin to go missing from a `RooHistFunc`. Notably, the occurence of this effect is a rounding issue that only happens for some values of upper bounds of observables. . I have attached a python test case that showcases the problem. The assertion in the last line will fail in the current master of ROOT, but will succeed using the bugfix in this MR. import ROOT. from math import pi. . xmin = -25.2. xmax = 6.3. nbins = 35. hfname = ""hists.root"". . histfile = ROOT.TFile.Open(hfname,""RECREATE""). . signalSR = ROOT.TH1F(""signalSR"",""signal"",nbins,xmin,xmax). signalSR.FillRandom(""gaus""). . backgroundSR = ROOT.TH1F(""backgroundSR"",""background"",nbins,xmin,xmax). backgroundSR.FillRandom(""pol0""). . signalCR = ROOT.TH1F(""signalCR"",""signal"",nbins,xmin,xmax). signalCR.FillRandom(""pol0""). . backgroundCR = ROOT.TH1F(""backgroundCR"",""background"",nbins,xmin,xmax). backgroundCR.FillRandom(""pol0""). . histfile.Write(). histfile.Close(). . sigSR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalSR""). sigSR.AddNormFactor(""mu"",1.,0.,10.,False). bkgSR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundSR""). bkgSR.AddNormFactor(""norm"",1.,0.,10.,False). . sr = ROOT.RooStats.HistFactory.Channel(""SR""). sr.AddSample(sigSR). sr.AddSample(bkgSR). . sigCR = ROOT.RooStats.HistFactory.Sample(""signal"","""",hfname,""signalCR""). sigCR.AddNormFactor(""mu"",1.,0.,10.,False). bkgCR = ROOT.RooStats.HistFactory.Sample(""background"","""",hfname,""backgroundCR""). bkgCR.AddNormFactor(""norm"",1.,0.,10.,False). . cr = ROOT.RooStats.HistFactory.Channel(""CR""). cr.AddSample(sigCR). cr.AddSample(bkgCR). . . meas = ROOT.RooStats.HistFactory.Measurement(""meas""). meas.AddChannel(sr). meas.AddChannel(cr). . meas.CollectHistograms(). ws = ROOT.RooStats.HistFactory.HistoToWorkspaceFactoryFast.MakeCombinedModel(meas). pdf = ws.pdf(""model_SR""). obs = ws.var(""obs_x_SR""). hist = pdf.createHistogram(""hist"",obs,ROOT.RooFit.IntrinsicBin",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1917:14,interoperability,convers,conversion,14,"[PyROOT] Show conversion of TTree to pandas.DataFrame in tutorial; Show the easy-going conversion of a `TTree` to a `pandas.DataFrame` in the `TTree.AsMatrix` tutorial. Here's the example in short:. ```python. >>> data, columns = tree.AsMatrix(return_labels=True). >>> df = pandas.DataFrame(data=data, columns=columns). >>> print(df). x y. 0 0.0 0.0. 1 1.0 -1.0. 2 2.0 -2.0. 3 3.0 -3.0. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1917
https://github.com/root-project/root/pull/1917:87,interoperability,convers,conversion,87,"[PyROOT] Show conversion of TTree to pandas.DataFrame in tutorial; Show the easy-going conversion of a `TTree` to a `pandas.DataFrame` in the `TTree.AsMatrix` tutorial. Here's the example in short:. ```python. >>> data, columns = tree.AsMatrix(return_labels=True). >>> df = pandas.DataFrame(data=data, columns=columns). >>> print(df). x y. 0 0.0 0.0. 1 1.0 -1.0. 2 2.0 -2.0. 3 3.0 -3.0. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1917
https://github.com/root-project/root/pull/1918:219,availability,error,error,219,"webgui: try to find chrome/firefox browser during building; If found, value will be used as first candidate when searching for browser on file system. Provide functionality to dump JSON file for canvas painting. Window error should be resolved by @bellenot",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1918
https://github.com/root-project/root/pull/1918:50,deployability,build,building,50,"webgui: try to find chrome/firefox browser during building; If found, value will be used as first candidate when searching for browser on file system. Provide functionality to dump JSON file for canvas painting. Window error should be resolved by @bellenot",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1918
https://github.com/root-project/root/pull/1918:219,performance,error,error,219,"webgui: try to find chrome/firefox browser during building; If found, value will be used as first candidate when searching for browser on file system. Provide functionality to dump JSON file for canvas painting. Window error should be resolved by @bellenot",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1918
https://github.com/root-project/root/pull/1918:219,safety,error,error,219,"webgui: try to find chrome/firefox browser during building; If found, value will be used as first candidate when searching for browser on file system. Provide functionality to dump JSON file for canvas painting. Window error should be resolved by @bellenot",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1918
https://github.com/root-project/root/pull/1918:219,usability,error,error,219,"webgui: try to find chrome/firefox browser during building; If found, value will be used as first candidate when searching for browser on file system. Provide functionality to dump JSON file for canvas painting. Window error should be resolved by @bellenot",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1918
https://github.com/root-project/root/pull/1919:21,availability,error,error,21,"[cling] Fix valgrind error in CIFactory/AddRuntimeIncludePaths.; Fixes. ```. ==19429== Source and destination overlap in memcpy(0xffeffca40, 0xffeffca40, 49). ==19429== at 0x403223C: memcpy@@GLIBC_2.14 (vg_replace_strmem.c:1018). ==19429== by 0x7B9DCB3: uninitialized_copy<const char, char> (SmallVector.h:296). ==19429== by 0x7B9DCB3: append<const char *, void> (SmallVector.h:402). ==19429== by 0x7B9DCB3: append<const char *> (SmallString.h:76). ==19429== by 0x7B9DCB3: operator+= (SmallString.h:286). ==19429== by 0x7B9DCB3: operator= (SmallString.h:282). ==19429== by 0x7B9DCB3: AddRuntimeIncludePaths (CIFactory.cpp:667). ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1919
https://github.com/root-project/root/pull/1919:473,availability,operat,operator,473,"[cling] Fix valgrind error in CIFactory/AddRuntimeIncludePaths.; Fixes. ```. ==19429== Source and destination overlap in memcpy(0xffeffca40, 0xffeffca40, 49). ==19429== at 0x403223C: memcpy@@GLIBC_2.14 (vg_replace_strmem.c:1018). ==19429== by 0x7B9DCB3: uninitialized_copy<const char, char> (SmallVector.h:296). ==19429== by 0x7B9DCB3: append<const char *, void> (SmallVector.h:402). ==19429== by 0x7B9DCB3: append<const char *> (SmallString.h:76). ==19429== by 0x7B9DCB3: operator+= (SmallString.h:286). ==19429== by 0x7B9DCB3: operator= (SmallString.h:282). ==19429== by 0x7B9DCB3: AddRuntimeIncludePaths (CIFactory.cpp:667). ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1919
https://github.com/root-project/root/pull/1919:529,availability,operat,operator,529,"[cling] Fix valgrind error in CIFactory/AddRuntimeIncludePaths.; Fixes. ```. ==19429== Source and destination overlap in memcpy(0xffeffca40, 0xffeffca40, 49). ==19429== at 0x403223C: memcpy@@GLIBC_2.14 (vg_replace_strmem.c:1018). ==19429== by 0x7B9DCB3: uninitialized_copy<const char, char> (SmallVector.h:296). ==19429== by 0x7B9DCB3: append<const char *, void> (SmallVector.h:402). ==19429== by 0x7B9DCB3: append<const char *> (SmallString.h:76). ==19429== by 0x7B9DCB3: operator+= (SmallString.h:286). ==19429== by 0x7B9DCB3: operator= (SmallString.h:282). ==19429== by 0x7B9DCB3: AddRuntimeIncludePaths (CIFactory.cpp:667). ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1919
https://github.com/root-project/root/pull/1919:21,performance,error,error,21,"[cling] Fix valgrind error in CIFactory/AddRuntimeIncludePaths.; Fixes. ```. ==19429== Source and destination overlap in memcpy(0xffeffca40, 0xffeffca40, 49). ==19429== at 0x403223C: memcpy@@GLIBC_2.14 (vg_replace_strmem.c:1018). ==19429== by 0x7B9DCB3: uninitialized_copy<const char, char> (SmallVector.h:296). ==19429== by 0x7B9DCB3: append<const char *, void> (SmallVector.h:402). ==19429== by 0x7B9DCB3: append<const char *> (SmallString.h:76). ==19429== by 0x7B9DCB3: operator+= (SmallString.h:286). ==19429== by 0x7B9DCB3: operator= (SmallString.h:282). ==19429== by 0x7B9DCB3: AddRuntimeIncludePaths (CIFactory.cpp:667). ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1919
https://github.com/root-project/root/pull/1919:21,safety,error,error,21,"[cling] Fix valgrind error in CIFactory/AddRuntimeIncludePaths.; Fixes. ```. ==19429== Source and destination overlap in memcpy(0xffeffca40, 0xffeffca40, 49). ==19429== at 0x403223C: memcpy@@GLIBC_2.14 (vg_replace_strmem.c:1018). ==19429== by 0x7B9DCB3: uninitialized_copy<const char, char> (SmallVector.h:296). ==19429== by 0x7B9DCB3: append<const char *, void> (SmallVector.h:402). ==19429== by 0x7B9DCB3: append<const char *> (SmallString.h:76). ==19429== by 0x7B9DCB3: operator+= (SmallString.h:286). ==19429== by 0x7B9DCB3: operator= (SmallString.h:282). ==19429== by 0x7B9DCB3: AddRuntimeIncludePaths (CIFactory.cpp:667). ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1919
https://github.com/root-project/root/pull/1919:21,usability,error,error,21,"[cling] Fix valgrind error in CIFactory/AddRuntimeIncludePaths.; Fixes. ```. ==19429== Source and destination overlap in memcpy(0xffeffca40, 0xffeffca40, 49). ==19429== at 0x403223C: memcpy@@GLIBC_2.14 (vg_replace_strmem.c:1018). ==19429== by 0x7B9DCB3: uninitialized_copy<const char, char> (SmallVector.h:296). ==19429== by 0x7B9DCB3: append<const char *, void> (SmallVector.h:402). ==19429== by 0x7B9DCB3: append<const char *> (SmallString.h:76). ==19429== by 0x7B9DCB3: operator+= (SmallString.h:286). ==19429== by 0x7B9DCB3: operator= (SmallString.h:282). ==19429== by 0x7B9DCB3: AddRuntimeIncludePaths (CIFactory.cpp:667). ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1919
https://github.com/root-project/root/pull/1920:8,deployability,version,version,8,Simpler version of line.cxx; TLine.hxx uses const TPadPos&. TPadLength.hxx allows expression like: 0.3_normal*TMath::Cos(angle) + 0.5_normal. line.cxx is much simpler,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1920
https://github.com/root-project/root/pull/1920:8,integrability,version,version,8,Simpler version of line.cxx; TLine.hxx uses const TPadPos&. TPadLength.hxx allows expression like: 0.3_normal*TMath::Cos(angle) + 0.5_normal. line.cxx is much simpler,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1920
https://github.com/root-project/root/pull/1920:8,modifiability,version,version,8,Simpler version of line.cxx; TLine.hxx uses const TPadPos&. TPadLength.hxx allows expression like: 0.3_normal*TMath::Cos(angle) + 0.5_normal. line.cxx is much simpler,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1920
https://github.com/root-project/root/pull/1920:0,testability,Simpl,Simpler,0,Simpler version of line.cxx; TLine.hxx uses const TPadPos&. TPadLength.hxx allows expression like: 0.3_normal*TMath::Cos(angle) + 0.5_normal. line.cxx is much simpler,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1920
https://github.com/root-project/root/pull/1920:159,testability,simpl,simpler,159,Simpler version of line.cxx; TLine.hxx uses const TPadPos&. TPadLength.hxx allows expression like: 0.3_normal*TMath::Cos(angle) + 0.5_normal. line.cxx is much simpler,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1920
https://github.com/root-project/root/pull/1920:0,usability,Simpl,Simpler,0,Simpler version of line.cxx; TLine.hxx uses const TPadPos&. TPadLength.hxx allows expression like: 0.3_normal*TMath::Cos(angle) + 0.5_normal. line.cxx is much simpler,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1920
https://github.com/root-project/root/pull/1920:159,usability,simpl,simpler,159,Simpler version of line.cxx; TLine.hxx uses const TPadPos&. TPadLength.hxx allows expression like: 0.3_normal*TMath::Cos(angle) + 0.5_normal. line.cxx is much simpler,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1920
https://github.com/root-project/root/pull/1921:6,usability,Custom,Custom,6,[TDF] Custom actions: Fix Book and provide tutorial showing how to fill ThN!;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1921
https://github.com/root-project/root/pull/1922:28,deployability,depend,dependency,28,[cxxmodules] Adding missing dependency for pyroot; This will fix broken runtime_cxxmodules option for ROOT,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1922
https://github.com/root-project/root/pull/1922:28,integrability,depend,dependency,28,[cxxmodules] Adding missing dependency for pyroot; This will fix broken runtime_cxxmodules option for ROOT,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1922
https://github.com/root-project/root/pull/1922:28,modifiability,depend,dependency,28,[cxxmodules] Adding missing dependency for pyroot; This will fix broken runtime_cxxmodules option for ROOT,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1922
https://github.com/root-project/root/pull/1922:28,safety,depend,dependency,28,[cxxmodules] Adding missing dependency for pyroot; This will fix broken runtime_cxxmodules option for ROOT,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1922
https://github.com/root-project/root/pull/1922:28,testability,depend,dependency,28,[cxxmodules] Adding missing dependency for pyroot; This will fix broken runtime_cxxmodules option for ROOT,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1922
https://github.com/root-project/root/pull/1924:49,interoperability,specif,specific,49,webgui: workaround if browser not found plus Mac specific;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1924
https://github.com/root-project/root/pull/1925:372,availability,failur,failure,372,"[PyROOT] Fix numpy array interface for long types on 32bit systems; The array interface now inferes the size of the data-type with `sizeof` by itself. This fixes [this](https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-master/1703/BUILDTYPE=Debug,COMPILER=gcc49,LABEL=slc6-i686/testReport/junit/projectroot.bindings.pyroot/test/pyunittests_pyroot_array_interface/) failure for `long` types on 32bit sytems not being 8 bytes long.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1925
https://github.com/root-project/root/pull/1925:238,deployability,BUILD,BUILDTYPE,238,"[PyROOT] Fix numpy array interface for long types on 32bit systems; The array interface now inferes the size of the data-type with `sizeof` by itself. This fixes [this](https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-master/1703/BUILDTYPE=Debug,COMPILER=gcc49,LABEL=slc6-i686/testReport/junit/projectroot.bindings.pyroot/test/pyunittests_pyroot_array_interface/) failure for `long` types on 32bit sytems not being 8 bytes long.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1925
https://github.com/root-project/root/pull/1925:372,deployability,fail,failure,372,"[PyROOT] Fix numpy array interface for long types on 32bit systems; The array interface now inferes the size of the data-type with `sizeof` by itself. This fixes [this](https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-master/1703/BUILDTYPE=Debug,COMPILER=gcc49,LABEL=slc6-i686/testReport/junit/projectroot.bindings.pyroot/test/pyunittests_pyroot_array_interface/) failure for `long` types on 32bit sytems not being 8 bytes long.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1925
https://github.com/root-project/root/pull/1925:25,integrability,interfac,interface,25,"[PyROOT] Fix numpy array interface for long types on 32bit systems; The array interface now inferes the size of the data-type with `sizeof` by itself. This fixes [this](https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-master/1703/BUILDTYPE=Debug,COMPILER=gcc49,LABEL=slc6-i686/testReport/junit/projectroot.bindings.pyroot/test/pyunittests_pyroot_array_interface/) failure for `long` types on 32bit sytems not being 8 bytes long.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1925
https://github.com/root-project/root/pull/1925:78,integrability,interfac,interface,78,"[PyROOT] Fix numpy array interface for long types on 32bit systems; The array interface now inferes the size of the data-type with `sizeof` by itself. This fixes [this](https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-master/1703/BUILDTYPE=Debug,COMPILER=gcc49,LABEL=slc6-i686/testReport/junit/projectroot.bindings.pyroot/test/pyunittests_pyroot_array_interface/) failure for `long` types on 32bit sytems not being 8 bytes long.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1925
https://github.com/root-project/root/pull/1925:25,interoperability,interfac,interface,25,"[PyROOT] Fix numpy array interface for long types on 32bit systems; The array interface now inferes the size of the data-type with `sizeof` by itself. This fixes [this](https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-master/1703/BUILDTYPE=Debug,COMPILER=gcc49,LABEL=slc6-i686/testReport/junit/projectroot.bindings.pyroot/test/pyunittests_pyroot_array_interface/) failure for `long` types on 32bit sytems not being 8 bytes long.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1925
https://github.com/root-project/root/pull/1925:78,interoperability,interfac,interface,78,"[PyROOT] Fix numpy array interface for long types on 32bit systems; The array interface now inferes the size of the data-type with `sizeof` by itself. This fixes [this](https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-master/1703/BUILDTYPE=Debug,COMPILER=gcc49,LABEL=slc6-i686/testReport/junit/projectroot.bindings.pyroot/test/pyunittests_pyroot_array_interface/) failure for `long` types on 32bit sytems not being 8 bytes long.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1925
https://github.com/root-project/root/pull/1925:314,interoperability,bind,bindings,314,"[PyROOT] Fix numpy array interface for long types on 32bit systems; The array interface now inferes the size of the data-type with `sizeof` by itself. This fixes [this](https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-master/1703/BUILDTYPE=Debug,COMPILER=gcc49,LABEL=slc6-i686/testReport/junit/projectroot.bindings.pyroot/test/pyunittests_pyroot_array_interface/) failure for `long` types on 32bit sytems not being 8 bytes long.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1925
https://github.com/root-project/root/pull/1925:25,modifiability,interfac,interface,25,"[PyROOT] Fix numpy array interface for long types on 32bit systems; The array interface now inferes the size of the data-type with `sizeof` by itself. This fixes [this](https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-master/1703/BUILDTYPE=Debug,COMPILER=gcc49,LABEL=slc6-i686/testReport/junit/projectroot.bindings.pyroot/test/pyunittests_pyroot_array_interface/) failure for `long` types on 32bit sytems not being 8 bytes long.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1925
https://github.com/root-project/root/pull/1925:78,modifiability,interfac,interface,78,"[PyROOT] Fix numpy array interface for long types on 32bit systems; The array interface now inferes the size of the data-type with `sizeof` by itself. This fixes [this](https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-master/1703/BUILDTYPE=Debug,COMPILER=gcc49,LABEL=slc6-i686/testReport/junit/projectroot.bindings.pyroot/test/pyunittests_pyroot_array_interface/) failure for `long` types on 32bit sytems not being 8 bytes long.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1925
https://github.com/root-project/root/pull/1925:314,modifiability,bind,bindings,314,"[PyROOT] Fix numpy array interface for long types on 32bit systems; The array interface now inferes the size of the data-type with `sizeof` by itself. This fixes [this](https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-master/1703/BUILDTYPE=Debug,COMPILER=gcc49,LABEL=slc6-i686/testReport/junit/projectroot.bindings.pyroot/test/pyunittests_pyroot_array_interface/) failure for `long` types on 32bit sytems not being 8 bytes long.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1925
https://github.com/root-project/root/pull/1925:372,performance,failur,failure,372,"[PyROOT] Fix numpy array interface for long types on 32bit systems; The array interface now inferes the size of the data-type with `sizeof` by itself. This fixes [this](https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-master/1703/BUILDTYPE=Debug,COMPILER=gcc49,LABEL=slc6-i686/testReport/junit/projectroot.bindings.pyroot/test/pyunittests_pyroot_array_interface/) failure for `long` types on 32bit sytems not being 8 bytes long.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1925
https://github.com/root-project/root/pull/1925:372,reliability,fail,failure,372,"[PyROOT] Fix numpy array interface for long types on 32bit systems; The array interface now inferes the size of the data-type with `sizeof` by itself. This fixes [this](https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-master/1703/BUILDTYPE=Debug,COMPILER=gcc49,LABEL=slc6-i686/testReport/junit/projectroot.bindings.pyroot/test/pyunittests_pyroot_array_interface/) failure for `long` types on 32bit sytems not being 8 bytes long.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1925
https://github.com/root-project/root/pull/1925:285,safety,test,testReport,285,"[PyROOT] Fix numpy array interface for long types on 32bit systems; The array interface now inferes the size of the data-type with `sizeof` by itself. This fixes [this](https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-master/1703/BUILDTYPE=Debug,COMPILER=gcc49,LABEL=slc6-i686/testReport/junit/projectroot.bindings.pyroot/test/pyunittests_pyroot_array_interface/) failure for `long` types on 32bit sytems not being 8 bytes long.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1925
https://github.com/root-project/root/pull/1925:330,safety,test,test,330,"[PyROOT] Fix numpy array interface for long types on 32bit systems; The array interface now inferes the size of the data-type with `sizeof` by itself. This fixes [this](https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-master/1703/BUILDTYPE=Debug,COMPILER=gcc49,LABEL=slc6-i686/testReport/junit/projectroot.bindings.pyroot/test/pyunittests_pyroot_array_interface/) failure for `long` types on 32bit sytems not being 8 bytes long.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1925
https://github.com/root-project/root/pull/1925:285,testability,test,testReport,285,"[PyROOT] Fix numpy array interface for long types on 32bit systems; The array interface now inferes the size of the data-type with `sizeof` by itself. This fixes [this](https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-master/1703/BUILDTYPE=Debug,COMPILER=gcc49,LABEL=slc6-i686/testReport/junit/projectroot.bindings.pyroot/test/pyunittests_pyroot_array_interface/) failure for `long` types on 32bit sytems not being 8 bytes long.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1925
https://github.com/root-project/root/pull/1925:330,testability,test,test,330,"[PyROOT] Fix numpy array interface for long types on 32bit systems; The array interface now inferes the size of the data-type with `sizeof` by itself. This fixes [this](https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-master/1703/BUILDTYPE=Debug,COMPILER=gcc49,LABEL=slc6-i686/testReport/junit/projectroot.bindings.pyroot/test/pyunittests_pyroot_array_interface/) failure for `long` types on 32bit sytems not being 8 bytes long.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1925
https://github.com/root-project/root/pull/1926:6,testability,simpl,simplification,6,TLine simplification;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1926
https://github.com/root-project/root/pull/1926:6,usability,simpl,simplification,6,TLine simplification;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1926
https://github.com/root-project/root/pull/1927:145,interoperability,standard,standard,145,"Workaround for NaN and Infinity values when store them in JSON; Native JSON does not support them, but at least use `null` to avoid problem with standard parsers. Also null value can be distinguished from 0 in JavaScript. When reading back with TBufferJSON, any null will be converted into NaN",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1927
https://github.com/root-project/root/pull/1927:76,reliability,doe,does,76,"Workaround for NaN and Infinity values when store them in JSON; Native JSON does not support them, but at least use `null` to avoid problem with standard parsers. Also null value can be distinguished from 0 in JavaScript. When reading back with TBufferJSON, any null will be converted into NaN",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1927
https://github.com/root-project/root/pull/1927:126,safety,avoid,avoid,126,"Workaround for NaN and Infinity values when store them in JSON; Native JSON does not support them, but at least use `null` to avoid problem with standard parsers. Also null value can be distinguished from 0 in JavaScript. When reading back with TBufferJSON, any null will be converted into NaN",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1927
https://github.com/root-project/root/pull/1927:85,usability,support,support,85,"Workaround for NaN and Infinity values when store them in JSON; Native JSON does not support them, but at least use `null` to avoid problem with standard parsers. Also null value can be distinguished from 0 in JavaScript. When reading back with TBufferJSON, any null will be converted into NaN",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1927
https://github.com/root-project/root/pull/1929:195,energy efficiency,load,load,195,"[rootcling] nullptr payload and fwddecls if in PCH:; If a dictionary's headers are in the PCH, they get #includes at. startup. There is no need for forward declarations (to be parsed. at library load time) nor payloads (to be parsed at autoparsing time). This should reduce the effect we see with recursive parsing, and. speed up ROOT (e.g. but not only the startup).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1929
https://github.com/root-project/root/pull/1929:267,energy efficiency,reduc,reduce,267,"[rootcling] nullptr payload and fwddecls if in PCH:; If a dictionary's headers are in the PCH, they get #includes at. startup. There is no need for forward declarations (to be parsed. at library load time) nor payloads (to be parsed at autoparsing time). This should reduce the effect we see with recursive parsing, and. speed up ROOT (e.g. but not only the startup).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1929
https://github.com/root-project/root/pull/1929:195,performance,load,load,195,"[rootcling] nullptr payload and fwddecls if in PCH:; If a dictionary's headers are in the PCH, they get #includes at. startup. There is no need for forward declarations (to be parsed. at library load time) nor payloads (to be parsed at autoparsing time). This should reduce the effect we see with recursive parsing, and. speed up ROOT (e.g. but not only the startup).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1929
https://github.com/root-project/root/pull/1929:200,performance,time,time,200,"[rootcling] nullptr payload and fwddecls if in PCH:; If a dictionary's headers are in the PCH, they get #includes at. startup. There is no need for forward declarations (to be parsed. at library load time) nor payloads (to be parsed at autoparsing time). This should reduce the effect we see with recursive parsing, and. speed up ROOT (e.g. but not only the startup).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1929
https://github.com/root-project/root/pull/1929:248,performance,time,time,248,"[rootcling] nullptr payload and fwddecls if in PCH:; If a dictionary's headers are in the PCH, they get #includes at. startup. There is no need for forward declarations (to be parsed. at library load time) nor payloads (to be parsed at autoparsing time). This should reduce the effect we see with recursive parsing, and. speed up ROOT (e.g. but not only the startup).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1929
https://github.com/root-project/root/pull/1930:4,usability,support,support,4,Add support for Chrome and Firefox web browsers on Windows;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1930
https://github.com/root-project/root/pull/1932:305,interoperability,share,shared,305,"[Math] Do not instantiate MixMaxEngine extern templates in gcc-5 ; Because of a bug in gcc-5, the extern template instantiation of. MixMaxEngine::Name would lack the correct cxx11 abi attribute in the. mangled name, so compilers which correctly add the cxx abi attribute. would not find the symbol in the shared library.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1932
https://github.com/root-project/root/pull/1933:184,availability,state,state,184,Also buffer Sema.UndefinedButUsed:; Else Sema::checkUndefinedButUsed() will complain about things it did not see. and should not care about (because they are only relevant to the Sema state. outside the recursive parse).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1933
https://github.com/root-project/root/pull/1933:5,integrability,buffer,buffer,5,Also buffer Sema.UndefinedButUsed:; Else Sema::checkUndefinedButUsed() will complain about things it did not see. and should not care about (because they are only relevant to the Sema state. outside the recursive parse).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1933
https://github.com/root-project/root/pull/1933:184,integrability,state,state,184,Also buffer Sema.UndefinedButUsed:; Else Sema::checkUndefinedButUsed() will complain about things it did not see. and should not care about (because they are only relevant to the Sema state. outside the recursive parse).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1933
https://github.com/root-project/root/pull/1933:76,safety,compl,complain,76,Also buffer Sema.UndefinedButUsed:; Else Sema::checkUndefinedButUsed() will complain about things it did not see. and should not care about (because they are only relevant to the Sema state. outside the recursive parse).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1933
https://github.com/root-project/root/pull/1933:76,security,compl,complain,76,Also buffer Sema.UndefinedButUsed:; Else Sema::checkUndefinedButUsed() will complain about things it did not see. and should not care about (because they are only relevant to the Sema state. outside the recursive parse).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1933
https://github.com/root-project/root/pull/1934:28,security,sign,signal,28,[VecOps] Write empty PCM to signal that VecOps is in PCH!;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1934
https://github.com/root-project/root/pull/1935:0,deployability,Updat,Update,0,Update root welcome logo to current year;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1935
https://github.com/root-project/root/pull/1935:20,deployability,log,logo,20,Update root welcome logo to current year;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1935
https://github.com/root-project/root/pull/1935:28,energy efficiency,current,current,28,Update root welcome logo to current year;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1935
https://github.com/root-project/root/pull/1935:0,safety,Updat,Update,0,Update root welcome logo to current year;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1935
https://github.com/root-project/root/pull/1935:20,safety,log,logo,20,Update root welcome logo to current year;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1935
https://github.com/root-project/root/pull/1935:0,security,Updat,Update,0,Update root welcome logo to current year;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1935
https://github.com/root-project/root/pull/1935:20,security,log,logo,20,Update root welcome logo to current year;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1935
https://github.com/root-project/root/pull/1935:20,testability,log,logo,20,Update root welcome logo to current year;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1935
https://github.com/root-project/root/pull/1936:359,interoperability,share,shared,359,"[Math] Avoid std::string in signature of template class method; Because of a bug in gcc-5, the extern template instantiation of. MixMaxEngine::Name would lack the correct cxx11 abi attribute in the. mangled name (required because std::string is part of the signature),. so compilers which correctly add the cxx abi attribute would not. find the symbol in the shared library. We now eturn a const char* pointing to contents of a static string instead. This PR supersedes #1932 .",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1936
https://github.com/root-project/root/pull/1936:414,performance,content,contents,414,"[Math] Avoid std::string in signature of template class method; Because of a bug in gcc-5, the extern template instantiation of. MixMaxEngine::Name would lack the correct cxx11 abi attribute in the. mangled name (required because std::string is part of the signature),. so compilers which correctly add the cxx abi attribute would not. find the symbol in the shared library. We now eturn a const char* pointing to contents of a static string instead. This PR supersedes #1932 .",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1936
https://github.com/root-project/root/pull/1936:7,safety,Avoid,Avoid,7,"[Math] Avoid std::string in signature of template class method; Because of a bug in gcc-5, the extern template instantiation of. MixMaxEngine::Name would lack the correct cxx11 abi attribute in the. mangled name (required because std::string is part of the signature),. so compilers which correctly add the cxx abi attribute would not. find the symbol in the shared library. We now eturn a const char* pointing to contents of a static string instead. This PR supersedes #1932 .",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1936
https://github.com/root-project/root/pull/1936:28,security,sign,signature,28,"[Math] Avoid std::string in signature of template class method; Because of a bug in gcc-5, the extern template instantiation of. MixMaxEngine::Name would lack the correct cxx11 abi attribute in the. mangled name (required because std::string is part of the signature),. so compilers which correctly add the cxx abi attribute would not. find the symbol in the shared library. We now eturn a const char* pointing to contents of a static string instead. This PR supersedes #1932 .",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1936
https://github.com/root-project/root/pull/1936:257,security,sign,signature,257,"[Math] Avoid std::string in signature of template class method; Because of a bug in gcc-5, the extern template instantiation of. MixMaxEngine::Name would lack the correct cxx11 abi attribute in the. mangled name (required because std::string is part of the signature),. so compilers which correctly add the cxx abi attribute would not. find the symbol in the shared library. We now eturn a const char* pointing to contents of a static string instead. This PR supersedes #1932 .",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1936
https://github.com/root-project/root/pull/1937:117,availability,failur,failures,117,[TDF][TO REVERT] Use ProcessLine instead of Calc for jitting; ...in the hope to get a clearer picture about the test failures. when jitting,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1937
https://github.com/root-project/root/pull/1937:117,deployability,fail,failures,117,[TDF][TO REVERT] Use ProcessLine instead of Calc for jitting; ...in the hope to get a clearer picture about the test failures. when jitting,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1937
https://github.com/root-project/root/pull/1937:117,performance,failur,failures,117,[TDF][TO REVERT] Use ProcessLine instead of Calc for jitting; ...in the hope to get a clearer picture about the test failures. when jitting,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1937
https://github.com/root-project/root/pull/1937:117,reliability,fail,failures,117,[TDF][TO REVERT] Use ProcessLine instead of Calc for jitting; ...in the hope to get a clearer picture about the test failures. when jitting,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1937
https://github.com/root-project/root/pull/1937:112,safety,test,test,112,[TDF][TO REVERT] Use ProcessLine instead of Calc for jitting; ...in the hope to get a clearer picture about the test failures. when jitting,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1937
https://github.com/root-project/root/pull/1937:112,testability,test,test,112,[TDF][TO REVERT] Use ProcessLine instead of Calc for jitting; ...in the hope to get a clearer picture about the test failures. when jitting,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1937
https://github.com/root-project/root/pull/1937:86,usability,clear,clearer,86,[TDF][TO REVERT] Use ProcessLine instead of Calc for jitting; ...in the hope to get a clearer picture about the test failures. when jitting,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1937
https://github.com/root-project/root/pull/1938:68,availability,failur,failures,68,[TDF] Avoid accessing zero-length TTreeReaderArray; This should fix failures in `test_readTotemNtuple` that started happening after the switch from `Calc` to `ProcessLine` (the access to the zero-length ReaderArrays was caught by `ProcessLine`'s instrumentation).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1938
https://github.com/root-project/root/pull/1938:68,deployability,fail,failures,68,[TDF] Avoid accessing zero-length TTreeReaderArray; This should fix failures in `test_readTotemNtuple` that started happening after the switch from `Calc` to `ProcessLine` (the access to the zero-length ReaderArrays was caught by `ProcessLine`'s instrumentation).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1938
https://github.com/root-project/root/pull/1938:68,performance,failur,failures,68,[TDF] Avoid accessing zero-length TTreeReaderArray; This should fix failures in `test_readTotemNtuple` that started happening after the switch from `Calc` to `ProcessLine` (the access to the zero-length ReaderArrays was caught by `ProcessLine`'s instrumentation).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1938
https://github.com/root-project/root/pull/1938:68,reliability,fail,failures,68,[TDF] Avoid accessing zero-length TTreeReaderArray; This should fix failures in `test_readTotemNtuple` that started happening after the switch from `Calc` to `ProcessLine` (the access to the zero-length ReaderArrays was caught by `ProcessLine`'s instrumentation).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1938
https://github.com/root-project/root/pull/1938:6,safety,Avoid,Avoid,6,[TDF] Avoid accessing zero-length TTreeReaderArray; This should fix failures in `test_readTotemNtuple` that started happening after the switch from `Calc` to `ProcessLine` (the access to the zero-length ReaderArrays was caught by `ProcessLine`'s instrumentation).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1938
https://github.com/root-project/root/pull/1938:12,security,access,accessing,12,[TDF] Avoid accessing zero-length TTreeReaderArray; This should fix failures in `test_readTotemNtuple` that started happening after the switch from `Calc` to `ProcessLine` (the access to the zero-length ReaderArrays was caught by `ProcessLine`'s instrumentation).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1938
https://github.com/root-project/root/pull/1938:177,security,access,access,177,[TDF] Avoid accessing zero-length TTreeReaderArray; This should fix failures in `test_readTotemNtuple` that started happening after the switch from `Calc` to `ProcessLine` (the access to the zero-length ReaderArrays was caught by `ProcessLine`'s instrumentation).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1938
https://github.com/root-project/root/pull/1938:246,testability,instrument,instrumentation,246,[TDF] Avoid accessing zero-length TTreeReaderArray; This should fix failures in `test_readTotemNtuple` that started happening after the switch from `Calc` to `ProcessLine` (the access to the zero-length ReaderArrays was caught by `ProcessLine`'s instrumentation).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1938
https://github.com/root-project/root/pull/1939:97,energy efficiency,optim,optimize,97,"[TDF] Template TInterface over the derived TDataSource type ; This will allow, in the future, to optimize loading of entries. from TDataSources: `GetColumnReaders` does not have to pass through. virtual calls to `TDataSource` anymore, which means that concrete. TDS's can provide custom, possibly lazy column readers which. TInterface will use directly. Concretely I would make this mechanism opt-in: TDataSources can still implement the usual `GetColumnReadersImpl` method, but if they implement `GetColumnReadersFast<T>` (better names are welcome) `TInterface` will switch to using that one. `GetColumnReadersFast<T>` is not limited to returning `vector<void *>` but can return smart objects which behave like pointers but can perform e.g. callbacks to their TDataSource. This basically allows `TDataSources` to implement a mechanism similar to `TTreeReader`/`TTreeReaderValue`, if required for performance reasons or in order to implement certain features.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1939
https://github.com/root-project/root/pull/1939:106,energy efficiency,load,loading,106,"[TDF] Template TInterface over the derived TDataSource type ; This will allow, in the future, to optimize loading of entries. from TDataSources: `GetColumnReaders` does not have to pass through. virtual calls to `TDataSource` anymore, which means that concrete. TDS's can provide custom, possibly lazy column readers which. TInterface will use directly. Concretely I would make this mechanism opt-in: TDataSources can still implement the usual `GetColumnReadersImpl` method, but if they implement `GetColumnReadersFast<T>` (better names are welcome) `TInterface` will switch to using that one. `GetColumnReadersFast<T>` is not limited to returning `vector<void *>` but can return smart objects which behave like pointers but can perform e.g. callbacks to their TDataSource. This basically allows `TDataSources` to implement a mechanism similar to `TTreeReader`/`TTreeReaderValue`, if required for performance reasons or in order to implement certain features.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1939
https://github.com/root-project/root/pull/1939:97,performance,optimiz,optimize,97,"[TDF] Template TInterface over the derived TDataSource type ; This will allow, in the future, to optimize loading of entries. from TDataSources: `GetColumnReaders` does not have to pass through. virtual calls to `TDataSource` anymore, which means that concrete. TDS's can provide custom, possibly lazy column readers which. TInterface will use directly. Concretely I would make this mechanism opt-in: TDataSources can still implement the usual `GetColumnReadersImpl` method, but if they implement `GetColumnReadersFast<T>` (better names are welcome) `TInterface` will switch to using that one. `GetColumnReadersFast<T>` is not limited to returning `vector<void *>` but can return smart objects which behave like pointers but can perform e.g. callbacks to their TDataSource. This basically allows `TDataSources` to implement a mechanism similar to `TTreeReader`/`TTreeReaderValue`, if required for performance reasons or in order to implement certain features.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1939
https://github.com/root-project/root/pull/1939:106,performance,load,loading,106,"[TDF] Template TInterface over the derived TDataSource type ; This will allow, in the future, to optimize loading of entries. from TDataSources: `GetColumnReaders` does not have to pass through. virtual calls to `TDataSource` anymore, which means that concrete. TDS's can provide custom, possibly lazy column readers which. TInterface will use directly. Concretely I would make this mechanism opt-in: TDataSources can still implement the usual `GetColumnReadersImpl` method, but if they implement `GetColumnReadersFast<T>` (better names are welcome) `TInterface` will switch to using that one. `GetColumnReadersFast<T>` is not limited to returning `vector<void *>` but can return smart objects which behave like pointers but can perform e.g. callbacks to their TDataSource. This basically allows `TDataSources` to implement a mechanism similar to `TTreeReader`/`TTreeReaderValue`, if required for performance reasons or in order to implement certain features.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1939
https://github.com/root-project/root/pull/1939:729,performance,perform,perform,729,"[TDF] Template TInterface over the derived TDataSource type ; This will allow, in the future, to optimize loading of entries. from TDataSources: `GetColumnReaders` does not have to pass through. virtual calls to `TDataSource` anymore, which means that concrete. TDS's can provide custom, possibly lazy column readers which. TInterface will use directly. Concretely I would make this mechanism opt-in: TDataSources can still implement the usual `GetColumnReadersImpl` method, but if they implement `GetColumnReadersFast<T>` (better names are welcome) `TInterface` will switch to using that one. `GetColumnReadersFast<T>` is not limited to returning `vector<void *>` but can return smart objects which behave like pointers but can perform e.g. callbacks to their TDataSource. This basically allows `TDataSources` to implement a mechanism similar to `TTreeReader`/`TTreeReaderValue`, if required for performance reasons or in order to implement certain features.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1939
https://github.com/root-project/root/pull/1939:897,performance,perform,performance,897,"[TDF] Template TInterface over the derived TDataSource type ; This will allow, in the future, to optimize loading of entries. from TDataSources: `GetColumnReaders` does not have to pass through. virtual calls to `TDataSource` anymore, which means that concrete. TDS's can provide custom, possibly lazy column readers which. TInterface will use directly. Concretely I would make this mechanism opt-in: TDataSources can still implement the usual `GetColumnReadersImpl` method, but if they implement `GetColumnReadersFast<T>` (better names are welcome) `TInterface` will switch to using that one. `GetColumnReadersFast<T>` is not limited to returning `vector<void *>` but can return smart objects which behave like pointers but can perform e.g. callbacks to their TDataSource. This basically allows `TDataSources` to implement a mechanism similar to `TTreeReader`/`TTreeReaderValue`, if required for performance reasons or in order to implement certain features.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1939
https://github.com/root-project/root/pull/1939:164,reliability,doe,does,164,"[TDF] Template TInterface over the derived TDataSource type ; This will allow, in the future, to optimize loading of entries. from TDataSources: `GetColumnReaders` does not have to pass through. virtual calls to `TDataSource` anymore, which means that concrete. TDS's can provide custom, possibly lazy column readers which. TInterface will use directly. Concretely I would make this mechanism opt-in: TDataSources can still implement the usual `GetColumnReadersImpl` method, but if they implement `GetColumnReadersFast<T>` (better names are welcome) `TInterface` will switch to using that one. `GetColumnReadersFast<T>` is not limited to returning `vector<void *>` but can return smart objects which behave like pointers but can perform e.g. callbacks to their TDataSource. This basically allows `TDataSources` to implement a mechanism similar to `TTreeReader`/`TTreeReaderValue`, if required for performance reasons or in order to implement certain features.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1939
https://github.com/root-project/root/pull/1939:280,usability,custom,custom,280,"[TDF] Template TInterface over the derived TDataSource type ; This will allow, in the future, to optimize loading of entries. from TDataSources: `GetColumnReaders` does not have to pass through. virtual calls to `TDataSource` anymore, which means that concrete. TDS's can provide custom, possibly lazy column readers which. TInterface will use directly. Concretely I would make this mechanism opt-in: TDataSources can still implement the usual `GetColumnReadersImpl` method, but if they implement `GetColumnReadersFast<T>` (better names are welcome) `TInterface` will switch to using that one. `GetColumnReadersFast<T>` is not limited to returning `vector<void *>` but can return smart objects which behave like pointers but can perform e.g. callbacks to their TDataSource. This basically allows `TDataSources` to implement a mechanism similar to `TTreeReader`/`TTreeReaderValue`, if required for performance reasons or in order to implement certain features.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1939
https://github.com/root-project/root/pull/1939:729,usability,perform,perform,729,"[TDF] Template TInterface over the derived TDataSource type ; This will allow, in the future, to optimize loading of entries. from TDataSources: `GetColumnReaders` does not have to pass through. virtual calls to `TDataSource` anymore, which means that concrete. TDS's can provide custom, possibly lazy column readers which. TInterface will use directly. Concretely I would make this mechanism opt-in: TDataSources can still implement the usual `GetColumnReadersImpl` method, but if they implement `GetColumnReadersFast<T>` (better names are welcome) `TInterface` will switch to using that one. `GetColumnReadersFast<T>` is not limited to returning `vector<void *>` but can return smart objects which behave like pointers but can perform e.g. callbacks to their TDataSource. This basically allows `TDataSources` to implement a mechanism similar to `TTreeReader`/`TTreeReaderValue`, if required for performance reasons or in order to implement certain features.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1939
https://github.com/root-project/root/pull/1939:897,usability,perform,performance,897,"[TDF] Template TInterface over the derived TDataSource type ; This will allow, in the future, to optimize loading of entries. from TDataSources: `GetColumnReaders` does not have to pass through. virtual calls to `TDataSource` anymore, which means that concrete. TDS's can provide custom, possibly lazy column readers which. TInterface will use directly. Concretely I would make this mechanism opt-in: TDataSources can still implement the usual `GetColumnReadersImpl` method, but if they implement `GetColumnReadersFast<T>` (better names are welcome) `TInterface` will switch to using that one. `GetColumnReadersFast<T>` is not limited to returning `vector<void *>` but can return smart objects which behave like pointers but can perform e.g. callbacks to their TDataSource. This basically allows `TDataSources` to implement a mechanism similar to `TTreeReader`/`TTreeReaderValue`, if required for performance reasons or in order to implement certain features.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1939
https://github.com/root-project/root/pull/1941:53,deployability,build,build,53,"[TMVA] Doc -- Modernise Quick Start chapter; Changes build instructions, where to get help and code examples.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1941
https://github.com/root-project/root/pull/1941:86,usability,help,help,86,"[TMVA] Doc -- Modernise Quick Start chapter; Changes build instructions, where to get help and code examples.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1941
https://github.com/root-project/root/pull/1943:69,reliability,doe,does,69,bug-fix: MinimumBuilder.cxx has an include issue; MinimumBuilder.cxx does not compile if neither WARNINGMSG nor DEBUG is set. Cherry-picked from #1677 to isolate that change from this one.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1943
https://github.com/root-project/root/pull/1943:155,safety,isol,isolate,155,bug-fix: MinimumBuilder.cxx has an include issue; MinimumBuilder.cxx does not compile if neither WARNINGMSG nor DEBUG is set. Cherry-picked from #1677 to isolate that change from this one.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1943
https://github.com/root-project/root/pull/1943:155,security,iso,isolate,155,bug-fix: MinimumBuilder.cxx has an include issue; MinimumBuilder.cxx does not compile if neither WARNINGMSG nor DEBUG is set. Cherry-picked from #1677 to isolate that change from this one.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1943
https://github.com/root-project/root/pull/1943:155,testability,isol,isolate,155,bug-fix: MinimumBuilder.cxx has an include issue; MinimumBuilder.cxx does not compile if neither WARNINGMSG nor DEBUG is set. Cherry-picked from #1677 to isolate that change from this one.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1943
https://github.com/root-project/root/pull/1943:9,usability,Minim,MinimumBuilder,9,bug-fix: MinimumBuilder.cxx has an include issue; MinimumBuilder.cxx does not compile if neither WARNINGMSG nor DEBUG is set. Cherry-picked from #1677 to isolate that change from this one.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1943
https://github.com/root-project/root/pull/1943:50,usability,Minim,MinimumBuilder,50,bug-fix: MinimumBuilder.cxx has an include issue; MinimumBuilder.cxx does not compile if neither WARNINGMSG nor DEBUG is set. Cherry-picked from #1677 to isolate that change from this one.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1943
https://github.com/root-project/root/pull/1944:131,reliability,doe,does,131,[WIP Do not touch][VecOps] Test Autoloading on Ubu 16.04 gcc 5.4; Test inlining of TVec<(unsigned) long long> ad their autoloading does not work on ubu 16.04 gcc 5.4,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1944
https://github.com/root-project/root/pull/1944:27,safety,Test,Test,27,[WIP Do not touch][VecOps] Test Autoloading on Ubu 16.04 gcc 5.4; Test inlining of TVec<(unsigned) long long> ad their autoloading does not work on ubu 16.04 gcc 5.4,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1944
https://github.com/root-project/root/pull/1944:66,safety,Test,Test,66,[WIP Do not touch][VecOps] Test Autoloading on Ubu 16.04 gcc 5.4; Test inlining of TVec<(unsigned) long long> ad their autoloading does not work on ubu 16.04 gcc 5.4,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1944
https://github.com/root-project/root/pull/1944:27,testability,Test,Test,27,[WIP Do not touch][VecOps] Test Autoloading on Ubu 16.04 gcc 5.4; Test inlining of TVec<(unsigned) long long> ad their autoloading does not work on ubu 16.04 gcc 5.4,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1944
https://github.com/root-project/root/pull/1944:66,testability,Test,Test,66,[WIP Do not touch][VecOps] Test Autoloading on Ubu 16.04 gcc 5.4; Test inlining of TVec<(unsigned) long long> ad their autoloading does not work on ubu 16.04 gcc 5.4,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1944
https://github.com/root-project/root/pull/1946:17,deployability,version,version,17,"Adding non const version of Minimizer; I think this is the correct fix for #1677; the non-const version of `Minimizer()` was missing from the interface. `Builder()` already has both const and non-const versions, so this should be enough to fix the chain `MnMigrad.Minimizer().Builder().SetPrintLevel(...)`. @HDembinski please check.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1946
https://github.com/root-project/root/pull/1946:96,deployability,version,version,96,"Adding non const version of Minimizer; I think this is the correct fix for #1677; the non-const version of `Minimizer()` was missing from the interface. `Builder()` already has both const and non-const versions, so this should be enough to fix the chain `MnMigrad.Minimizer().Builder().SetPrintLevel(...)`. @HDembinski please check.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1946
https://github.com/root-project/root/pull/1946:154,deployability,Build,Builder,154,"Adding non const version of Minimizer; I think this is the correct fix for #1677; the non-const version of `Minimizer()` was missing from the interface. `Builder()` already has both const and non-const versions, so this should be enough to fix the chain `MnMigrad.Minimizer().Builder().SetPrintLevel(...)`. @HDembinski please check.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1946
https://github.com/root-project/root/pull/1946:202,deployability,version,versions,202,"Adding non const version of Minimizer; I think this is the correct fix for #1677; the non-const version of `Minimizer()` was missing from the interface. `Builder()` already has both const and non-const versions, so this should be enough to fix the chain `MnMigrad.Minimizer().Builder().SetPrintLevel(...)`. @HDembinski please check.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1946
https://github.com/root-project/root/pull/1946:276,deployability,Build,Builder,276,"Adding non const version of Minimizer; I think this is the correct fix for #1677; the non-const version of `Minimizer()` was missing from the interface. `Builder()` already has both const and non-const versions, so this should be enough to fix the chain `MnMigrad.Minimizer().Builder().SetPrintLevel(...)`. @HDembinski please check.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1946
https://github.com/root-project/root/pull/1946:17,integrability,version,version,17,"Adding non const version of Minimizer; I think this is the correct fix for #1677; the non-const version of `Minimizer()` was missing from the interface. `Builder()` already has both const and non-const versions, so this should be enough to fix the chain `MnMigrad.Minimizer().Builder().SetPrintLevel(...)`. @HDembinski please check.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1946
https://github.com/root-project/root/pull/1946:96,integrability,version,version,96,"Adding non const version of Minimizer; I think this is the correct fix for #1677; the non-const version of `Minimizer()` was missing from the interface. `Builder()` already has both const and non-const versions, so this should be enough to fix the chain `MnMigrad.Minimizer().Builder().SetPrintLevel(...)`. @HDembinski please check.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1946
https://github.com/root-project/root/pull/1946:142,integrability,interfac,interface,142,"Adding non const version of Minimizer; I think this is the correct fix for #1677; the non-const version of `Minimizer()` was missing from the interface. `Builder()` already has both const and non-const versions, so this should be enough to fix the chain `MnMigrad.Minimizer().Builder().SetPrintLevel(...)`. @HDembinski please check.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1946
https://github.com/root-project/root/pull/1946:202,integrability,version,versions,202,"Adding non const version of Minimizer; I think this is the correct fix for #1677; the non-const version of `Minimizer()` was missing from the interface. `Builder()` already has both const and non-const versions, so this should be enough to fix the chain `MnMigrad.Minimizer().Builder().SetPrintLevel(...)`. @HDembinski please check.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1946
https://github.com/root-project/root/pull/1946:142,interoperability,interfac,interface,142,"Adding non const version of Minimizer; I think this is the correct fix for #1677; the non-const version of `Minimizer()` was missing from the interface. `Builder()` already has both const and non-const versions, so this should be enough to fix the chain `MnMigrad.Minimizer().Builder().SetPrintLevel(...)`. @HDembinski please check.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1946
https://github.com/root-project/root/pull/1946:17,modifiability,version,version,17,"Adding non const version of Minimizer; I think this is the correct fix for #1677; the non-const version of `Minimizer()` was missing from the interface. `Builder()` already has both const and non-const versions, so this should be enough to fix the chain `MnMigrad.Minimizer().Builder().SetPrintLevel(...)`. @HDembinski please check.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1946
https://github.com/root-project/root/pull/1946:96,modifiability,version,version,96,"Adding non const version of Minimizer; I think this is the correct fix for #1677; the non-const version of `Minimizer()` was missing from the interface. `Builder()` already has both const and non-const versions, so this should be enough to fix the chain `MnMigrad.Minimizer().Builder().SetPrintLevel(...)`. @HDembinski please check.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1946
https://github.com/root-project/root/pull/1946:142,modifiability,interfac,interface,142,"Adding non const version of Minimizer; I think this is the correct fix for #1677; the non-const version of `Minimizer()` was missing from the interface. `Builder()` already has both const and non-const versions, so this should be enough to fix the chain `MnMigrad.Minimizer().Builder().SetPrintLevel(...)`. @HDembinski please check.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1946
https://github.com/root-project/root/pull/1946:202,modifiability,version,versions,202,"Adding non const version of Minimizer; I think this is the correct fix for #1677; the non-const version of `Minimizer()` was missing from the interface. `Builder()` already has both const and non-const versions, so this should be enough to fix the chain `MnMigrad.Minimizer().Builder().SetPrintLevel(...)`. @HDembinski please check.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1946
https://github.com/root-project/root/pull/1946:28,usability,Minim,Minimizer,28,"Adding non const version of Minimizer; I think this is the correct fix for #1677; the non-const version of `Minimizer()` was missing from the interface. `Builder()` already has both const and non-const versions, so this should be enough to fix the chain `MnMigrad.Minimizer().Builder().SetPrintLevel(...)`. @HDembinski please check.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1946
https://github.com/root-project/root/pull/1946:108,usability,Minim,Minimizer,108,"Adding non const version of Minimizer; I think this is the correct fix for #1677; the non-const version of `Minimizer()` was missing from the interface. `Builder()` already has both const and non-const versions, so this should be enough to fix the chain `MnMigrad.Minimizer().Builder().SetPrintLevel(...)`. @HDembinski please check.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1946
https://github.com/root-project/root/pull/1946:264,usability,Minim,Minimizer,264,"Adding non const version of Minimizer; I think this is the correct fix for #1677; the non-const version of `Minimizer()` was missing from the interface. `Builder()` already has both const and non-const versions, so this should be enough to fix the chain `MnMigrad.Minimizer().Builder().SetPrintLevel(...)`. @HDembinski please check.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1946
https://github.com/root-project/root/pull/1947:24,availability,failur,failures,24,[cxxmodules] Fix recent failures due to VecOps namespace lookups.;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1947
https://github.com/root-project/root/pull/1947:24,deployability,fail,failures,24,[cxxmodules] Fix recent failures due to VecOps namespace lookups.;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1947
https://github.com/root-project/root/pull/1947:24,performance,failur,failures,24,[cxxmodules] Fix recent failures due to VecOps namespace lookups.;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1947
https://github.com/root-project/root/pull/1947:24,reliability,fail,failures,24,[cxxmodules] Fix recent failures due to VecOps namespace lookups.;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1947
https://github.com/root-project/root/pull/1948:152,availability,error,errors,152,"[VecOps] Do not use extern templates on Windows, Linux gcc48/clang(all versions); this functionality has been removed since there are still compilation errors.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1948
https://github.com/root-project/root/pull/1948:71,deployability,version,versions,71,"[VecOps] Do not use extern templates on Windows, Linux gcc48/clang(all versions); this functionality has been removed since there are still compilation errors.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1948
https://github.com/root-project/root/pull/1948:71,integrability,version,versions,71,"[VecOps] Do not use extern templates on Windows, Linux gcc48/clang(all versions); this functionality has been removed since there are still compilation errors.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1948
https://github.com/root-project/root/pull/1948:71,modifiability,version,versions,71,"[VecOps] Do not use extern templates on Windows, Linux gcc48/clang(all versions); this functionality has been removed since there are still compilation errors.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1948
https://github.com/root-project/root/pull/1948:152,performance,error,errors,152,"[VecOps] Do not use extern templates on Windows, Linux gcc48/clang(all versions); this functionality has been removed since there are still compilation errors.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1948
https://github.com/root-project/root/pull/1948:152,safety,error,errors,152,"[VecOps] Do not use extern templates on Windows, Linux gcc48/clang(all versions); this functionality has been removed since there are still compilation errors.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1948
https://github.com/root-project/root/pull/1948:152,usability,error,errors,152,"[VecOps] Do not use extern templates on Windows, Linux gcc48/clang(all versions); this functionality has been removed since there are still compilation errors.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1948
https://github.com/root-project/root/pull/1950:67,deployability,fail,failing,67,[PyROOT] Fix TTree.AsMatrix unit-test for 32bit systems; Fixes the failing test [here](http://cdash.cern.ch/testDetails.php?test=42349361&build=497461). Treats `long` types on 32bit as `int`s.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1950
https://github.com/root-project/root/pull/1950:138,deployability,build,build,138,[PyROOT] Fix TTree.AsMatrix unit-test for 32bit systems; Fixes the failing test [here](http://cdash.cern.ch/testDetails.php?test=42349361&build=497461). Treats `long` types on 32bit as `int`s.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1950
https://github.com/root-project/root/pull/1950:67,reliability,fail,failing,67,[PyROOT] Fix TTree.AsMatrix unit-test for 32bit systems; Fixes the failing test [here](http://cdash.cern.ch/testDetails.php?test=42349361&build=497461). Treats `long` types on 32bit as `int`s.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1950
https://github.com/root-project/root/pull/1950:33,safety,test,test,33,[PyROOT] Fix TTree.AsMatrix unit-test for 32bit systems; Fixes the failing test [here](http://cdash.cern.ch/testDetails.php?test=42349361&build=497461). Treats `long` types on 32bit as `int`s.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1950
https://github.com/root-project/root/pull/1950:75,safety,test,test,75,[PyROOT] Fix TTree.AsMatrix unit-test for 32bit systems; Fixes the failing test [here](http://cdash.cern.ch/testDetails.php?test=42349361&build=497461). Treats `long` types on 32bit as `int`s.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1950
https://github.com/root-project/root/pull/1950:108,safety,test,testDetails,108,[PyROOT] Fix TTree.AsMatrix unit-test for 32bit systems; Fixes the failing test [here](http://cdash.cern.ch/testDetails.php?test=42349361&build=497461). Treats `long` types on 32bit as `int`s.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1950
https://github.com/root-project/root/pull/1950:124,safety,test,test,124,[PyROOT] Fix TTree.AsMatrix unit-test for 32bit systems; Fixes the failing test [here](http://cdash.cern.ch/testDetails.php?test=42349361&build=497461). Treats `long` types on 32bit as `int`s.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1950
https://github.com/root-project/root/pull/1950:28,testability,unit,unit-test,28,[PyROOT] Fix TTree.AsMatrix unit-test for 32bit systems; Fixes the failing test [here](http://cdash.cern.ch/testDetails.php?test=42349361&build=497461). Treats `long` types on 32bit as `int`s.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1950
https://github.com/root-project/root/pull/1950:75,testability,test,test,75,[PyROOT] Fix TTree.AsMatrix unit-test for 32bit systems; Fixes the failing test [here](http://cdash.cern.ch/testDetails.php?test=42349361&build=497461). Treats `long` types on 32bit as `int`s.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1950
https://github.com/root-project/root/pull/1950:108,testability,test,testDetails,108,[PyROOT] Fix TTree.AsMatrix unit-test for 32bit systems; Fixes the failing test [here](http://cdash.cern.ch/testDetails.php?test=42349361&build=497461). Treats `long` types on 32bit as `int`s.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1950
https://github.com/root-project/root/pull/1950:124,testability,test,test,124,[PyROOT] Fix TTree.AsMatrix unit-test for 32bit systems; Fixes the failing test [here](http://cdash.cern.ch/testDetails.php?test=42349361&build=497461). Treats `long` types on 32bit as `int`s.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1950
https://github.com/root-project/root/pull/1951:12,usability,support,support,12,Introducing support for extra cases of llvm5 binaries for builtin_llvm=OFF;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1951
https://github.com/root-project/root/pull/1952:80,deployability,fail,fails,80,"Revert ""Autoload canonical namespaces""; Reverts root-project/root#1547. This PR fails projectroot.roottest.root.treeproxy.roottest_root_treeproxy_make by spuriously loading libRooFit.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1952
https://github.com/root-project/root/pull/1952:165,energy efficiency,load,loading,165,"Revert ""Autoload canonical namespaces""; Reverts root-project/root#1547. This PR fails projectroot.roottest.root.treeproxy.roottest_root_treeproxy_make by spuriously loading libRooFit.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1952
https://github.com/root-project/root/pull/1952:165,performance,load,loading,165,"Revert ""Autoload canonical namespaces""; Reverts root-project/root#1547. This PR fails projectroot.roottest.root.treeproxy.roottest_root_treeproxy_make by spuriously loading libRooFit.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1952
https://github.com/root-project/root/pull/1952:80,reliability,fail,fails,80,"Revert ""Autoload canonical namespaces""; Reverts root-project/root#1547. This PR fails projectroot.roottest.root.treeproxy.roottest_root_treeproxy_make by spuriously loading libRooFit.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1952
https://github.com/root-project/root/pull/1953:26,safety,test,test,26,cling::printValue() cling-test fixes;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1953
https://github.com/root-project/root/pull/1953:26,testability,test,test,26,cling::printValue() cling-test fixes;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1953
https://github.com/root-project/root/pull/1955:37,deployability,patch,patches,37,Fix option of having clang with ROOT patches as an external package (builtin_clang=OFF); Fixing linking of Clang libraries for Cling and rootcling_stage1 in case of builtin_clang=OFF.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1955
https://github.com/root-project/root/pull/1955:60,modifiability,pac,package,60,Fix option of having clang with ROOT patches as an external package (builtin_clang=OFF); Fixing linking of Clang libraries for Cling and rootcling_stage1 in case of builtin_clang=OFF.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1955
https://github.com/root-project/root/pull/1955:37,safety,patch,patches,37,Fix option of having clang with ROOT patches as an external package (builtin_clang=OFF); Fixing linking of Clang libraries for Cling and rootcling_stage1 in case of builtin_clang=OFF.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1955
https://github.com/root-project/root/pull/1955:37,security,patch,patches,37,Fix option of having clang with ROOT patches as an external package (builtin_clang=OFF); Fixing linking of Clang libraries for Cling and rootcling_stage1 in case of builtin_clang=OFF.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1955
https://github.com/root-project/root/pull/1957:73,availability,failur,failures,73,[PyROOT] Fix TTree.AsMatrix tutorial for Mac OS; This PR fixes following failures:. 1. http://cdash.cern.ch/testDetails.php?test=42006642&build=497548. 2. http://cdash.cern.ch/testDetails.php?test=42274691&build=497583. Before merging it should be understood why. @etejedor The tests for `TTree.AsMatrix` run all fine but the tutorial fails occasionally with a segfault (only on Mac OS and only on these two versions). It is not related to the `TTree.AsMatrix` code but to the creation of a `TFile` inside a Python function. Any ideas?,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1957
https://github.com/root-project/root/pull/1957:73,deployability,fail,failures,73,[PyROOT] Fix TTree.AsMatrix tutorial for Mac OS; This PR fixes following failures:. 1. http://cdash.cern.ch/testDetails.php?test=42006642&build=497548. 2. http://cdash.cern.ch/testDetails.php?test=42274691&build=497583. Before merging it should be understood why. @etejedor The tests for `TTree.AsMatrix` run all fine but the tutorial fails occasionally with a segfault (only on Mac OS and only on these two versions). It is not related to the `TTree.AsMatrix` code but to the creation of a `TFile` inside a Python function. Any ideas?,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1957
https://github.com/root-project/root/pull/1957:138,deployability,build,build,138,[PyROOT] Fix TTree.AsMatrix tutorial for Mac OS; This PR fixes following failures:. 1. http://cdash.cern.ch/testDetails.php?test=42006642&build=497548. 2. http://cdash.cern.ch/testDetails.php?test=42274691&build=497583. Before merging it should be understood why. @etejedor The tests for `TTree.AsMatrix` run all fine but the tutorial fails occasionally with a segfault (only on Mac OS and only on these two versions). It is not related to the `TTree.AsMatrix` code but to the creation of a `TFile` inside a Python function. Any ideas?,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1957
https://github.com/root-project/root/pull/1957:206,deployability,build,build,206,[PyROOT] Fix TTree.AsMatrix tutorial for Mac OS; This PR fixes following failures:. 1. http://cdash.cern.ch/testDetails.php?test=42006642&build=497548. 2. http://cdash.cern.ch/testDetails.php?test=42274691&build=497583. Before merging it should be understood why. @etejedor The tests for `TTree.AsMatrix` run all fine but the tutorial fails occasionally with a segfault (only on Mac OS and only on these two versions). It is not related to the `TTree.AsMatrix` code but to the creation of a `TFile` inside a Python function. Any ideas?,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1957
https://github.com/root-project/root/pull/1957:335,deployability,fail,fails,335,[PyROOT] Fix TTree.AsMatrix tutorial for Mac OS; This PR fixes following failures:. 1. http://cdash.cern.ch/testDetails.php?test=42006642&build=497548. 2. http://cdash.cern.ch/testDetails.php?test=42274691&build=497583. Before merging it should be understood why. @etejedor The tests for `TTree.AsMatrix` run all fine but the tutorial fails occasionally with a segfault (only on Mac OS and only on these two versions). It is not related to the `TTree.AsMatrix` code but to the creation of a `TFile` inside a Python function. Any ideas?,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1957
https://github.com/root-project/root/pull/1957:408,deployability,version,versions,408,[PyROOT] Fix TTree.AsMatrix tutorial for Mac OS; This PR fixes following failures:. 1. http://cdash.cern.ch/testDetails.php?test=42006642&build=497548. 2. http://cdash.cern.ch/testDetails.php?test=42274691&build=497583. Before merging it should be understood why. @etejedor The tests for `TTree.AsMatrix` run all fine but the tutorial fails occasionally with a segfault (only on Mac OS and only on these two versions). It is not related to the `TTree.AsMatrix` code but to the creation of a `TFile` inside a Python function. Any ideas?,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1957
https://github.com/root-project/root/pull/1957:408,integrability,version,versions,408,[PyROOT] Fix TTree.AsMatrix tutorial for Mac OS; This PR fixes following failures:. 1. http://cdash.cern.ch/testDetails.php?test=42006642&build=497548. 2. http://cdash.cern.ch/testDetails.php?test=42274691&build=497583. Before merging it should be understood why. @etejedor The tests for `TTree.AsMatrix` run all fine but the tutorial fails occasionally with a segfault (only on Mac OS and only on these two versions). It is not related to the `TTree.AsMatrix` code but to the creation of a `TFile` inside a Python function. Any ideas?,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1957
https://github.com/root-project/root/pull/1957:408,modifiability,version,versions,408,[PyROOT] Fix TTree.AsMatrix tutorial for Mac OS; This PR fixes following failures:. 1. http://cdash.cern.ch/testDetails.php?test=42006642&build=497548. 2. http://cdash.cern.ch/testDetails.php?test=42274691&build=497583. Before merging it should be understood why. @etejedor The tests for `TTree.AsMatrix` run all fine but the tutorial fails occasionally with a segfault (only on Mac OS and only on these two versions). It is not related to the `TTree.AsMatrix` code but to the creation of a `TFile` inside a Python function. Any ideas?,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1957
https://github.com/root-project/root/pull/1957:73,performance,failur,failures,73,[PyROOT] Fix TTree.AsMatrix tutorial for Mac OS; This PR fixes following failures:. 1. http://cdash.cern.ch/testDetails.php?test=42006642&build=497548. 2. http://cdash.cern.ch/testDetails.php?test=42274691&build=497583. Before merging it should be understood why. @etejedor The tests for `TTree.AsMatrix` run all fine but the tutorial fails occasionally with a segfault (only on Mac OS and only on these two versions). It is not related to the `TTree.AsMatrix` code but to the creation of a `TFile` inside a Python function. Any ideas?,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1957
https://github.com/root-project/root/pull/1957:73,reliability,fail,failures,73,[PyROOT] Fix TTree.AsMatrix tutorial for Mac OS; This PR fixes following failures:. 1. http://cdash.cern.ch/testDetails.php?test=42006642&build=497548. 2. http://cdash.cern.ch/testDetails.php?test=42274691&build=497583. Before merging it should be understood why. @etejedor The tests for `TTree.AsMatrix` run all fine but the tutorial fails occasionally with a segfault (only on Mac OS and only on these two versions). It is not related to the `TTree.AsMatrix` code but to the creation of a `TFile` inside a Python function. Any ideas?,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1957
https://github.com/root-project/root/pull/1957:335,reliability,fail,fails,335,[PyROOT] Fix TTree.AsMatrix tutorial for Mac OS; This PR fixes following failures:. 1. http://cdash.cern.ch/testDetails.php?test=42006642&build=497548. 2. http://cdash.cern.ch/testDetails.php?test=42274691&build=497583. Before merging it should be understood why. @etejedor The tests for `TTree.AsMatrix` run all fine but the tutorial fails occasionally with a segfault (only on Mac OS and only on these two versions). It is not related to the `TTree.AsMatrix` code but to the creation of a `TFile` inside a Python function. Any ideas?,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1957
https://github.com/root-project/root/pull/1957:108,safety,test,testDetails,108,[PyROOT] Fix TTree.AsMatrix tutorial for Mac OS; This PR fixes following failures:. 1. http://cdash.cern.ch/testDetails.php?test=42006642&build=497548. 2. http://cdash.cern.ch/testDetails.php?test=42274691&build=497583. Before merging it should be understood why. @etejedor The tests for `TTree.AsMatrix` run all fine but the tutorial fails occasionally with a segfault (only on Mac OS and only on these two versions). It is not related to the `TTree.AsMatrix` code but to the creation of a `TFile` inside a Python function. Any ideas?,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1957
https://github.com/root-project/root/pull/1957:124,safety,test,test,124,[PyROOT] Fix TTree.AsMatrix tutorial for Mac OS; This PR fixes following failures:. 1. http://cdash.cern.ch/testDetails.php?test=42006642&build=497548. 2. http://cdash.cern.ch/testDetails.php?test=42274691&build=497583. Before merging it should be understood why. @etejedor The tests for `TTree.AsMatrix` run all fine but the tutorial fails occasionally with a segfault (only on Mac OS and only on these two versions). It is not related to the `TTree.AsMatrix` code but to the creation of a `TFile` inside a Python function. Any ideas?,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1957
https://github.com/root-project/root/pull/1957:176,safety,test,testDetails,176,[PyROOT] Fix TTree.AsMatrix tutorial for Mac OS; This PR fixes following failures:. 1. http://cdash.cern.ch/testDetails.php?test=42006642&build=497548. 2. http://cdash.cern.ch/testDetails.php?test=42274691&build=497583. Before merging it should be understood why. @etejedor The tests for `TTree.AsMatrix` run all fine but the tutorial fails occasionally with a segfault (only on Mac OS and only on these two versions). It is not related to the `TTree.AsMatrix` code but to the creation of a `TFile` inside a Python function. Any ideas?,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1957
https://github.com/root-project/root/pull/1957:192,safety,test,test,192,[PyROOT] Fix TTree.AsMatrix tutorial for Mac OS; This PR fixes following failures:. 1. http://cdash.cern.ch/testDetails.php?test=42006642&build=497548. 2. http://cdash.cern.ch/testDetails.php?test=42274691&build=497583. Before merging it should be understood why. @etejedor The tests for `TTree.AsMatrix` run all fine but the tutorial fails occasionally with a segfault (only on Mac OS and only on these two versions). It is not related to the `TTree.AsMatrix` code but to the creation of a `TFile` inside a Python function. Any ideas?,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1957
https://github.com/root-project/root/pull/1957:278,safety,test,tests,278,[PyROOT] Fix TTree.AsMatrix tutorial for Mac OS; This PR fixes following failures:. 1. http://cdash.cern.ch/testDetails.php?test=42006642&build=497548. 2. http://cdash.cern.ch/testDetails.php?test=42274691&build=497583. Before merging it should be understood why. @etejedor The tests for `TTree.AsMatrix` run all fine but the tutorial fails occasionally with a segfault (only on Mac OS and only on these two versions). It is not related to the `TTree.AsMatrix` code but to the creation of a `TFile` inside a Python function. Any ideas?,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1957
https://github.com/root-project/root/pull/1957:108,testability,test,testDetails,108,[PyROOT] Fix TTree.AsMatrix tutorial for Mac OS; This PR fixes following failures:. 1. http://cdash.cern.ch/testDetails.php?test=42006642&build=497548. 2. http://cdash.cern.ch/testDetails.php?test=42274691&build=497583. Before merging it should be understood why. @etejedor The tests for `TTree.AsMatrix` run all fine but the tutorial fails occasionally with a segfault (only on Mac OS and only on these two versions). It is not related to the `TTree.AsMatrix` code but to the creation of a `TFile` inside a Python function. Any ideas?,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1957
https://github.com/root-project/root/pull/1957:124,testability,test,test,124,[PyROOT] Fix TTree.AsMatrix tutorial for Mac OS; This PR fixes following failures:. 1. http://cdash.cern.ch/testDetails.php?test=42006642&build=497548. 2. http://cdash.cern.ch/testDetails.php?test=42274691&build=497583. Before merging it should be understood why. @etejedor The tests for `TTree.AsMatrix` run all fine but the tutorial fails occasionally with a segfault (only on Mac OS and only on these two versions). It is not related to the `TTree.AsMatrix` code but to the creation of a `TFile` inside a Python function. Any ideas?,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1957
https://github.com/root-project/root/pull/1957:176,testability,test,testDetails,176,[PyROOT] Fix TTree.AsMatrix tutorial for Mac OS; This PR fixes following failures:. 1. http://cdash.cern.ch/testDetails.php?test=42006642&build=497548. 2. http://cdash.cern.ch/testDetails.php?test=42274691&build=497583. Before merging it should be understood why. @etejedor The tests for `TTree.AsMatrix` run all fine but the tutorial fails occasionally with a segfault (only on Mac OS and only on these two versions). It is not related to the `TTree.AsMatrix` code but to the creation of a `TFile` inside a Python function. Any ideas?,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1957
https://github.com/root-project/root/pull/1957:192,testability,test,test,192,[PyROOT] Fix TTree.AsMatrix tutorial for Mac OS; This PR fixes following failures:. 1. http://cdash.cern.ch/testDetails.php?test=42006642&build=497548. 2. http://cdash.cern.ch/testDetails.php?test=42274691&build=497583. Before merging it should be understood why. @etejedor The tests for `TTree.AsMatrix` run all fine but the tutorial fails occasionally with a segfault (only on Mac OS and only on these two versions). It is not related to the `TTree.AsMatrix` code but to the creation of a `TFile` inside a Python function. Any ideas?,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1957
https://github.com/root-project/root/pull/1957:278,testability,test,tests,278,[PyROOT] Fix TTree.AsMatrix tutorial for Mac OS; This PR fixes following failures:. 1. http://cdash.cern.ch/testDetails.php?test=42006642&build=497548. 2. http://cdash.cern.ch/testDetails.php?test=42274691&build=497583. Before merging it should be understood why. @etejedor The tests for `TTree.AsMatrix` run all fine but the tutorial fails occasionally with a segfault (only on Mac OS and only on these two versions). It is not related to the `TTree.AsMatrix` code but to the creation of a `TFile` inside a Python function. Any ideas?,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1957
https://github.com/root-project/root/pull/1958:154,availability,failur,failures,154,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:206,availability,reliab,reliably,206,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:154,deployability,fail,failures,154,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:899,deployability,version,version,899,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:899,integrability,version,version,899,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:899,modifiability,version,version,899,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:13,performance,Tune,Tune,13,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:154,performance,failur,failures,154,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:176,performance,tune,tuned,176,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:1087,performance,Time,Time,1087,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:154,reliability,fail,failures,154,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:206,reliability,reliab,reliably,206,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:31,safety,test,test,31,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:39,safety,avoid,avoid,39,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:76,safety,test,test,76,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:149,safety,test,test,149,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:168,safety,test,test,168,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:347,safety,test,testMinimization,347,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:365,safety,test,test,365,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:542,safety,test,test,542,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:551,safety,test,tested,551,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:661,safety,test,test,661,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:670,safety,test,testMinimizationCpu,670,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:786,safety,input,input,786,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:31,testability,test,test,31,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:76,testability,test,test,76,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:149,testability,test,test,149,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:168,testability,test,test,168,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:347,testability,test,testMinimization,347,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:365,testability,test,test,365,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:542,testability,test,test,542,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:551,testability,test,tested,551,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:661,testability,test,test,661,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:670,testability,test,testMinimizationCpu,670,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:18,usability,minim,minimization,18,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:66,usability,minim,minimizer,66,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:234,usability,learn,learning,234,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:291,usability,stop,stopping,291,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:374,usability,minim,minimizer,374,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1958:786,usability,input,input,786,"[TMVA] DNN - Tune minimization test to avoid false positives; The minimizer test quite often did not converge. As a result there were. many spurious test failures. The test is tuned to converge _much_ more reliably by increasing the. learning rate (0.0001 -> 0.001), and the number of early stopping epochs. (5 -> 50). This commit also makes the `testMinimization` test the minimizer. _without_ using momentum (this code path was previously untested here). The following code was used to benchmark changes (only single precision. part of the test was tested and some aux text was commented out if you. want to reproduce):. ```. for i in `seq 100`; do tmva/tmva/test/DNN/testMinimizationCpu; done | awk '{print $6;}' | python -c 'import numpy; import fileinput; a = map(float, fileinput.input()); print(numpy.std(a), numpy.mean(a), numpy.min(a), numpy.max(a))'. ```. Results (typical values):. - Old version: 2.70*10^{-7} (std dev), 3.34*10^5 (mean), 2.27*10^{-6} (min), 0.0017 (max). - New verstion: 2.59 * 10^{-6} (std dev), 2.51*10*{-6} (mean), 1.16*10*{-7} (min), 1.37*10^{-5} (max). Time taken is roughly doubled (~1 sec -> ~2 secs). All results on local mac.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1958
https://github.com/root-project/root/pull/1959:1279,availability,error,error,1279,"p a user trying to use targets:. | New target | Usage |. |---|---|. | `ROOT::Libraries` | This is the target equivalent of `ROOT_LIBRARIES`, and links all common and requested components. |. | ~~`ROOT::Flags`~~ | ~~The target equivalent of `ROOT_*_FLAGS`, `ROOT_DEFINITIONS`, and `ROOT_EXE_LINKER_FLAGS`. Adds the flags that ROOT recommends; this is a smart target and will add `C`, `CXX`, and `FORTRAN` flags as needed depending on the target you link to.~~ |. ~~I have added `_LIST` versions of `FLAGS` variables, since CMake expects the flags to be a real list in most cases (really everywhere except in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC. ROOT::Core ROOT::Imt ROOT::RIO ROOT::Net ROOT::Hist. ROOT::Graf ROOT::Graf3d ROOT::Gpad ROOT::Tree ROOT::TreePlayer. ROOT::Rint ROOT::Postscript ROOT:",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:702,deployability,depend,depending,702,"Adding a ROOT::Libraries target for Modern CMake usage; I was looking into ways to improve the target-based usage of ROOT in CMake. I found the missing `INTERFACE_INCLUDE_DIRECTORIES` has already been added to master (Yay!), but there are still other additions that could really help a user trying to use targets:. | New target | Usage |. |---|---|. | `ROOT::Libraries` | This is the target equivalent of `ROOT_LIBRARIES`, and links all common and requested components. |. | ~~`ROOT::Flags`~~ | ~~The target equivalent of `ROOT_*_FLAGS`, `ROOT_DEFINITIONS`, and `ROOT_EXE_LINKER_FLAGS`. Adds the flags that ROOT recommends; this is a smart target and will add `C`, `CXX`, and `FORTRAN` flags as needed depending on the target you link to.~~ |. ~~I have added `_LIST` versions of `FLAGS` variables, since CMake expects the flags to be a real list in most cases (really everywhere except in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and lin",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:767,deployability,version,versions,767,"Adding a ROOT::Libraries target for Modern CMake usage; I was looking into ways to improve the target-based usage of ROOT in CMake. I found the missing `INTERFACE_INCLUDE_DIRECTORIES` has already been added to master (Yay!), but there are still other additions that could really help a user trying to use targets:. | New target | Usage |. |---|---|. | `ROOT::Libraries` | This is the target equivalent of `ROOT_LIBRARIES`, and links all common and requested components. |. | ~~`ROOT::Flags`~~ | ~~The target equivalent of `ROOT_*_FLAGS`, `ROOT_DEFINITIONS`, and `ROOT_EXE_LINKER_FLAGS`. Adds the flags that ROOT recommends; this is a smart target and will add `C`, `CXX`, and `FORTRAN` flags as needed depending on the target you link to.~~ |. ~~I have added `_LIST` versions of `FLAGS` variables, since CMake expects the flags to be a real list in most cases (really everywhere except in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and lin",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:1124,deployability,VERSION,VERSION,1124,"ke. I found the missing `INTERFACE_INCLUDE_DIRECTORIES` has already been added to master (Yay!), but there are still other additions that could really help a user trying to use targets:. | New target | Usage |. |---|---|. | `ROOT::Libraries` | This is the target equivalent of `ROOT_LIBRARIES`, and links all common and requested components. |. | ~~`ROOT::Flags`~~ | ~~The target equivalent of `ROOT_*_FLAGS`, `ROOT_DEFINITIONS`, and `ROOT_EXE_LINKER_FLAGS`. Adds the flags that ROOT recommends; this is a smart target and will add `C`, `CXX`, and `FORTRAN` flags as needed depending on the target you link to.~~ |. ~~I have added `_LIST` versions of `FLAGS` variables, since CMake expects the flags to be a real list in most cases (really everywhere except in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBL",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:2445,deployability,depend,dependency,2445,"pt in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC. ROOT::Core ROOT::Imt ROOT::RIO ROOT::Net ROOT::Hist. ROOT::Graf ROOT::Graf3d ROOT::Gpad ROOT::Tree ROOT::TreePlayer. ROOT::Rint ROOT::Postscript ROOT::Matrix ROOT::Physics. ROOT::MathCore ROOT::Thread ROOT::RooFit. ROOT::Flags). ```. > Note: I'm listing all the libraries that ROOT adds by default, though due to dependency resolution, a few of them might not be needed to achieve the same result. After:. ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC ROOT::Libraries ROOT::Flags). ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:2571,deployability,VERSION,VERSION,2571,"pt in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC. ROOT::Core ROOT::Imt ROOT::RIO ROOT::Net ROOT::Hist. ROOT::Graf ROOT::Graf3d ROOT::Gpad ROOT::Tree ROOT::TreePlayer. ROOT::Rint ROOT::Postscript ROOT::Matrix ROOT::Physics. ROOT::MathCore ROOT::Thread ROOT::RooFit. ROOT::Flags). ```. > Note: I'm listing all the libraries that ROOT adds by default, though due to dependency resolution, a few of them might not be needed to achieve the same result. After:. ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC ROOT::Libraries ROOT::Flags). ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:1371,energy efficiency,Core,Core,1371,"his is the target equivalent of `ROOT_LIBRARIES`, and links all common and requested components. |. | ~~`ROOT::Flags`~~ | ~~The target equivalent of `ROOT_*_FLAGS`, `ROOT_DEFINITIONS`, and `ROOT_EXE_LINKER_FLAGS`. Adds the flags that ROOT recommends; this is a smart target and will add `C`, `CXX`, and `FORTRAN` flags as needed depending on the target you link to.~~ |. ~~I have added `_LIST` versions of `FLAGS` variables, since CMake expects the flags to be a real list in most cases (really everywhere except in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC. ROOT::Core ROOT::Imt ROOT::RIO ROOT::Net ROOT::Hist. ROOT::Graf ROOT::Graf3d ROOT::Gpad ROOT::Tree ROOT::TreePlayer. ROOT::Rint ROOT::Postscript ROOT::Matrix ROOT::Physics. ROOT::MathCore ROOT::Thread ROOT::RooFit. ROOT::Flags). ```. > Note:",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:2138,energy efficiency,Core,Core,2138,"pt in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC. ROOT::Core ROOT::Imt ROOT::RIO ROOT::Net ROOT::Hist. ROOT::Graf ROOT::Graf3d ROOT::Gpad ROOT::Tree ROOT::TreePlayer. ROOT::Rint ROOT::Postscript ROOT::Matrix ROOT::Physics. ROOT::MathCore ROOT::Thread ROOT::RooFit. ROOT::Flags). ```. > Note: I'm listing all the libraries that ROOT adds by default, though due to dependency resolution, a few of them might not be needed to achieve the same result. After:. ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC ROOT::Libraries ROOT::Flags). ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:458,integrability,compon,components,458,"Adding a ROOT::Libraries target for Modern CMake usage; I was looking into ways to improve the target-based usage of ROOT in CMake. I found the missing `INTERFACE_INCLUDE_DIRECTORIES` has already been added to master (Yay!), but there are still other additions that could really help a user trying to use targets:. | New target | Usage |. |---|---|. | `ROOT::Libraries` | This is the target equivalent of `ROOT_LIBRARIES`, and links all common and requested components. |. | ~~`ROOT::Flags`~~ | ~~The target equivalent of `ROOT_*_FLAGS`, `ROOT_DEFINITIONS`, and `ROOT_EXE_LINKER_FLAGS`. Adds the flags that ROOT recommends; this is a smart target and will add `C`, `CXX`, and `FORTRAN` flags as needed depending on the target you link to.~~ |. ~~I have added `_LIST` versions of `FLAGS` variables, since CMake expects the flags to be a real list in most cases (really everywhere except in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and lin",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:702,integrability,depend,depending,702,"Adding a ROOT::Libraries target for Modern CMake usage; I was looking into ways to improve the target-based usage of ROOT in CMake. I found the missing `INTERFACE_INCLUDE_DIRECTORIES` has already been added to master (Yay!), but there are still other additions that could really help a user trying to use targets:. | New target | Usage |. |---|---|. | `ROOT::Libraries` | This is the target equivalent of `ROOT_LIBRARIES`, and links all common and requested components. |. | ~~`ROOT::Flags`~~ | ~~The target equivalent of `ROOT_*_FLAGS`, `ROOT_DEFINITIONS`, and `ROOT_EXE_LINKER_FLAGS`. Adds the flags that ROOT recommends; this is a smart target and will add `C`, `CXX`, and `FORTRAN` flags as needed depending on the target you link to.~~ |. ~~I have added `_LIST` versions of `FLAGS` variables, since CMake expects the flags to be a real list in most cases (really everywhere except in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and lin",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:767,integrability,version,versions,767,"Adding a ROOT::Libraries target for Modern CMake usage; I was looking into ways to improve the target-based usage of ROOT in CMake. I found the missing `INTERFACE_INCLUDE_DIRECTORIES` has already been added to master (Yay!), but there are still other additions that could really help a user trying to use targets:. | New target | Usage |. |---|---|. | `ROOT::Libraries` | This is the target equivalent of `ROOT_LIBRARIES`, and links all common and requested components. |. | ~~`ROOT::Flags`~~ | ~~The target equivalent of `ROOT_*_FLAGS`, `ROOT_DEFINITIONS`, and `ROOT_EXE_LINKER_FLAGS`. Adds the flags that ROOT recommends; this is a smart target and will add `C`, `CXX`, and `FORTRAN` flags as needed depending on the target you link to.~~ |. ~~I have added `_LIST` versions of `FLAGS` variables, since CMake expects the flags to be a real list in most cases (really everywhere except in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and lin",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:1124,integrability,VERSION,VERSION,1124,"ke. I found the missing `INTERFACE_INCLUDE_DIRECTORIES` has already been added to master (Yay!), but there are still other additions that could really help a user trying to use targets:. | New target | Usage |. |---|---|. | `ROOT::Libraries` | This is the target equivalent of `ROOT_LIBRARIES`, and links all common and requested components. |. | ~~`ROOT::Flags`~~ | ~~The target equivalent of `ROOT_*_FLAGS`, `ROOT_DEFINITIONS`, and `ROOT_EXE_LINKER_FLAGS`. Adds the flags that ROOT recommends; this is a smart target and will add `C`, `CXX`, and `FORTRAN` flags as needed depending on the target you link to.~~ |. ~~I have added `_LIST` versions of `FLAGS` variables, since CMake expects the flags to be a real list in most cases (really everywhere except in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBL",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:1214,integrability,COMPON,COMPONENTS,1214,"ay!), but there are still other additions that could really help a user trying to use targets:. | New target | Usage |. |---|---|. | `ROOT::Libraries` | This is the target equivalent of `ROOT_LIBRARIES`, and links all common and requested components. |. | ~~`ROOT::Flags`~~ | ~~The target equivalent of `ROOT_*_FLAGS`, `ROOT_DEFINITIONS`, and `ROOT_EXE_LINKER_FLAGS`. Adds the flags that ROOT recommends; this is a smart target and will add `C`, `CXX`, and `FORTRAN` flags as needed depending on the target you link to.~~ |. ~~I have added `_LIST` versions of `FLAGS` variables, since CMake expects the flags to be a real list in most cases (really everywhere except in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC. ROOT::Core ROOT::Imt ROOT::RIO ROOT::Net ROOT::Hist. ROOT::Graf ROOT::Graf3d ROOT::Gpad",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:1650,integrability,INTERFAC,INTERFACE,1650," add `C`, `CXX`, and `FORTRAN` flags as needed depending on the target you link to.~~ |. ~~I have added `_LIST` versions of `FLAGS` variables, since CMake expects the flags to be a real list in most cases (really everywhere except in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC. ROOT::Core ROOT::Imt ROOT::RIO ROOT::Net ROOT::Hist. ROOT::Graf ROOT::Graf3d ROOT::Gpad ROOT::Tree ROOT::TreePlayer. ROOT::Rint ROOT::Postscript ROOT::Matrix ROOT::Physics. ROOT::MathCore ROOT::Thread ROOT::RooFit. ROOT::Flags). ```. > Note: I'm listing all the libraries that ROOT adds by default, though due to dependency resolution, a few of them might not be needed to achieve the same result. After:. ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:2124,integrability,PUB,PUBLIC,2124,"pt in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC. ROOT::Core ROOT::Imt ROOT::RIO ROOT::Net ROOT::Hist. ROOT::Graf ROOT::Graf3d ROOT::Gpad ROOT::Tree ROOT::TreePlayer. ROOT::Rint ROOT::Postscript ROOT::Matrix ROOT::Physics. ROOT::MathCore ROOT::Thread ROOT::RooFit. ROOT::Flags). ```. > Note: I'm listing all the libraries that ROOT adds by default, though due to dependency resolution, a few of them might not be needed to achieve the same result. After:. ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC ROOT::Libraries ROOT::Flags). ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:2445,integrability,depend,dependency,2445,"pt in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC. ROOT::Core ROOT::Imt ROOT::RIO ROOT::Net ROOT::Hist. ROOT::Graf ROOT::Graf3d ROOT::Gpad ROOT::Tree ROOT::TreePlayer. ROOT::Rint ROOT::Postscript ROOT::Matrix ROOT::Physics. ROOT::MathCore ROOT::Thread ROOT::RooFit. ROOT::Flags). ```. > Note: I'm listing all the libraries that ROOT adds by default, though due to dependency resolution, a few of them might not be needed to achieve the same result. After:. ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC ROOT::Libraries ROOT::Flags). ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:2571,integrability,VERSION,VERSION,2571,"pt in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC. ROOT::Core ROOT::Imt ROOT::RIO ROOT::Net ROOT::Hist. ROOT::Graf ROOT::Graf3d ROOT::Gpad ROOT::Tree ROOT::TreePlayer. ROOT::Rint ROOT::Postscript ROOT::Matrix ROOT::Physics. ROOT::MathCore ROOT::Thread ROOT::RooFit. ROOT::Flags). ```. > Note: I'm listing all the libraries that ROOT adds by default, though due to dependency resolution, a few of them might not be needed to achieve the same result. After:. ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC ROOT::Libraries ROOT::Flags). ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:2661,integrability,COMPON,COMPONENTS,2661,"pt in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC. ROOT::Core ROOT::Imt ROOT::RIO ROOT::Net ROOT::Hist. ROOT::Graf ROOT::Graf3d ROOT::Gpad ROOT::Tree ROOT::TreePlayer. ROOT::Rint ROOT::Postscript ROOT::Matrix ROOT::Physics. ROOT::MathCore ROOT::Thread ROOT::RooFit. ROOT::Flags). ```. > Note: I'm listing all the libraries that ROOT adds by default, though due to dependency resolution, a few of them might not be needed to achieve the same result. After:. ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC ROOT::Libraries ROOT::Flags). ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:2843,integrability,PUB,PUBLIC,2843,"pt in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC. ROOT::Core ROOT::Imt ROOT::RIO ROOT::Net ROOT::Hist. ROOT::Graf ROOT::Graf3d ROOT::Gpad ROOT::Tree ROOT::TreePlayer. ROOT::Rint ROOT::Postscript ROOT::Matrix ROOT::Physics. ROOT::MathCore ROOT::Thread ROOT::RooFit. ROOT::Flags). ```. > Note: I'm listing all the libraries that ROOT adds by default, though due to dependency resolution, a few of them might not be needed to achieve the same result. After:. ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC ROOT::Libraries ROOT::Flags). ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:458,interoperability,compon,components,458,"Adding a ROOT::Libraries target for Modern CMake usage; I was looking into ways to improve the target-based usage of ROOT in CMake. I found the missing `INTERFACE_INCLUDE_DIRECTORIES` has already been added to master (Yay!), but there are still other additions that could really help a user trying to use targets:. | New target | Usage |. |---|---|. | `ROOT::Libraries` | This is the target equivalent of `ROOT_LIBRARIES`, and links all common and requested components. |. | ~~`ROOT::Flags`~~ | ~~The target equivalent of `ROOT_*_FLAGS`, `ROOT_DEFINITIONS`, and `ROOT_EXE_LINKER_FLAGS`. Adds the flags that ROOT recommends; this is a smart target and will add `C`, `CXX`, and `FORTRAN` flags as needed depending on the target you link to.~~ |. ~~I have added `_LIST` versions of `FLAGS` variables, since CMake expects the flags to be a real list in most cases (really everywhere except in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and lin",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:1214,interoperability,COMPON,COMPONENTS,1214,"ay!), but there are still other additions that could really help a user trying to use targets:. | New target | Usage |. |---|---|. | `ROOT::Libraries` | This is the target equivalent of `ROOT_LIBRARIES`, and links all common and requested components. |. | ~~`ROOT::Flags`~~ | ~~The target equivalent of `ROOT_*_FLAGS`, `ROOT_DEFINITIONS`, and `ROOT_EXE_LINKER_FLAGS`. Adds the flags that ROOT recommends; this is a smart target and will add `C`, `CXX`, and `FORTRAN` flags as needed depending on the target you link to.~~ |. ~~I have added `_LIST` versions of `FLAGS` variables, since CMake expects the flags to be a real list in most cases (really everywhere except in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC. ROOT::Core ROOT::Imt ROOT::RIO ROOT::Net ROOT::Hist. ROOT::Graf ROOT::Graf3d ROOT::Gpad",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:1650,interoperability,INTERFAC,INTERFACE,1650," add `C`, `CXX`, and `FORTRAN` flags as needed depending on the target you link to.~~ |. ~~I have added `_LIST` versions of `FLAGS` variables, since CMake expects the flags to be a real list in most cases (really everywhere except in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC. ROOT::Core ROOT::Imt ROOT::RIO ROOT::Net ROOT::Hist. ROOT::Graf ROOT::Graf3d ROOT::Gpad ROOT::Tree ROOT::TreePlayer. ROOT::Rint ROOT::Postscript ROOT::Matrix ROOT::Physics. ROOT::MathCore ROOT::Thread ROOT::RooFit. ROOT::Flags). ```. > Note: I'm listing all the libraries that ROOT adds by default, though due to dependency resolution, a few of them might not be needed to achieve the same result. After:. ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:2661,interoperability,COMPON,COMPONENTS,2661,"pt in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC. ROOT::Core ROOT::Imt ROOT::RIO ROOT::Net ROOT::Hist. ROOT::Graf ROOT::Graf3d ROOT::Gpad ROOT::Tree ROOT::TreePlayer. ROOT::Rint ROOT::Postscript ROOT::Matrix ROOT::Physics. ROOT::MathCore ROOT::Thread ROOT::RooFit. ROOT::Flags). ```. > Note: I'm listing all the libraries that ROOT adds by default, though due to dependency resolution, a few of them might not be needed to achieve the same result. After:. ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC ROOT::Libraries ROOT::Flags). ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:458,modifiability,compon,components,458,"Adding a ROOT::Libraries target for Modern CMake usage; I was looking into ways to improve the target-based usage of ROOT in CMake. I found the missing `INTERFACE_INCLUDE_DIRECTORIES` has already been added to master (Yay!), but there are still other additions that could really help a user trying to use targets:. | New target | Usage |. |---|---|. | `ROOT::Libraries` | This is the target equivalent of `ROOT_LIBRARIES`, and links all common and requested components. |. | ~~`ROOT::Flags`~~ | ~~The target equivalent of `ROOT_*_FLAGS`, `ROOT_DEFINITIONS`, and `ROOT_EXE_LINKER_FLAGS`. Adds the flags that ROOT recommends; this is a smart target and will add `C`, `CXX`, and `FORTRAN` flags as needed depending on the target you link to.~~ |. ~~I have added `_LIST` versions of `FLAGS` variables, since CMake expects the flags to be a real list in most cases (really everywhere except in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and lin",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:702,modifiability,depend,depending,702,"Adding a ROOT::Libraries target for Modern CMake usage; I was looking into ways to improve the target-based usage of ROOT in CMake. I found the missing `INTERFACE_INCLUDE_DIRECTORIES` has already been added to master (Yay!), but there are still other additions that could really help a user trying to use targets:. | New target | Usage |. |---|---|. | `ROOT::Libraries` | This is the target equivalent of `ROOT_LIBRARIES`, and links all common and requested components. |. | ~~`ROOT::Flags`~~ | ~~The target equivalent of `ROOT_*_FLAGS`, `ROOT_DEFINITIONS`, and `ROOT_EXE_LINKER_FLAGS`. Adds the flags that ROOT recommends; this is a smart target and will add `C`, `CXX`, and `FORTRAN` flags as needed depending on the target you link to.~~ |. ~~I have added `_LIST` versions of `FLAGS` variables, since CMake expects the flags to be a real list in most cases (really everywhere except in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and lin",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:767,modifiability,version,versions,767,"Adding a ROOT::Libraries target for Modern CMake usage; I was looking into ways to improve the target-based usage of ROOT in CMake. I found the missing `INTERFACE_INCLUDE_DIRECTORIES` has already been added to master (Yay!), but there are still other additions that could really help a user trying to use targets:. | New target | Usage |. |---|---|. | `ROOT::Libraries` | This is the target equivalent of `ROOT_LIBRARIES`, and links all common and requested components. |. | ~~`ROOT::Flags`~~ | ~~The target equivalent of `ROOT_*_FLAGS`, `ROOT_DEFINITIONS`, and `ROOT_EXE_LINKER_FLAGS`. Adds the flags that ROOT recommends; this is a smart target and will add `C`, `CXX`, and `FORTRAN` flags as needed depending on the target you link to.~~ |. ~~I have added `_LIST` versions of `FLAGS` variables, since CMake expects the flags to be a real list in most cases (really everywhere except in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and lin",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:787,modifiability,variab,variables,787,"Adding a ROOT::Libraries target for Modern CMake usage; I was looking into ways to improve the target-based usage of ROOT in CMake. I found the missing `INTERFACE_INCLUDE_DIRECTORIES` has already been added to master (Yay!), but there are still other additions that could really help a user trying to use targets:. | New target | Usage |. |---|---|. | `ROOT::Libraries` | This is the target equivalent of `ROOT_LIBRARIES`, and links all common and requested components. |. | ~~`ROOT::Flags`~~ | ~~The target equivalent of `ROOT_*_FLAGS`, `ROOT_DEFINITIONS`, and `ROOT_EXE_LINKER_FLAGS`. Adds the flags that ROOT recommends; this is a smart target and will add `C`, `CXX`, and `FORTRAN` flags as needed depending on the target you link to.~~ |. ~~I have added `_LIST` versions of `FLAGS` variables, since CMake expects the flags to be a real list in most cases (really everywhere except in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and lin",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:911,modifiability,variab,variable,911,"Adding a ROOT::Libraries target for Modern CMake usage; I was looking into ways to improve the target-based usage of ROOT in CMake. I found the missing `INTERFACE_INCLUDE_DIRECTORIES` has already been added to master (Yay!), but there are still other additions that could really help a user trying to use targets:. | New target | Usage |. |---|---|. | `ROOT::Libraries` | This is the target equivalent of `ROOT_LIBRARIES`, and links all common and requested components. |. | ~~`ROOT::Flags`~~ | ~~The target equivalent of `ROOT_*_FLAGS`, `ROOT_DEFINITIONS`, and `ROOT_EXE_LINKER_FLAGS`. Adds the flags that ROOT recommends; this is a smart target and will add `C`, `CXX`, and `FORTRAN` flags as needed depending on the target you link to.~~ |. ~~I have added `_LIST` versions of `FLAGS` variables, since CMake expects the flags to be a real list in most cases (really everywhere except in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and lin",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:1124,modifiability,VERSION,VERSION,1124,"ke. I found the missing `INTERFACE_INCLUDE_DIRECTORIES` has already been added to master (Yay!), but there are still other additions that could really help a user trying to use targets:. | New target | Usage |. |---|---|. | `ROOT::Libraries` | This is the target equivalent of `ROOT_LIBRARIES`, and links all common and requested components. |. | ~~`ROOT::Flags`~~ | ~~The target equivalent of `ROOT_*_FLAGS`, `ROOT_DEFINITIONS`, and `ROOT_EXE_LINKER_FLAGS`. Adds the flags that ROOT recommends; this is a smart target and will add `C`, `CXX`, and `FORTRAN` flags as needed depending on the target you link to.~~ |. ~~I have added `_LIST` versions of `FLAGS` variables, since CMake expects the flags to be a real list in most cases (really everywhere except in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBL",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:1214,modifiability,COMPON,COMPONENTS,1214,"ay!), but there are still other additions that could really help a user trying to use targets:. | New target | Usage |. |---|---|. | `ROOT::Libraries` | This is the target equivalent of `ROOT_LIBRARIES`, and links all common and requested components. |. | ~~`ROOT::Flags`~~ | ~~The target equivalent of `ROOT_*_FLAGS`, `ROOT_DEFINITIONS`, and `ROOT_EXE_LINKER_FLAGS`. Adds the flags that ROOT recommends; this is a smart target and will add `C`, `CXX`, and `FORTRAN` flags as needed depending on the target you link to.~~ |. ~~I have added `_LIST` versions of `FLAGS` variables, since CMake expects the flags to be a real list in most cases (really everywhere except in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC. ROOT::Core ROOT::Imt ROOT::RIO ROOT::Net ROOT::Hist. ROOT::Graf ROOT::Graf3d ROOT::Gpad",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:1650,modifiability,INTERFAC,INTERFACE,1650," add `C`, `CXX`, and `FORTRAN` flags as needed depending on the target you link to.~~ |. ~~I have added `_LIST` versions of `FLAGS` variables, since CMake expects the flags to be a real list in most cases (really everywhere except in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC. ROOT::Core ROOT::Imt ROOT::RIO ROOT::Net ROOT::Hist. ROOT::Graf ROOT::Graf3d ROOT::Gpad ROOT::Tree ROOT::TreePlayer. ROOT::Rint ROOT::Postscript ROOT::Matrix ROOT::Physics. ROOT::MathCore ROOT::Thread ROOT::RooFit. ROOT::Flags). ```. > Note: I'm listing all the libraries that ROOT adds by default, though due to dependency resolution, a few of them might not be needed to achieve the same result. After:. ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:2445,modifiability,depend,dependency,2445,"pt in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC. ROOT::Core ROOT::Imt ROOT::RIO ROOT::Net ROOT::Hist. ROOT::Graf ROOT::Graf3d ROOT::Gpad ROOT::Tree ROOT::TreePlayer. ROOT::Rint ROOT::Postscript ROOT::Matrix ROOT::Physics. ROOT::MathCore ROOT::Thread ROOT::RooFit. ROOT::Flags). ```. > Note: I'm listing all the libraries that ROOT adds by default, though due to dependency resolution, a few of them might not be needed to achieve the same result. After:. ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC ROOT::Libraries ROOT::Flags). ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:2571,modifiability,VERSION,VERSION,2571,"pt in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC. ROOT::Core ROOT::Imt ROOT::RIO ROOT::Net ROOT::Hist. ROOT::Graf ROOT::Graf3d ROOT::Gpad ROOT::Tree ROOT::TreePlayer. ROOT::Rint ROOT::Postscript ROOT::Matrix ROOT::Physics. ROOT::MathCore ROOT::Thread ROOT::RooFit. ROOT::Flags). ```. > Note: I'm listing all the libraries that ROOT adds by default, though due to dependency resolution, a few of them might not be needed to achieve the same result. After:. ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC ROOT::Libraries ROOT::Flags). ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:2661,modifiability,COMPON,COMPONENTS,2661,"pt in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC. ROOT::Core ROOT::Imt ROOT::RIO ROOT::Net ROOT::Hist. ROOT::Graf ROOT::Graf3d ROOT::Gpad ROOT::Tree ROOT::TreePlayer. ROOT::Rint ROOT::Postscript ROOT::Matrix ROOT::Physics. ROOT::MathCore ROOT::Thread ROOT::RooFit. ROOT::Flags). ```. > Note: I'm listing all the libraries that ROOT adds by default, though due to dependency resolution, a few of them might not be needed to achieve the same result. After:. ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC ROOT::Libraries ROOT::Flags). ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:1279,performance,error,error,1279,"p a user trying to use targets:. | New target | Usage |. |---|---|. | `ROOT::Libraries` | This is the target equivalent of `ROOT_LIBRARIES`, and links all common and requested components. |. | ~~`ROOT::Flags`~~ | ~~The target equivalent of `ROOT_*_FLAGS`, `ROOT_DEFINITIONS`, and `ROOT_EXE_LINKER_FLAGS`. Adds the flags that ROOT recommends; this is a smart target and will add `C`, `CXX`, and `FORTRAN` flags as needed depending on the target you link to.~~ |. ~~I have added `_LIST` versions of `FLAGS` variables, since CMake expects the flags to be a real list in most cases (really everywhere except in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC. ROOT::Core ROOT::Imt ROOT::RIO ROOT::Net ROOT::Hist. ROOT::Graf ROOT::Graf3d ROOT::Gpad ROOT::Tree ROOT::TreePlayer. ROOT::Rint ROOT::Postscript ROOT:",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:702,safety,depend,depending,702,"Adding a ROOT::Libraries target for Modern CMake usage; I was looking into ways to improve the target-based usage of ROOT in CMake. I found the missing `INTERFACE_INCLUDE_DIRECTORIES` has already been added to master (Yay!), but there are still other additions that could really help a user trying to use targets:. | New target | Usage |. |---|---|. | `ROOT::Libraries` | This is the target equivalent of `ROOT_LIBRARIES`, and links all common and requested components. |. | ~~`ROOT::Flags`~~ | ~~The target equivalent of `ROOT_*_FLAGS`, `ROOT_DEFINITIONS`, and `ROOT_EXE_LINKER_FLAGS`. Adds the flags that ROOT recommends; this is a smart target and will add `C`, `CXX`, and `FORTRAN` flags as needed depending on the target you link to.~~ |. ~~I have added `_LIST` versions of `FLAGS` variables, since CMake expects the flags to be a real list in most cases (really everywhere except in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and lin",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:879,safety,except,except,879,"Adding a ROOT::Libraries target for Modern CMake usage; I was looking into ways to improve the target-based usage of ROOT in CMake. I found the missing `INTERFACE_INCLUDE_DIRECTORIES` has already been added to master (Yay!), but there are still other additions that could really help a user trying to use targets:. | New target | Usage |. |---|---|. | `ROOT::Libraries` | This is the target equivalent of `ROOT_LIBRARIES`, and links all common and requested components. |. | ~~`ROOT::Flags`~~ | ~~The target equivalent of `ROOT_*_FLAGS`, `ROOT_DEFINITIONS`, and `ROOT_EXE_LINKER_FLAGS`. Adds the flags that ROOT recommends; this is a smart target and will add `C`, `CXX`, and `FORTRAN` flags as needed depending on the target you link to.~~ |. ~~I have added `_LIST` versions of `FLAGS` variables, since CMake expects the flags to be a real list in most cases (really everywhere except in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and lin",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:1015,safety,safe,safer,1015,"raries target for Modern CMake usage; I was looking into ways to improve the target-based usage of ROOT in CMake. I found the missing `INTERFACE_INCLUDE_DIRECTORIES` has already been added to master (Yay!), but there are still other additions that could really help a user trying to use targets:. | New target | Usage |. |---|---|. | `ROOT::Libraries` | This is the target equivalent of `ROOT_LIBRARIES`, and links all common and requested components. |. | ~~`ROOT::Flags`~~ | ~~The target equivalent of `ROOT_*_FLAGS`, `ROOT_DEFINITIONS`, and `ROOT_EXE_LINKER_FLAGS`. Adds the flags that ROOT recommends; this is a smart target and will add `C`, `CXX`, and `FORTRAN` flags as needed depending on the target you link to.~~ |. ~~I have added `_LIST` versions of `FLAGS` variables, since CMake expects the flags to be a real list in most cases (really everywhere except in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and linking to needed ROO",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:1279,safety,error,error,1279,"p a user trying to use targets:. | New target | Usage |. |---|---|. | `ROOT::Libraries` | This is the target equivalent of `ROOT_LIBRARIES`, and links all common and requested components. |. | ~~`ROOT::Flags`~~ | ~~The target equivalent of `ROOT_*_FLAGS`, `ROOT_DEFINITIONS`, and `ROOT_EXE_LINKER_FLAGS`. Adds the flags that ROOT recommends; this is a smart target and will add `C`, `CXX`, and `FORTRAN` flags as needed depending on the target you link to.~~ |. ~~I have added `_LIST` versions of `FLAGS` variables, since CMake expects the flags to be a real list in most cases (really everywhere except in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC. ROOT::Core ROOT::Imt ROOT::RIO ROOT::Net ROOT::Hist. ROOT::Graf ROOT::Graf3d ROOT::Gpad ROOT::Tree ROOT::TreePlayer. ROOT::Rint ROOT::Postscript ROOT:",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:2445,safety,depend,dependency,2445,"pt in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC. ROOT::Core ROOT::Imt ROOT::RIO ROOT::Net ROOT::Hist. ROOT::Graf ROOT::Graf3d ROOT::Gpad ROOT::Tree ROOT::TreePlayer. ROOT::Rint ROOT::Postscript ROOT::Matrix ROOT::Physics. ROOT::MathCore ROOT::Thread ROOT::RooFit. ROOT::Flags). ```. > Note: I'm listing all the libraries that ROOT adds by default, though due to dependency resolution, a few of them might not be needed to achieve the same result. After:. ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC ROOT::Libraries ROOT::Flags). ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:702,testability,depend,depending,702,"Adding a ROOT::Libraries target for Modern CMake usage; I was looking into ways to improve the target-based usage of ROOT in CMake. I found the missing `INTERFACE_INCLUDE_DIRECTORIES` has already been added to master (Yay!), but there are still other additions that could really help a user trying to use targets:. | New target | Usage |. |---|---|. | `ROOT::Libraries` | This is the target equivalent of `ROOT_LIBRARIES`, and links all common and requested components. |. | ~~`ROOT::Flags`~~ | ~~The target equivalent of `ROOT_*_FLAGS`, `ROOT_DEFINITIONS`, and `ROOT_EXE_LINKER_FLAGS`. Adds the flags that ROOT recommends; this is a smart target and will add `C`, `CXX`, and `FORTRAN` flags as needed depending on the target you link to.~~ |. ~~I have added `_LIST` versions of `FLAGS` variables, since CMake expects the flags to be a real list in most cases (really everywhere except in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and lin",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:2064,testability,Simpl,SimpleExample,2064,"pt in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC. ROOT::Core ROOT::Imt ROOT::RIO ROOT::Net ROOT::Hist. ROOT::Graf ROOT::Graf3d ROOT::Gpad ROOT::Tree ROOT::TreePlayer. ROOT::Rint ROOT::Postscript ROOT::Matrix ROOT::Physics. ROOT::MathCore ROOT::Thread ROOT::RooFit. ROOT::Flags). ```. > Note: I'm listing all the libraries that ROOT adds by default, though due to dependency resolution, a few of them might not be needed to achieve the same result. After:. ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC ROOT::Libraries ROOT::Flags). ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:2445,testability,depend,dependency,2445,"pt in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC. ROOT::Core ROOT::Imt ROOT::RIO ROOT::Net ROOT::Hist. ROOT::Graf ROOT::Graf3d ROOT::Gpad ROOT::Tree ROOT::TreePlayer. ROOT::Rint ROOT::Postscript ROOT::Matrix ROOT::Physics. ROOT::MathCore ROOT::Thread ROOT::RooFit. ROOT::Flags). ```. > Note: I'm listing all the libraries that ROOT adds by default, though due to dependency resolution, a few of them might not be needed to achieve the same result. After:. ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC ROOT::Libraries ROOT::Flags). ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:2783,testability,Simpl,SimpleExample,2783,"pt in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC. ROOT::Core ROOT::Imt ROOT::RIO ROOT::Net ROOT::Hist. ROOT::Graf ROOT::Graf3d ROOT::Gpad ROOT::Tree ROOT::TreePlayer. ROOT::Rint ROOT::Postscript ROOT::Matrix ROOT::Physics. ROOT::MathCore ROOT::Thread ROOT::RooFit. ROOT::Flags). ```. > Note: I'm listing all the libraries that ROOT adds by default, though due to dependency resolution, a few of them might not be needed to achieve the same result. After:. ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC ROOT::Libraries ROOT::Flags). ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:279,usability,help,help,279,"Adding a ROOT::Libraries target for Modern CMake usage; I was looking into ways to improve the target-based usage of ROOT in CMake. I found the missing `INTERFACE_INCLUDE_DIRECTORIES` has already been added to master (Yay!), but there are still other additions that could really help a user trying to use targets:. | New target | Usage |. |---|---|. | `ROOT::Libraries` | This is the target equivalent of `ROOT_LIBRARIES`, and links all common and requested components. |. | ~~`ROOT::Flags`~~ | ~~The target equivalent of `ROOT_*_FLAGS`, `ROOT_DEFINITIONS`, and `ROOT_EXE_LINKER_FLAGS`. Adds the flags that ROOT recommends; this is a smart target and will add `C`, `CXX`, and `FORTRAN` flags as needed depending on the target you link to.~~ |. ~~I have added `_LIST` versions of `FLAGS` variables, since CMake expects the flags to be a real list in most cases (really everywhere except in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and lin",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:286,usability,user,user,286,"Adding a ROOT::Libraries target for Modern CMake usage; I was looking into ways to improve the target-based usage of ROOT in CMake. I found the missing `INTERFACE_INCLUDE_DIRECTORIES` has already been added to master (Yay!), but there are still other additions that could really help a user trying to use targets:. | New target | Usage |. |---|---|. | `ROOT::Libraries` | This is the target equivalent of `ROOT_LIBRARIES`, and links all common and requested components. |. | ~~`ROOT::Flags`~~ | ~~The target equivalent of `ROOT_*_FLAGS`, `ROOT_DEFINITIONS`, and `ROOT_EXE_LINKER_FLAGS`. Adds the flags that ROOT recommends; this is a smart target and will add `C`, `CXX`, and `FORTRAN` flags as needed depending on the target you link to.~~ |. ~~I have added `_LIST` versions of `FLAGS` variables, since CMake expects the flags to be a real list in most cases (really everywhere except in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and lin",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:988,usability,user,users,988,"Adding a ROOT::Libraries target for Modern CMake usage; I was looking into ways to improve the target-based usage of ROOT in CMake. I found the missing `INTERFACE_INCLUDE_DIRECTORIES` has already been added to master (Yay!), but there are still other additions that could really help a user trying to use targets:. | New target | Usage |. |---|---|. | `ROOT::Libraries` | This is the target equivalent of `ROOT_LIBRARIES`, and links all common and requested components. |. | ~~`ROOT::Flags`~~ | ~~The target equivalent of `ROOT_*_FLAGS`, `ROOT_DEFINITIONS`, and `ROOT_EXE_LINKER_FLAGS`. Adds the flags that ROOT recommends; this is a smart target and will add `C`, `CXX`, and `FORTRAN` flags as needed depending on the target you link to.~~ |. ~~I have added `_LIST` versions of `FLAGS` variables, since CMake expects the flags to be a real list in most cases (really everywhere except in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and lin",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:1279,usability,error,error,1279,"p a user trying to use targets:. | New target | Usage |. |---|---|. | `ROOT::Libraries` | This is the target equivalent of `ROOT_LIBRARIES`, and links all common and requested components. |. | ~~`ROOT::Flags`~~ | ~~The target equivalent of `ROOT_*_FLAGS`, `ROOT_DEFINITIONS`, and `ROOT_EXE_LINKER_FLAGS`. Adds the flags that ROOT recommends; this is a smart target and will add `C`, `CXX`, and `FORTRAN` flags as needed depending on the target you link to.~~ |. ~~I have added `_LIST` versions of `FLAGS` variables, since CMake expects the flags to be a real list in most cases (really everywhere except in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC. ROOT::Core ROOT::Imt ROOT::RIO ROOT::Net ROOT::Hist. ROOT::Graf ROOT::Graf3d ROOT::Gpad ROOT::Tree ROOT::TreePlayer. ROOT::Rint ROOT::Postscript ROOT:",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:1288,usability,user,user,1288," trying to use targets:. | New target | Usage |. |---|---|. | `ROOT::Libraries` | This is the target equivalent of `ROOT_LIBRARIES`, and links all common and requested components. |. | ~~`ROOT::Flags`~~ | ~~The target equivalent of `ROOT_*_FLAGS`, `ROOT_DEFINITIONS`, and `ROOT_EXE_LINKER_FLAGS`. Adds the flags that ROOT recommends; this is a smart target and will add `C`, `CXX`, and `FORTRAN` flags as needed depending on the target you link to.~~ |. ~~I have added `_LIST` versions of `FLAGS` variables, since CMake expects the flags to be a real list in most cases (really everywhere except in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC. ROOT::Core ROOT::Imt ROOT::RIO ROOT::Net ROOT::Hist. ROOT::Graf ROOT::Graf3d ROOT::Gpad ROOT::Tree ROOT::TreePlayer. ROOT::Rint ROOT::Postscript ROOT::Matrix ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:2064,usability,Simpl,SimpleExample,2064,"pt in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC. ROOT::Core ROOT::Imt ROOT::RIO ROOT::Net ROOT::Hist. ROOT::Graf ROOT::Graf3d ROOT::Gpad ROOT::Tree ROOT::TreePlayer. ROOT::Rint ROOT::Postscript ROOT::Matrix ROOT::Physics. ROOT::MathCore ROOT::Thread ROOT::RooFit. ROOT::Flags). ```. > Note: I'm listing all the libraries that ROOT adds by default, though due to dependency resolution, a few of them might not be needed to achieve the same result. After:. ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC ROOT::Libraries ROOT::Flags). ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1959:2783,usability,Simpl,SimpleExample,2783,"pt in the `CMAKE_CXX_FLAGS` variable itself). Actually changing them to CMake lists directly might break users code, so this way is safer.~~. Target based approach before (showing the old INCLUDE issue too). ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit RooFitCore). # Note: Symbols missing compiling error if user forgets RooFitCore! # Already fixed in ROOT master. set_property(TARGET ROOT::Core PROPERTY. INTERFACE_INCLUDE_DIRECTORIES ""${ROOT_INCLUDE_DIRS}""). # Fix for ROOT_*_FLAGS not actually being a CMake list. separate_arguments(ROOT_CXX_FLAGS). separate_arguments(ROOT_EXE_LINKER_FLAGS). # Setting up the recommended ROOT flags. add_library(ROOT::Flags IMPORTED INTERFACE). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_OPTIONS ${ROOT_CXX_FLAGS}). set_property(TARGET ROOT::Flags APPEND PROPERTY. INTERFACE_COMPILE_DEFINITIONS ${ROOT_DEFINITIONS}). #set_property(TARGET ROOT::Flags APPEND PROPERTY. # INTERFACE_LINK_LIBRARIES ${ROOT_EXE_LINKER_FLAGS}). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC. ROOT::Core ROOT::Imt ROOT::RIO ROOT::Net ROOT::Hist. ROOT::Graf ROOT::Graf3d ROOT::Gpad ROOT::Tree ROOT::TreePlayer. ROOT::Rint ROOT::Postscript ROOT::Matrix ROOT::Physics. ROOT::MathCore ROOT::Thread ROOT::RooFit. ROOT::Flags). ```. > Note: I'm listing all the libraries that ROOT adds by default, though due to dependency resolution, a few of them might not be needed to achieve the same result. After:. ```cmake. cmake_minimum_required(VERSION 3.4). project(RootSimpleExample LANGUAGES CXX). find_package(ROOT CONFIG REQUIRED COMPONENTS RooFit). # Adding an exectuable program and linking to needed ROOT libraries. add_executable(RootSimpleExample SimpleExample.cxx). target_link_libraries(RootSimpleExample PUBLIC ROOT::Libraries ROOT::Flags). ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1959
https://github.com/root-project/root/pull/1960:512,availability,cluster,cluster,512,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:640,availability,cluster,cluster,640,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:763,availability,cluster,cluster,763,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:862,availability,cluster,cluster,862,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1112,availability,cluster,clusters,1112,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1878,availability,slo,slow,1878,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1883,availability,operat,operations,1883,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:322,deployability,contain,contains,322,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:512,deployability,cluster,cluster,512,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:640,deployability,cluster,cluster,640,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:763,deployability,cluster,cluster,763,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:772,deployability,continu,continue,772,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:862,deployability,cluster,cluster,862,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:871,deployability,continu,continue,871,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1112,deployability,cluster,clusters,1112,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1122,deployability,continu,continue,1122,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1633,deployability,log,log,1633,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:364,energy efficiency,load,loaded,364,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:504,energy efficiency,current,current,504,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:579,energy efficiency,current,current,579,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1446,energy efficiency,load,load,1446,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1668,energy efficiency,load,loaded,1668,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1717,energy efficiency,load,loaded,1717,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:204,integrability,buffer,buffer,204,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:151,performance,memor,memory,151,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:364,performance,load,loaded,364,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:689,performance,cach,cache,689,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:789,performance,time,times,789,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:815,performance,cach,cache,815,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:888,performance,time,times,888,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:914,performance,cach,cache,914,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1001,performance,time,times,1001,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1027,performance,cach,cache,1027,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1156,performance,cach,cache,1156,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1255,performance,cach,cache,1255,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1294,performance,cach,cache,1294,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1355,performance,cach,cache,1355,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1399,performance,cach,cache,1399,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1446,performance,load,load,1446,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1543,performance,cach,cache,1543,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1668,performance,load,loaded,1668,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1687,performance,cach,cache,1687,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1707,performance,time,times,1707,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1717,performance,load,loaded,1717,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1739,performance,cach,cache,1739,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1759,performance,time,times,1759,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1801,performance,cach,cache,1801,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1878,reliability,slo,slow,1878,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1321,safety,detect,detects,1321,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1623,safety,compl,complete,1623,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1633,safety,log,log,1633,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1792,safety,compl,complete,1792,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:36,security,Sign,Significant,36,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1321,security,detect,detects,1321,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1623,security,compl,complete,1623,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1633,security,log,log,1633,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1792,security,compl,complete,1792,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1633,testability,log,log,1633,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1838,testability,understand,understanding,1838,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:116,usability,efficien,efficient,116,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:126,usability,behavi,behavior,126,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:151,usability,memor,memory,151,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:171,usability,user,user,171,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:457,usability,close,close,457,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:666,usability,stop,stopped,666,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:799,usability,user,user,799,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:898,usability,user,user,898,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1012,usability,user,user,1012,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1141,usability,user,user,1141,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1239,usability,user,user,1239,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1960:1827,usability,help,helpful,1827,"TTreeCache FillBuffer enhancements; Significant revamp of FillBuffer. The new scheme insures a much more stable and efficient behavior in case of low. memory given by the user compared to the size of the buffer or 'odd' basket. layout. The basket collection is now done in 4 phases:. 1. One basket per branch, basket must contains the request entry and is not yet loaded or used,. 2. Even out by adding baskets so that all branches reach the same entry (or close). 3. Add the remaining branches from the current cluster. 4. Add the basket from the begining of the clsuter to the current entry (if any). then repeat the 4 steps for the next cluster. The iteration is stopped as soon as the cache is 'full' as defined by these. rules:. - During step 1 of the first cluster, continue up to 4 times the user requested. cache size. - During steps 2 to 4 of the first cluster, continue up to 2 times the user. requested cache sizep. - During steps 2 to 4, the 'first' basket of a branch is accepted up to 4 times. the user requested cache size (i.e as if it had been selected during the 1st. step). - During the other clusters, continue up to the user requested cache size. A basket if rejected/skipped if its individual size is larger than the user. requested cache size. In addition, upon seeing a cache miss, FillBuffer now detects if all the basket. in the cache have already been used (read from the cache) in which case we can\. discard them and load the next set of baskets. As a side effect, we now keep a record of which baskets are in the cache and. which of those baskets have been used. The TTreePerfStats now keep a complete. log of all the basket that are:. - loaded in the main cache (and how many times). - loaded in the 'misss' cache (and how many times). - used. - read directly (complete cache miss). This will be helpful in understanding situation of over-read or slow operations.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1960
https://github.com/root-project/root/pull/1961:176,deployability,fail,fail,176,"[TDF] Create DataFrame library in Tree, extracting TDF from TreePlayer; this a preparatory step for https://sft.its.cern.ch/jira/browse/ROOT-9351. All roottest are expected to fail: see PR https://github.com/root-project/roottest/pull/167",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1961
https://github.com/root-project/root/pull/1961:176,reliability,fail,fail,176,"[TDF] Create DataFrame library in Tree, extracting TDF from TreePlayer; this a preparatory step for https://sft.its.cern.ch/jira/browse/ROOT-9351. All roottest are expected to fail: see PR https://github.com/root-project/roottest/pull/167",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1961
https://github.com/root-project/root/pull/1963:8,safety,Avoid,Avoid,8,"[cmake] Avoid ""warning: redirecting to https://"";",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1963
https://github.com/root-project/root/pull/1964:8,safety,avoid,avoid,8,webgui: avoid compiler warnings when Qt5 and/or CEF are not used;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1964
https://github.com/root-project/root/pull/1965:41,deployability,stack,stack,41,Print USR2 context before generating the stack trace.;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1965
https://github.com/root-project/root/pull/1965:11,testability,context,context,11,Print USR2 context before generating the stack trace.;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1965
https://github.com/root-project/root/pull/1965:47,testability,trace,trace,47,Print USR2 context before generating the stack trace.;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1965
https://github.com/root-project/root/pull/1966:13,safety,avoid,avoid,13,http: try to avoid civetweb warnings on clang/mac; One should always enable _GNU_SOURCE to use extra functionality from. glibc,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1966
https://github.com/root-project/root/pull/1967:93,deployability,depend,dependent,93,Do not add -fPIC to CMAKE_CXX_FLAGS; These flags end up in ROOTConfig.cmake and propagate to dependent projects. Fixes: https://sft.its.cern.ch/jira/browse/ROOT-9212,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1967
https://github.com/root-project/root/pull/1967:93,integrability,depend,dependent,93,Do not add -fPIC to CMAKE_CXX_FLAGS; These flags end up in ROOTConfig.cmake and propagate to dependent projects. Fixes: https://sft.its.cern.ch/jira/browse/ROOT-9212,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1967
https://github.com/root-project/root/pull/1967:93,modifiability,depend,dependent,93,Do not add -fPIC to CMAKE_CXX_FLAGS; These flags end up in ROOTConfig.cmake and propagate to dependent projects. Fixes: https://sft.its.cern.ch/jira/browse/ROOT-9212,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1967
https://github.com/root-project/root/pull/1967:93,safety,depend,dependent,93,Do not add -fPIC to CMAKE_CXX_FLAGS; These flags end up in ROOTConfig.cmake and propagate to dependent projects. Fixes: https://sft.its.cern.ch/jira/browse/ROOT-9212,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1967
https://github.com/root-project/root/pull/1967:93,testability,depend,dependent,93,Do not add -fPIC to CMAKE_CXX_FLAGS; These flags end up in ROOTConfig.cmake and propagate to dependent projects. Fixes: https://sft.its.cern.ch/jira/browse/ROOT-9212,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1967
https://github.com/root-project/root/pull/1969:47,interoperability,standard,standard,47,"Try to Find Chrome and Firefox on Windows; Add standard ""Program Files"" location on Windows to find chrome.exe and firefox.exe",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1969
https://github.com/root-project/root/pull/1971:168,deployability,updat,updates,168,"[TMVA] ROOT-9081 -- Replace GradBoost with BoostType=Grad; Since some time back the gradient boosting option of TMVA is called. ""BoostType=Grad"", not ""GradBoost"". This updates textual output to use. the new name.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1971
https://github.com/root-project/root/pull/1971:70,performance,time,time,70,"[TMVA] ROOT-9081 -- Replace GradBoost with BoostType=Grad; Since some time back the gradient boosting option of TMVA is called. ""BoostType=Grad"", not ""GradBoost"". This updates textual output to use. the new name.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1971
https://github.com/root-project/root/pull/1971:168,safety,updat,updates,168,"[TMVA] ROOT-9081 -- Replace GradBoost with BoostType=Grad; Since some time back the gradient boosting option of TMVA is called. ""BoostType=Grad"", not ""GradBoost"". This updates textual output to use. the new name.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1971
https://github.com/root-project/root/pull/1971:168,security,updat,updates,168,"[TMVA] ROOT-9081 -- Replace GradBoost with BoostType=Grad; Since some time back the gradient boosting option of TMVA is called. ""BoostType=Grad"", not ""GradBoost"". This updates textual output to use. the new name.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1971
https://github.com/root-project/root/pull/1973:80,energy efficiency,optim,optimiser,80,"[TMVA] ROOT-9194 -- Sporadic timeouts for TMVARegression; Sometimes the genetic optimiser of the functional discriminant analysis. method takes a long time to complete. The TMVA manual suggest that the. first FitMethod to try should be ""Minuit"", not ""GA"". (GA stands for. genetic algorithm in this case). This commit disables FDA_GA and enables FDA_MT in as default methods in. the tutorial TMVARegression.C.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1973
https://github.com/root-project/root/pull/1973:29,performance,time,timeouts,29,"[TMVA] ROOT-9194 -- Sporadic timeouts for TMVARegression; Sometimes the genetic optimiser of the functional discriminant analysis. method takes a long time to complete. The TMVA manual suggest that the. first FitMethod to try should be ""Minuit"", not ""GA"". (GA stands for. genetic algorithm in this case). This commit disables FDA_GA and enables FDA_MT in as default methods in. the tutorial TMVARegression.C.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1973
https://github.com/root-project/root/pull/1973:151,performance,time,time,151,"[TMVA] ROOT-9194 -- Sporadic timeouts for TMVARegression; Sometimes the genetic optimiser of the functional discriminant analysis. method takes a long time to complete. The TMVA manual suggest that the. first FitMethod to try should be ""Minuit"", not ""GA"". (GA stands for. genetic algorithm in this case). This commit disables FDA_GA and enables FDA_MT in as default methods in. the tutorial TMVARegression.C.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1973
https://github.com/root-project/root/pull/1973:29,safety,timeout,timeouts,29,"[TMVA] ROOT-9194 -- Sporadic timeouts for TMVARegression; Sometimes the genetic optimiser of the functional discriminant analysis. method takes a long time to complete. The TMVA manual suggest that the. first FitMethod to try should be ""Minuit"", not ""GA"". (GA stands for. genetic algorithm in this case). This commit disables FDA_GA and enables FDA_MT in as default methods in. the tutorial TMVARegression.C.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1973
https://github.com/root-project/root/pull/1973:159,safety,compl,complete,159,"[TMVA] ROOT-9194 -- Sporadic timeouts for TMVARegression; Sometimes the genetic optimiser of the functional discriminant analysis. method takes a long time to complete. The TMVA manual suggest that the. first FitMethod to try should be ""Minuit"", not ""GA"". (GA stands for. genetic algorithm in this case). This commit disables FDA_GA and enables FDA_MT in as default methods in. the tutorial TMVARegression.C.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1973
https://github.com/root-project/root/pull/1973:159,security,compl,complete,159,"[TMVA] ROOT-9194 -- Sporadic timeouts for TMVARegression; Sometimes the genetic optimiser of the functional discriminant analysis. method takes a long time to complete. The TMVA manual suggest that the. first FitMethod to try should be ""Minuit"", not ""GA"". (GA stands for. genetic algorithm in this case). This commit disables FDA_GA and enables FDA_MT in as default methods in. the tutorial TMVARegression.C.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1973
https://github.com/root-project/root/pull/1974:0,deployability,Updat,Update,0,Update XRootD version to cope with new compilers (gcc 8.1); Should fix ROOT-9391,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1974
https://github.com/root-project/root/pull/1974:14,deployability,version,version,14,Update XRootD version to cope with new compilers (gcc 8.1); Should fix ROOT-9391,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1974
https://github.com/root-project/root/pull/1974:14,integrability,version,version,14,Update XRootD version to cope with new compilers (gcc 8.1); Should fix ROOT-9391,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1974
https://github.com/root-project/root/pull/1974:14,modifiability,version,version,14,Update XRootD version to cope with new compilers (gcc 8.1); Should fix ROOT-9391,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1974
https://github.com/root-project/root/pull/1974:0,safety,Updat,Update,0,Update XRootD version to cope with new compilers (gcc 8.1); Should fix ROOT-9391,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1974
https://github.com/root-project/root/pull/1974:0,security,Updat,Update,0,Update XRootD version to cope with new compilers (gcc 8.1); Should fix ROOT-9391,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1974
https://github.com/root-project/root/pull/1975:0,deployability,Fail,Fail,0,Fail to configure when packages are not found and fail-on-missing=ON; Fixes https://sft.its.cern.ch/jira/browse/ROOT-9385.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1975
https://github.com/root-project/root/pull/1975:50,deployability,fail,fail-on-missing,50,Fail to configure when packages are not found and fail-on-missing=ON; Fixes https://sft.its.cern.ch/jira/browse/ROOT-9385.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1975
https://github.com/root-project/root/pull/1975:8,integrability,configur,configure,8,Fail to configure when packages are not found and fail-on-missing=ON; Fixes https://sft.its.cern.ch/jira/browse/ROOT-9385.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1975
https://github.com/root-project/root/pull/1975:8,modifiability,configur,configure,8,Fail to configure when packages are not found and fail-on-missing=ON; Fixes https://sft.its.cern.ch/jira/browse/ROOT-9385.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1975
https://github.com/root-project/root/pull/1975:23,modifiability,pac,packages,23,Fail to configure when packages are not found and fail-on-missing=ON; Fixes https://sft.its.cern.ch/jira/browse/ROOT-9385.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1975
https://github.com/root-project/root/pull/1975:0,reliability,Fail,Fail,0,Fail to configure when packages are not found and fail-on-missing=ON; Fixes https://sft.its.cern.ch/jira/browse/ROOT-9385.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1975
https://github.com/root-project/root/pull/1975:50,reliability,fail,fail-on-missing,50,Fail to configure when packages are not found and fail-on-missing=ON; Fixes https://sft.its.cern.ch/jira/browse/ROOT-9385.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1975
https://github.com/root-project/root/pull/1975:8,security,configur,configure,8,Fail to configure when packages are not found and fail-on-missing=ON; Fixes https://sft.its.cern.ch/jira/browse/ROOT-9385.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1975
https://github.com/root-project/root/pull/1977:135,deployability,releas,release,135,"Reverting Cloudflare zlib before branching; We need to do additional work to get zlib-cf fully working, reverting temporary before new release branching.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1977
https://github.com/root-project/root/pull/1977:10,energy efficiency,Cloud,Cloudflare,10,"Reverting Cloudflare zlib before branching; We need to do additional work to get zlib-cf fully working, reverting temporary before new release branching.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1977
https://github.com/root-project/root/pull/1978:931,deployability,version,version,931,"I/O of TTreePlayer; Revert ""Use preprocessor macro __ROOTCLING__ instead of __CINT__ in linkdef"". . This reverts commit 915d488afd46a8e8199484ab77861bb47d8bac09. . The replacement prevented the recording of the data member documentation. strings for the content of the library and thus was breaking the I/O, in. particular transientness, for thoses classes, eg TTreePerfStats. (See below for an example). . This seems to be due to the fact that we need/must not add __ROOTCLING__. during the parsing that will be recorded in the the pch, see in. core/dictgen/src/rootcling_impl.cxx line 4334:. . // We do not want __ROOTCLING__ in the pch! if (!onepcm) {. clingArgs.push_back(""-D__ROOTCLING__"");. . So, at least for now, we need to keep using __CINT__ for the LinkDef.h. of the libraries included in the PCH. . See:. . root [0] TClass::GetClass(""TTreePerfStats"")->GetStreamerInfo()->ls(). . StreamerInfo for class: TTreePerfStats, version=7, checksum=0x1f86d003. TVirtualPerfStats BASE offset= 0 type= 0 ABC for collecting PROOF statistics. int fTreeCacheSize offset= 16 type= 3 TTreeCache buffer size. int fNleaves offset= 20 type= 3 Number of leaves in the tree. . vs. . root [0] TClass::GetClass(""TTreePerfStats"")->GetStreamerInfo()->ls(). . StreamerInfo for class: TTreePerfStats, version=6, checksum=0x84181ab4. TVirtualPerfStats BASE offset= 0 type= 0 ABC for collecting PROOF statistics. int fTreeCacheSize offset= 16 type= 3. int fNleaves offset= 20 type= 3.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1978
https://github.com/root-project/root/pull/1978:1285,deployability,version,version,1285,"I/O of TTreePlayer; Revert ""Use preprocessor macro __ROOTCLING__ instead of __CINT__ in linkdef"". . This reverts commit 915d488afd46a8e8199484ab77861bb47d8bac09. . The replacement prevented the recording of the data member documentation. strings for the content of the library and thus was breaking the I/O, in. particular transientness, for thoses classes, eg TTreePerfStats. (See below for an example). . This seems to be due to the fact that we need/must not add __ROOTCLING__. during the parsing that will be recorded in the the pch, see in. core/dictgen/src/rootcling_impl.cxx line 4334:. . // We do not want __ROOTCLING__ in the pch! if (!onepcm) {. clingArgs.push_back(""-D__ROOTCLING__"");. . So, at least for now, we need to keep using __CINT__ for the LinkDef.h. of the libraries included in the PCH. . See:. . root [0] TClass::GetClass(""TTreePerfStats"")->GetStreamerInfo()->ls(). . StreamerInfo for class: TTreePerfStats, version=7, checksum=0x1f86d003. TVirtualPerfStats BASE offset= 0 type= 0 ABC for collecting PROOF statistics. int fTreeCacheSize offset= 16 type= 3 TTreeCache buffer size. int fNleaves offset= 20 type= 3 Number of leaves in the tree. . vs. . root [0] TClass::GetClass(""TTreePerfStats"")->GetStreamerInfo()->ls(). . StreamerInfo for class: TTreePerfStats, version=6, checksum=0x84181ab4. TVirtualPerfStats BASE offset= 0 type= 0 ABC for collecting PROOF statistics. int fTreeCacheSize offset= 16 type= 3. int fNleaves offset= 20 type= 3.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1978
https://github.com/root-project/root/pull/1978:546,energy efficiency,core,core,546,"I/O of TTreePlayer; Revert ""Use preprocessor macro __ROOTCLING__ instead of __CINT__ in linkdef"". . This reverts commit 915d488afd46a8e8199484ab77861bb47d8bac09. . The replacement prevented the recording of the data member documentation. strings for the content of the library and thus was breaking the I/O, in. particular transientness, for thoses classes, eg TTreePerfStats. (See below for an example). . This seems to be due to the fact that we need/must not add __ROOTCLING__. during the parsing that will be recorded in the the pch, see in. core/dictgen/src/rootcling_impl.cxx line 4334:. . // We do not want __ROOTCLING__ in the pch! if (!onepcm) {. clingArgs.push_back(""-D__ROOTCLING__"");. . So, at least for now, we need to keep using __CINT__ for the LinkDef.h. of the libraries included in the PCH. . See:. . root [0] TClass::GetClass(""TTreePerfStats"")->GetStreamerInfo()->ls(). . StreamerInfo for class: TTreePerfStats, version=7, checksum=0x1f86d003. TVirtualPerfStats BASE offset= 0 type= 0 ABC for collecting PROOF statistics. int fTreeCacheSize offset= 16 type= 3 TTreeCache buffer size. int fNleaves offset= 20 type= 3 Number of leaves in the tree. . vs. . root [0] TClass::GetClass(""TTreePerfStats"")->GetStreamerInfo()->ls(). . StreamerInfo for class: TTreePerfStats, version=6, checksum=0x84181ab4. TVirtualPerfStats BASE offset= 0 type= 0 ABC for collecting PROOF statistics. int fTreeCacheSize offset= 16 type= 3. int fNleaves offset= 20 type= 3.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1978
https://github.com/root-project/root/pull/1978:931,integrability,version,version,931,"I/O of TTreePlayer; Revert ""Use preprocessor macro __ROOTCLING__ instead of __CINT__ in linkdef"". . This reverts commit 915d488afd46a8e8199484ab77861bb47d8bac09. . The replacement prevented the recording of the data member documentation. strings for the content of the library and thus was breaking the I/O, in. particular transientness, for thoses classes, eg TTreePerfStats. (See below for an example). . This seems to be due to the fact that we need/must not add __ROOTCLING__. during the parsing that will be recorded in the the pch, see in. core/dictgen/src/rootcling_impl.cxx line 4334:. . // We do not want __ROOTCLING__ in the pch! if (!onepcm) {. clingArgs.push_back(""-D__ROOTCLING__"");. . So, at least for now, we need to keep using __CINT__ for the LinkDef.h. of the libraries included in the PCH. . See:. . root [0] TClass::GetClass(""TTreePerfStats"")->GetStreamerInfo()->ls(). . StreamerInfo for class: TTreePerfStats, version=7, checksum=0x1f86d003. TVirtualPerfStats BASE offset= 0 type= 0 ABC for collecting PROOF statistics. int fTreeCacheSize offset= 16 type= 3 TTreeCache buffer size. int fNleaves offset= 20 type= 3 Number of leaves in the tree. . vs. . root [0] TClass::GetClass(""TTreePerfStats"")->GetStreamerInfo()->ls(). . StreamerInfo for class: TTreePerfStats, version=6, checksum=0x84181ab4. TVirtualPerfStats BASE offset= 0 type= 0 ABC for collecting PROOF statistics. int fTreeCacheSize offset= 16 type= 3. int fNleaves offset= 20 type= 3.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1978
https://github.com/root-project/root/pull/1978:1090,integrability,buffer,buffer,1090,"I/O of TTreePlayer; Revert ""Use preprocessor macro __ROOTCLING__ instead of __CINT__ in linkdef"". . This reverts commit 915d488afd46a8e8199484ab77861bb47d8bac09. . The replacement prevented the recording of the data member documentation. strings for the content of the library and thus was breaking the I/O, in. particular transientness, for thoses classes, eg TTreePerfStats. (See below for an example). . This seems to be due to the fact that we need/must not add __ROOTCLING__. during the parsing that will be recorded in the the pch, see in. core/dictgen/src/rootcling_impl.cxx line 4334:. . // We do not want __ROOTCLING__ in the pch! if (!onepcm) {. clingArgs.push_back(""-D__ROOTCLING__"");. . So, at least for now, we need to keep using __CINT__ for the LinkDef.h. of the libraries included in the PCH. . See:. . root [0] TClass::GetClass(""TTreePerfStats"")->GetStreamerInfo()->ls(). . StreamerInfo for class: TTreePerfStats, version=7, checksum=0x1f86d003. TVirtualPerfStats BASE offset= 0 type= 0 ABC for collecting PROOF statistics. int fTreeCacheSize offset= 16 type= 3 TTreeCache buffer size. int fNleaves offset= 20 type= 3 Number of leaves in the tree. . vs. . root [0] TClass::GetClass(""TTreePerfStats"")->GetStreamerInfo()->ls(). . StreamerInfo for class: TTreePerfStats, version=6, checksum=0x84181ab4. TVirtualPerfStats BASE offset= 0 type= 0 ABC for collecting PROOF statistics. int fTreeCacheSize offset= 16 type= 3. int fNleaves offset= 20 type= 3.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1978
https://github.com/root-project/root/pull/1978:1285,integrability,version,version,1285,"I/O of TTreePlayer; Revert ""Use preprocessor macro __ROOTCLING__ instead of __CINT__ in linkdef"". . This reverts commit 915d488afd46a8e8199484ab77861bb47d8bac09. . The replacement prevented the recording of the data member documentation. strings for the content of the library and thus was breaking the I/O, in. particular transientness, for thoses classes, eg TTreePerfStats. (See below for an example). . This seems to be due to the fact that we need/must not add __ROOTCLING__. during the parsing that will be recorded in the the pch, see in. core/dictgen/src/rootcling_impl.cxx line 4334:. . // We do not want __ROOTCLING__ in the pch! if (!onepcm) {. clingArgs.push_back(""-D__ROOTCLING__"");. . So, at least for now, we need to keep using __CINT__ for the LinkDef.h. of the libraries included in the PCH. . See:. . root [0] TClass::GetClass(""TTreePerfStats"")->GetStreamerInfo()->ls(). . StreamerInfo for class: TTreePerfStats, version=7, checksum=0x1f86d003. TVirtualPerfStats BASE offset= 0 type= 0 ABC for collecting PROOF statistics. int fTreeCacheSize offset= 16 type= 3 TTreeCache buffer size. int fNleaves offset= 20 type= 3 Number of leaves in the tree. . vs. . root [0] TClass::GetClass(""TTreePerfStats"")->GetStreamerInfo()->ls(). . StreamerInfo for class: TTreePerfStats, version=6, checksum=0x84181ab4. TVirtualPerfStats BASE offset= 0 type= 0 ABC for collecting PROOF statistics. int fTreeCacheSize offset= 16 type= 3. int fNleaves offset= 20 type= 3.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1978
https://github.com/root-project/root/pull/1978:931,modifiability,version,version,931,"I/O of TTreePlayer; Revert ""Use preprocessor macro __ROOTCLING__ instead of __CINT__ in linkdef"". . This reverts commit 915d488afd46a8e8199484ab77861bb47d8bac09. . The replacement prevented the recording of the data member documentation. strings for the content of the library and thus was breaking the I/O, in. particular transientness, for thoses classes, eg TTreePerfStats. (See below for an example). . This seems to be due to the fact that we need/must not add __ROOTCLING__. during the parsing that will be recorded in the the pch, see in. core/dictgen/src/rootcling_impl.cxx line 4334:. . // We do not want __ROOTCLING__ in the pch! if (!onepcm) {. clingArgs.push_back(""-D__ROOTCLING__"");. . So, at least for now, we need to keep using __CINT__ for the LinkDef.h. of the libraries included in the PCH. . See:. . root [0] TClass::GetClass(""TTreePerfStats"")->GetStreamerInfo()->ls(). . StreamerInfo for class: TTreePerfStats, version=7, checksum=0x1f86d003. TVirtualPerfStats BASE offset= 0 type= 0 ABC for collecting PROOF statistics. int fTreeCacheSize offset= 16 type= 3 TTreeCache buffer size. int fNleaves offset= 20 type= 3 Number of leaves in the tree. . vs. . root [0] TClass::GetClass(""TTreePerfStats"")->GetStreamerInfo()->ls(). . StreamerInfo for class: TTreePerfStats, version=6, checksum=0x84181ab4. TVirtualPerfStats BASE offset= 0 type= 0 ABC for collecting PROOF statistics. int fTreeCacheSize offset= 16 type= 3. int fNleaves offset= 20 type= 3.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1978
https://github.com/root-project/root/pull/1978:1285,modifiability,version,version,1285,"I/O of TTreePlayer; Revert ""Use preprocessor macro __ROOTCLING__ instead of __CINT__ in linkdef"". . This reverts commit 915d488afd46a8e8199484ab77861bb47d8bac09. . The replacement prevented the recording of the data member documentation. strings for the content of the library and thus was breaking the I/O, in. particular transientness, for thoses classes, eg TTreePerfStats. (See below for an example). . This seems to be due to the fact that we need/must not add __ROOTCLING__. during the parsing that will be recorded in the the pch, see in. core/dictgen/src/rootcling_impl.cxx line 4334:. . // We do not want __ROOTCLING__ in the pch! if (!onepcm) {. clingArgs.push_back(""-D__ROOTCLING__"");. . So, at least for now, we need to keep using __CINT__ for the LinkDef.h. of the libraries included in the PCH. . See:. . root [0] TClass::GetClass(""TTreePerfStats"")->GetStreamerInfo()->ls(). . StreamerInfo for class: TTreePerfStats, version=7, checksum=0x1f86d003. TVirtualPerfStats BASE offset= 0 type= 0 ABC for collecting PROOF statistics. int fTreeCacheSize offset= 16 type= 3 TTreeCache buffer size. int fNleaves offset= 20 type= 3 Number of leaves in the tree. . vs. . root [0] TClass::GetClass(""TTreePerfStats"")->GetStreamerInfo()->ls(). . StreamerInfo for class: TTreePerfStats, version=6, checksum=0x84181ab4. TVirtualPerfStats BASE offset= 0 type= 0 ABC for collecting PROOF statistics. int fTreeCacheSize offset= 16 type= 3. int fNleaves offset= 20 type= 3.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1978
https://github.com/root-project/root/pull/1978:0,performance,I/O,I/O,0,"I/O of TTreePlayer; Revert ""Use preprocessor macro __ROOTCLING__ instead of __CINT__ in linkdef"". . This reverts commit 915d488afd46a8e8199484ab77861bb47d8bac09. . The replacement prevented the recording of the data member documentation. strings for the content of the library and thus was breaking the I/O, in. particular transientness, for thoses classes, eg TTreePerfStats. (See below for an example). . This seems to be due to the fact that we need/must not add __ROOTCLING__. during the parsing that will be recorded in the the pch, see in. core/dictgen/src/rootcling_impl.cxx line 4334:. . // We do not want __ROOTCLING__ in the pch! if (!onepcm) {. clingArgs.push_back(""-D__ROOTCLING__"");. . So, at least for now, we need to keep using __CINT__ for the LinkDef.h. of the libraries included in the PCH. . See:. . root [0] TClass::GetClass(""TTreePerfStats"")->GetStreamerInfo()->ls(). . StreamerInfo for class: TTreePerfStats, version=7, checksum=0x1f86d003. TVirtualPerfStats BASE offset= 0 type= 0 ABC for collecting PROOF statistics. int fTreeCacheSize offset= 16 type= 3 TTreeCache buffer size. int fNleaves offset= 20 type= 3 Number of leaves in the tree. . vs. . root [0] TClass::GetClass(""TTreePerfStats"")->GetStreamerInfo()->ls(). . StreamerInfo for class: TTreePerfStats, version=6, checksum=0x84181ab4. TVirtualPerfStats BASE offset= 0 type= 0 ABC for collecting PROOF statistics. int fTreeCacheSize offset= 16 type= 3. int fNleaves offset= 20 type= 3.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1978
https://github.com/root-project/root/pull/1978:254,performance,content,content,254,"I/O of TTreePlayer; Revert ""Use preprocessor macro __ROOTCLING__ instead of __CINT__ in linkdef"". . This reverts commit 915d488afd46a8e8199484ab77861bb47d8bac09. . The replacement prevented the recording of the data member documentation. strings for the content of the library and thus was breaking the I/O, in. particular transientness, for thoses classes, eg TTreePerfStats. (See below for an example). . This seems to be due to the fact that we need/must not add __ROOTCLING__. during the parsing that will be recorded in the the pch, see in. core/dictgen/src/rootcling_impl.cxx line 4334:. . // We do not want __ROOTCLING__ in the pch! if (!onepcm) {. clingArgs.push_back(""-D__ROOTCLING__"");. . So, at least for now, we need to keep using __CINT__ for the LinkDef.h. of the libraries included in the PCH. . See:. . root [0] TClass::GetClass(""TTreePerfStats"")->GetStreamerInfo()->ls(). . StreamerInfo for class: TTreePerfStats, version=7, checksum=0x1f86d003. TVirtualPerfStats BASE offset= 0 type= 0 ABC for collecting PROOF statistics. int fTreeCacheSize offset= 16 type= 3 TTreeCache buffer size. int fNleaves offset= 20 type= 3 Number of leaves in the tree. . vs. . root [0] TClass::GetClass(""TTreePerfStats"")->GetStreamerInfo()->ls(). . StreamerInfo for class: TTreePerfStats, version=6, checksum=0x84181ab4. TVirtualPerfStats BASE offset= 0 type= 0 ABC for collecting PROOF statistics. int fTreeCacheSize offset= 16 type= 3. int fNleaves offset= 20 type= 3.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1978
https://github.com/root-project/root/pull/1978:303,performance,I/O,I/O,303,"I/O of TTreePlayer; Revert ""Use preprocessor macro __ROOTCLING__ instead of __CINT__ in linkdef"". . This reverts commit 915d488afd46a8e8199484ab77861bb47d8bac09. . The replacement prevented the recording of the data member documentation. strings for the content of the library and thus was breaking the I/O, in. particular transientness, for thoses classes, eg TTreePerfStats. (See below for an example). . This seems to be due to the fact that we need/must not add __ROOTCLING__. during the parsing that will be recorded in the the pch, see in. core/dictgen/src/rootcling_impl.cxx line 4334:. . // We do not want __ROOTCLING__ in the pch! if (!onepcm) {. clingArgs.push_back(""-D__ROOTCLING__"");. . So, at least for now, we need to keep using __CINT__ for the LinkDef.h. of the libraries included in the PCH. . See:. . root [0] TClass::GetClass(""TTreePerfStats"")->GetStreamerInfo()->ls(). . StreamerInfo for class: TTreePerfStats, version=7, checksum=0x1f86d003. TVirtualPerfStats BASE offset= 0 type= 0 ABC for collecting PROOF statistics. int fTreeCacheSize offset= 16 type= 3 TTreeCache buffer size. int fNleaves offset= 20 type= 3 Number of leaves in the tree. . vs. . root [0] TClass::GetClass(""TTreePerfStats"")->GetStreamerInfo()->ls(). . StreamerInfo for class: TTreePerfStats, version=6, checksum=0x84181ab4. TVirtualPerfStats BASE offset= 0 type= 0 ABC for collecting PROOF statistics. int fTreeCacheSize offset= 16 type= 3. int fNleaves offset= 20 type= 3.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1978
https://github.com/root-project/root/pull/1978:180,safety,prevent,prevented,180,"I/O of TTreePlayer; Revert ""Use preprocessor macro __ROOTCLING__ instead of __CINT__ in linkdef"". . This reverts commit 915d488afd46a8e8199484ab77861bb47d8bac09. . The replacement prevented the recording of the data member documentation. strings for the content of the library and thus was breaking the I/O, in. particular transientness, for thoses classes, eg TTreePerfStats. (See below for an example). . This seems to be due to the fact that we need/must not add __ROOTCLING__. during the parsing that will be recorded in the the pch, see in. core/dictgen/src/rootcling_impl.cxx line 4334:. . // We do not want __ROOTCLING__ in the pch! if (!onepcm) {. clingArgs.push_back(""-D__ROOTCLING__"");. . So, at least for now, we need to keep using __CINT__ for the LinkDef.h. of the libraries included in the PCH. . See:. . root [0] TClass::GetClass(""TTreePerfStats"")->GetStreamerInfo()->ls(). . StreamerInfo for class: TTreePerfStats, version=7, checksum=0x1f86d003. TVirtualPerfStats BASE offset= 0 type= 0 ABC for collecting PROOF statistics. int fTreeCacheSize offset= 16 type= 3 TTreeCache buffer size. int fNleaves offset= 20 type= 3 Number of leaves in the tree. . vs. . root [0] TClass::GetClass(""TTreePerfStats"")->GetStreamerInfo()->ls(). . StreamerInfo for class: TTreePerfStats, version=6, checksum=0x84181ab4. TVirtualPerfStats BASE offset= 0 type= 0 ABC for collecting PROOF statistics. int fTreeCacheSize offset= 16 type= 3. int fNleaves offset= 20 type= 3.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1978
https://github.com/root-project/root/pull/1978:180,security,preven,prevented,180,"I/O of TTreePlayer; Revert ""Use preprocessor macro __ROOTCLING__ instead of __CINT__ in linkdef"". . This reverts commit 915d488afd46a8e8199484ab77861bb47d8bac09. . The replacement prevented the recording of the data member documentation. strings for the content of the library and thus was breaking the I/O, in. particular transientness, for thoses classes, eg TTreePerfStats. (See below for an example). . This seems to be due to the fact that we need/must not add __ROOTCLING__. during the parsing that will be recorded in the the pch, see in. core/dictgen/src/rootcling_impl.cxx line 4334:. . // We do not want __ROOTCLING__ in the pch! if (!onepcm) {. clingArgs.push_back(""-D__ROOTCLING__"");. . So, at least for now, we need to keep using __CINT__ for the LinkDef.h. of the libraries included in the PCH. . See:. . root [0] TClass::GetClass(""TTreePerfStats"")->GetStreamerInfo()->ls(). . StreamerInfo for class: TTreePerfStats, version=7, checksum=0x1f86d003. TVirtualPerfStats BASE offset= 0 type= 0 ABC for collecting PROOF statistics. int fTreeCacheSize offset= 16 type= 3 TTreeCache buffer size. int fNleaves offset= 20 type= 3 Number of leaves in the tree. . vs. . root [0] TClass::GetClass(""TTreePerfStats"")->GetStreamerInfo()->ls(). . StreamerInfo for class: TTreePerfStats, version=6, checksum=0x84181ab4. TVirtualPerfStats BASE offset= 0 type= 0 ABC for collecting PROOF statistics. int fTreeCacheSize offset= 16 type= 3. int fNleaves offset= 20 type= 3.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1978
https://github.com/root-project/root/pull/1978:942,security,checksum,checksum,942,"I/O of TTreePlayer; Revert ""Use preprocessor macro __ROOTCLING__ instead of __CINT__ in linkdef"". . This reverts commit 915d488afd46a8e8199484ab77861bb47d8bac09. . The replacement prevented the recording of the data member documentation. strings for the content of the library and thus was breaking the I/O, in. particular transientness, for thoses classes, eg TTreePerfStats. (See below for an example). . This seems to be due to the fact that we need/must not add __ROOTCLING__. during the parsing that will be recorded in the the pch, see in. core/dictgen/src/rootcling_impl.cxx line 4334:. . // We do not want __ROOTCLING__ in the pch! if (!onepcm) {. clingArgs.push_back(""-D__ROOTCLING__"");. . So, at least for now, we need to keep using __CINT__ for the LinkDef.h. of the libraries included in the PCH. . See:. . root [0] TClass::GetClass(""TTreePerfStats"")->GetStreamerInfo()->ls(). . StreamerInfo for class: TTreePerfStats, version=7, checksum=0x1f86d003. TVirtualPerfStats BASE offset= 0 type= 0 ABC for collecting PROOF statistics. int fTreeCacheSize offset= 16 type= 3 TTreeCache buffer size. int fNleaves offset= 20 type= 3 Number of leaves in the tree. . vs. . root [0] TClass::GetClass(""TTreePerfStats"")->GetStreamerInfo()->ls(). . StreamerInfo for class: TTreePerfStats, version=6, checksum=0x84181ab4. TVirtualPerfStats BASE offset= 0 type= 0 ABC for collecting PROOF statistics. int fTreeCacheSize offset= 16 type= 3. int fNleaves offset= 20 type= 3.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1978
https://github.com/root-project/root/pull/1978:1296,security,checksum,checksum,1296,"I/O of TTreePlayer; Revert ""Use preprocessor macro __ROOTCLING__ instead of __CINT__ in linkdef"". . This reverts commit 915d488afd46a8e8199484ab77861bb47d8bac09. . The replacement prevented the recording of the data member documentation. strings for the content of the library and thus was breaking the I/O, in. particular transientness, for thoses classes, eg TTreePerfStats. (See below for an example). . This seems to be due to the fact that we need/must not add __ROOTCLING__. during the parsing that will be recorded in the the pch, see in. core/dictgen/src/rootcling_impl.cxx line 4334:. . // We do not want __ROOTCLING__ in the pch! if (!onepcm) {. clingArgs.push_back(""-D__ROOTCLING__"");. . So, at least for now, we need to keep using __CINT__ for the LinkDef.h. of the libraries included in the PCH. . See:. . root [0] TClass::GetClass(""TTreePerfStats"")->GetStreamerInfo()->ls(). . StreamerInfo for class: TTreePerfStats, version=7, checksum=0x1f86d003. TVirtualPerfStats BASE offset= 0 type= 0 ABC for collecting PROOF statistics. int fTreeCacheSize offset= 16 type= 3 TTreeCache buffer size. int fNleaves offset= 20 type= 3 Number of leaves in the tree. . vs. . root [0] TClass::GetClass(""TTreePerfStats"")->GetStreamerInfo()->ls(). . StreamerInfo for class: TTreePerfStats, version=6, checksum=0x84181ab4. TVirtualPerfStats BASE offset= 0 type= 0 ABC for collecting PROOF statistics. int fTreeCacheSize offset= 16 type= 3. int fNleaves offset= 20 type= 3.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1978
https://github.com/root-project/root/pull/1978:223,usability,document,documentation,223,"I/O of TTreePlayer; Revert ""Use preprocessor macro __ROOTCLING__ instead of __CINT__ in linkdef"". . This reverts commit 915d488afd46a8e8199484ab77861bb47d8bac09. . The replacement prevented the recording of the data member documentation. strings for the content of the library and thus was breaking the I/O, in. particular transientness, for thoses classes, eg TTreePerfStats. (See below for an example). . This seems to be due to the fact that we need/must not add __ROOTCLING__. during the parsing that will be recorded in the the pch, see in. core/dictgen/src/rootcling_impl.cxx line 4334:. . // We do not want __ROOTCLING__ in the pch! if (!onepcm) {. clingArgs.push_back(""-D__ROOTCLING__"");. . So, at least for now, we need to keep using __CINT__ for the LinkDef.h. of the libraries included in the PCH. . See:. . root [0] TClass::GetClass(""TTreePerfStats"")->GetStreamerInfo()->ls(). . StreamerInfo for class: TTreePerfStats, version=7, checksum=0x1f86d003. TVirtualPerfStats BASE offset= 0 type= 0 ABC for collecting PROOF statistics. int fTreeCacheSize offset= 16 type= 3 TTreeCache buffer size. int fNleaves offset= 20 type= 3 Number of leaves in the tree. . vs. . root [0] TClass::GetClass(""TTreePerfStats"")->GetStreamerInfo()->ls(). . StreamerInfo for class: TTreePerfStats, version=6, checksum=0x84181ab4. TVirtualPerfStats BASE offset= 0 type= 0 ABC for collecting PROOF statistics. int fTreeCacheSize offset= 16 type= 3. int fNleaves offset= 20 type= 3.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1978
https://github.com/root-project/root/pull/1979:51,deployability,build,building,51,[cxxmodules][cmake] Switch off the pch option when building with runt; ime_cxxmodules=On.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1979
https://github.com/root-project/root/pull/1980:0,deployability,Patch,Patch,0,Patch from Vassil! Add the cwg to the prebuilt module cache path.; Some modules (produced by rootcling) are located in the cwg and they. should be resolved from there without being rebuilt.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1980
https://github.com/root-project/root/pull/1980:47,deployability,modul,module,47,Patch from Vassil! Add the cwg to the prebuilt module cache path.; Some modules (produced by rootcling) are located in the cwg and they. should be resolved from there without being rebuilt.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1980
https://github.com/root-project/root/pull/1980:72,deployability,modul,modules,72,Patch from Vassil! Add the cwg to the prebuilt module cache path.; Some modules (produced by rootcling) are located in the cwg and they. should be resolved from there without being rebuilt.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1980
https://github.com/root-project/root/pull/1980:47,modifiability,modul,module,47,Patch from Vassil! Add the cwg to the prebuilt module cache path.; Some modules (produced by rootcling) are located in the cwg and they. should be resolved from there without being rebuilt.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1980
https://github.com/root-project/root/pull/1980:72,modifiability,modul,modules,72,Patch from Vassil! Add the cwg to the prebuilt module cache path.; Some modules (produced by rootcling) are located in the cwg and they. should be resolved from there without being rebuilt.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1980
https://github.com/root-project/root/pull/1980:54,performance,cach,cache,54,Patch from Vassil! Add the cwg to the prebuilt module cache path.; Some modules (produced by rootcling) are located in the cwg and they. should be resolved from there without being rebuilt.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1980
https://github.com/root-project/root/pull/1980:0,safety,Patch,Patch,0,Patch from Vassil! Add the cwg to the prebuilt module cache path.; Some modules (produced by rootcling) are located in the cwg and they. should be resolved from there without being rebuilt.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1980
https://github.com/root-project/root/pull/1980:47,safety,modul,module,47,Patch from Vassil! Add the cwg to the prebuilt module cache path.; Some modules (produced by rootcling) are located in the cwg and they. should be resolved from there without being rebuilt.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1980
https://github.com/root-project/root/pull/1980:72,safety,modul,modules,72,Patch from Vassil! Add the cwg to the prebuilt module cache path.; Some modules (produced by rootcling) are located in the cwg and they. should be resolved from there without being rebuilt.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1980
https://github.com/root-project/root/pull/1980:0,security,Patch,Patch,0,Patch from Vassil! Add the cwg to the prebuilt module cache path.; Some modules (produced by rootcling) are located in the cwg and they. should be resolved from there without being rebuilt.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1980
https://github.com/root-project/root/pull/1981:164,safety,test,test,164,"[cxxmodules] Remove outdated workaround for canonical namespaces; It looks we don't need this workaround anymore, it works on our. allmoduels branch and we want to test if this works on nightly as well.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1981
https://github.com/root-project/root/pull/1981:164,testability,test,test,164,"[cxxmodules] Remove outdated workaround for canonical namespaces; It looks we don't need this workaround anymore, it works on our. allmoduels branch and we want to test if this works on nightly as well.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1981
https://github.com/root-project/root/pull/1982:183,availability,cluster,cluster,183,Add TTreePerfStats::GetDuplicateBasketCache.; This allows for testing that there is no unexpected duplicate (duplicates are unavoidable in case. of 'multiple' pass throught the TTree cluster(s)).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1982
https://github.com/root-project/root/pull/1982:183,deployability,cluster,cluster,183,Add TTreePerfStats::GetDuplicateBasketCache.; This allows for testing that there is no unexpected duplicate (duplicates are unavoidable in case. of 'multiple' pass throught the TTree cluster(s)).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1982
https://github.com/root-project/root/pull/1982:62,safety,test,testing,62,Add TTreePerfStats::GetDuplicateBasketCache.; This allows for testing that there is no unexpected duplicate (duplicates are unavoidable in case. of 'multiple' pass throught the TTree cluster(s)).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1982
https://github.com/root-project/root/pull/1982:62,testability,test,testing,62,Add TTreePerfStats::GetDuplicateBasketCache.; This allows for testing that there is no unexpected duplicate (duplicates are unavoidable in case. of 'multiple' pass throught the TTree cluster(s)).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1982
https://github.com/root-project/root/pull/1983:65,interoperability,registr,registration,65,"Add TChain::SetName.; Allows renaming a TChain, without this the registration in the list of specials,. list of cleanups and list of datasets are corrupted",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1983
https://github.com/root-project/root/pull/1985:27,availability,error,error,27,"[cxxmodules] Fix a compile error; ""VecOps"" was hardcoded in TCling.cxx and VecOps were renamed to. ""ROOTVecOps"" afterwards.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1985
https://github.com/root-project/root/pull/1985:27,performance,error,error,27,"[cxxmodules] Fix a compile error; ""VecOps"" was hardcoded in TCling.cxx and VecOps were renamed to. ""ROOTVecOps"" afterwards.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1985
https://github.com/root-project/root/pull/1985:27,safety,error,error,27,"[cxxmodules] Fix a compile error; ""VecOps"" was hardcoded in TCling.cxx and VecOps were renamed to. ""ROOTVecOps"" afterwards.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1985
https://github.com/root-project/root/pull/1985:47,security,hardcod,hardcoded,47,"[cxxmodules] Fix a compile error; ""VecOps"" was hardcoded in TCling.cxx and VecOps were renamed to. ""ROOTVecOps"" afterwards.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1985
https://github.com/root-project/root/pull/1985:27,usability,error,error,27,"[cxxmodules] Fix a compile error; ""VecOps"" was hardcoded in TCling.cxx and VecOps were renamed to. ""ROOTVecOps"" afterwards.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1985
https://github.com/root-project/root/pull/1988:217,availability,error,error,217,"Include Vc without going through VecCore in testGenvectorVc; We uncovered this bug from the changes in fail-on-missing behavior. The test uses only Vc, and uses it directly:. ```. root/test/testGenVectorVc.cxx:67:30: error: Vc was not declared in this scope. typedef std::vector<Data, Vc::Allocator<Data>> Vector;. ^. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1988
https://github.com/root-project/root/pull/1988:103,deployability,fail,fail-on-missing,103,"Include Vc without going through VecCore in testGenvectorVc; We uncovered this bug from the changes in fail-on-missing behavior. The test uses only Vc, and uses it directly:. ```. root/test/testGenVectorVc.cxx:67:30: error: Vc was not declared in this scope. typedef std::vector<Data, Vc::Allocator<Data>> Vector;. ^. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1988
https://github.com/root-project/root/pull/1988:291,energy efficiency,Alloc,Allocator,291,"Include Vc without going through VecCore in testGenvectorVc; We uncovered this bug from the changes in fail-on-missing behavior. The test uses only Vc, and uses it directly:. ```. root/test/testGenVectorVc.cxx:67:30: error: Vc was not declared in this scope. typedef std::vector<Data, Vc::Allocator<Data>> Vector;. ^. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1988
https://github.com/root-project/root/pull/1988:217,performance,error,error,217,"Include Vc without going through VecCore in testGenvectorVc; We uncovered this bug from the changes in fail-on-missing behavior. The test uses only Vc, and uses it directly:. ```. root/test/testGenVectorVc.cxx:67:30: error: Vc was not declared in this scope. typedef std::vector<Data, Vc::Allocator<Data>> Vector;. ^. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1988
https://github.com/root-project/root/pull/1988:103,reliability,fail,fail-on-missing,103,"Include Vc without going through VecCore in testGenvectorVc; We uncovered this bug from the changes in fail-on-missing behavior. The test uses only Vc, and uses it directly:. ```. root/test/testGenVectorVc.cxx:67:30: error: Vc was not declared in this scope. typedef std::vector<Data, Vc::Allocator<Data>> Vector;. ^. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1988
https://github.com/root-project/root/pull/1988:44,safety,test,testGenvectorVc,44,"Include Vc without going through VecCore in testGenvectorVc; We uncovered this bug from the changes in fail-on-missing behavior. The test uses only Vc, and uses it directly:. ```. root/test/testGenVectorVc.cxx:67:30: error: Vc was not declared in this scope. typedef std::vector<Data, Vc::Allocator<Data>> Vector;. ^. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1988
https://github.com/root-project/root/pull/1988:133,safety,test,test,133,"Include Vc without going through VecCore in testGenvectorVc; We uncovered this bug from the changes in fail-on-missing behavior. The test uses only Vc, and uses it directly:. ```. root/test/testGenVectorVc.cxx:67:30: error: Vc was not declared in this scope. typedef std::vector<Data, Vc::Allocator<Data>> Vector;. ^. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1988
https://github.com/root-project/root/pull/1988:185,safety,test,test,185,"Include Vc without going through VecCore in testGenvectorVc; We uncovered this bug from the changes in fail-on-missing behavior. The test uses only Vc, and uses it directly:. ```. root/test/testGenVectorVc.cxx:67:30: error: Vc was not declared in this scope. typedef std::vector<Data, Vc::Allocator<Data>> Vector;. ^. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1988
https://github.com/root-project/root/pull/1988:190,safety,test,testGenVectorVc,190,"Include Vc without going through VecCore in testGenvectorVc; We uncovered this bug from the changes in fail-on-missing behavior. The test uses only Vc, and uses it directly:. ```. root/test/testGenVectorVc.cxx:67:30: error: Vc was not declared in this scope. typedef std::vector<Data, Vc::Allocator<Data>> Vector;. ^. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1988
https://github.com/root-project/root/pull/1988:217,safety,error,error,217,"Include Vc without going through VecCore in testGenvectorVc; We uncovered this bug from the changes in fail-on-missing behavior. The test uses only Vc, and uses it directly:. ```. root/test/testGenVectorVc.cxx:67:30: error: Vc was not declared in this scope. typedef std::vector<Data, Vc::Allocator<Data>> Vector;. ^. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1988
https://github.com/root-project/root/pull/1988:44,testability,test,testGenvectorVc,44,"Include Vc without going through VecCore in testGenvectorVc; We uncovered this bug from the changes in fail-on-missing behavior. The test uses only Vc, and uses it directly:. ```. root/test/testGenVectorVc.cxx:67:30: error: Vc was not declared in this scope. typedef std::vector<Data, Vc::Allocator<Data>> Vector;. ^. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1988
https://github.com/root-project/root/pull/1988:133,testability,test,test,133,"Include Vc without going through VecCore in testGenvectorVc; We uncovered this bug from the changes in fail-on-missing behavior. The test uses only Vc, and uses it directly:. ```. root/test/testGenVectorVc.cxx:67:30: error: Vc was not declared in this scope. typedef std::vector<Data, Vc::Allocator<Data>> Vector;. ^. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1988
https://github.com/root-project/root/pull/1988:185,testability,test,test,185,"Include Vc without going through VecCore in testGenvectorVc; We uncovered this bug from the changes in fail-on-missing behavior. The test uses only Vc, and uses it directly:. ```. root/test/testGenVectorVc.cxx:67:30: error: Vc was not declared in this scope. typedef std::vector<Data, Vc::Allocator<Data>> Vector;. ^. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1988
https://github.com/root-project/root/pull/1988:190,testability,test,testGenVectorVc,190,"Include Vc without going through VecCore in testGenvectorVc; We uncovered this bug from the changes in fail-on-missing behavior. The test uses only Vc, and uses it directly:. ```. root/test/testGenVectorVc.cxx:67:30: error: Vc was not declared in this scope. typedef std::vector<Data, Vc::Allocator<Data>> Vector;. ^. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1988
https://github.com/root-project/root/pull/1988:119,usability,behavi,behavior,119,"Include Vc without going through VecCore in testGenvectorVc; We uncovered this bug from the changes in fail-on-missing behavior. The test uses only Vc, and uses it directly:. ```. root/test/testGenVectorVc.cxx:67:30: error: Vc was not declared in this scope. typedef std::vector<Data, Vc::Allocator<Data>> Vector;. ^. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1988
https://github.com/root-project/root/pull/1988:217,usability,error,error,217,"Include Vc without going through VecCore in testGenvectorVc; We uncovered this bug from the changes in fail-on-missing behavior. The test uses only Vc, and uses it directly:. ```. root/test/testGenVectorVc.cxx:67:30: error: Vc was not declared in this scope. typedef std::vector<Data, Vc::Allocator<Data>> Vector;. ^. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1988
https://github.com/root-project/root/pull/1989:0,deployability,Updat,Update,0,Update release notes;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1989
https://github.com/root-project/root/pull/1989:7,deployability,releas,release,7,Update release notes;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1989
https://github.com/root-project/root/pull/1989:0,safety,Updat,Update,0,Update release notes;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1989
https://github.com/root-project/root/pull/1989:0,security,Updat,Update,0,Update release notes;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1989
https://github.com/root-project/root/pull/1992:54,deployability,build,build,54,[cxxmodules] Temporary excluding tests for cxxmodules build bot; This excludes tests which are failing in runtime modules nightly builds. We want to add runtime modules bot to incrementals and PRs so that. people can fix their bugs before commiting.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1992
https://github.com/root-project/root/pull/1992:95,deployability,fail,failing,95,[cxxmodules] Temporary excluding tests for cxxmodules build bot; This excludes tests which are failing in runtime modules nightly builds. We want to add runtime modules bot to incrementals and PRs so that. people can fix their bugs before commiting.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1992
https://github.com/root-project/root/pull/1992:114,deployability,modul,modules,114,[cxxmodules] Temporary excluding tests for cxxmodules build bot; This excludes tests which are failing in runtime modules nightly builds. We want to add runtime modules bot to incrementals and PRs so that. people can fix their bugs before commiting.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1992
https://github.com/root-project/root/pull/1992:130,deployability,build,builds,130,[cxxmodules] Temporary excluding tests for cxxmodules build bot; This excludes tests which are failing in runtime modules nightly builds. We want to add runtime modules bot to incrementals and PRs so that. people can fix their bugs before commiting.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1992
https://github.com/root-project/root/pull/1992:161,deployability,modul,modules,161,[cxxmodules] Temporary excluding tests for cxxmodules build bot; This excludes tests which are failing in runtime modules nightly builds. We want to add runtime modules bot to incrementals and PRs so that. people can fix their bugs before commiting.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1992
https://github.com/root-project/root/pull/1992:114,modifiability,modul,modules,114,[cxxmodules] Temporary excluding tests for cxxmodules build bot; This excludes tests which are failing in runtime modules nightly builds. We want to add runtime modules bot to incrementals and PRs so that. people can fix their bugs before commiting.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1992
https://github.com/root-project/root/pull/1992:161,modifiability,modul,modules,161,[cxxmodules] Temporary excluding tests for cxxmodules build bot; This excludes tests which are failing in runtime modules nightly builds. We want to add runtime modules bot to incrementals and PRs so that. people can fix their bugs before commiting.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1992
https://github.com/root-project/root/pull/1992:95,reliability,fail,failing,95,[cxxmodules] Temporary excluding tests for cxxmodules build bot; This excludes tests which are failing in runtime modules nightly builds. We want to add runtime modules bot to incrementals and PRs so that. people can fix their bugs before commiting.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1992
https://github.com/root-project/root/pull/1992:33,safety,test,tests,33,[cxxmodules] Temporary excluding tests for cxxmodules build bot; This excludes tests which are failing in runtime modules nightly builds. We want to add runtime modules bot to incrementals and PRs so that. people can fix their bugs before commiting.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1992
https://github.com/root-project/root/pull/1992:79,safety,test,tests,79,[cxxmodules] Temporary excluding tests for cxxmodules build bot; This excludes tests which are failing in runtime modules nightly builds. We want to add runtime modules bot to incrementals and PRs so that. people can fix their bugs before commiting.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1992
https://github.com/root-project/root/pull/1992:114,safety,modul,modules,114,[cxxmodules] Temporary excluding tests for cxxmodules build bot; This excludes tests which are failing in runtime modules nightly builds. We want to add runtime modules bot to incrementals and PRs so that. people can fix their bugs before commiting.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1992
https://github.com/root-project/root/pull/1992:161,safety,modul,modules,161,[cxxmodules] Temporary excluding tests for cxxmodules build bot; This excludes tests which are failing in runtime modules nightly builds. We want to add runtime modules bot to incrementals and PRs so that. people can fix their bugs before commiting.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1992
https://github.com/root-project/root/pull/1992:33,testability,test,tests,33,[cxxmodules] Temporary excluding tests for cxxmodules build bot; This excludes tests which are failing in runtime modules nightly builds. We want to add runtime modules bot to incrementals and PRs so that. people can fix their bugs before commiting.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1992
https://github.com/root-project/root/pull/1992:79,testability,test,tests,79,[cxxmodules] Temporary excluding tests for cxxmodules build bot; This excludes tests which are failing in runtime modules nightly builds. We want to add runtime modules bot to incrementals and PRs so that. people can fix their bugs before commiting.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1992
https://github.com/root-project/root/pull/1993:185,deployability,instal,installation,185,"Add support for MariaDB and fix customizability of FindMySQL.; Because in FindMySQL, the system path are listed before the environment variable provide path, it always favored a system installation.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1993
https://github.com/root-project/root/pull/1993:135,modifiability,variab,variable,135,"Add support for MariaDB and fix customizability of FindMySQL.; Because in FindMySQL, the system path are listed before the environment variable provide path, it always favored a system installation.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1993
https://github.com/root-project/root/pull/1993:4,usability,support,support,4,"Add support for MariaDB and fix customizability of FindMySQL.; Because in FindMySQL, the system path are listed before the environment variable provide path, it always favored a system installation.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1993
https://github.com/root-project/root/pull/1993:32,usability,custom,customizability,32,"Add support for MariaDB and fix customizability of FindMySQL.; Because in FindMySQL, the system path are listed before the environment variable provide path, it always favored a system installation.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1993
https://github.com/root-project/root/pull/1995:81,safety,test,testing,81,"Add --pedantic flag: no using namespace, no auto-#includes etc.; E.g. useful for testing whether we have a ""using namespace std"" in our headers!",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1995
https://github.com/root-project/root/pull/1995:81,testability,test,testing,81,"Add --pedantic flag: no using namespace, no auto-#includes etc.; E.g. useful for testing whether we have a ""using namespace std"" in our headers!",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1995
https://github.com/root-project/root/pull/1996:1397,availability,error,error,1397,ation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(deriv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(eval.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt1-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(integ.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(error.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(stream.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(strerror.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qag.o): relocation R_X86_64_32S against symbol `gsl_integration_qk15' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qagp.o): relocation R_X86_64_32S against symbol `gsl_integration_qk21' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bi,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:43237,availability,error,error,43237,"2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(xerbla.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: final link failed: Nonrepresentable section on output. collect2: error: ld returned 1 exit status. make[3]: *** [lib/libMathMore.so] Error 1. make[2]: *** [math/mathmore/CMakeFiles/MathMore.dir/all] Error 2. make[1]: *** [math/mathmore/CMakeFiles/MathMore.dir/rule] Error 2. make: *** [MathMore] Error 2. ```. This came from trying to build the master branch in the way that we build ROOT for the ATLAS analysis releases (https://gitlab.cern.ch/atlas/atlasexternals/blob/1.0/External/ROOT/CMakeLists.txt), using a command like:. ```. cmake -Dall=ON -Dbuiltin_gsl=ON -Dbuiltin_freetype=ON -Dbuiltin_fftw3=ON -Dbuiltin_lzma=ON -DCMAKE_BUILD_TYPE=Release -Dcxx14=ON -Dxrootd=ON -Ddcache=ON -Ddavix=ON -Dbuiltin_veccore=ON ../root/. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:43305,availability,Error,Error,43305,"2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(xerbla.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: final link failed: Nonrepresentable section on output. collect2: error: ld returned 1 exit status. make[3]: *** [lib/libMathMore.so] Error 1. make[2]: *** [math/mathmore/CMakeFiles/MathMore.dir/all] Error 2. make[1]: *** [math/mathmore/CMakeFiles/MathMore.dir/rule] Error 2. make: *** [MathMore] Error 2. ```. This came from trying to build the master branch in the way that we build ROOT for the ATLAS analysis releases (https://gitlab.cern.ch/atlas/atlasexternals/blob/1.0/External/ROOT/CMakeLists.txt), using a command like:. ```. cmake -Dall=ON -Dbuiltin_gsl=ON -Dbuiltin_freetype=ON -Dbuiltin_fftw3=ON -Dbuiltin_lzma=ON -DCMAKE_BUILD_TYPE=Release -Dcxx14=ON -Dxrootd=ON -Ddcache=ON -Ddavix=ON -Dbuiltin_veccore=ON ../root/. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:43371,availability,Error,Error,43371,"2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(xerbla.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: final link failed: Nonrepresentable section on output. collect2: error: ld returned 1 exit status. make[3]: *** [lib/libMathMore.so] Error 1. make[2]: *** [math/mathmore/CMakeFiles/MathMore.dir/all] Error 2. make[1]: *** [math/mathmore/CMakeFiles/MathMore.dir/rule] Error 2. make: *** [MathMore] Error 2. ```. This came from trying to build the master branch in the way that we build ROOT for the ATLAS analysis releases (https://gitlab.cern.ch/atlas/atlasexternals/blob/1.0/External/ROOT/CMakeLists.txt), using a command like:. ```. cmake -Dall=ON -Dbuiltin_gsl=ON -Dbuiltin_freetype=ON -Dbuiltin_fftw3=ON -Dbuiltin_lzma=ON -DCMAKE_BUILD_TYPE=Release -Dcxx14=ON -Dxrootd=ON -Ddcache=ON -Ddavix=ON -Dbuiltin_veccore=ON ../root/. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:43438,availability,Error,Error,43438,"2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(xerbla.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: final link failed: Nonrepresentable section on output. collect2: error: ld returned 1 exit status. make[3]: *** [lib/libMathMore.so] Error 1. make[2]: *** [math/mathmore/CMakeFiles/MathMore.dir/all] Error 2. make[1]: *** [math/mathmore/CMakeFiles/MathMore.dir/rule] Error 2. make: *** [MathMore] Error 2. ```. This came from trying to build the master branch in the way that we build ROOT for the ATLAS analysis releases (https://gitlab.cern.ch/atlas/atlasexternals/blob/1.0/External/ROOT/CMakeLists.txt), using a command like:. ```. cmake -Dall=ON -Dbuiltin_gsl=ON -Dbuiltin_freetype=ON -Dbuiltin_fftw3=ON -Dbuiltin_lzma=ON -DCMAKE_BUILD_TYPE=Release -Dcxx14=ON -Dxrootd=ON -Ddcache=ON -Ddavix=ON -Dbuiltin_veccore=ON ../root/. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:43468,availability,Error,Error,43468,"2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(xerbla.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: final link failed: Nonrepresentable section on output. collect2: error: ld returned 1 exit status. make[3]: *** [lib/libMathMore.so] Error 1. make[2]: *** [math/mathmore/CMakeFiles/MathMore.dir/all] Error 2. make[1]: *** [math/mathmore/CMakeFiles/MathMore.dir/rule] Error 2. make: *** [MathMore] Error 2. ```. This came from trying to build the master branch in the way that we build ROOT for the ATLAS analysis releases (https://gitlab.cern.ch/atlas/atlasexternals/blob/1.0/External/ROOT/CMakeLists.txt), using a command like:. ```. cmake -Dall=ON -Dbuiltin_gsl=ON -Dbuiltin_freetype=ON -Dbuiltin_fftw3=ON -Dbuiltin_lzma=ON -DCMAKE_BUILD_TYPE=Release -Dcxx14=ON -Dxrootd=ON -Ddcache=ON -Ddavix=ON -Dbuiltin_veccore=ON ../root/. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:84,deployability,build,build,84,"Builtin GSL Fix, master branch (2018.05.09.); Made it explicit that the builtin GSL build should use `-fPIC`. Without it the build, at least on SLC6 with GCC 6.2 would fail to link against the generated GSL library, with messages like:. ```. [100%] Linking CXX shared library ../../lib/libMathMore.so. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(blas.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(deriv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(eval.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt1-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(integ.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(error.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(stream.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(strerror.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/l",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:125,deployability,build,build,125,"Builtin GSL Fix, master branch (2018.05.09.); Made it explicit that the builtin GSL build should use `-fPIC`. Without it the build, at least on SLC6 with GCC 6.2 would fail to link against the generated GSL library, with messages like:. ```. [100%] Linking CXX shared library ../../lib/libMathMore.so. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(blas.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(deriv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(eval.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt1-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(integ.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(error.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(stream.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(strerror.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/l",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:168,deployability,fail,fail,168,"Builtin GSL Fix, master branch (2018.05.09.); Made it explicit that the builtin GSL build should use `-fPIC`. Without it the build, at least on SLC6 with GCC 6.2 would fail to link against the generated GSL library, with messages like:. ```. [100%] Linking CXX shared library ../../lib/libMathMore.so. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(blas.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(deriv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(eval.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt1-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(integ.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(error.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(stream.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(strerror.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/l",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:22000,deployability,log,log,22000,2 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_2F1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_U.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(laguerre.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(legendre_poly.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(log.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(poch.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(pow_int.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(psi.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(trig.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:43183,deployability,fail,failed,43183,"2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(xerbla.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: final link failed: Nonrepresentable section on output. collect2: error: ld returned 1 exit status. make[3]: *** [lib/libMathMore.so] Error 1. make[2]: *** [math/mathmore/CMakeFiles/MathMore.dir/all] Error 2. make[1]: *** [math/mathmore/CMakeFiles/MathMore.dir/rule] Error 2. make: *** [MathMore] Error 2. ```. This came from trying to build the master branch in the way that we build ROOT for the ATLAS analysis releases (https://gitlab.cern.ch/atlas/atlasexternals/blob/1.0/External/ROOT/CMakeLists.txt), using a command like:. ```. cmake -Dall=ON -Dbuiltin_gsl=ON -Dbuiltin_freetype=ON -Dbuiltin_fftw3=ON -Dbuiltin_lzma=ON -DCMAKE_BUILD_TYPE=Release -Dcxx14=ON -Dxrootd=ON -Ddcache=ON -Ddavix=ON -Dbuiltin_veccore=ON ../root/. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:43507,deployability,build,build,43507,"2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(xerbla.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: final link failed: Nonrepresentable section on output. collect2: error: ld returned 1 exit status. make[3]: *** [lib/libMathMore.so] Error 1. make[2]: *** [math/mathmore/CMakeFiles/MathMore.dir/all] Error 2. make[1]: *** [math/mathmore/CMakeFiles/MathMore.dir/rule] Error 2. make: *** [MathMore] Error 2. ```. This came from trying to build the master branch in the way that we build ROOT for the ATLAS analysis releases (https://gitlab.cern.ch/atlas/atlasexternals/blob/1.0/External/ROOT/CMakeLists.txt), using a command like:. ```. cmake -Dall=ON -Dbuiltin_gsl=ON -Dbuiltin_freetype=ON -Dbuiltin_fftw3=ON -Dbuiltin_lzma=ON -DCMAKE_BUILD_TYPE=Release -Dcxx14=ON -Dxrootd=ON -Ddcache=ON -Ddavix=ON -Dbuiltin_veccore=ON ../root/. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:43550,deployability,build,build,43550,"2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(xerbla.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: final link failed: Nonrepresentable section on output. collect2: error: ld returned 1 exit status. make[3]: *** [lib/libMathMore.so] Error 1. make[2]: *** [math/mathmore/CMakeFiles/MathMore.dir/all] Error 2. make[1]: *** [math/mathmore/CMakeFiles/MathMore.dir/rule] Error 2. make: *** [MathMore] Error 2. ```. This came from trying to build the master branch in the way that we build ROOT for the ATLAS analysis releases (https://gitlab.cern.ch/atlas/atlasexternals/blob/1.0/External/ROOT/CMakeLists.txt), using a command like:. ```. cmake -Dall=ON -Dbuiltin_gsl=ON -Dbuiltin_freetype=ON -Dbuiltin_fftw3=ON -Dbuiltin_lzma=ON -DCMAKE_BUILD_TYPE=Release -Dcxx14=ON -Dxrootd=ON -Ddcache=ON -Ddavix=ON -Dbuiltin_veccore=ON ../root/. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:43584,deployability,releas,releases,43584,"2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(xerbla.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: final link failed: Nonrepresentable section on output. collect2: error: ld returned 1 exit status. make[3]: *** [lib/libMathMore.so] Error 1. make[2]: *** [math/mathmore/CMakeFiles/MathMore.dir/all] Error 2. make[1]: *** [math/mathmore/CMakeFiles/MathMore.dir/rule] Error 2. make: *** [MathMore] Error 2. ```. This came from trying to build the master branch in the way that we build ROOT for the ATLAS analysis releases (https://gitlab.cern.ch/atlas/atlasexternals/blob/1.0/External/ROOT/CMakeLists.txt), using a command like:. ```. cmake -Dall=ON -Dbuiltin_gsl=ON -Dbuiltin_freetype=ON -Dbuiltin_fftw3=ON -Dbuiltin_lzma=ON -DCMAKE_BUILD_TYPE=Release -Dcxx14=ON -Dxrootd=ON -Ddcache=ON -Ddavix=ON -Dbuiltin_veccore=ON ../root/. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:43816,deployability,Releas,Release,43816,"2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(xerbla.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: final link failed: Nonrepresentable section on output. collect2: error: ld returned 1 exit status. make[3]: *** [lib/libMathMore.so] Error 1. make[2]: *** [math/mathmore/CMakeFiles/MathMore.dir/all] Error 2. make[1]: *** [math/mathmore/CMakeFiles/MathMore.dir/rule] Error 2. make: *** [MathMore] Error 2. ```. This came from trying to build the master branch in the way that we build ROOT for the ATLAS analysis releases (https://gitlab.cern.ch/atlas/atlasexternals/blob/1.0/External/ROOT/CMakeLists.txt), using a command like:. ```. cmake -Dall=ON -Dbuiltin_gsl=ON -Dbuiltin_freetype=ON -Dbuiltin_fftw3=ON -Dbuiltin_lzma=ON -DCMAKE_BUILD_TYPE=Release -Dcxx14=ON -Dxrootd=ON -Ddcache=ON -Ddavix=ON -Dbuiltin_veccore=ON ../root/. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:221,integrability,messag,messages,221,"Builtin GSL Fix, master branch (2018.05.09.); Made it explicit that the builtin GSL build should use `-fPIC`. Without it the build, at least on SLC6 with GCC 6.2 would fail to link against the generated GSL library, with messages like:. ```. [100%] Linking CXX shared library ../../lib/libMathMore.so. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(blas.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(deriv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(eval.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt1-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(integ.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(error.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(stream.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(strerror.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/l",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:19323,integrability,coupl,coupling,19323,32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_j.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_olver.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_temme.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_y.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(coupling.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ellint.o): relocation R_X86_64_32S against symbol `gsl_prec_eps' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(erfc.o): relocation R_X86_64_32S against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(exp.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(expint.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld:,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:26460,integrability,sub,submatrix,26460,n R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qrpt.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt8-copy.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(matrix.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(rowcol.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(submatrix.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(swap.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(permutation.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ran0.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(tt.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:29533,integrability,sub,subvector,29533,gainst `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_K0.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt54-beta.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(elementary.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt56-hyperg.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(subvector.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt66-swap.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_I0.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(sgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(sgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bi,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:221,interoperability,messag,messages,221,"Builtin GSL Fix, master branch (2018.05.09.); Made it explicit that the builtin GSL build should use `-fPIC`. Without it the build, at least on SLC6 with GCC 6.2 would fail to link against the generated GSL library, with messages like:. ```. [100%] Linking CXX shared library ../../lib/libMathMore.so. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(blas.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(deriv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(eval.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt1-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(integ.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(error.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(stream.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(strerror.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/l",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:261,interoperability,share,shared,261,"Builtin GSL Fix, master branch (2018.05.09.); Made it explicit that the builtin GSL build should use `-fPIC`. Without it the build, at least on SLC6 with GCC 6.2 would fail to link against the generated GSL library, with messages like:. ```. [100%] Linking CXX shared library ../../lib/libMathMore.so. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(blas.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(deriv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(eval.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt1-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(integ.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(error.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(stream.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(strerror.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/l",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:466,interoperability,share,shared,466,"Builtin GSL Fix, master branch (2018.05.09.); Made it explicit that the builtin GSL build should use `-fPIC`. Without it the build, at least on SLC6 with GCC 6.2 would fail to link against the generated GSL library, with messages like:. ```. [100%] Linking CXX shared library ../../lib/libMathMore.so. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(blas.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(deriv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(eval.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt1-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(integ.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(error.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(stream.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(strerror.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/l",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:668,interoperability,share,shared,668,"Builtin GSL Fix, master branch (2018.05.09.); Made it explicit that the builtin GSL build should use `-fPIC`. Without it the build, at least on SLC6 with GCC 6.2 would fail to link against the generated GSL library, with messages like:. ```. [100%] Linking CXX shared library ../../lib/libMathMore.so. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(blas.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(deriv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(eval.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt1-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(integ.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(error.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(stream.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(strerror.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/l",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:869,interoperability,share,shared,869,"Builtin GSL Fix, master branch (2018.05.09.); Made it explicit that the builtin GSL build should use `-fPIC`. Without it the build, at least on SLC6 with GCC 6.2 would fail to link against the generated GSL library, with messages like:. ```. [100%] Linking CXX shared library ../../lib/libMathMore.so. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(blas.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(deriv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(eval.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt1-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(integ.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(error.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(stream.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(strerror.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/l",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:1074,interoperability,share,shared,1074,"in GSL build should use `-fPIC`. Without it the build, at least on SLC6 with GCC 6.2 would fail to link against the generated GSL library, with messages like:. ```. [100%] Linking CXX shared library ../../lib/libMathMore.so. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(blas.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(deriv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(eval.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt1-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(integ.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(error.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(stream.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(strerror.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qag.o): relocation R_X86_64_32S against symbol `gsl_integration_qk15'",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:1276,interoperability,share,shared,1276,../lib/libMathMore.so. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(blas.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(deriv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(eval.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt1-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(integ.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(error.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(stream.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(strerror.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qag.o): relocation R_X86_64_32S against symbol `gsl_integration_qk15' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qagp.o): relocation R_X86_64_32S against symbol `g,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:1478,interoperability,share,shared,1478,recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(deriv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(eval.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt1-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(integ.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(error.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(stream.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(strerror.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qag.o): relocation R_X86_64_32S against symbol `gsl_integration_qk15' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qagp.o): relocation R_X86_64_32S against symbol `gsl_integration_qk21' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qags.o): relocation R_X86_64_3,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:1681,interoperability,share,shared,1681,ecompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(eval.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt1-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(integ.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(error.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(stream.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(strerror.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qag.o): relocation R_X86_64_32S against symbol `gsl_integration_qk15' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qagp.o): relocation R_X86_64_32S against symbol `gsl_integration_qk21' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qags.o): relocation R_X86_64_32 against symbol `gsl_integration_qk21' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qawc.o): rel,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:1887,interoperability,share,shared,1887,ile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt1-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(integ.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(error.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(stream.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(strerror.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qag.o): relocation R_X86_64_32S against symbol `gsl_integration_qk15' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qagp.o): relocation R_X86_64_32S against symbol `gsl_integration_qk21' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qags.o): relocation R_X86_64_32 against symbol `gsl_integration_qk21' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qawc.o): relocation R_X86_64_32S against `.text' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk15.o): relocatio,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:2108,interoperability,share,shared,2108,/cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(integ.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(error.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(stream.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(strerror.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qag.o): relocation R_X86_64_32S against symbol `gsl_integration_qk15' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qagp.o): relocation R_X86_64_32S against symbol `gsl_integration_qk21' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qags.o): relocation R_X86_64_32 against symbol `gsl_integration_qk21' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qawc.o): relocation R_X86_64_32S against `.text' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk15.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk21.o): relocation R_X86_64_32 agains,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:2330,interoperability,share,shared,2330,cg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(error.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(stream.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(strerror.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qag.o): relocation R_X86_64_32S against symbol `gsl_integration_qk15' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qagp.o): relocation R_X86_64_32S against symbol `gsl_integration_qk21' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qags.o): relocation R_X86_64_32 against symbol `gsl_integration_qk21' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qawc.o): relocation R_X86_64_32S against `.text' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk15.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk21.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk31.o): relocation R_X86_64_32 against `.rodata' can not b,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:2551,interoperability,share,shared,2551,/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(stream.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(strerror.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qag.o): relocation R_X86_64_32S against symbol `gsl_integration_qk15' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qagp.o): relocation R_X86_64_32S against symbol `gsl_integration_qk21' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qags.o): relocation R_X86_64_32 against symbol `gsl_integration_qk21' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qawc.o): relocation R_X86_64_32S against `.text' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk15.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk21.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk31.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk41.o): relocation R_X86_64_32 against `.rodata' can not be used when making a,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:2751,interoperability,share,shared,2751,ils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(strerror.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qag.o): relocation R_X86_64_32S against symbol `gsl_integration_qk15' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qagp.o): relocation R_X86_64_32S against symbol `gsl_integration_qk21' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qags.o): relocation R_X86_64_32 against symbol `gsl_integration_qk21' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qawc.o): relocation R_X86_64_32S against `.text' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk15.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk21.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk31.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk41.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk51.o): relocation R_X86_64_32 against `.rodata' can not be used when making ,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:2952,interoperability,share,shared,2952,bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qag.o): relocation R_X86_64_32S against symbol `gsl_integration_qk15' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qagp.o): relocation R_X86_64_32S against symbol `gsl_integration_qk21' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qags.o): relocation R_X86_64_32 against symbol `gsl_integration_qk21' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qawc.o): relocation R_X86_64_32S against `.text' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk15.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk21.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk31.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk41.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk51.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk61.o): relocation R_X86_64_32 against `.rodata' can not be used when making ,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:3153,interoperability,share,shared,3153,cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qagp.o): relocation R_X86_64_32S against symbol `gsl_integration_qk21' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qags.o): relocation R_X86_64_32 against symbol `gsl_integration_qk21' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qawc.o): relocation R_X86_64_32S against `.text' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk15.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk21.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk31.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk41.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk51.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk61.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qng.o): relocation R_X86_64_32 against `.rodata' can not be used when making a,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:3354,interoperability,share,shared,3354,th -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qags.o): relocation R_X86_64_32 against symbol `gsl_integration_qk21' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qawc.o): relocation R_X86_64_32S against `.text' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk15.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk21.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk31.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk41.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk51.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk61.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qng.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(workspace.o): relocation R_X86_64_32 against `.rodata' can not be used when mak,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:3555,interoperability,share,shared,3555,object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qawc.o): relocation R_X86_64_32S against `.text' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk15.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk21.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk31.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk41.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk51.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk61.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qng.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(workspace.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(accel.o): relocation R_X86_64_32 against `.rodata' can not be used when ma,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:3756,interoperability,share,shared,3756,bject; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk15.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk21.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk31.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk41.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk51.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk61.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qng.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(workspace.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(accel.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(akima.o): relocation R_X86_64_32 against `.rodata' can not be used when m,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:3957,interoperability,share,shared,3957,bject; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk21.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk31.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk41.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk51.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk61.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qng.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(workspace.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(accel.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(akima.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(cspline.o): relocation R_X86_64_32 against `.rodata' can not be used whe,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:4157,interoperability,share,shared,4157,object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk31.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk41.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk51.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk61.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qng.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(workspace.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(accel.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(akima.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(cspline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(poly.o): relocation R_X86_64_32 against `.rodata' can not be used wh,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:4363,interoperability,share,shared,4363,t; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk41.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk51.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk61.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qng.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(workspace.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(accel.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(akima.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(cspline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(poly.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(spline.o): relocation R_X86_64_32 against `.rodata' can not be used when ,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:4565,interoperability,share,shared,4565,; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk51.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk61.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qng.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(workspace.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(accel.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(akima.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(cspline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(poly.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(spline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(tridiag.o): relocation R_X86_64_32 against `.rodata' can not be used whe,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:4767,interoperability,share,shared,4767, recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qk61.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qng.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(workspace.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(accel.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(akima.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(cspline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(poly.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(spline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(tridiag.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt10-init.o): relocation R_X86_64_32 against `.rodata' can not be used,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:4971,interoperability,share,shared,4971,compile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qng.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(workspace.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(accel.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(akima.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(cspline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(poly.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(spline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(tridiag.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt10-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(brent.o): relocation R_X86_64_32 against `.rodata' can not be used w,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:5172,interoperability,share,shared,5172,ompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(workspace.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(accel.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(akima.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(cspline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(poly.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(spline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(tridiag.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt10-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(brent.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(convergence.o): relocation R_X86_64_32 against `.rodata' can not be,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:5375,interoperability,share,shared,5375,recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(accel.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(akima.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(cspline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(poly.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(spline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(tridiag.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt10-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(brent.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(fsolver.o): relocation R_X86_64_32 against `.rodata' can not b,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:5579,interoperability,share,shared,5579,compile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(akima.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(cspline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(poly.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(spline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(tridiag.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt10-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(brent.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(fsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(golden.o): relocation R_X86_64_32 against `.rodata' can not be,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:5785,interoperability,share,shared,5785,ile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(cspline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(poly.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(spline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(tridiag.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt10-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(brent.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(fsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(golden.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(miser.o): relocation R_X86_64_32 against `.rodata' can not be use,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:5987,interoperability,share,shared,5987,mpile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(poly.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(spline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(tridiag.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt10-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(brent.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(fsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(golden.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(miser.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(plain.o): relocation R_X86_64_32 against `.rodata' can not be use,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:6195,interoperability,share,shared,6195,ith -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(spline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(tridiag.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt10-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(brent.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(fsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(golden.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(miser.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(plain.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vegas.o): relocation R_X86_64_32 against `.rodata' can not be used when,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:6399,interoperability,share,shared,6399,th -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(tridiag.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt10-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(brent.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(fsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(golden.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(miser.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(plain.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vegas.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt12-convergence.o): relocation R_X86_64_32 against `.rodata' can not be ,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:6602,interoperability,share,shared,6602,ith -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt10-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(brent.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(fsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(golden.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(miser.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(plain.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vegas.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt12-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(covar.o): relocation R_X86_64_32 against `.rodata' can not be u,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:6804,interoperability,share,shared,6804,le with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(brent.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(fsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(golden.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(miser.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(plain.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vegas.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt12-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(covar.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(fdfsolver.o): relocation R_X86_64_32 against `.rodata' can not ,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:7006,interoperability,share,shared,7006,le with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(fsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(golden.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(miser.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(plain.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vegas.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt12-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(covar.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(fdfsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lmder.o): relocation R_X86_64_32 against `.rodata' can not ,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:7208,interoperability,share,shared,7208,ecompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(fsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(golden.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(miser.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(plain.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vegas.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt12-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(covar.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(fdfsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lmder.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(conjugate_fr.o): relocation R_X86_64_32 against `.rodata' c,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:7421,interoperability,share,shared,7421,with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(golden.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(miser.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(plain.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vegas.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt12-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(covar.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(fdfsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lmder.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(conjugate_fr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(conjugate_pr.o): relocation R_X86_64_32 against `.rodata' can n,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:7623,interoperability,share,shared,7623, with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(miser.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(plain.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vegas.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt12-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(covar.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(fdfsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lmder.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(conjugate_fr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(conjugate_pr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt14-convergence.o): relocation R_X86_64_32 against `.ro,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:7829,interoperability,share,shared,7829,h -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(plain.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vegas.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt12-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(covar.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(fdfsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lmder.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(conjugate_fr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(conjugate_pr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt14-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(fdfminimizer.o): relocation R_X86_64_32 against `,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:8031,interoperability,share,shared,8031,h -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vegas.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt12-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(covar.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(fdfsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lmder.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(conjugate_fr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(conjugate_pr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt14-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(fdfminimizer.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(steepest_descent.o): relocation R_X86_64_3,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:8240,interoperability,share,shared,8240,. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt12-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(covar.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(fdfsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lmder.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(conjugate_fr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(conjugate_pr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt14-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(fdfminimizer.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(steepest_descent.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vector_bfgs.o): relocation R_X86_64_32,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:8449,interoperability,share,shared,8449,fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(covar.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(fdfsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lmder.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(conjugate_fr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(conjugate_pr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt14-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(fdfminimizer.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(steepest_descent.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vector_bfgs.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vector_bfgs2.o): relocation R_X86_64_32,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:8662,interoperability,share,shared,8662,s/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(fdfsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lmder.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(conjugate_fr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(conjugate_pr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt14-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(fdfminimizer.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(steepest_descent.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vector_bfgs.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vector_bfgs2.o): relocation R_X86_64_32S against `.text' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(broyden.o): relocation R_X86_64_32 against `,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:8871,interoperability,share,shared,8871,ft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lmder.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(conjugate_fr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(conjugate_pr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt14-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(fdfminimizer.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(steepest_descent.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vector_bfgs.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vector_bfgs2.o): relocation R_X86_64_32S against `.text' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(broyden.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt16-convergence.o): relocation R_X86_64_32 again,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:9084,interoperability,share,shared,9084,lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(conjugate_fr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(conjugate_pr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt14-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(fdfminimizer.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(steepest_descent.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vector_bfgs.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vector_bfgs2.o): relocation R_X86_64_32S against `.text' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(broyden.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt16-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(dnewton.o): relocation R_X86_64_32 against `.roda,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:9292,interoperability,share,shared,9292,/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(conjugate_pr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt14-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(fdfminimizer.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(steepest_descent.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vector_bfgs.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vector_bfgs2.o): relocation R_X86_64_32S against `.text' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(broyden.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt16-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(dnewton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt17-fdfsolver.o): relocation R_X86_64_32 against `.r,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:9500,interoperability,share,shared,9500,h/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt14-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(fdfminimizer.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(steepest_descent.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vector_bfgs.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vector_bfgs2.o): relocation R_X86_64_32S against `.text' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(broyden.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt16-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(dnewton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt17-fdfsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt18-fdjac.o): relocation R_X86_64_32 against `.ro,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:9704,interoperability,share,shared,9704,ft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(fdfminimizer.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(steepest_descent.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vector_bfgs.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vector_bfgs2.o): relocation R_X86_64_32S against `.text' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(broyden.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt16-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(dnewton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt17-fdfsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt18-fdjac.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt19-fsolver.o): relocation R_X86_64_32 against,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:9917,interoperability,share,shared,9917,ern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(steepest_descent.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vector_bfgs.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vector_bfgs2.o): relocation R_X86_64_32S against `.text' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(broyden.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt16-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(dnewton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt17-fdfsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt18-fdjac.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt19-fsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gnewton.o): relocation R_X86_64_32 against `.rodata,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:10121,interoperability,share,shared,10121,mfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vector_bfgs.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vector_bfgs2.o): relocation R_X86_64_32S against `.text' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(broyden.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt16-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(dnewton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt17-fdfsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt18-fdjac.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt19-fsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gnewton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hybrid.o): relocation R_X86_64_32 against `.rodata',MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:10332,interoperability,share,shared,10332,/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vector_bfgs2.o): relocation R_X86_64_32S against `.text' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(broyden.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt16-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(dnewton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt17-fdfsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt18-fdjac.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt19-fsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gnewton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hybrid.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hybridj.o): relocation R_X86_64_32 against `.rodata' can no,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:10539,interoperability,share,shared,10539,s/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(broyden.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt16-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(dnewton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt17-fdfsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt18-fdjac.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt19-fsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gnewton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hybrid.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hybridj.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(newton.o): relocation R_X86_64_32 against `.rodata' can not be,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:10748,interoperability,share,shared,10748,.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt16-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(dnewton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt17-fdfsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt18-fdjac.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt19-fsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gnewton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hybrid.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hybridj.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(newton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt34-init.o): relocation R_X86_64_32 against `.rodata' can not be us,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:10952,interoperability,share,shared,10952,cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(dnewton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt17-fdfsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt18-fdjac.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt19-fsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gnewton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hybrid.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hybridj.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(newton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt34-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt35-inline.o): relocation R_X86_64_32 against `.rodata' can not b,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:11155,interoperability,share,shared,11155,/cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt17-fdfsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt18-fdjac.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt19-fsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gnewton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hybrid.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hybridj.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(newton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt34-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt35-inline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(permute.o): relocation R_X86_64_32 against `.rodata' can not ,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:11359,interoperability,share,shared,11359,-fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt18-fdjac.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt19-fsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gnewton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hybrid.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hybridj.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(newton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt34-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt35-inline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(permute.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(zsolve.o): relocation R_X86_64_32 against `.rodata' can not b,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:11562,interoperability,share,shared,11562,ith -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt19-fsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gnewton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hybrid.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hybridj.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(newton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt34-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt35-inline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(permute.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(zsolve.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(zsolve_init.o): relocation R_X86_64_32 against `.rodata' can ,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:11768,interoperability,share,shared,11768,e with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gnewton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hybrid.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hybridj.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(newton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt34-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt35-inline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(permute.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(zsolve.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(zsolve_init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(niederreiter-2.o): relocation R_X86_64_32S against `.rodata,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:11976,interoperability,share,shared,11976,th -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hybrid.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hybridj.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(newton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt34-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt35-inline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(permute.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(zsolve.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(zsolve_init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(niederreiter-2.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qrng.o): relocation R_X86_64_32 against `.rodata' can n,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:12180,interoperability,share,shared,12180,h -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hybridj.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(newton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt34-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt35-inline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(permute.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(zsolve.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(zsolve_init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(niederreiter-2.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qrng.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(sobol.o): relocation R_X86_64_32S against `.rodata' can no,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:12383,interoperability,share,shared,12383,th -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(newton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt34-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt35-inline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(permute.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(zsolve.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(zsolve_init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(niederreiter-2.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qrng.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(sobol.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gausszig.o): relocation R_X86_64_32S against `.rodata' can,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:12591,interoperability,share,shared,12591,PIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt34-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt35-inline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(permute.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(zsolve.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(zsolve_init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(niederreiter-2.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qrng.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(sobol.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gausszig.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(landau.o): relocation R_X86_64_32S against `.data' can not b,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:12803,interoperability,share,shared,12803,cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt35-inline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(permute.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(zsolve.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(zsolve_init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(niederreiter-2.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qrng.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(sobol.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gausszig.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(landau.o): relocation R_X86_64_32S against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(default.o): relocation R_X86_64_32 against `.rodata' can not be used w,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:13004,interoperability,share,shared,13004,fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(permute.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(zsolve.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(zsolve_init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(niederreiter-2.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qrng.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(sobol.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gausszig.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(landau.o): relocation R_X86_64_32S against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(default.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt47-inline.o): relocation R_X86_64_32 against `.rodata' can not be,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:13207,interoperability,share,shared,13207,-fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(zsolve.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(zsolve_init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(niederreiter-2.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qrng.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(sobol.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gausszig.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(landau.o): relocation R_X86_64_32S against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(default.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt47-inline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ranlxd.o): relocation R_X86_64_32S against `.rodata' can not b,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:13413,interoperability,share,shared,13413,IC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(zsolve_init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(niederreiter-2.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qrng.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(sobol.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gausszig.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(landau.o): relocation R_X86_64_32S against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(default.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt47-inline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ranlxd.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ranlxs.o): relocation R_X86_64_32S against `.rodata' can not be ,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:13615,interoperability,share,shared,13615,th -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(niederreiter-2.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qrng.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(sobol.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gausszig.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(landau.o): relocation R_X86_64_32S against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(default.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt47-inline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ranlxd.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ranlxs.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(rng.o): relocation R_X86_64_32 against `.rodata' can not be us,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:13819,interoperability,share,shared,13819,mpile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qrng.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(sobol.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gausszig.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(landau.o): relocation R_X86_64_32S against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(default.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt47-inline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ranlxd.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ranlxs.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(rng.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(types.o): relocation R_X86_64_32S against undefined symbol `gsl_rn,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:14027,interoperability,share,shared,14027,ith -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(sobol.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gausszig.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(landau.o): relocation R_X86_64_32S against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(default.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt47-inline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ranlxd.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ranlxs.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(rng.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(types.o): relocation R_X86_64_32S against undefined symbol `gsl_rng_generator_types' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bisection.o): relocation R_X86_64_32 a,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:14231,interoperability,share,shared,14231,th -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gausszig.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(landau.o): relocation R_X86_64_32S against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(default.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt47-inline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ranlxd.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ranlxs.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(rng.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(types.o): relocation R_X86_64_32S against undefined symbol `gsl_rng_generator_types' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bisection.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt48-brent.o): relocation R_X86_64_3,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:14435,interoperability,share,shared,14435,with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(landau.o): relocation R_X86_64_32S against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(default.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt47-inline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ranlxd.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ranlxs.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(rng.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(types.o): relocation R_X86_64_32S against undefined symbol `gsl_rng_generator_types' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bisection.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt48-brent.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt49-convergence.o): relocation R,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:14635,interoperability,share,shared,14635,e with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(default.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt47-inline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ranlxd.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ranlxs.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(rng.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(types.o): relocation R_X86_64_32S against undefined symbol `gsl_rng_generator_types' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bisection.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt48-brent.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt49-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(falsepos.o): relocat,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:14871,interoperability,share,shared,14871,/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt47-inline.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ranlxd.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ranlxs.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(rng.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(types.o): relocation R_X86_64_32S against undefined symbol `gsl_rng_generator_types' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bisection.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt48-brent.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt49-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(falsepos.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt50-fdfsolver.o): relocation R_X86_64_32 against `,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:15077,interoperability,share,shared,15077,ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ranlxd.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ranlxs.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(rng.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(types.o): relocation R_X86_64_32S against undefined symbol `gsl_rng_generator_types' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bisection.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt48-brent.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt49-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(falsepos.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt50-fdfsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt51-fsolver.o): relocation R_X86_64_32 agains,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:15284,interoperability,share,shared,15284,lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ranlxs.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(rng.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(types.o): relocation R_X86_64_32S against undefined symbol `gsl_rng_generator_types' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bisection.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt48-brent.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt49-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(falsepos.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt50-fdfsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt51-fsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt52-newton.o): relocation R_X86_64_32 again,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:15497,interoperability,share,shared,15497,ib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(rng.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(types.o): relocation R_X86_64_32S against undefined symbol `gsl_rng_generator_types' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bisection.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt48-brent.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt49-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(falsepos.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt50-fdfsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt51-fsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt52-newton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(secant.o): relocation R_X86_64_32 against `.rodat,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:15702,interoperability,share,shared,15702,ntuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(types.o): relocation R_X86_64_32S against undefined symbol `gsl_rng_generator_types' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bisection.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt48-brent.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt49-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(falsepos.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt50-fdfsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt51-fsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt52-newton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(secant.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(steffenson.o): relocation R_X86_64_32 against `.rod,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:15913,interoperability,share,shared,15913,ft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bisection.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt48-brent.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt49-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(falsepos.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt50-fdfsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt51-fsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt52-newton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(secant.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(steffenson.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(siman.o): relocation R_X86_64_32 against `.rodata' can ,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:16122,interoperability,share,shared,16122,cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt48-brent.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt49-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(falsepos.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt50-fdfsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt51-fsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt52-newton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(secant.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(steffenson.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(siman.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(airy.o): relocation R_X86_64_32 against `.data' can not be use,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:16330,interoperability,share,shared,16330,ern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt49-convergence.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(falsepos.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt50-fdfsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt51-fsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt52-newton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(secant.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(steffenson.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(siman.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(airy.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(airy_der.o): relocation R_X86_64_32 against `.data' can not be used whe,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:16533,interoperability,share,shared,16533,vmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(falsepos.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt50-fdfsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt51-fsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt52-newton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(secant.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(steffenson.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(siman.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(airy.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(airy_der.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(airy_zero.o): relocation R_X86_64_32 against `.rodata' can not be used ,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:16740,interoperability,share,shared,16740,fs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt50-fdfsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt51-fsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt52-newton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(secant.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(steffenson.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(siman.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(airy.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(airy_der.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(airy_zero.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Inu.o): relocation R_X86_64_32 against `.rodata' can not be used ,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:16942,interoperability,share,shared,16942,PIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt51-fsolver.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt52-newton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(secant.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(steffenson.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(siman.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(airy.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(airy_der.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(airy_zero.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Inu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Jnu.o): relocation R_X86_64_32 against `.rodata' can not be ,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:17141,interoperability,share,shared,17141,le with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt52-newton.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(secant.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(steffenson.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(siman.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(airy.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(airy_der.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(airy_zero.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Inu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Jnu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Knu.o): relocation R_X86_64_32 against `.rodata' can,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:17344,interoperability,share,shared,17344,compile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(secant.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(steffenson.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(siman.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(airy.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(airy_der.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(airy_zero.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Inu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Jnu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Knu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Ynu.o): relocation R_X86_64_32 against `.rodata',MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:17550,interoperability,share,shared,17550,pile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(steffenson.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(siman.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(airy.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(airy_der.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(airy_zero.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Inu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Jnu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Knu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Ynu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_j.o): relocation R_X86_64_32 against `.rodata' ,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:17757,interoperability,share,shared,17757,pile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(siman.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(airy.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(airy_der.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(airy_zero.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Inu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Jnu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Knu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Ynu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_j.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_olver.o): relocation R_X86_64_32 against `.data' ,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:17964,interoperability,share,shared,17964,with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(airy.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(airy_der.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(airy_zero.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Inu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Jnu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Knu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Ynu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_j.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_olver.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_temme.o): relocation R_X86_64_32 against `.data' ,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:18171,interoperability,share,shared,18171,IC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(airy_der.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(airy_zero.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Inu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Jnu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Knu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Ynu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_j.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_olver.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_temme.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_y.o): relocation R_X86_64_32 against `.rodata' ca,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:18378,interoperability,share,shared,18378,/cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(airy_zero.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Inu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Jnu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Knu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Ynu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_j.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_olver.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_temme.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_y.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(coupling.o): relocation R_X86_64_32 against `.rodata' can ,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:18583,interoperability,share,shared,18583, /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Inu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Jnu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Knu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Ynu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_j.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_olver.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_temme.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_y.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(coupling.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ellint.o): relocation R_X86_64_32S against symbol `gsl_pre,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:18790,interoperability,share,shared,18790, /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Jnu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Knu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Ynu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_j.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_olver.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_temme.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_y.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(coupling.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ellint.o): relocation R_X86_64_32S against symbol `gsl_prec_eps' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(erfc.o): relocation R_X86_64_32S against `.data' ,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:18997,interoperability,share,shared,18997, /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Knu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Ynu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_j.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_olver.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_temme.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_y.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(coupling.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ellint.o): relocation R_X86_64_32S against symbol `gsl_prec_eps' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(erfc.o): relocation R_X86_64_32S against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(exp.o): relocation R_X86_64_32 against `.rodata' can not,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:19202,interoperability,share,shared,19202,C. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Ynu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_j.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_olver.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_temme.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_y.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(coupling.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ellint.o): relocation R_X86_64_32S against symbol `gsl_prec_eps' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(erfc.o): relocation R_X86_64_32S against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(exp.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(expint.o): relocation R_X86_64_32 against `.rodata' can not b,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:19407,interoperability,share,shared,19407,PIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_j.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_olver.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_temme.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_y.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(coupling.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ellint.o): relocation R_X86_64_32S against symbol `gsl_prec_eps' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(erfc.o): relocation R_X86_64_32S against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(exp.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(expint.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt55-gamma.o): relocation R_X86_64_32S against `.data' can not ,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:19623,interoperability,share,shared,19623,/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_olver.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_temme.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_y.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(coupling.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ellint.o): relocation R_X86_64_32S against symbol `gsl_prec_eps' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(erfc.o): relocation R_X86_64_32S against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(exp.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(expint.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt55-gamma.o): relocation R_X86_64_32S against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gamma_inc.o): relocation R_X86_64_32 against `.rodata' can not be used wh,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:19823,interoperability,share,shared,19823, /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_temme.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_y.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(coupling.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ellint.o): relocation R_X86_64_32S against symbol `gsl_prec_eps' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(erfc.o): relocation R_X86_64_32S against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(exp.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(expint.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt55-gamma.o): relocation R_X86_64_32S against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gamma_inc.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_0F1.o): relocation R_X86_64_32 against `.rodata' can not be ,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:20023,interoperability,share,shared,20023, -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_y.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(coupling.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ellint.o): relocation R_X86_64_32S against symbol `gsl_prec_eps' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(erfc.o): relocation R_X86_64_32S against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(exp.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(expint.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt55-gamma.o): relocation R_X86_64_32S against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gamma_inc.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_0F1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_1F1.o): relocation R_X86_64_32 against `.rodata' can ,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:20226,interoperability,share,shared,20226,th -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(coupling.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ellint.o): relocation R_X86_64_32S against symbol `gsl_prec_eps' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(erfc.o): relocation R_X86_64_32S against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(exp.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(expint.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt55-gamma.o): relocation R_X86_64_32S against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gamma_inc.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_0F1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_1F1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_2F1.o): relocation R_X86_64_32 against `.rodata' ,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:20432,interoperability,share,shared,20432,h -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ellint.o): relocation R_X86_64_32S against symbol `gsl_prec_eps' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(erfc.o): relocation R_X86_64_32S against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(exp.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(expint.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt55-gamma.o): relocation R_X86_64_32S against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gamma_inc.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_0F1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_1F1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_2F1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_U.o): relocation R_X86_64_32 against `.rodata' c,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:20638,interoperability,share,shared,20638,ompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(erfc.o): relocation R_X86_64_32S against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(exp.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(expint.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt55-gamma.o): relocation R_X86_64_32S against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gamma_inc.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_0F1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_1F1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_2F1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_U.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(laguerre.o): relocation R_X86_64_32 against `.rodata' ca,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:20845,interoperability,share,shared,20845,with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(exp.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(expint.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt55-gamma.o): relocation R_X86_64_32S against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gamma_inc.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_0F1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_1F1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_2F1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_U.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(laguerre.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(legendre_poly.o): relocation R_X86_64_32 against `.rodata',MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:21052,interoperability,share,shared,21052,PIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(expint.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt55-gamma.o): relocation R_X86_64_32S against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gamma_inc.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_0F1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_1F1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_2F1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_U.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(laguerre.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(legendre_poly.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(log.o): relocation R_X86_64_32 against `.rodata' can no,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:21259,interoperability,share,shared,21259, /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt55-gamma.o): relocation R_X86_64_32S against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gamma_inc.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_0F1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_1F1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_2F1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_U.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(laguerre.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(legendre_poly.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(log.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(poch.o): relocation R_X86_64_32 against `.rodata' can not be u,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:21464,interoperability,share,shared,21464,. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gamma_inc.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_0F1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_1F1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_2F1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_U.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(laguerre.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(legendre_poly.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(log.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(poch.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(pow_int.o): relocation R_X86_64_32 against `.rodata' can not be us,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:21669,interoperability,share,shared,21669,C. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_0F1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_1F1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_2F1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_U.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(laguerre.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(legendre_poly.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(log.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(poch.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(pow_int.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(psi.o): relocation R_X86_64_32 against `.rodata' can not be used wh,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:21879,interoperability,share,shared,21879,/cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_1F1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_2F1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_U.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(laguerre.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(legendre_poly.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(log.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(poch.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(pow_int.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(psi.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(trig.o): relocation R_X86_64_32 against `.data' can not be used when making a,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:22079,interoperability,share,shared,22079,-fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_2F1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_U.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(laguerre.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(legendre_poly.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(log.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(poch.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(pow_int.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(psi.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(trig.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(zeta.o): relocation R_X86_64_32 against `.data' can not be used when making a ,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:22280,interoperability,share,shared,22280, with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_U.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(laguerre.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(legendre_poly.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(log.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(poch.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(pow_int.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(psi.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(trig.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(zeta.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt60-copy.o): relocation R_X86_64_32 against `.rodata' can not be used when maki,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:22484,interoperability,share,shared,22484,e with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(laguerre.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(legendre_poly.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(log.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(poch.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(pow_int.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(psi.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(trig.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(zeta.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt60-copy.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt62-init.o): relocation R_X86_64_32 against `.rodata' can not be used when ma,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:22684,interoperability,share,shared,22684,ompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(legendre_poly.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(log.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(poch.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(pow_int.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(psi.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(trig.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(zeta.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt60-copy.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt62-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt64-oper.o): relocation R_X86_64_32 against `.rodata' can not be used w,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:22883,interoperability,share,shared,22883,object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(log.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(poch.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(pow_int.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(psi.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(trig.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(zeta.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt60-copy.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt62-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt64-oper.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt65-prop.o): relocation R_X86_64_32 against `.rodata' can not be,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:23082,interoperability,share,shared,23082, object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(poch.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(pow_int.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(psi.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(trig.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(zeta.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt60-copy.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt62-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt64-oper.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt65-prop.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vector.o): relocation R_X86_64_32 against `.rodata' can no,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:23288,interoperability,share,shared,23288,ct; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(pow_int.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(psi.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(trig.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(zeta.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt60-copy.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt62-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt64-oper.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt65-prop.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vector.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt67-view.o): relocation R_X86_64_32 against `.rodata' can no,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:23494,interoperability,share,shared,23494,; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(psi.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(trig.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(zeta.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt60-copy.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt62-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt64-oper.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt65-prop.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vector.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt67-view.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gammainv.o): relocation R_X86_64_32 against `.rodata' can not,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:23700,interoperability,share,shared,23700,mpile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(trig.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(zeta.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt60-copy.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt62-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt64-oper.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt65-prop.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vector.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt67-view.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gammainv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(tdistinv.o): relocation R_X86_64_32 against `.rodata' can not ,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:23906,interoperability,share,shared,23906,ith -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(zeta.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt60-copy.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt62-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt64-oper.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt65-prop.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vector.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt67-view.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gammainv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(tdistinv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(init.o): relocation R_X86_64_32 against `.rodata' can not be us,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:24109,interoperability,share,shared,24109,-fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt60-copy.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt62-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt64-oper.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt65-prop.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vector.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt67-view.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gammainv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(tdistinv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(interp.o): relocation R_X86_64_32 against `.rodata' can not be us,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:24315,interoperability,share,shared,24315,-fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt62-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt64-oper.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt65-prop.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vector.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt67-view.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gammainv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(tdistinv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(interp.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lu.o): relocation R_X86_64_32 against `.rodata' can not be used when,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:24520,interoperability,share,shared,24520, -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt64-oper.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt65-prop.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vector.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt67-view.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gammainv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(tdistinv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(interp.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qr.o): relocation R_X86_64_32 against `.rodata' can not be used when makin,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:24725,interoperability,share,shared,24725,h -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt65-prop.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vector.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt67-view.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gammainv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(tdistinv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(interp.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qrpt.o): relocation R_X86_64_32 against `.rodata' can not be used when making a ,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:24926,interoperability,share,shared,24926,e with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(vector.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt67-view.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gammainv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(tdistinv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(interp.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qrpt.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt8-copy.o): relocation R_X86_64_32 against `.rodata' can not be used when makin,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:25129,interoperability,share,shared,25129,e with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt67-view.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gammainv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(tdistinv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(interp.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qrpt.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt8-copy.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(matrix.o): relocation R_X86_64_32 against `.rodata' can not be used when makin,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:25328,interoperability,share,shared,25328,ecompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(gammainv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(tdistinv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(interp.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qrpt.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt8-copy.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(matrix.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(rowcol.o): relocation R_X86_64_32 against `.rodata' can not be used when m,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:25527,interoperability,share,shared,25527,ect; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(tdistinv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(interp.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qrpt.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt8-copy.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(matrix.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(rowcol.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(submatrix.o): relocation R_X86_64_32 against `.rodata' can not be used,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:25728,interoperability,share,shared,25728, object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(interp.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qrpt.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt8-copy.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(matrix.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(rowcol.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(submatrix.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(swap.o): relocation R_X86_64_32 against `.rodata' can not be used,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:25933,interoperability,share,shared,25933,ect; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(interp.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qrpt.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt8-copy.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(matrix.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(rowcol.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(submatrix.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(swap.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(permutation.o): relocation R_X86_64_32 against `.rodata' can not be u,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:26136,interoperability,share,shared,26136,ect; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lu.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qrpt.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt8-copy.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(matrix.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(rowcol.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(submatrix.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(swap.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(permutation.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ran0.o): relocation R_X86_64_32 against `.rodata' can not be use,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:26339,interoperability,share,shared,26339, recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qrpt.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt8-copy.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(matrix.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(rowcol.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(submatrix.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(swap.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(permutation.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ran0.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(tt.o): relocation R_X86_64_32 against `.rodata' can not be used wh,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:26545,interoperability,share,shared,26545,ile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qrpt.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt8-copy.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(matrix.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(rowcol.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(submatrix.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(swap.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(permutation.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ran0.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(tt.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel.o): relocation R_X86_64_32 against `.rodata' can not be used when ,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:26746,interoperability,share,shared,26746,ile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt8-copy.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(matrix.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(rowcol.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(submatrix.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(swap.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(permutation.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ran0.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(tt.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_I1.o): relocation R_X86_64_32 against `.rodata' can not be used ,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:26954,interoperability,share,shared,26954, with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(matrix.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(rowcol.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(submatrix.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(swap.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(permutation.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ran0.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(tt.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_I1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_In.o): relocation R_X86_64_32 against `.rodata' can not be used wh,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:27155,interoperability,share,shared,27155,le with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(rowcol.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(submatrix.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(swap.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(permutation.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ran0.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(tt.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_I1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_In.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_J0.o): relocation R_X86_64_32 against `.data' can not be used,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:27354,interoperability,share,shared,27354,ompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(submatrix.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(swap.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(permutation.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ran0.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(tt.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_I1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_In.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_J0.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_J1.o): relocation R_X86_64_32 against `.rodata' can not ,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:27557,interoperability,share,shared,27557,recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(swap.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(permutation.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ran0.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(tt.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_I1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_In.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_J0.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_J1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Jn.o): relocation R_X86_64_32 against `.rodata' can n,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:27763,interoperability,share,shared,27763,pile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(permutation.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ran0.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(tt.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_I1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_In.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_J0.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_J1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Jn.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_K0.o): relocation R_X86_64_32 against `.rodata' can n,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:27969,interoperability,share,shared,27969,ompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ran0.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(tt.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_I1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_In.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_J0.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_J1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Jn.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_K0.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt54-beta.o): relocation R_X86_64_32 against `.rodata' can n,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:28173,interoperability,share,shared,28173,ile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(tt.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_I1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_In.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_J0.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_J1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Jn.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_K0.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt54-beta.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(elementary.o): relocation R_X86_64_32 against `.rodata' ca,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:28379,interoperability,share,shared,28379,h -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_I1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_In.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_J0.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_J1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Jn.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_K0.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt54-beta.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(elementary.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt56-hyperg.o): relocation R_X86_64_32 against `.rodata' ,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:28585,interoperability,share,shared,28585,fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_I1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_In.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_J0.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_J1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Jn.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_K0.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt54-beta.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(elementary.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt56-hyperg.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(subvector.o): relocation R_X86_64_32 against `.rodata' ,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:28791,interoperability,share,shared,28791,fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_In.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_J0.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_J1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Jn.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_K0.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt54-beta.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(elementary.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt56-hyperg.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(subvector.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt66-swap.o): relocation R_X86_64_32 against `.rodata' ,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:28997,interoperability,share,shared,28997,fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_J0.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_J1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Jn.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_K0.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt54-beta.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(elementary.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt56-hyperg.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(subvector.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt66-swap.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_I0.o): relocation R_X86_64_32 against `.data' ca,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:29204,interoperability,share,shared,29204,C. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_J1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Jn.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_K0.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt54-beta.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(elementary.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt56-hyperg.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(subvector.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt66-swap.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_I0.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(sgemm.o): relocation R_X86_64_32 against `.rodata' ca,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:29412,interoperability,share,shared,29412, /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_Jn.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_K0.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt54-beta.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(elementary.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt56-hyperg.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(subvector.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt66-swap.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_I0.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(sgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(sgemv.o): relocation R_X86_64_32 against `.rodata' can,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:29618,interoperability,share,shared,29618, /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_K0.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt54-beta.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(elementary.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt56-hyperg.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(subvector.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt66-swap.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_I0.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(sgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(sgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(sger.o): relocation R_X86_64_32 against `.rodata' can,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:29824,interoperability,share,shared,29824, /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt54-beta.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(elementary.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt56-hyperg.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(subvector.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt66-swap.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_I0.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(sgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(sgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(sger.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(srotm.o): relocation R_X86_64_32 against `.rodata' ca,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:30028,interoperability,share,shared,30028,C. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(elementary.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt56-hyperg.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(subvector.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt66-swap.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_I0.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(sgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(sgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(sger.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(srotm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssymm.o): relocation R_X86_64_32 against `.rodata',MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:30235,interoperability,share,shared,30235,C. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt56-hyperg.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(subvector.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt66-swap.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_I0.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(sgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(sgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(sger.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(srotm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssymv.o): relocation R_X86_64_32 against `.rodata',MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:30442,interoperability,share,shared,30442,IC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(subvector.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt66-swap.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_I0.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(sgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(sgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(sger.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(srotm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssymv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyr.o): relocation R_X86_64_32 against `.rodata' ,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:30648,interoperability,share,shared,30648,IC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt66-swap.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_I0.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(sgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(sgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(sger.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(srotm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssymv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyr2.o): relocation R_X86_64_32 against `.rodata',MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:30855,interoperability,share,shared,30855,C. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_I0.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(sgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(sgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(sger.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(srotm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssymv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyr2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyr2k.o): relocation R_X86_64_32 against `.rodata,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:31062,interoperability,share,shared,31062,/cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(sgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(sgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(sger.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(srotm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssymv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyr2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyrk.o): relocation R_X86_64_32 against `.rodata,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:31269,interoperability,share,shared,31269,/cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(sgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(sger.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(srotm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssymv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyr2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strmm.o): relocation R_X86_64_32 against `.rodata,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:31475,interoperability,share,shared,31475, /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(sger.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(srotm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssymv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyr2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strmv.o): relocation R_X86_64_32 against `.rodat,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:31682,interoperability,share,shared,31682,/cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(srotm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssymv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyr2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strsm.o): relocation R_X86_64_32 against `.rodat,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:31890,interoperability,share,shared,31890,cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssymv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyr2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strsv.o): relocation R_X86_64_32 against `.rodata,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:32097,interoperability,share,shared,32097,cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssymv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyr2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dgemm.o): relocation R_X86_64_32 against `.rodata,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:32304,interoperability,share,shared,32304,cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyr2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dgemv.o): relocation R_X86_64_32 against `.rodata,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:32511,interoperability,share,shared,32511,vmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyr2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dger.o): relocation R_X86_64_32 against `.rodata',MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:32718,interoperability,share,shared,32718,vmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dger.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(drotm.o): relocation R_X86_64_32 against `.rodata',MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:32925,interoperability,share,shared,32925,cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ssyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dger.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(drotm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsymm.o): relocation R_X86_64_32 against `.rodata',MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:33132,interoperability,share,shared,33132,cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dger.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(drotm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsymv.o): relocation R_X86_64_32 against `.rodata',MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:33339,interoperability,share,shared,33339,cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dger.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(drotm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsymv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyr.o): relocation R_X86_64_32 against `.rodata' ,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:33545,interoperability,share,shared,33545,/cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dger.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(drotm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsymv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyr2.o): relocation R_X86_64_32 against `.rodata',MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:33752,interoperability,share,shared,33752,/cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(strsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dger.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(drotm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsymv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyr2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyr2k.o): relocation R_X86_64_32 against `.rodata,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:33959,interoperability,share,shared,33959,/cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dger.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(drotm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsymv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyr2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyrk.o): relocation R_X86_64_32 against `.rodata,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:34166,interoperability,share,shared,34166,/cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dger.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(drotm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsymv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyr2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrmm.o): relocation R_X86_64_32 against `.rodata,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:34372,interoperability,share,shared,34372, /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dger.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(drotm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsymv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyr2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrmv.o): relocation R_X86_64_32 against `.rodat,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:34579,interoperability,share,shared,34579,/cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(drotm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsymv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyr2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrsm.o): relocation R_X86_64_32 against `.rodat,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:34787,interoperability,share,shared,34787,cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsymv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyr2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrsv.o): relocation R_X86_64_32 against `.rodata,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:34994,interoperability,share,shared,34994,cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsymv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyr2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgemm.o): relocation R_X86_64_32 against `.rodata,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:35201,interoperability,share,shared,35201,cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyr.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyr2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgemv.o): relocation R_X86_64_32 against `.rodata,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:35408,interoperability,share,shared,35408,vmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyr2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgerc.o): relocation R_X86_64_32 against `.rodata,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:35615,interoperability,share,shared,35615,vmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgerc.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgeru.o): relocation R_X86_64_32 against `.rodata,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:35822,interoperability,share,shared,35822,cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgerc.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgeru.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(chemm.o): relocation R_X86_64_32 against `.rodata,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:36029,interoperability,share,shared,36029,cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgerc.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgeru.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(chemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(chemv.o): relocation R_X86_64_32 against `.rodata,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:36236,interoperability,share,shared,36236,cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgerc.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgeru.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(chemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(chemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cher.o): relocation R_X86_64_32 against `.rodata',MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:36443,interoperability,share,shared,36443,cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgerc.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgeru.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(chemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(chemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cher.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cher2.o): relocation R_X86_64_32 against `.rodata',MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:36650,interoperability,share,shared,36650,cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(dtrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgerc.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgeru.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(chemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(chemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cher.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cher2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cher2k.o): relocation R_X86_64_32 against `.rodata,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:36857,interoperability,share,shared,36857,cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgerc.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgeru.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(chemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(chemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cher.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cher2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cher2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cherk.o): relocation R_X86_64_32 against `.rodata,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:37064,interoperability,share,shared,37064,cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgerc.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgeru.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(chemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(chemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cher.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cher2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cher2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cherk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(csymm.o): relocation R_X86_64_32 against `.rodata,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:37270,interoperability,share,shared,37270,/cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgerc.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgeru.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(chemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(chemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cher.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cher2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cher2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cherk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(csymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(csyr2k.o): relocation R_X86_64_32 against `.roda,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:37477,interoperability,share,shared,37477,/cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cgeru.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(chemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(chemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cher.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cher2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cher2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cherk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(csymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(csyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(csyrk.o): relocation R_X86_64_32 against `.roda,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:37685,interoperability,share,shared,37685,cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(chemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(chemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cher.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cher2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cher2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cherk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(csymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(csyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(csyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrmm.o): relocation R_X86_64_32 against `.rodat,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:37892,interoperability,share,shared,37892,cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(chemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cher.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cher2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cher2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cherk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(csymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(csyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(csyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrmv.o): relocation R_X86_64_32 against `.rodat,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:38099,interoperability,share,shared,38099,cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cher.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cher2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cher2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cherk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(csymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(csyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(csyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrsm.o): relocation R_X86_64_32 against `.rodat,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:38307,interoperability,share,shared,38307,mfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cher2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cher2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cherk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(csymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(csyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(csyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrsv.o): relocation R_X86_64_32 against `.rodata,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:38514,interoperability,share,shared,38514,mfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cher2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cherk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(csymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(csyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(csyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgemm.o): relocation R_X86_64_32 against `.rodata,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:38721,interoperability,share,shared,38721,vmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(cherk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(csymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(csyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(csyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgemv.o): relocation R_X86_64_32 against `.rodata,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:38928,interoperability,share,shared,38928,vmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(csymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(csyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(csyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgerc.o): relocation R_X86_64_32 against `.rodata,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:39135,interoperability,share,shared,39135,vmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(csyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(csyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgerc.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgeru.o): relocation R_X86_64_32 against `.rodata,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:39342,interoperability,share,shared,39342,cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(csyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgerc.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgeru.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zhemm.o): relocation R_X86_64_32 against `.rodata,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:39549,interoperability,share,shared,39549,cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgerc.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgeru.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zhemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zhemv.o): relocation R_X86_64_32 against `.rodata,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:39756,interoperability,share,shared,39756,cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgerc.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgeru.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zhemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zhemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zher.o): relocation R_X86_64_32 against `.rodata',MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:39963,interoperability,share,shared,39963,cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgerc.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgeru.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zhemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zhemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zher.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zher2.o): relocation R_X86_64_32 against `.rodata',MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:40170,interoperability,share,shared,40170,cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ctrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgerc.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgeru.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zhemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zhemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zher.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zher2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zher2k.o): relocation R_X86_64_32 against `.rodata,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:40377,interoperability,share,shared,40377,cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgerc.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgeru.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zhemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zhemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zher.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zher2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zher2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zherk.o): relocation R_X86_64_32 against `.rodata,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:40584,interoperability,share,shared,40584,cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgerc.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgeru.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zhemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zhemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zher.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zher2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zher2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zherk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsymm.o): relocation R_X86_64_32 against `.rodata,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:40790,interoperability,share,shared,40790,/cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgerc.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgeru.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zhemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zhemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zher.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zher2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zher2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zherk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyr2k.o): relocation R_X86_64_32 against `.roda,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:40997,interoperability,share,shared,40997,/cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zgeru.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zhemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zhemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zher.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zher2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zher2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zherk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.roda,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:41205,interoperability,share,shared,41205,cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zhemm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zhemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zher.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zher2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zher2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zherk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodat,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:41412,interoperability,share,shared,41412,cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zhemv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zher.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zher2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zher2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zherk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodat,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:41619,interoperability,share,shared,41619,cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zher.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zher2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zher2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zherk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodat,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:41827,interoperability,share,shared,41827,mfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zher2.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zher2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zherk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsv.o): relocation R_X86_64_32 against `.rodata,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:42034,interoperability,share,shared,42034,mfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zher2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zherk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(xerbla.o): relocation R_X86_64_32 against `.rodat,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:42241,interoperability,share,shared,42241,vmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zherk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(xerbla.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: final link failed: Nonrepresentable section on output. collect2: error: ,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:42448,interoperability,share,shared,42448,vmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsymm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(xerbla.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: final link failed: Nonrepresentable section on output. collect2: error: ld returned 1 exit status. make[3]: *** [lib/libMathMore.so] Error 1. make[2]: *** [math/mathmore/CMakeFiles/MathMore.dir/all] Error 2. make[1]: *** [math/mathmore/CMakeFiles/MathMore.dir/rule] Error 2. make,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:42655,interoperability,share,shared,42655,vmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyr2k.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(xerbla.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: final link failed: Nonrepresentable section on output. collect2: error: ld returned 1 exit status. make[3]: *** [lib/libMathMore.so] Error 1. make[2]: *** [math/mathmore/CMakeFiles/MathMore.dir/all] Error 2. make[1]: *** [math/mathmore/CMakeFiles/MathMore.dir/rule] Error 2. make: *** [MathMore] Error 2. ```. This came from trying to build the master branch in the way that we build ROOT for the ATLAS analysis releases (https://gitlab.cern.ch/atlas/atlasexternals/blob/1.0/External/RO,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:42862,interoperability,share,shared,42862,"cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(xerbla.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: final link failed: Nonrepresentable section on output. collect2: error: ld returned 1 exit status. make[3]: *** [lib/libMathMore.so] Error 1. make[2]: *** [math/mathmore/CMakeFiles/MathMore.dir/all] Error 2. make[1]: *** [math/mathmore/CMakeFiles/MathMore.dir/rule] Error 2. make: *** [MathMore] Error 2. ```. This came from trying to build the master branch in the way that we build ROOT for the ATLAS analysis releases (https://gitlab.cern.ch/atlas/atlasexternals/blob/1.0/External/ROOT/CMakeLists.txt), using a command like:. ```. cmake -Dall=ON -Dbuiltin_gsl=ON -Dbuiltin_freetype=ON -Dbuiltin_fftw3=ON -Dbuiltin_lzma=ON -DCMAKE_BUILD_TYPE=Release -Dcxx14=ON -Dxrootd=ON -Ddcache=ON -Ddavi",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:43070,interoperability,share,shared,43070,"2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(xerbla.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: final link failed: Nonrepresentable section on output. collect2: error: ld returned 1 exit status. make[3]: *** [lib/libMathMore.so] Error 1. make[2]: *** [math/mathmore/CMakeFiles/MathMore.dir/all] Error 2. make[1]: *** [math/mathmore/CMakeFiles/MathMore.dir/rule] Error 2. make: *** [MathMore] Error 2. ```. This came from trying to build the master branch in the way that we build ROOT for the ATLAS analysis releases (https://gitlab.cern.ch/atlas/atlasexternals/blob/1.0/External/ROOT/CMakeLists.txt), using a command like:. ```. cmake -Dall=ON -Dbuiltin_gsl=ON -Dbuiltin_freetype=ON -Dbuiltin_fftw3=ON -Dbuiltin_lzma=ON -DCMAKE_BUILD_TYPE=Release -Dcxx14=ON -Dxrootd=ON -Ddcache=ON -Ddavix=ON -Dbuiltin_veccore=ON ../root/. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:19323,modifiability,coupl,coupling,19323,32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_j.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_olver.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_temme.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_y.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(coupling.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ellint.o): relocation R_X86_64_32S against symbol `gsl_prec_eps' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(erfc.o): relocation R_X86_64_32S against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(exp.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(expint.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld:,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:1397,performance,error,error,1397,ation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(deriv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(eval.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt1-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(integ.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(error.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(stream.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(strerror.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qag.o): relocation R_X86_64_32S against symbol `gsl_integration_qk15' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qagp.o): relocation R_X86_64_32S against symbol `gsl_integration_qk21' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bi,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:43237,performance,error,error,43237,"2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(xerbla.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: final link failed: Nonrepresentable section on output. collect2: error: ld returned 1 exit status. make[3]: *** [lib/libMathMore.so] Error 1. make[2]: *** [math/mathmore/CMakeFiles/MathMore.dir/all] Error 2. make[1]: *** [math/mathmore/CMakeFiles/MathMore.dir/rule] Error 2. make: *** [MathMore] Error 2. ```. This came from trying to build the master branch in the way that we build ROOT for the ATLAS analysis releases (https://gitlab.cern.ch/atlas/atlasexternals/blob/1.0/External/ROOT/CMakeLists.txt), using a command like:. ```. cmake -Dall=ON -Dbuiltin_gsl=ON -Dbuiltin_freetype=ON -Dbuiltin_fftw3=ON -Dbuiltin_lzma=ON -DCMAKE_BUILD_TYPE=Release -Dcxx14=ON -Dxrootd=ON -Ddcache=ON -Ddavix=ON -Dbuiltin_veccore=ON ../root/. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:43305,performance,Error,Error,43305,"2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(xerbla.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: final link failed: Nonrepresentable section on output. collect2: error: ld returned 1 exit status. make[3]: *** [lib/libMathMore.so] Error 1. make[2]: *** [math/mathmore/CMakeFiles/MathMore.dir/all] Error 2. make[1]: *** [math/mathmore/CMakeFiles/MathMore.dir/rule] Error 2. make: *** [MathMore] Error 2. ```. This came from trying to build the master branch in the way that we build ROOT for the ATLAS analysis releases (https://gitlab.cern.ch/atlas/atlasexternals/blob/1.0/External/ROOT/CMakeLists.txt), using a command like:. ```. cmake -Dall=ON -Dbuiltin_gsl=ON -Dbuiltin_freetype=ON -Dbuiltin_fftw3=ON -Dbuiltin_lzma=ON -DCMAKE_BUILD_TYPE=Release -Dcxx14=ON -Dxrootd=ON -Ddcache=ON -Ddavix=ON -Dbuiltin_veccore=ON ../root/. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:43371,performance,Error,Error,43371,"2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(xerbla.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: final link failed: Nonrepresentable section on output. collect2: error: ld returned 1 exit status. make[3]: *** [lib/libMathMore.so] Error 1. make[2]: *** [math/mathmore/CMakeFiles/MathMore.dir/all] Error 2. make[1]: *** [math/mathmore/CMakeFiles/MathMore.dir/rule] Error 2. make: *** [MathMore] Error 2. ```. This came from trying to build the master branch in the way that we build ROOT for the ATLAS analysis releases (https://gitlab.cern.ch/atlas/atlasexternals/blob/1.0/External/ROOT/CMakeLists.txt), using a command like:. ```. cmake -Dall=ON -Dbuiltin_gsl=ON -Dbuiltin_freetype=ON -Dbuiltin_fftw3=ON -Dbuiltin_lzma=ON -DCMAKE_BUILD_TYPE=Release -Dcxx14=ON -Dxrootd=ON -Ddcache=ON -Ddavix=ON -Dbuiltin_veccore=ON ../root/. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:43438,performance,Error,Error,43438,"2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(xerbla.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: final link failed: Nonrepresentable section on output. collect2: error: ld returned 1 exit status. make[3]: *** [lib/libMathMore.so] Error 1. make[2]: *** [math/mathmore/CMakeFiles/MathMore.dir/all] Error 2. make[1]: *** [math/mathmore/CMakeFiles/MathMore.dir/rule] Error 2. make: *** [MathMore] Error 2. ```. This came from trying to build the master branch in the way that we build ROOT for the ATLAS analysis releases (https://gitlab.cern.ch/atlas/atlasexternals/blob/1.0/External/ROOT/CMakeLists.txt), using a command like:. ```. cmake -Dall=ON -Dbuiltin_gsl=ON -Dbuiltin_freetype=ON -Dbuiltin_fftw3=ON -Dbuiltin_lzma=ON -DCMAKE_BUILD_TYPE=Release -Dcxx14=ON -Dxrootd=ON -Ddcache=ON -Ddavix=ON -Dbuiltin_veccore=ON ../root/. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:43468,performance,Error,Error,43468,"2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(xerbla.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: final link failed: Nonrepresentable section on output. collect2: error: ld returned 1 exit status. make[3]: *** [lib/libMathMore.so] Error 1. make[2]: *** [math/mathmore/CMakeFiles/MathMore.dir/all] Error 2. make[1]: *** [math/mathmore/CMakeFiles/MathMore.dir/rule] Error 2. make: *** [MathMore] Error 2. ```. This came from trying to build the master branch in the way that we build ROOT for the ATLAS analysis releases (https://gitlab.cern.ch/atlas/atlasexternals/blob/1.0/External/ROOT/CMakeLists.txt), using a command like:. ```. cmake -Dall=ON -Dbuiltin_gsl=ON -Dbuiltin_freetype=ON -Dbuiltin_fftw3=ON -Dbuiltin_lzma=ON -DCMAKE_BUILD_TYPE=Release -Dcxx14=ON -Dxrootd=ON -Ddcache=ON -Ddavix=ON -Dbuiltin_veccore=ON ../root/. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:168,reliability,fail,fail,168,"Builtin GSL Fix, master branch (2018.05.09.); Made it explicit that the builtin GSL build should use `-fPIC`. Without it the build, at least on SLC6 with GCC 6.2 would fail to link against the generated GSL library, with messages like:. ```. [100%] Linking CXX shared library ../../lib/libMathMore.so. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(blas.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(deriv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(eval.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt1-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(integ.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(error.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(stream.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(strerror.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/l",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:43183,reliability,fail,failed,43183,"2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(xerbla.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: final link failed: Nonrepresentable section on output. collect2: error: ld returned 1 exit status. make[3]: *** [lib/libMathMore.so] Error 1. make[2]: *** [math/mathmore/CMakeFiles/MathMore.dir/all] Error 2. make[1]: *** [math/mathmore/CMakeFiles/MathMore.dir/rule] Error 2. make: *** [MathMore] Error 2. ```. This came from trying to build the master branch in the way that we build ROOT for the ATLAS analysis releases (https://gitlab.cern.ch/atlas/atlasexternals/blob/1.0/External/ROOT/CMakeLists.txt), using a command like:. ```. cmake -Dall=ON -Dbuiltin_gsl=ON -Dbuiltin_freetype=ON -Dbuiltin_fftw3=ON -Dbuiltin_lzma=ON -DCMAKE_BUILD_TYPE=Release -Dcxx14=ON -Dxrootd=ON -Ddcache=ON -Ddavix=ON -Dbuiltin_veccore=ON ../root/. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:1397,safety,error,error,1397,ation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(deriv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(eval.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt1-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(integ.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(error.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(stream.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(strerror.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qag.o): relocation R_X86_64_32S against symbol `gsl_integration_qk15' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qagp.o): relocation R_X86_64_32S against symbol `gsl_integration_qk21' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bi,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:22000,safety,log,log,22000,2 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_2F1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_U.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(laguerre.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(legendre_poly.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(log.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(poch.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(pow_int.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(psi.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(trig.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:43237,safety,error,error,43237,"2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(xerbla.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: final link failed: Nonrepresentable section on output. collect2: error: ld returned 1 exit status. make[3]: *** [lib/libMathMore.so] Error 1. make[2]: *** [math/mathmore/CMakeFiles/MathMore.dir/all] Error 2. make[1]: *** [math/mathmore/CMakeFiles/MathMore.dir/rule] Error 2. make: *** [MathMore] Error 2. ```. This came from trying to build the master branch in the way that we build ROOT for the ATLAS analysis releases (https://gitlab.cern.ch/atlas/atlasexternals/blob/1.0/External/ROOT/CMakeLists.txt), using a command like:. ```. cmake -Dall=ON -Dbuiltin_gsl=ON -Dbuiltin_freetype=ON -Dbuiltin_fftw3=ON -Dbuiltin_lzma=ON -DCMAKE_BUILD_TYPE=Release -Dcxx14=ON -Dxrootd=ON -Ddcache=ON -Ddavix=ON -Dbuiltin_veccore=ON ../root/. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:43305,safety,Error,Error,43305,"2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(xerbla.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: final link failed: Nonrepresentable section on output. collect2: error: ld returned 1 exit status. make[3]: *** [lib/libMathMore.so] Error 1. make[2]: *** [math/mathmore/CMakeFiles/MathMore.dir/all] Error 2. make[1]: *** [math/mathmore/CMakeFiles/MathMore.dir/rule] Error 2. make: *** [MathMore] Error 2. ```. This came from trying to build the master branch in the way that we build ROOT for the ATLAS analysis releases (https://gitlab.cern.ch/atlas/atlasexternals/blob/1.0/External/ROOT/CMakeLists.txt), using a command like:. ```. cmake -Dall=ON -Dbuiltin_gsl=ON -Dbuiltin_freetype=ON -Dbuiltin_fftw3=ON -Dbuiltin_lzma=ON -DCMAKE_BUILD_TYPE=Release -Dcxx14=ON -Dxrootd=ON -Ddcache=ON -Ddavix=ON -Dbuiltin_veccore=ON ../root/. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:43371,safety,Error,Error,43371,"2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(xerbla.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: final link failed: Nonrepresentable section on output. collect2: error: ld returned 1 exit status. make[3]: *** [lib/libMathMore.so] Error 1. make[2]: *** [math/mathmore/CMakeFiles/MathMore.dir/all] Error 2. make[1]: *** [math/mathmore/CMakeFiles/MathMore.dir/rule] Error 2. make: *** [MathMore] Error 2. ```. This came from trying to build the master branch in the way that we build ROOT for the ATLAS analysis releases (https://gitlab.cern.ch/atlas/atlasexternals/blob/1.0/External/ROOT/CMakeLists.txt), using a command like:. ```. cmake -Dall=ON -Dbuiltin_gsl=ON -Dbuiltin_freetype=ON -Dbuiltin_fftw3=ON -Dbuiltin_lzma=ON -DCMAKE_BUILD_TYPE=Release -Dcxx14=ON -Dxrootd=ON -Ddcache=ON -Ddavix=ON -Dbuiltin_veccore=ON ../root/. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:43438,safety,Error,Error,43438,"2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(xerbla.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: final link failed: Nonrepresentable section on output. collect2: error: ld returned 1 exit status. make[3]: *** [lib/libMathMore.so] Error 1. make[2]: *** [math/mathmore/CMakeFiles/MathMore.dir/all] Error 2. make[1]: *** [math/mathmore/CMakeFiles/MathMore.dir/rule] Error 2. make: *** [MathMore] Error 2. ```. This came from trying to build the master branch in the way that we build ROOT for the ATLAS analysis releases (https://gitlab.cern.ch/atlas/atlasexternals/blob/1.0/External/ROOT/CMakeLists.txt), using a command like:. ```. cmake -Dall=ON -Dbuiltin_gsl=ON -Dbuiltin_freetype=ON -Dbuiltin_fftw3=ON -Dbuiltin_lzma=ON -DCMAKE_BUILD_TYPE=Release -Dcxx14=ON -Dxrootd=ON -Ddcache=ON -Ddavix=ON -Dbuiltin_veccore=ON ../root/. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:43468,safety,Error,Error,43468,"2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(xerbla.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: final link failed: Nonrepresentable section on output. collect2: error: ld returned 1 exit status. make[3]: *** [lib/libMathMore.so] Error 1. make[2]: *** [math/mathmore/CMakeFiles/MathMore.dir/all] Error 2. make[1]: *** [math/mathmore/CMakeFiles/MathMore.dir/rule] Error 2. make: *** [MathMore] Error 2. ```. This came from trying to build the master branch in the way that we build ROOT for the ATLAS analysis releases (https://gitlab.cern.ch/atlas/atlasexternals/blob/1.0/External/ROOT/CMakeLists.txt), using a command like:. ```. cmake -Dall=ON -Dbuiltin_gsl=ON -Dbuiltin_freetype=ON -Dbuiltin_fftw3=ON -Dbuiltin_lzma=ON -DCMAKE_BUILD_TYPE=Release -Dcxx14=ON -Dxrootd=ON -Ddcache=ON -Ddavix=ON -Dbuiltin_veccore=ON ../root/. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:22000,security,log,log,22000,2 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_2F1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_U.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(laguerre.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(legendre_poly.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(log.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(poch.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(pow_int.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(psi.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(trig.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:19323,testability,coupl,coupling,19323,32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_j.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_olver.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_temme.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(bessel_y.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(coupling.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(ellint.o): relocation R_X86_64_32S against symbol `gsl_prec_eps' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(erfc.o): relocation R_X86_64_32S against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(exp.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(expint.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld:,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:22000,testability,log,log,22000,2 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_2F1.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(hyperg_U.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(laguerre.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(legendre_poly.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(log.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(poch.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(pow_int.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(psi.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(trig.o): relocation R_X86_64_32 against `.data' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:1397,usability,error,error,1397,ation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(deriv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(eval.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(lt1-init.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(integ.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(error.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(stream.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(strerror.o): relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qag.o): relocation R_X86_64_32S against symbol `gsl_integration_qk15' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgsl.a(qagp.o): relocation R_X86_64_32S against symbol `gsl_integration_qk21' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bi,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:43237,usability,error,error,43237,"2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(xerbla.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: final link failed: Nonrepresentable section on output. collect2: error: ld returned 1 exit status. make[3]: *** [lib/libMathMore.so] Error 1. make[2]: *** [math/mathmore/CMakeFiles/MathMore.dir/all] Error 2. make[1]: *** [math/mathmore/CMakeFiles/MathMore.dir/rule] Error 2. make: *** [MathMore] Error 2. ```. This came from trying to build the master branch in the way that we build ROOT for the ATLAS analysis releases (https://gitlab.cern.ch/atlas/atlasexternals/blob/1.0/External/ROOT/CMakeLists.txt), using a command like:. ```. cmake -Dall=ON -Dbuiltin_gsl=ON -Dbuiltin_freetype=ON -Dbuiltin_fftw3=ON -Dbuiltin_lzma=ON -DCMAKE_BUILD_TYPE=Release -Dcxx14=ON -Dxrootd=ON -Ddcache=ON -Ddavix=ON -Dbuiltin_veccore=ON ../root/. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:43263,usability,statu,status,43263,"2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(xerbla.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: final link failed: Nonrepresentable section on output. collect2: error: ld returned 1 exit status. make[3]: *** [lib/libMathMore.so] Error 1. make[2]: *** [math/mathmore/CMakeFiles/MathMore.dir/all] Error 2. make[1]: *** [math/mathmore/CMakeFiles/MathMore.dir/rule] Error 2. make: *** [MathMore] Error 2. ```. This came from trying to build the master branch in the way that we build ROOT for the ATLAS analysis releases (https://gitlab.cern.ch/atlas/atlasexternals/blob/1.0/External/ROOT/CMakeLists.txt), using a command like:. ```. cmake -Dall=ON -Dbuiltin_gsl=ON -Dbuiltin_freetype=ON -Dbuiltin_fftw3=ON -Dbuiltin_lzma=ON -DCMAKE_BUILD_TYPE=Release -Dcxx14=ON -Dxrootd=ON -Ddcache=ON -Ddavix=ON -Dbuiltin_veccore=ON ../root/. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:43305,usability,Error,Error,43305,"2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(xerbla.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: final link failed: Nonrepresentable section on output. collect2: error: ld returned 1 exit status. make[3]: *** [lib/libMathMore.so] Error 1. make[2]: *** [math/mathmore/CMakeFiles/MathMore.dir/all] Error 2. make[1]: *** [math/mathmore/CMakeFiles/MathMore.dir/rule] Error 2. make: *** [MathMore] Error 2. ```. This came from trying to build the master branch in the way that we build ROOT for the ATLAS analysis releases (https://gitlab.cern.ch/atlas/atlasexternals/blob/1.0/External/ROOT/CMakeLists.txt), using a command like:. ```. cmake -Dall=ON -Dbuiltin_gsl=ON -Dbuiltin_freetype=ON -Dbuiltin_fftw3=ON -Dbuiltin_lzma=ON -DCMAKE_BUILD_TYPE=Release -Dcxx14=ON -Dxrootd=ON -Ddcache=ON -Ddavix=ON -Dbuiltin_veccore=ON ../root/. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:43371,usability,Error,Error,43371,"2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(xerbla.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: final link failed: Nonrepresentable section on output. collect2: error: ld returned 1 exit status. make[3]: *** [lib/libMathMore.so] Error 1. make[2]: *** [math/mathmore/CMakeFiles/MathMore.dir/all] Error 2. make[1]: *** [math/mathmore/CMakeFiles/MathMore.dir/rule] Error 2. make: *** [MathMore] Error 2. ```. This came from trying to build the master branch in the way that we build ROOT for the ATLAS analysis releases (https://gitlab.cern.ch/atlas/atlasexternals/blob/1.0/External/ROOT/CMakeLists.txt), using a command like:. ```. cmake -Dall=ON -Dbuiltin_gsl=ON -Dbuiltin_freetype=ON -Dbuiltin_fftw3=ON -Dbuiltin_lzma=ON -DCMAKE_BUILD_TYPE=Release -Dcxx14=ON -Dxrootd=ON -Ddcache=ON -Ddavix=ON -Dbuiltin_veccore=ON ../root/. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:43438,usability,Error,Error,43438,"2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(xerbla.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: final link failed: Nonrepresentable section on output. collect2: error: ld returned 1 exit status. make[3]: *** [lib/libMathMore.so] Error 1. make[2]: *** [math/mathmore/CMakeFiles/MathMore.dir/all] Error 2. make[1]: *** [math/mathmore/CMakeFiles/MathMore.dir/rule] Error 2. make: *** [MathMore] Error 2. ```. This came from trying to build the master branch in the way that we build ROOT for the ATLAS analysis releases (https://gitlab.cern.ch/atlas/atlasexternals/blob/1.0/External/ROOT/CMakeLists.txt), using a command like:. ```. cmake -Dall=ON -Dbuiltin_gsl=ON -Dbuiltin_freetype=ON -Dbuiltin_fftw3=ON -Dbuiltin_lzma=ON -DCMAKE_BUILD_TYPE=Release -Dcxx14=ON -Dxrootd=ON -Ddcache=ON -Ddavix=ON -Dbuiltin_veccore=ON ../root/. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:43468,usability,Error,Error,43468,"2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(xerbla.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: final link failed: Nonrepresentable section on output. collect2: error: ld returned 1 exit status. make[3]: *** [lib/libMathMore.so] Error 1. make[2]: *** [math/mathmore/CMakeFiles/MathMore.dir/all] Error 2. make[1]: *** [math/mathmore/CMakeFiles/MathMore.dir/rule] Error 2. make: *** [MathMore] Error 2. ```. This came from trying to build the master branch in the way that we build ROOT for the ATLAS analysis releases (https://gitlab.cern.ch/atlas/atlasexternals/blob/1.0/External/ROOT/CMakeLists.txt), using a command like:. ```. cmake -Dall=ON -Dbuiltin_gsl=ON -Dbuiltin_freetype=ON -Dbuiltin_fftw3=ON -Dbuiltin_lzma=ON -DCMAKE_BUILD_TYPE=Release -Dcxx14=ON -Dxrootd=ON -Ddcache=ON -Ddavix=ON -Dbuiltin_veccore=ON ../root/. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1996:43686,usability,command,command,43686,"2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(zsyrk.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrmv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsm.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(ztrsv.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: ../../lib/libgslcblas.a(xerbla.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC. /cvmfs/sft.cern.ch/lcg/contrib/bintuils/2.28/x86_64-slc6/bin/ld: final link failed: Nonrepresentable section on output. collect2: error: ld returned 1 exit status. make[3]: *** [lib/libMathMore.so] Error 1. make[2]: *** [math/mathmore/CMakeFiles/MathMore.dir/all] Error 2. make[1]: *** [math/mathmore/CMakeFiles/MathMore.dir/rule] Error 2. make: *** [MathMore] Error 2. ```. This came from trying to build the master branch in the way that we build ROOT for the ATLAS analysis releases (https://gitlab.cern.ch/atlas/atlasexternals/blob/1.0/External/ROOT/CMakeLists.txt), using a command like:. ```. cmake -Dall=ON -Dbuiltin_gsl=ON -Dbuiltin_freetype=ON -Dbuiltin_fftw3=ON -Dbuiltin_lzma=ON -DCMAKE_BUILD_TYPE=Release -Dcxx14=ON -Dxrootd=ON -Ddcache=ON -Ddavix=ON -Dbuiltin_veccore=ON ../root/. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1996
https://github.com/root-project/root/pull/1997:0,safety,Avoid,Avoid,0,Avoid out-of-bound read.; Note: This read was however harmless as the loop cut short immediately thereafter. without using the result of the read.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1997
https://github.com/root-project/root/pull/1998:204,availability,cluster,cluster,204,"Avoid over-sizing basket when they contain fixed size data.; Basically, the problem was twofold:. 1. Using the number of entries for scaling the basket size can be really incorrect -- rather, we want the cluster size. This is only available it OptimizeBaskets is called via AutoFlush. 2. We only need to set aside extra metadata if there is an entry offset buffer.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1998
https://github.com/root-project/root/pull/1998:231,availability,avail,available,231,"Avoid over-sizing basket when they contain fixed size data.; Basically, the problem was twofold:. 1. Using the number of entries for scaling the basket size can be really incorrect -- rather, we want the cluster size. This is only available it OptimizeBaskets is called via AutoFlush. 2. We only need to set aside extra metadata if there is an entry offset buffer.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1998
https://github.com/root-project/root/pull/1998:35,deployability,contain,contain,35,"Avoid over-sizing basket when they contain fixed size data.; Basically, the problem was twofold:. 1. Using the number of entries for scaling the basket size can be really incorrect -- rather, we want the cluster size. This is only available it OptimizeBaskets is called via AutoFlush. 2. We only need to set aside extra metadata if there is an entry offset buffer.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1998
https://github.com/root-project/root/pull/1998:204,deployability,cluster,cluster,204,"Avoid over-sizing basket when they contain fixed size data.; Basically, the problem was twofold:. 1. Using the number of entries for scaling the basket size can be really incorrect -- rather, we want the cluster size. This is only available it OptimizeBaskets is called via AutoFlush. 2. We only need to set aside extra metadata if there is an entry offset buffer.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1998
https://github.com/root-project/root/pull/1998:244,energy efficiency,Optim,OptimizeBaskets,244,"Avoid over-sizing basket when they contain fixed size data.; Basically, the problem was twofold:. 1. Using the number of entries for scaling the basket size can be really incorrect -- rather, we want the cluster size. This is only available it OptimizeBaskets is called via AutoFlush. 2. We only need to set aside extra metadata if there is an entry offset buffer.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1998
https://github.com/root-project/root/pull/1998:357,integrability,buffer,buffer,357,"Avoid over-sizing basket when they contain fixed size data.; Basically, the problem was twofold:. 1. Using the number of entries for scaling the basket size can be really incorrect -- rather, we want the cluster size. This is only available it OptimizeBaskets is called via AutoFlush. 2. We only need to set aside extra metadata if there is an entry offset buffer.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1998
https://github.com/root-project/root/pull/1998:133,modifiability,scal,scaling,133,"Avoid over-sizing basket when they contain fixed size data.; Basically, the problem was twofold:. 1. Using the number of entries for scaling the basket size can be really incorrect -- rather, we want the cluster size. This is only available it OptimizeBaskets is called via AutoFlush. 2. We only need to set aside extra metadata if there is an entry offset buffer.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1998
https://github.com/root-project/root/pull/1998:244,performance,Optimiz,OptimizeBaskets,244,"Avoid over-sizing basket when they contain fixed size data.; Basically, the problem was twofold:. 1. Using the number of entries for scaling the basket size can be really incorrect -- rather, we want the cluster size. This is only available it OptimizeBaskets is called via AutoFlush. 2. We only need to set aside extra metadata if there is an entry offset buffer.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1998
https://github.com/root-project/root/pull/1998:231,reliability,availab,available,231,"Avoid over-sizing basket when they contain fixed size data.; Basically, the problem was twofold:. 1. Using the number of entries for scaling the basket size can be really incorrect -- rather, we want the cluster size. This is only available it OptimizeBaskets is called via AutoFlush. 2. We only need to set aside extra metadata if there is an entry offset buffer.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1998
https://github.com/root-project/root/pull/1998:0,safety,Avoid,Avoid,0,"Avoid over-sizing basket when they contain fixed size data.; Basically, the problem was twofold:. 1. Using the number of entries for scaling the basket size can be really incorrect -- rather, we want the cluster size. This is only available it OptimizeBaskets is called via AutoFlush. 2. We only need to set aside extra metadata if there is an entry offset buffer.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1998
https://github.com/root-project/root/pull/1998:231,safety,avail,available,231,"Avoid over-sizing basket when they contain fixed size data.; Basically, the problem was twofold:. 1. Using the number of entries for scaling the basket size can be really incorrect -- rather, we want the cluster size. This is only available it OptimizeBaskets is called via AutoFlush. 2. We only need to set aside extra metadata if there is an entry offset buffer.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1998
https://github.com/root-project/root/pull/1998:231,security,availab,available,231,"Avoid over-sizing basket when they contain fixed size data.; Basically, the problem was twofold:. 1. Using the number of entries for scaling the basket size can be really incorrect -- rather, we want the cluster size. This is only available it OptimizeBaskets is called via AutoFlush. 2. We only need to set aside extra metadata if there is an entry offset buffer.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1998
https://github.com/root-project/root/pull/1999:20,energy efficiency,alloc,allocate,20,Fix ROOT-9393; i.e. allocate enough memory for the data!,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1999
https://github.com/root-project/root/pull/1999:36,performance,memor,memory,36,Fix ROOT-9393; i.e. allocate enough memory for the data!,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1999
https://github.com/root-project/root/pull/1999:36,usability,memor,memory,36,Fix ROOT-9393; i.e. allocate enough memory for the data!,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1999
https://github.com/root-project/root/pull/2000:70,deployability,modul,modules,70,[cxxmodules] Headerparsing is switched off by default; This fixes few modules bugs.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2000
https://github.com/root-project/root/pull/2000:70,modifiability,modul,modules,70,[cxxmodules] Headerparsing is switched off by default; This fixes few modules bugs.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2000
https://github.com/root-project/root/pull/2000:70,safety,modul,modules,70,[cxxmodules] Headerparsing is switched off by default; This fixes few modules bugs.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2000
https://github.com/root-project/root/pull/2001:31,safety,test,tests,31,"[cxxmodules] Exclude remaining tests; Excluded tdf012_DefinesAndFiltersAsStrings, stressvector-interpreted,. stressmathcore-interpreted when runtime_cxxmodules is On.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2001
https://github.com/root-project/root/pull/2001:31,testability,test,tests,31,"[cxxmodules] Exclude remaining tests; Excluded tdf012_DefinesAndFiltersAsStrings, stressvector-interpreted,. stressmathcore-interpreted when runtime_cxxmodules is On.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2001
https://github.com/root-project/root/pull/2002:88,deployability,patch,patch,88,tree/TChain: revise treatment of tree_name in TChain URLs (fix for RO; OT-9344). This patch provides a fix for ROOT-9344. Support for the spurious way to pass. the tree name in the url as '/tree_name' is limited to cases where the substring. '.root' is contained in the file name but not in the tree name. Updates the infile documentation with deprecation for the old practice.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2002
https://github.com/root-project/root/pull/2002:255,deployability,contain,contained,255,tree/TChain: revise treatment of tree_name in TChain URLs (fix for RO; OT-9344). This patch provides a fix for ROOT-9344. Support for the spurious way to pass. the tree name in the url as '/tree_name' is limited to cases where the substring. '.root' is contained in the file name but not in the tree name. Updates the infile documentation with deprecation for the old practice.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2002
https://github.com/root-project/root/pull/2002:308,deployability,Updat,Updates,308,tree/TChain: revise treatment of tree_name in TChain URLs (fix for RO; OT-9344). This patch provides a fix for ROOT-9344. Support for the spurious way to pass. the tree name in the url as '/tree_name' is limited to cases where the substring. '.root' is contained in the file name but not in the tree name. Updates the infile documentation with deprecation for the old practice.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2002
https://github.com/root-project/root/pull/2002:233,integrability,sub,substring,233,tree/TChain: revise treatment of tree_name in TChain URLs (fix for RO; OT-9344). This patch provides a fix for ROOT-9344. Support for the spurious way to pass. the tree name in the url as '/tree_name' is limited to cases where the substring. '.root' is contained in the file name but not in the tree name. Updates the infile documentation with deprecation for the old practice.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2002
https://github.com/root-project/root/pull/2002:370,reliability,pra,practice,370,tree/TChain: revise treatment of tree_name in TChain URLs (fix for RO; OT-9344). This patch provides a fix for ROOT-9344. Support for the spurious way to pass. the tree name in the url as '/tree_name' is limited to cases where the substring. '.root' is contained in the file name but not in the tree name. Updates the infile documentation with deprecation for the old practice.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2002
https://github.com/root-project/root/pull/2002:88,safety,patch,patch,88,tree/TChain: revise treatment of tree_name in TChain URLs (fix for RO; OT-9344). This patch provides a fix for ROOT-9344. Support for the spurious way to pass. the tree name in the url as '/tree_name' is limited to cases where the substring. '.root' is contained in the file name but not in the tree name. Updates the infile documentation with deprecation for the old practice.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2002
https://github.com/root-project/root/pull/2002:308,safety,Updat,Updates,308,tree/TChain: revise treatment of tree_name in TChain URLs (fix for RO; OT-9344). This patch provides a fix for ROOT-9344. Support for the spurious way to pass. the tree name in the url as '/tree_name' is limited to cases where the substring. '.root' is contained in the file name but not in the tree name. Updates the infile documentation with deprecation for the old practice.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2002
https://github.com/root-project/root/pull/2002:88,security,patch,patch,88,tree/TChain: revise treatment of tree_name in TChain URLs (fix for RO; OT-9344). This patch provides a fix for ROOT-9344. Support for the spurious way to pass. the tree name in the url as '/tree_name' is limited to cases where the substring. '.root' is contained in the file name but not in the tree name. Updates the infile documentation with deprecation for the old practice.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2002
https://github.com/root-project/root/pull/2002:308,security,Updat,Updates,308,tree/TChain: revise treatment of tree_name in TChain URLs (fix for RO; OT-9344). This patch provides a fix for ROOT-9344. Support for the spurious way to pass. the tree name in the url as '/tree_name' is limited to cases where the substring. '.root' is contained in the file name but not in the tree name. Updates the infile documentation with deprecation for the old practice.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2002
https://github.com/root-project/root/pull/2002:124,usability,Support,Support,124,tree/TChain: revise treatment of tree_name in TChain URLs (fix for RO; OT-9344). This patch provides a fix for ROOT-9344. Support for the spurious way to pass. the tree name in the url as '/tree_name' is limited to cases where the substring. '.root' is contained in the file name but not in the tree name. Updates the infile documentation with deprecation for the old practice.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2002
https://github.com/root-project/root/pull/2002:327,usability,document,documentation,327,tree/TChain: revise treatment of tree_name in TChain URLs (fix for RO; OT-9344). This patch provides a fix for ROOT-9344. Support for the spurious way to pass. the tree name in the url as '/tree_name' is limited to cases where the substring. '.root' is contained in the file name but not in the tree name. Updates the infile documentation with deprecation for the old practice.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2002
https://github.com/root-project/root/pull/2003:411,availability,error,error,411,[cxxmodules] Fix absolute paths for v7 headers in modulemap; Our CMake code for making path to headers relative is broken. for the v7 headers (as they don't have the 'CURRENT_SOURCE/inc'. prefix we check for). This caused that we have absolute paths for. those headers in the modulemap we ship with ROOT. This patch just hacks in the additional check for v7 headers. and a sanity check that should prevent this error in the future.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2003
https://github.com/root-project/root/pull/2003:50,deployability,modul,modulemap,50,[cxxmodules] Fix absolute paths for v7 headers in modulemap; Our CMake code for making path to headers relative is broken. for the v7 headers (as they don't have the 'CURRENT_SOURCE/inc'. prefix we check for). This caused that we have absolute paths for. those headers in the modulemap we ship with ROOT. This patch just hacks in the additional check for v7 headers. and a sanity check that should prevent this error in the future.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2003
https://github.com/root-project/root/pull/2003:276,deployability,modul,modulemap,276,[cxxmodules] Fix absolute paths for v7 headers in modulemap; Our CMake code for making path to headers relative is broken. for the v7 headers (as they don't have the 'CURRENT_SOURCE/inc'. prefix we check for). This caused that we have absolute paths for. those headers in the modulemap we ship with ROOT. This patch just hacks in the additional check for v7 headers. and a sanity check that should prevent this error in the future.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2003
https://github.com/root-project/root/pull/2003:310,deployability,patch,patch,310,[cxxmodules] Fix absolute paths for v7 headers in modulemap; Our CMake code for making path to headers relative is broken. for the v7 headers (as they don't have the 'CURRENT_SOURCE/inc'. prefix we check for). This caused that we have absolute paths for. those headers in the modulemap we ship with ROOT. This patch just hacks in the additional check for v7 headers. and a sanity check that should prevent this error in the future.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2003
https://github.com/root-project/root/pull/2003:50,modifiability,modul,modulemap,50,[cxxmodules] Fix absolute paths for v7 headers in modulemap; Our CMake code for making path to headers relative is broken. for the v7 headers (as they don't have the 'CURRENT_SOURCE/inc'. prefix we check for). This caused that we have absolute paths for. those headers in the modulemap we ship with ROOT. This patch just hacks in the additional check for v7 headers. and a sanity check that should prevent this error in the future.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2003
https://github.com/root-project/root/pull/2003:276,modifiability,modul,modulemap,276,[cxxmodules] Fix absolute paths for v7 headers in modulemap; Our CMake code for making path to headers relative is broken. for the v7 headers (as they don't have the 'CURRENT_SOURCE/inc'. prefix we check for). This caused that we have absolute paths for. those headers in the modulemap we ship with ROOT. This patch just hacks in the additional check for v7 headers. and a sanity check that should prevent this error in the future.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2003
https://github.com/root-project/root/pull/2003:411,performance,error,error,411,[cxxmodules] Fix absolute paths for v7 headers in modulemap; Our CMake code for making path to headers relative is broken. for the v7 headers (as they don't have the 'CURRENT_SOURCE/inc'. prefix we check for). This caused that we have absolute paths for. those headers in the modulemap we ship with ROOT. This patch just hacks in the additional check for v7 headers. and a sanity check that should prevent this error in the future.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2003
https://github.com/root-project/root/pull/2003:50,safety,modul,modulemap,50,[cxxmodules] Fix absolute paths for v7 headers in modulemap; Our CMake code for making path to headers relative is broken. for the v7 headers (as they don't have the 'CURRENT_SOURCE/inc'. prefix we check for). This caused that we have absolute paths for. those headers in the modulemap we ship with ROOT. This patch just hacks in the additional check for v7 headers. and a sanity check that should prevent this error in the future.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2003
https://github.com/root-project/root/pull/2003:276,safety,modul,modulemap,276,[cxxmodules] Fix absolute paths for v7 headers in modulemap; Our CMake code for making path to headers relative is broken. for the v7 headers (as they don't have the 'CURRENT_SOURCE/inc'. prefix we check for). This caused that we have absolute paths for. those headers in the modulemap we ship with ROOT. This patch just hacks in the additional check for v7 headers. and a sanity check that should prevent this error in the future.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2003
https://github.com/root-project/root/pull/2003:310,safety,patch,patch,310,[cxxmodules] Fix absolute paths for v7 headers in modulemap; Our CMake code for making path to headers relative is broken. for the v7 headers (as they don't have the 'CURRENT_SOURCE/inc'. prefix we check for). This caused that we have absolute paths for. those headers in the modulemap we ship with ROOT. This patch just hacks in the additional check for v7 headers. and a sanity check that should prevent this error in the future.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2003
https://github.com/root-project/root/pull/2003:373,safety,sanit,sanity,373,[cxxmodules] Fix absolute paths for v7 headers in modulemap; Our CMake code for making path to headers relative is broken. for the v7 headers (as they don't have the 'CURRENT_SOURCE/inc'. prefix we check for). This caused that we have absolute paths for. those headers in the modulemap we ship with ROOT. This patch just hacks in the additional check for v7 headers. and a sanity check that should prevent this error in the future.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2003
https://github.com/root-project/root/pull/2003:398,safety,prevent,prevent,398,[cxxmodules] Fix absolute paths for v7 headers in modulemap; Our CMake code for making path to headers relative is broken. for the v7 headers (as they don't have the 'CURRENT_SOURCE/inc'. prefix we check for). This caused that we have absolute paths for. those headers in the modulemap we ship with ROOT. This patch just hacks in the additional check for v7 headers. and a sanity check that should prevent this error in the future.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2003
https://github.com/root-project/root/pull/2003:411,safety,error,error,411,[cxxmodules] Fix absolute paths for v7 headers in modulemap; Our CMake code for making path to headers relative is broken. for the v7 headers (as they don't have the 'CURRENT_SOURCE/inc'. prefix we check for). This caused that we have absolute paths for. those headers in the modulemap we ship with ROOT. This patch just hacks in the additional check for v7 headers. and a sanity check that should prevent this error in the future.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2003
https://github.com/root-project/root/pull/2003:310,security,patch,patch,310,[cxxmodules] Fix absolute paths for v7 headers in modulemap; Our CMake code for making path to headers relative is broken. for the v7 headers (as they don't have the 'CURRENT_SOURCE/inc'. prefix we check for). This caused that we have absolute paths for. those headers in the modulemap we ship with ROOT. This patch just hacks in the additional check for v7 headers. and a sanity check that should prevent this error in the future.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2003
https://github.com/root-project/root/pull/2003:321,security,hack,hacks,321,[cxxmodules] Fix absolute paths for v7 headers in modulemap; Our CMake code for making path to headers relative is broken. for the v7 headers (as they don't have the 'CURRENT_SOURCE/inc'. prefix we check for). This caused that we have absolute paths for. those headers in the modulemap we ship with ROOT. This patch just hacks in the additional check for v7 headers. and a sanity check that should prevent this error in the future.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2003
https://github.com/root-project/root/pull/2003:373,security,sanit,sanity,373,[cxxmodules] Fix absolute paths for v7 headers in modulemap; Our CMake code for making path to headers relative is broken. for the v7 headers (as they don't have the 'CURRENT_SOURCE/inc'. prefix we check for). This caused that we have absolute paths for. those headers in the modulemap we ship with ROOT. This patch just hacks in the additional check for v7 headers. and a sanity check that should prevent this error in the future.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2003
https://github.com/root-project/root/pull/2003:398,security,preven,prevent,398,[cxxmodules] Fix absolute paths for v7 headers in modulemap; Our CMake code for making path to headers relative is broken. for the v7 headers (as they don't have the 'CURRENT_SOURCE/inc'. prefix we check for). This caused that we have absolute paths for. those headers in the modulemap we ship with ROOT. This patch just hacks in the additional check for v7 headers. and a sanity check that should prevent this error in the future.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2003
https://github.com/root-project/root/pull/2003:411,usability,error,error,411,[cxxmodules] Fix absolute paths for v7 headers in modulemap; Our CMake code for making path to headers relative is broken. for the v7 headers (as they don't have the 'CURRENT_SOURCE/inc'. prefix we check for). This caused that we have absolute paths for. those headers in the modulemap we ship with ROOT. This patch just hacks in the additional check for v7 headers. and a sanity check that should prevent this error in the future.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2003
https://github.com/root-project/root/pull/2005:76,deployability,modul,modules,76,[cxxmodules] Add missing header file.; This reduces the duplications in all modules reducing the overall. modules size by 1MB.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2005
https://github.com/root-project/root/pull/2005:106,deployability,modul,modules,106,[cxxmodules] Add missing header file.; This reduces the duplications in all modules reducing the overall. modules size by 1MB.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2005
https://github.com/root-project/root/pull/2005:44,energy efficiency,reduc,reduces,44,[cxxmodules] Add missing header file.; This reduces the duplications in all modules reducing the overall. modules size by 1MB.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2005
https://github.com/root-project/root/pull/2005:84,energy efficiency,reduc,reducing,84,[cxxmodules] Add missing header file.; This reduces the duplications in all modules reducing the overall. modules size by 1MB.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2005
https://github.com/root-project/root/pull/2005:76,modifiability,modul,modules,76,[cxxmodules] Add missing header file.; This reduces the duplications in all modules reducing the overall. modules size by 1MB.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2005
https://github.com/root-project/root/pull/2005:106,modifiability,modul,modules,106,[cxxmodules] Add missing header file.; This reduces the duplications in all modules reducing the overall. modules size by 1MB.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2005
https://github.com/root-project/root/pull/2005:76,safety,modul,modules,76,[cxxmodules] Add missing header file.; This reduces the duplications in all modules reducing the overall. modules size by 1MB.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2005
https://github.com/root-project/root/pull/2005:106,safety,modul,modules,106,[cxxmodules] Add missing header file.; This reduces the duplications in all modules reducing the overall. modules size by 1MB.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2005
https://github.com/root-project/root/pull/2006:89,deployability,modul,modules,89,"The ASTReader knows better what needs CodeGenning.; We were trying to collect the owning modules of every deserialized. decl. Later, we loaded the corresponding library. This is too. much because for some entities (such as forward declarations) we. load the shared object file in vain because no CodeGen is. required. . This patch relies on the ASTReader to decide if a decl needs to. be CodeGenned or not. If it requires an action from CodeGen the. ASTReader passes it through the HandleInterestingDecl interface. . This patch brings back to normal the amount of loaded libraries.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2006
https://github.com/root-project/root/pull/2006:325,deployability,patch,patch,325,"The ASTReader knows better what needs CodeGenning.; We were trying to collect the owning modules of every deserialized. decl. Later, we loaded the corresponding library. This is too. much because for some entities (such as forward declarations) we. load the shared object file in vain because no CodeGen is. required. . This patch relies on the ASTReader to decide if a decl needs to. be CodeGenned or not. If it requires an action from CodeGen the. ASTReader passes it through the HandleInterestingDecl interface. . This patch brings back to normal the amount of loaded libraries.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2006
https://github.com/root-project/root/pull/2006:522,deployability,patch,patch,522,"The ASTReader knows better what needs CodeGenning.; We were trying to collect the owning modules of every deserialized. decl. Later, we loaded the corresponding library. This is too. much because for some entities (such as forward declarations) we. load the shared object file in vain because no CodeGen is. required. . This patch relies on the ASTReader to decide if a decl needs to. be CodeGenned or not. If it requires an action from CodeGen the. ASTReader passes it through the HandleInterestingDecl interface. . This patch brings back to normal the amount of loaded libraries.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2006
https://github.com/root-project/root/pull/2006:136,energy efficiency,load,loaded,136,"The ASTReader knows better what needs CodeGenning.; We were trying to collect the owning modules of every deserialized. decl. Later, we loaded the corresponding library. This is too. much because for some entities (such as forward declarations) we. load the shared object file in vain because no CodeGen is. required. . This patch relies on the ASTReader to decide if a decl needs to. be CodeGenned or not. If it requires an action from CodeGen the. ASTReader passes it through the HandleInterestingDecl interface. . This patch brings back to normal the amount of loaded libraries.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2006
https://github.com/root-project/root/pull/2006:249,energy efficiency,load,load,249,"The ASTReader knows better what needs CodeGenning.; We were trying to collect the owning modules of every deserialized. decl. Later, we loaded the corresponding library. This is too. much because for some entities (such as forward declarations) we. load the shared object file in vain because no CodeGen is. required. . This patch relies on the ASTReader to decide if a decl needs to. be CodeGenned or not. If it requires an action from CodeGen the. ASTReader passes it through the HandleInterestingDecl interface. . This patch brings back to normal the amount of loaded libraries.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2006
https://github.com/root-project/root/pull/2006:564,energy efficiency,load,loaded,564,"The ASTReader knows better what needs CodeGenning.; We were trying to collect the owning modules of every deserialized. decl. Later, we loaded the corresponding library. This is too. much because for some entities (such as forward declarations) we. load the shared object file in vain because no CodeGen is. required. . This patch relies on the ASTReader to decide if a decl needs to. be CodeGenned or not. If it requires an action from CodeGen the. ASTReader passes it through the HandleInterestingDecl interface. . This patch brings back to normal the amount of loaded libraries.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2006
https://github.com/root-project/root/pull/2006:504,integrability,interfac,interface,504,"The ASTReader knows better what needs CodeGenning.; We were trying to collect the owning modules of every deserialized. decl. Later, we loaded the corresponding library. This is too. much because for some entities (such as forward declarations) we. load the shared object file in vain because no CodeGen is. required. . This patch relies on the ASTReader to decide if a decl needs to. be CodeGenned or not. If it requires an action from CodeGen the. ASTReader passes it through the HandleInterestingDecl interface. . This patch brings back to normal the amount of loaded libraries.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2006
https://github.com/root-project/root/pull/2006:258,interoperability,share,shared,258,"The ASTReader knows better what needs CodeGenning.; We were trying to collect the owning modules of every deserialized. decl. Later, we loaded the corresponding library. This is too. much because for some entities (such as forward declarations) we. load the shared object file in vain because no CodeGen is. required. . This patch relies on the ASTReader to decide if a decl needs to. be CodeGenned or not. If it requires an action from CodeGen the. ASTReader passes it through the HandleInterestingDecl interface. . This patch brings back to normal the amount of loaded libraries.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2006
https://github.com/root-project/root/pull/2006:504,interoperability,interfac,interface,504,"The ASTReader knows better what needs CodeGenning.; We were trying to collect the owning modules of every deserialized. decl. Later, we loaded the corresponding library. This is too. much because for some entities (such as forward declarations) we. load the shared object file in vain because no CodeGen is. required. . This patch relies on the ASTReader to decide if a decl needs to. be CodeGenned or not. If it requires an action from CodeGen the. ASTReader passes it through the HandleInterestingDecl interface. . This patch brings back to normal the amount of loaded libraries.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2006
https://github.com/root-project/root/pull/2006:89,modifiability,modul,modules,89,"The ASTReader knows better what needs CodeGenning.; We were trying to collect the owning modules of every deserialized. decl. Later, we loaded the corresponding library. This is too. much because for some entities (such as forward declarations) we. load the shared object file in vain because no CodeGen is. required. . This patch relies on the ASTReader to decide if a decl needs to. be CodeGenned or not. If it requires an action from CodeGen the. ASTReader passes it through the HandleInterestingDecl interface. . This patch brings back to normal the amount of loaded libraries.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2006
https://github.com/root-project/root/pull/2006:504,modifiability,interfac,interface,504,"The ASTReader knows better what needs CodeGenning.; We were trying to collect the owning modules of every deserialized. decl. Later, we loaded the corresponding library. This is too. much because for some entities (such as forward declarations) we. load the shared object file in vain because no CodeGen is. required. . This patch relies on the ASTReader to decide if a decl needs to. be CodeGenned or not. If it requires an action from CodeGen the. ASTReader passes it through the HandleInterestingDecl interface. . This patch brings back to normal the amount of loaded libraries.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2006
https://github.com/root-project/root/pull/2006:136,performance,load,loaded,136,"The ASTReader knows better what needs CodeGenning.; We were trying to collect the owning modules of every deserialized. decl. Later, we loaded the corresponding library. This is too. much because for some entities (such as forward declarations) we. load the shared object file in vain because no CodeGen is. required. . This patch relies on the ASTReader to decide if a decl needs to. be CodeGenned or not. If it requires an action from CodeGen the. ASTReader passes it through the HandleInterestingDecl interface. . This patch brings back to normal the amount of loaded libraries.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2006
https://github.com/root-project/root/pull/2006:249,performance,load,load,249,"The ASTReader knows better what needs CodeGenning.; We were trying to collect the owning modules of every deserialized. decl. Later, we loaded the corresponding library. This is too. much because for some entities (such as forward declarations) we. load the shared object file in vain because no CodeGen is. required. . This patch relies on the ASTReader to decide if a decl needs to. be CodeGenned or not. If it requires an action from CodeGen the. ASTReader passes it through the HandleInterestingDecl interface. . This patch brings back to normal the amount of loaded libraries.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2006
https://github.com/root-project/root/pull/2006:564,performance,load,loaded,564,"The ASTReader knows better what needs CodeGenning.; We were trying to collect the owning modules of every deserialized. decl. Later, we loaded the corresponding library. This is too. much because for some entities (such as forward declarations) we. load the shared object file in vain because no CodeGen is. required. . This patch relies on the ASTReader to decide if a decl needs to. be CodeGenned or not. If it requires an action from CodeGen the. ASTReader passes it through the HandleInterestingDecl interface. . This patch brings back to normal the amount of loaded libraries.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2006
https://github.com/root-project/root/pull/2006:89,safety,modul,modules,89,"The ASTReader knows better what needs CodeGenning.; We were trying to collect the owning modules of every deserialized. decl. Later, we loaded the corresponding library. This is too. much because for some entities (such as forward declarations) we. load the shared object file in vain because no CodeGen is. required. . This patch relies on the ASTReader to decide if a decl needs to. be CodeGenned or not. If it requires an action from CodeGen the. ASTReader passes it through the HandleInterestingDecl interface. . This patch brings back to normal the amount of loaded libraries.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2006
https://github.com/root-project/root/pull/2006:325,safety,patch,patch,325,"The ASTReader knows better what needs CodeGenning.; We were trying to collect the owning modules of every deserialized. decl. Later, we loaded the corresponding library. This is too. much because for some entities (such as forward declarations) we. load the shared object file in vain because no CodeGen is. required. . This patch relies on the ASTReader to decide if a decl needs to. be CodeGenned or not. If it requires an action from CodeGen the. ASTReader passes it through the HandleInterestingDecl interface. . This patch brings back to normal the amount of loaded libraries.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2006
https://github.com/root-project/root/pull/2006:522,safety,patch,patch,522,"The ASTReader knows better what needs CodeGenning.; We were trying to collect the owning modules of every deserialized. decl. Later, we loaded the corresponding library. This is too. much because for some entities (such as forward declarations) we. load the shared object file in vain because no CodeGen is. required. . This patch relies on the ASTReader to decide if a decl needs to. be CodeGenned or not. If it requires an action from CodeGen the. ASTReader passes it through the HandleInterestingDecl interface. . This patch brings back to normal the amount of loaded libraries.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2006
https://github.com/root-project/root/pull/2006:325,security,patch,patch,325,"The ASTReader knows better what needs CodeGenning.; We were trying to collect the owning modules of every deserialized. decl. Later, we loaded the corresponding library. This is too. much because for some entities (such as forward declarations) we. load the shared object file in vain because no CodeGen is. required. . This patch relies on the ASTReader to decide if a decl needs to. be CodeGenned or not. If it requires an action from CodeGen the. ASTReader passes it through the HandleInterestingDecl interface. . This patch brings back to normal the amount of loaded libraries.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2006
https://github.com/root-project/root/pull/2006:522,security,patch,patch,522,"The ASTReader knows better what needs CodeGenning.; We were trying to collect the owning modules of every deserialized. decl. Later, we loaded the corresponding library. This is too. much because for some entities (such as forward declarations) we. load the shared object file in vain because no CodeGen is. required. . This patch relies on the ASTReader to decide if a decl needs to. be CodeGenned or not. If it requires an action from CodeGen the. ASTReader passes it through the HandleInterestingDecl interface. . This patch brings back to normal the amount of loaded libraries.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2006
https://github.com/root-project/root/pull/2007:63,deployability,version,version,63,Removing unused lambda captures (warnings from Clang 7.0 trunk version);,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2007
https://github.com/root-project/root/pull/2007:63,integrability,version,version,63,Removing unused lambda captures (warnings from Clang 7.0 trunk version);,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2007
https://github.com/root-project/root/pull/2007:63,modifiability,version,version,63,Removing unused lambda captures (warnings from Clang 7.0 trunk version);,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2007
https://github.com/root-project/root/pull/2008:17,deployability,fail,failing,17,[cxxmodules] Fix failing nightly caused by renaming of TreePlayer;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2008
https://github.com/root-project/root/pull/2008:17,reliability,fail,failing,17,[cxxmodules] Fix failing nightly caused by renaming of TreePlayer;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2008
https://github.com/root-project/root/pull/2009:52,deployability,patch,patch,52,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:220,deployability,Modul,Modules,220,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:451,deployability,modul,module-release,451,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:526,deployability,modul,module-release,526,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:606,deployability,releas,release,606,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:13,energy efficiency,Reduc,Reduce,13,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:29,energy efficiency,load,loaded,29,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:58,energy efficiency,reduc,reduces,58,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:66,energy efficiency,load,loaded,66,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:394,energy efficiency,load,load,394,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:725,energy efficiency,Cpu,Cpu,725,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:820,energy efficiency,cpu,cpu,820,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:1011,energy efficiency,Cpu,Cpu,1011,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:1106,energy efficiency,cpu,cpu,1106,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:220,modifiability,Modul,Modules,220,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:451,modifiability,modul,module-release,451,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:526,modifiability,modul,module-release,526,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:29,performance,load,loaded,29,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:66,performance,load,loaded,66,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:394,performance,load,load,394,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:705,performance,Time,Time,705,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:725,performance,Cpu,Cpu,725,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:729,performance,Time,Time,729,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:808,performance,memor,memory,808,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:820,performance,cpu,cpu,820,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:824,performance,time,time,824,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:853,performance,time,time,853,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:882,performance,memor,memory,882,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:911,performance,memor,memory,911,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:991,performance,Time,Time,991,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:1011,performance,Cpu,Cpu,1011,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:1015,performance,Time,Time,1015,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:1094,performance,memor,memory,1094,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:1106,performance,cpu,cpu,1106,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:1110,performance,time,time,1110,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:1139,performance,time,time,1139,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:1168,performance,memor,memory,1168,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:1195,performance,memor,memory,1195,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:52,safety,patch,patch,52,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:220,safety,Modul,Modules,220,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:451,safety,modul,module-release,451,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:526,safety,modul,module-release,526,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:52,security,patch,patch,52,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:808,usability,memor,memory,808,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:882,usability,memor,memory,882,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:911,usability,memor,memory,911,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:1094,usability,memor,memory,1094,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:1168,usability,memor,memory,1168,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2009:1195,usability,memor,memory,1195,"[cxxmodules] Reduce amout of loaded libraries; This patch reduces loaded libraries to half, nearly the same amount of pch's. . What I did is:. 1. Change DeclCollector and Transaction to collect clang::Decls, not. clang::Modules so that we still have decls information after finishing. deserialization. 2. In TClingCallbacks, we check if the decl is ""isUsed()"" or not. If. not, we don't want to load corresponding libararies. ```. w/o. yuka@yukadesk:~/module-release$ lsof -p 25477 | grep so | wc -l. 88. with. yuka@yukadesk:~/module-release$ lsof -p 23676 | grep so | wc -l . 37. PCH. yuka@yukadesk:~/root-release$ lsof -p 9664 | grep so | wc -l. 32. w/o. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. with. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x55c8a399bfa0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.371789 seconds. sys time = 0.069116 seconds. res memory = 273.5 Mbytes. vir memory = 461.43 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2009
https://github.com/root-project/root/pull/2010:17,deployability,fail,failing,17,"[cxxmodules] Fix failing tests by preloading some modules; Preloading ""GenVector"", ""MultiProc"", ""TreePlayer"", ""Hist"", ""TreePlayer"" and excluding TFormula test",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2010
https://github.com/root-project/root/pull/2010:50,deployability,modul,modules,50,"[cxxmodules] Fix failing tests by preloading some modules; Preloading ""GenVector"", ""MultiProc"", ""TreePlayer"", ""Hist"", ""TreePlayer"" and excluding TFormula test",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2010
https://github.com/root-project/root/pull/2010:50,modifiability,modul,modules,50,"[cxxmodules] Fix failing tests by preloading some modules; Preloading ""GenVector"", ""MultiProc"", ""TreePlayer"", ""Hist"", ""TreePlayer"" and excluding TFormula test",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2010
https://github.com/root-project/root/pull/2010:17,reliability,fail,failing,17,"[cxxmodules] Fix failing tests by preloading some modules; Preloading ""GenVector"", ""MultiProc"", ""TreePlayer"", ""Hist"", ""TreePlayer"" and excluding TFormula test",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2010
https://github.com/root-project/root/pull/2010:25,safety,test,tests,25,"[cxxmodules] Fix failing tests by preloading some modules; Preloading ""GenVector"", ""MultiProc"", ""TreePlayer"", ""Hist"", ""TreePlayer"" and excluding TFormula test",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2010
https://github.com/root-project/root/pull/2010:50,safety,modul,modules,50,"[cxxmodules] Fix failing tests by preloading some modules; Preloading ""GenVector"", ""MultiProc"", ""TreePlayer"", ""Hist"", ""TreePlayer"" and excluding TFormula test",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2010
https://github.com/root-project/root/pull/2010:154,safety,test,test,154,"[cxxmodules] Fix failing tests by preloading some modules; Preloading ""GenVector"", ""MultiProc"", ""TreePlayer"", ""Hist"", ""TreePlayer"" and excluding TFormula test",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2010
https://github.com/root-project/root/pull/2010:25,testability,test,tests,25,"[cxxmodules] Fix failing tests by preloading some modules; Preloading ""GenVector"", ""MultiProc"", ""TreePlayer"", ""Hist"", ""TreePlayer"" and excluding TFormula test",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2010
https://github.com/root-project/root/pull/2010:154,testability,test,test,154,"[cxxmodules] Fix failing tests by preloading some modules; Preloading ""GenVector"", ""MultiProc"", ""TreePlayer"", ""Hist"", ""TreePlayer"" and excluding TFormula test",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2010
https://github.com/root-project/root/pull/2011:47,deployability,modul,module,47,[cxxmodules] Move all Qt header into a wrapper module to fix warnings; Currently all included Qt headers in this ROOT module are duplicated. into each submodule. We now wrap all includes to Qt headers in a. single wrapper module which includes and owns those declarations. This should fix warnings related to ambiguous linkage of all the. constants that the Qt headers define (and which make the builds. yellow).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2011
https://github.com/root-project/root/pull/2011:118,deployability,modul,module,118,[cxxmodules] Move all Qt header into a wrapper module to fix warnings; Currently all included Qt headers in this ROOT module are duplicated. into each submodule. We now wrap all includes to Qt headers in a. single wrapper module which includes and owns those declarations. This should fix warnings related to ambiguous linkage of all the. constants that the Qt headers define (and which make the builds. yellow).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2011
https://github.com/root-project/root/pull/2011:222,deployability,modul,module,222,[cxxmodules] Move all Qt header into a wrapper module to fix warnings; Currently all included Qt headers in this ROOT module are duplicated. into each submodule. We now wrap all includes to Qt headers in a. single wrapper module which includes and owns those declarations. This should fix warnings related to ambiguous linkage of all the. constants that the Qt headers define (and which make the builds. yellow).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2011
https://github.com/root-project/root/pull/2011:396,deployability,build,builds,396,[cxxmodules] Move all Qt header into a wrapper module to fix warnings; Currently all included Qt headers in this ROOT module are duplicated. into each submodule. We now wrap all includes to Qt headers in a. single wrapper module which includes and owns those declarations. This should fix warnings related to ambiguous linkage of all the. constants that the Qt headers define (and which make the builds. yellow).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2011
https://github.com/root-project/root/pull/2011:71,energy efficiency,Current,Currently,71,[cxxmodules] Move all Qt header into a wrapper module to fix warnings; Currently all included Qt headers in this ROOT module are duplicated. into each submodule. We now wrap all includes to Qt headers in a. single wrapper module which includes and owns those declarations. This should fix warnings related to ambiguous linkage of all the. constants that the Qt headers define (and which make the builds. yellow).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2011
https://github.com/root-project/root/pull/2011:39,integrability,wrap,wrapper,39,[cxxmodules] Move all Qt header into a wrapper module to fix warnings; Currently all included Qt headers in this ROOT module are duplicated. into each submodule. We now wrap all includes to Qt headers in a. single wrapper module which includes and owns those declarations. This should fix warnings related to ambiguous linkage of all the. constants that the Qt headers define (and which make the builds. yellow).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2011
https://github.com/root-project/root/pull/2011:151,integrability,sub,submodule,151,[cxxmodules] Move all Qt header into a wrapper module to fix warnings; Currently all included Qt headers in this ROOT module are duplicated. into each submodule. We now wrap all includes to Qt headers in a. single wrapper module which includes and owns those declarations. This should fix warnings related to ambiguous linkage of all the. constants that the Qt headers define (and which make the builds. yellow).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2011
https://github.com/root-project/root/pull/2011:169,integrability,wrap,wrap,169,[cxxmodules] Move all Qt header into a wrapper module to fix warnings; Currently all included Qt headers in this ROOT module are duplicated. into each submodule. We now wrap all includes to Qt headers in a. single wrapper module which includes and owns those declarations. This should fix warnings related to ambiguous linkage of all the. constants that the Qt headers define (and which make the builds. yellow).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2011
https://github.com/root-project/root/pull/2011:214,integrability,wrap,wrapper,214,[cxxmodules] Move all Qt header into a wrapper module to fix warnings; Currently all included Qt headers in this ROOT module are duplicated. into each submodule. We now wrap all includes to Qt headers in a. single wrapper module which includes and owns those declarations. This should fix warnings related to ambiguous linkage of all the. constants that the Qt headers define (and which make the builds. yellow).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2011
https://github.com/root-project/root/pull/2011:39,interoperability,wrapper,wrapper,39,[cxxmodules] Move all Qt header into a wrapper module to fix warnings; Currently all included Qt headers in this ROOT module are duplicated. into each submodule. We now wrap all includes to Qt headers in a. single wrapper module which includes and owns those declarations. This should fix warnings related to ambiguous linkage of all the. constants that the Qt headers define (and which make the builds. yellow).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2011
https://github.com/root-project/root/pull/2011:214,interoperability,wrapper,wrapper,214,[cxxmodules] Move all Qt header into a wrapper module to fix warnings; Currently all included Qt headers in this ROOT module are duplicated. into each submodule. We now wrap all includes to Qt headers in a. single wrapper module which includes and owns those declarations. This should fix warnings related to ambiguous linkage of all the. constants that the Qt headers define (and which make the builds. yellow).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2011
https://github.com/root-project/root/pull/2011:47,modifiability,modul,module,47,[cxxmodules] Move all Qt header into a wrapper module to fix warnings; Currently all included Qt headers in this ROOT module are duplicated. into each submodule. We now wrap all includes to Qt headers in a. single wrapper module which includes and owns those declarations. This should fix warnings related to ambiguous linkage of all the. constants that the Qt headers define (and which make the builds. yellow).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2011
https://github.com/root-project/root/pull/2011:118,modifiability,modul,module,118,[cxxmodules] Move all Qt header into a wrapper module to fix warnings; Currently all included Qt headers in this ROOT module are duplicated. into each submodule. We now wrap all includes to Qt headers in a. single wrapper module which includes and owns those declarations. This should fix warnings related to ambiguous linkage of all the. constants that the Qt headers define (and which make the builds. yellow).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2011
https://github.com/root-project/root/pull/2011:222,modifiability,modul,module,222,[cxxmodules] Move all Qt header into a wrapper module to fix warnings; Currently all included Qt headers in this ROOT module are duplicated. into each submodule. We now wrap all includes to Qt headers in a. single wrapper module which includes and owns those declarations. This should fix warnings related to ambiguous linkage of all the. constants that the Qt headers define (and which make the builds. yellow).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2011
https://github.com/root-project/root/pull/2011:47,safety,modul,module,47,[cxxmodules] Move all Qt header into a wrapper module to fix warnings; Currently all included Qt headers in this ROOT module are duplicated. into each submodule. We now wrap all includes to Qt headers in a. single wrapper module which includes and owns those declarations. This should fix warnings related to ambiguous linkage of all the. constants that the Qt headers define (and which make the builds. yellow).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2011
https://github.com/root-project/root/pull/2011:118,safety,modul,module,118,[cxxmodules] Move all Qt header into a wrapper module to fix warnings; Currently all included Qt headers in this ROOT module are duplicated. into each submodule. We now wrap all includes to Qt headers in a. single wrapper module which includes and owns those declarations. This should fix warnings related to ambiguous linkage of all the. constants that the Qt headers define (and which make the builds. yellow).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2011
https://github.com/root-project/root/pull/2011:222,safety,modul,module,222,[cxxmodules] Move all Qt header into a wrapper module to fix warnings; Currently all included Qt headers in this ROOT module are duplicated. into each submodule. We now wrap all includes to Qt headers in a. single wrapper module which includes and owns those declarations. This should fix warnings related to ambiguous linkage of all the. constants that the Qt headers define (and which make the builds. yellow).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2011
https://github.com/root-project/root/pull/2013:4,usability,support,support,4,"Add support for disable MustCleanup in TCheckHashRecursiveRemoveConsi; stency. If the user calls 'gROOT->SetMustCleanup(kFALSE);'. the RecursiveRemove mechanism is disabled, nonetheless we still need to have. TCheckHashRecursiveRemoveConsistency return the intended answer. So the disabling is now 'lifted' for the object created by TCheckHashRecursiveRemoveConsistency. This fixes ROOT-9369",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2013
https://github.com/root-project/root/pull/2013:88,usability,user,user,88,"Add support for disable MustCleanup in TCheckHashRecursiveRemoveConsi; stency. If the user calls 'gROOT->SetMustCleanup(kFALSE);'. the RecursiveRemove mechanism is disabled, nonetheless we still need to have. TCheckHashRecursiveRemoveConsistency return the intended answer. So the disabling is now 'lifted' for the object created by TCheckHashRecursiveRemoveConsistency. This fixes ROOT-9369",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2013
https://github.com/root-project/root/pull/2014:151,safety,review,reviews,151,"More warnings from Clang 7.0 [trunk]; Suppressing warnings for Clang trunk for newly introduced ""-Wseff-assign-overloaded"" (ongoing discussion https://reviews.llvm.org/D45766)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2014
https://github.com/root-project/root/pull/2014:151,testability,review,reviews,151,"More warnings from Clang 7.0 [trunk]; Suppressing warnings for Clang trunk for newly introduced ""-Wseff-assign-overloaded"" (ongoing discussion https://reviews.llvm.org/D45766)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2014
https://github.com/root-project/root/pull/2016:36,deployability,depend,depend,36,ROOT-9216: Move mathcore tests that depend on RooFit into test/roofit; Fixes: https://sft.its.cern.ch/jira/browse/ROOT-9216,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2016
https://github.com/root-project/root/pull/2016:36,integrability,depend,depend,36,ROOT-9216: Move mathcore tests that depend on RooFit into test/roofit; Fixes: https://sft.its.cern.ch/jira/browse/ROOT-9216,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2016
https://github.com/root-project/root/pull/2016:36,modifiability,depend,depend,36,ROOT-9216: Move mathcore tests that depend on RooFit into test/roofit; Fixes: https://sft.its.cern.ch/jira/browse/ROOT-9216,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2016
https://github.com/root-project/root/pull/2016:25,safety,test,tests,25,ROOT-9216: Move mathcore tests that depend on RooFit into test/roofit; Fixes: https://sft.its.cern.ch/jira/browse/ROOT-9216,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2016
https://github.com/root-project/root/pull/2016:36,safety,depend,depend,36,ROOT-9216: Move mathcore tests that depend on RooFit into test/roofit; Fixes: https://sft.its.cern.ch/jira/browse/ROOT-9216,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2016
https://github.com/root-project/root/pull/2016:58,safety,test,test,58,ROOT-9216: Move mathcore tests that depend on RooFit into test/roofit; Fixes: https://sft.its.cern.ch/jira/browse/ROOT-9216,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2016
https://github.com/root-project/root/pull/2016:25,testability,test,tests,25,ROOT-9216: Move mathcore tests that depend on RooFit into test/roofit; Fixes: https://sft.its.cern.ch/jira/browse/ROOT-9216,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2016
https://github.com/root-project/root/pull/2016:36,testability,depend,depend,36,ROOT-9216: Move mathcore tests that depend on RooFit into test/roofit; Fixes: https://sft.its.cern.ch/jira/browse/ROOT-9216,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2016
https://github.com/root-project/root/pull/2016:58,testability,test,test,58,ROOT-9216: Move mathcore tests that depend on RooFit into test/roofit; Fixes: https://sft.its.cern.ch/jira/browse/ROOT-9216,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2016
https://github.com/root-project/root/pull/2017:28,safety,valid,valid,28,"Remove check if function is valid in TFormula ; This PR superseedes PR 1821. The code to check if the function is valid looking at TClass and gROOT->GetListOfGlobalFunctions is not needed. This, as pointed in PR 1821 makes the code more efficient",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2017
https://github.com/root-project/root/pull/2017:114,safety,valid,valid,114,"Remove check if function is valid in TFormula ; This PR superseedes PR 1821. The code to check if the function is valid looking at TClass and gROOT->GetListOfGlobalFunctions is not needed. This, as pointed in PR 1821 makes the code more efficient",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2017
https://github.com/root-project/root/pull/2017:237,usability,efficien,efficient,237,"Remove check if function is valid in TFormula ; This PR superseedes PR 1821. The code to check if the function is valid looking at TClass and gROOT->GetListOfGlobalFunctions is not needed. This, as pointed in PR 1821 makes the code more efficient",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2017
https://github.com/root-project/root/pull/2018:13,integrability,buffer,buffer,13,Speedup fill buffer;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2018
https://github.com/root-project/root/pull/2021:36,deployability,depend,dependent,36,rootcling: do not select classes of dependent type (ROOT-9185).;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2021
https://github.com/root-project/root/pull/2021:36,integrability,depend,dependent,36,rootcling: do not select classes of dependent type (ROOT-9185).;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2021
https://github.com/root-project/root/pull/2021:36,modifiability,depend,dependent,36,rootcling: do not select classes of dependent type (ROOT-9185).;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2021
https://github.com/root-project/root/pull/2021:36,safety,depend,dependent,36,rootcling: do not select classes of dependent type (ROOT-9185).;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2021
https://github.com/root-project/root/pull/2021:36,testability,depend,dependent,36,rootcling: do not select classes of dependent type (ROOT-9185).;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2021
https://github.com/root-project/root/pull/2022:26,energy efficiency,temperatur,temperature,26,[cxxmodules] Exclude tree-temperature test from runtime_cxxmodules;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2022
https://github.com/root-project/root/pull/2022:38,safety,test,test,38,[cxxmodules] Exclude tree-temperature test from runtime_cxxmodules;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2022
https://github.com/root-project/root/pull/2022:38,testability,test,test,38,[cxxmodules] Exclude tree-temperature test from runtime_cxxmodules;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2022
https://github.com/root-project/root/pull/2023:18,deployability,instal,install,18,[cxxmodules] Also install the overlay file and modulemaps; ROOT needs an overlay files in the include directory during runtime. to correctly mount the system modulemaps for libc/STL. For this. we need to generate and install a new overlay file that points to. the *installed* modulemaps for those libraries. We can't use the existing modulemap as this one still points to the. original build directory. We also need to install the related stl/lib modulemaps.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2023
https://github.com/root-project/root/pull/2023:47,deployability,modul,modulemaps,47,[cxxmodules] Also install the overlay file and modulemaps; ROOT needs an overlay files in the include directory during runtime. to correctly mount the system modulemaps for libc/STL. For this. we need to generate and install a new overlay file that points to. the *installed* modulemaps for those libraries. We can't use the existing modulemap as this one still points to the. original build directory. We also need to install the related stl/lib modulemaps.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2023
https://github.com/root-project/root/pull/2023:158,deployability,modul,modulemaps,158,[cxxmodules] Also install the overlay file and modulemaps; ROOT needs an overlay files in the include directory during runtime. to correctly mount the system modulemaps for libc/STL. For this. we need to generate and install a new overlay file that points to. the *installed* modulemaps for those libraries. We can't use the existing modulemap as this one still points to the. original build directory. We also need to install the related stl/lib modulemaps.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2023
https://github.com/root-project/root/pull/2023:217,deployability,instal,install,217,[cxxmodules] Also install the overlay file and modulemaps; ROOT needs an overlay files in the include directory during runtime. to correctly mount the system modulemaps for libc/STL. For this. we need to generate and install a new overlay file that points to. the *installed* modulemaps for those libraries. We can't use the existing modulemap as this one still points to the. original build directory. We also need to install the related stl/lib modulemaps.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2023
https://github.com/root-project/root/pull/2023:265,deployability,instal,installed,265,[cxxmodules] Also install the overlay file and modulemaps; ROOT needs an overlay files in the include directory during runtime. to correctly mount the system modulemaps for libc/STL. For this. we need to generate and install a new overlay file that points to. the *installed* modulemaps for those libraries. We can't use the existing modulemap as this one still points to the. original build directory. We also need to install the related stl/lib modulemaps.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2023
https://github.com/root-project/root/pull/2023:276,deployability,modul,modulemaps,276,[cxxmodules] Also install the overlay file and modulemaps; ROOT needs an overlay files in the include directory during runtime. to correctly mount the system modulemaps for libc/STL. For this. we need to generate and install a new overlay file that points to. the *installed* modulemaps for those libraries. We can't use the existing modulemap as this one still points to the. original build directory. We also need to install the related stl/lib modulemaps.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2023
https://github.com/root-project/root/pull/2023:334,deployability,modul,modulemap,334,[cxxmodules] Also install the overlay file and modulemaps; ROOT needs an overlay files in the include directory during runtime. to correctly mount the system modulemaps for libc/STL. For this. we need to generate and install a new overlay file that points to. the *installed* modulemaps for those libraries. We can't use the existing modulemap as this one still points to the. original build directory. We also need to install the related stl/lib modulemaps.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2023
https://github.com/root-project/root/pull/2023:386,deployability,build,build,386,[cxxmodules] Also install the overlay file and modulemaps; ROOT needs an overlay files in the include directory during runtime. to correctly mount the system modulemaps for libc/STL. For this. we need to generate and install a new overlay file that points to. the *installed* modulemaps for those libraries. We can't use the existing modulemap as this one still points to the. original build directory. We also need to install the related stl/lib modulemaps.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2023
https://github.com/root-project/root/pull/2023:419,deployability,instal,install,419,[cxxmodules] Also install the overlay file and modulemaps; ROOT needs an overlay files in the include directory during runtime. to correctly mount the system modulemaps for libc/STL. For this. we need to generate and install a new overlay file that points to. the *installed* modulemaps for those libraries. We can't use the existing modulemap as this one still points to the. original build directory. We also need to install the related stl/lib modulemaps.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2023
https://github.com/root-project/root/pull/2023:447,deployability,modul,modulemaps,447,[cxxmodules] Also install the overlay file and modulemaps; ROOT needs an overlay files in the include directory during runtime. to correctly mount the system modulemaps for libc/STL. For this. we need to generate and install a new overlay file that points to. the *installed* modulemaps for those libraries. We can't use the existing modulemap as this one still points to the. original build directory. We also need to install the related stl/lib modulemaps.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2023
https://github.com/root-project/root/pull/2023:47,modifiability,modul,modulemaps,47,[cxxmodules] Also install the overlay file and modulemaps; ROOT needs an overlay files in the include directory during runtime. to correctly mount the system modulemaps for libc/STL. For this. we need to generate and install a new overlay file that points to. the *installed* modulemaps for those libraries. We can't use the existing modulemap as this one still points to the. original build directory. We also need to install the related stl/lib modulemaps.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2023
https://github.com/root-project/root/pull/2023:158,modifiability,modul,modulemaps,158,[cxxmodules] Also install the overlay file and modulemaps; ROOT needs an overlay files in the include directory during runtime. to correctly mount the system modulemaps for libc/STL. For this. we need to generate and install a new overlay file that points to. the *installed* modulemaps for those libraries. We can't use the existing modulemap as this one still points to the. original build directory. We also need to install the related stl/lib modulemaps.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2023
https://github.com/root-project/root/pull/2023:276,modifiability,modul,modulemaps,276,[cxxmodules] Also install the overlay file and modulemaps; ROOT needs an overlay files in the include directory during runtime. to correctly mount the system modulemaps for libc/STL. For this. we need to generate and install a new overlay file that points to. the *installed* modulemaps for those libraries. We can't use the existing modulemap as this one still points to the. original build directory. We also need to install the related stl/lib modulemaps.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2023
https://github.com/root-project/root/pull/2023:334,modifiability,modul,modulemap,334,[cxxmodules] Also install the overlay file and modulemaps; ROOT needs an overlay files in the include directory during runtime. to correctly mount the system modulemaps for libc/STL. For this. we need to generate and install a new overlay file that points to. the *installed* modulemaps for those libraries. We can't use the existing modulemap as this one still points to the. original build directory. We also need to install the related stl/lib modulemaps.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2023
https://github.com/root-project/root/pull/2023:447,modifiability,modul,modulemaps,447,[cxxmodules] Also install the overlay file and modulemaps; ROOT needs an overlay files in the include directory during runtime. to correctly mount the system modulemaps for libc/STL. For this. we need to generate and install a new overlay file that points to. the *installed* modulemaps for those libraries. We can't use the existing modulemap as this one still points to the. original build directory. We also need to install the related stl/lib modulemaps.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2023
https://github.com/root-project/root/pull/2023:47,safety,modul,modulemaps,47,[cxxmodules] Also install the overlay file and modulemaps; ROOT needs an overlay files in the include directory during runtime. to correctly mount the system modulemaps for libc/STL. For this. we need to generate and install a new overlay file that points to. the *installed* modulemaps for those libraries. We can't use the existing modulemap as this one still points to the. original build directory. We also need to install the related stl/lib modulemaps.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2023
https://github.com/root-project/root/pull/2023:158,safety,modul,modulemaps,158,[cxxmodules] Also install the overlay file and modulemaps; ROOT needs an overlay files in the include directory during runtime. to correctly mount the system modulemaps for libc/STL. For this. we need to generate and install a new overlay file that points to. the *installed* modulemaps for those libraries. We can't use the existing modulemap as this one still points to the. original build directory. We also need to install the related stl/lib modulemaps.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2023
https://github.com/root-project/root/pull/2023:276,safety,modul,modulemaps,276,[cxxmodules] Also install the overlay file and modulemaps; ROOT needs an overlay files in the include directory during runtime. to correctly mount the system modulemaps for libc/STL. For this. we need to generate and install a new overlay file that points to. the *installed* modulemaps for those libraries. We can't use the existing modulemap as this one still points to the. original build directory. We also need to install the related stl/lib modulemaps.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2023
https://github.com/root-project/root/pull/2023:334,safety,modul,modulemap,334,[cxxmodules] Also install the overlay file and modulemaps; ROOT needs an overlay files in the include directory during runtime. to correctly mount the system modulemaps for libc/STL. For this. we need to generate and install a new overlay file that points to. the *installed* modulemaps for those libraries. We can't use the existing modulemap as this one still points to the. original build directory. We also need to install the related stl/lib modulemaps.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2023
https://github.com/root-project/root/pull/2023:447,safety,modul,modulemaps,447,[cxxmodules] Also install the overlay file and modulemaps; ROOT needs an overlay files in the include directory during runtime. to correctly mount the system modulemaps for libc/STL. For this. we need to generate and install a new overlay file that points to. the *installed* modulemaps for those libraries. We can't use the existing modulemap as this one still points to the. original build directory. We also need to install the related stl/lib modulemaps.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2023
https://github.com/root-project/root/pull/2024:18,deployability,instal,install,18,"[cxxmodules] Also install generated C++ modules; We generate C++ modules, but we currently don't install them where. they belong.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2024
https://github.com/root-project/root/pull/2024:40,deployability,modul,modules,40,"[cxxmodules] Also install generated C++ modules; We generate C++ modules, but we currently don't install them where. they belong.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2024
https://github.com/root-project/root/pull/2024:65,deployability,modul,modules,65,"[cxxmodules] Also install generated C++ modules; We generate C++ modules, but we currently don't install them where. they belong.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2024
https://github.com/root-project/root/pull/2024:97,deployability,instal,install,97,"[cxxmodules] Also install generated C++ modules; We generate C++ modules, but we currently don't install them where. they belong.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2024
https://github.com/root-project/root/pull/2024:81,energy efficiency,current,currently,81,"[cxxmodules] Also install generated C++ modules; We generate C++ modules, but we currently don't install them where. they belong.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2024
https://github.com/root-project/root/pull/2024:40,modifiability,modul,modules,40,"[cxxmodules] Also install generated C++ modules; We generate C++ modules, but we currently don't install them where. they belong.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2024
https://github.com/root-project/root/pull/2024:65,modifiability,modul,modules,65,"[cxxmodules] Also install generated C++ modules; We generate C++ modules, but we currently don't install them where. they belong.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2024
https://github.com/root-project/root/pull/2024:40,safety,modul,modules,40,"[cxxmodules] Also install generated C++ modules; We generate C++ modules, but we currently don't install them where. they belong.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2024
https://github.com/root-project/root/pull/2024:65,safety,modul,modules,65,"[cxxmodules] Also install generated C++ modules; We generate C++ modules, but we currently don't install them where. they belong.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2024
https://github.com/root-project/root/pull/2025:54,deployability,modul,module,54,"[cxxmodules] Better check if we should generate a C++ module; We currently have two checks (that are supposed to have the same. result) in the changed if-stmt and a few lines above where we. set cpp_module_file. Obviously if we generate a module, we should. also set cpp_module_file, however (due to the duplicated code) in. the case of multidicts we generate a module without specifying the. file. This probably causes CMake to behave incorrectly when rebuilding. PCM files.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2025
https://github.com/root-project/root/pull/2025:239,deployability,modul,module,239,"[cxxmodules] Better check if we should generate a C++ module; We currently have two checks (that are supposed to have the same. result) in the changed if-stmt and a few lines above where we. set cpp_module_file. Obviously if we generate a module, we should. also set cpp_module_file, however (due to the duplicated code) in. the case of multidicts we generate a module without specifying the. file. This probably causes CMake to behave incorrectly when rebuilding. PCM files.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2025
https://github.com/root-project/root/pull/2025:362,deployability,modul,module,362,"[cxxmodules] Better check if we should generate a C++ module; We currently have two checks (that are supposed to have the same. result) in the changed if-stmt and a few lines above where we. set cpp_module_file. Obviously if we generate a module, we should. also set cpp_module_file, however (due to the duplicated code) in. the case of multidicts we generate a module without specifying the. file. This probably causes CMake to behave incorrectly when rebuilding. PCM files.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2025
https://github.com/root-project/root/pull/2025:65,energy efficiency,current,currently,65,"[cxxmodules] Better check if we should generate a C++ module; We currently have two checks (that are supposed to have the same. result) in the changed if-stmt and a few lines above where we. set cpp_module_file. Obviously if we generate a module, we should. also set cpp_module_file, however (due to the duplicated code) in. the case of multidicts we generate a module without specifying the. file. This probably causes CMake to behave incorrectly when rebuilding. PCM files.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2025
https://github.com/root-project/root/pull/2025:377,interoperability,specif,specifying,377,"[cxxmodules] Better check if we should generate a C++ module; We currently have two checks (that are supposed to have the same. result) in the changed if-stmt and a few lines above where we. set cpp_module_file. Obviously if we generate a module, we should. also set cpp_module_file, however (due to the duplicated code) in. the case of multidicts we generate a module without specifying the. file. This probably causes CMake to behave incorrectly when rebuilding. PCM files.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2025
https://github.com/root-project/root/pull/2025:54,modifiability,modul,module,54,"[cxxmodules] Better check if we should generate a C++ module; We currently have two checks (that are supposed to have the same. result) in the changed if-stmt and a few lines above where we. set cpp_module_file. Obviously if we generate a module, we should. also set cpp_module_file, however (due to the duplicated code) in. the case of multidicts we generate a module without specifying the. file. This probably causes CMake to behave incorrectly when rebuilding. PCM files.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2025
https://github.com/root-project/root/pull/2025:239,modifiability,modul,module,239,"[cxxmodules] Better check if we should generate a C++ module; We currently have two checks (that are supposed to have the same. result) in the changed if-stmt and a few lines above where we. set cpp_module_file. Obviously if we generate a module, we should. also set cpp_module_file, however (due to the duplicated code) in. the case of multidicts we generate a module without specifying the. file. This probably causes CMake to behave incorrectly when rebuilding. PCM files.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2025
https://github.com/root-project/root/pull/2025:362,modifiability,modul,module,362,"[cxxmodules] Better check if we should generate a C++ module; We currently have two checks (that are supposed to have the same. result) in the changed if-stmt and a few lines above where we. set cpp_module_file. Obviously if we generate a module, we should. also set cpp_module_file, however (due to the duplicated code) in. the case of multidicts we generate a module without specifying the. file. This probably causes CMake to behave incorrectly when rebuilding. PCM files.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2025
https://github.com/root-project/root/pull/2025:54,safety,modul,module,54,"[cxxmodules] Better check if we should generate a C++ module; We currently have two checks (that are supposed to have the same. result) in the changed if-stmt and a few lines above where we. set cpp_module_file. Obviously if we generate a module, we should. also set cpp_module_file, however (due to the duplicated code) in. the case of multidicts we generate a module without specifying the. file. This probably causes CMake to behave incorrectly when rebuilding. PCM files.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2025
https://github.com/root-project/root/pull/2025:239,safety,modul,module,239,"[cxxmodules] Better check if we should generate a C++ module; We currently have two checks (that are supposed to have the same. result) in the changed if-stmt and a few lines above where we. set cpp_module_file. Obviously if we generate a module, we should. also set cpp_module_file, however (due to the duplicated code) in. the case of multidicts we generate a module without specifying the. file. This probably causes CMake to behave incorrectly when rebuilding. PCM files.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2025
https://github.com/root-project/root/pull/2025:362,safety,modul,module,362,"[cxxmodules] Better check if we should generate a C++ module; We currently have two checks (that are supposed to have the same. result) in the changed if-stmt and a few lines above where we. set cpp_module_file. Obviously if we generate a module, we should. also set cpp_module_file, however (due to the duplicated code) in. the case of multidicts we generate a module without specifying the. file. This probably causes CMake to behave incorrectly when rebuilding. PCM files.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2025
https://github.com/root-project/root/pull/2026:143,usability,support,supported,143,Add several improvements and fixes to MethodDL; This PR adds several improvements and fixes to MethodDL. - Several training strategies are now supported. - Have now correct Xavier and Xavier normal (glorot) initialisation of weights. - Add option to give a seed to weight initialisation (weightInitSeed),MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2026
https://github.com/root-project/root/pull/2028:215,interoperability,coordinat,coordinates,215,New 4-vector with Polar3D-mass construction.; Added new four-vector class `PThetaPhiM` for constructing a Lorentz vector from a 3D polar vector and a mass. This addition class makes use of `Polar3D` for the spatial coordinates.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2028
https://github.com/root-project/root/pull/2029:111,deployability,build,build,111,"Minuit2 standalone improvements; This adds two improvements (split into two commits) to the standalone Minuit2 build. First, warnings are reduced using the new syntax coming out in CMake 3.12, with a fallback for 3.1-3.11 versions. The other fix is a protection added to the target names ""Math"" and ""Common""; in CMake when this is built with `add_subdirectory`, these target names may clash with the master project or other `add_subdirectory` usages. The protection only kicks in if building as a subdirectory.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2029
https://github.com/root-project/root/pull/2029:222,deployability,version,versions,222,"Minuit2 standalone improvements; This adds two improvements (split into two commits) to the standalone Minuit2 build. First, warnings are reduced using the new syntax coming out in CMake 3.12, with a fallback for 3.1-3.11 versions. The other fix is a protection added to the target names ""Math"" and ""Common""; in CMake when this is built with `add_subdirectory`, these target names may clash with the master project or other `add_subdirectory` usages. The protection only kicks in if building as a subdirectory.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2029
https://github.com/root-project/root/pull/2029:483,deployability,build,building,483,"Minuit2 standalone improvements; This adds two improvements (split into two commits) to the standalone Minuit2 build. First, warnings are reduced using the new syntax coming out in CMake 3.12, with a fallback for 3.1-3.11 versions. The other fix is a protection added to the target names ""Math"" and ""Common""; in CMake when this is built with `add_subdirectory`, these target names may clash with the master project or other `add_subdirectory` usages. The protection only kicks in if building as a subdirectory.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2029
https://github.com/root-project/root/pull/2029:138,energy efficiency,reduc,reduced,138,"Minuit2 standalone improvements; This adds two improvements (split into two commits) to the standalone Minuit2 build. First, warnings are reduced using the new syntax coming out in CMake 3.12, with a fallback for 3.1-3.11 versions. The other fix is a protection added to the target names ""Math"" and ""Common""; in CMake when this is built with `add_subdirectory`, these target names may clash with the master project or other `add_subdirectory` usages. The protection only kicks in if building as a subdirectory.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2029
https://github.com/root-project/root/pull/2029:222,integrability,version,versions,222,"Minuit2 standalone improvements; This adds two improvements (split into two commits) to the standalone Minuit2 build. First, warnings are reduced using the new syntax coming out in CMake 3.12, with a fallback for 3.1-3.11 versions. The other fix is a protection added to the target names ""Math"" and ""Common""; in CMake when this is built with `add_subdirectory`, these target names may clash with the master project or other `add_subdirectory` usages. The protection only kicks in if building as a subdirectory.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2029
https://github.com/root-project/root/pull/2029:497,integrability,sub,subdirectory,497,"Minuit2 standalone improvements; This adds two improvements (split into two commits) to the standalone Minuit2 build. First, warnings are reduced using the new syntax coming out in CMake 3.12, with a fallback for 3.1-3.11 versions. The other fix is a protection added to the target names ""Math"" and ""Common""; in CMake when this is built with `add_subdirectory`, these target names may clash with the master project or other `add_subdirectory` usages. The protection only kicks in if building as a subdirectory.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2029
https://github.com/root-project/root/pull/2029:222,modifiability,version,versions,222,"Minuit2 standalone improvements; This adds two improvements (split into two commits) to the standalone Minuit2 build. First, warnings are reduced using the new syntax coming out in CMake 3.12, with a fallback for 3.1-3.11 versions. The other fix is a protection added to the target names ""Math"" and ""Common""; in CMake when this is built with `add_subdirectory`, these target names may clash with the master project or other `add_subdirectory` usages. The protection only kicks in if building as a subdirectory.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2029
https://github.com/root-project/root/pull/2030:292,security,ident,identifying,292,"ROOT-9319: Allow TBranchProxy to store the full branch name.; Before, branch->GetName() would only capture the ""local"" branch name of a friended tree. This relies on the use of TFriendProxy, which is not a useful concept for the TTeeReader. OTOH the director of the main tree has no problems identifying the correct friend,. given a ""fully scoped"" branch name.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2030
https://github.com/root-project/root/pull/2032:56,deployability,version,version,56,Add CheckTObjectHashConsistency to interpreter ClassDef version.; Fixes e.g. eve tutorials.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2032
https://github.com/root-project/root/pull/2032:56,integrability,version,version,56,Add CheckTObjectHashConsistency to interpreter ClassDef version.; Fixes e.g. eve tutorials.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2032
https://github.com/root-project/root/pull/2032:56,modifiability,version,version,56,Add CheckTObjectHashConsistency to interpreter ClassDef version.; Fixes e.g. eve tutorials.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2032
https://github.com/root-project/root/pull/2033:63,deployability,automat,automatism,63,"component selection handling fix; The RooFit::SelectComponents automatism is intended to allow plotting components of likelihoods. However, the current implementation only works as intended for ""flat"" Likelihoods as created by HistFactory. Likliehoods with more elaborate structures, notably such containing nested instances of RooRealSumFunc and RooRealSumPdf exhibit a broken behavior, resulting in wrong values displayed and retrieved from the workspace. This bugfix disables the component selection mechanisms inside RooRealIntegrals unless specifically requested otherwise, which solves the problem for most scenarios and leaves the user with the option to manually edit the Likelihood to produce the correct results in all other cases.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2033
https://github.com/root-project/root/pull/2033:297,deployability,contain,containing,297,"component selection handling fix; The RooFit::SelectComponents automatism is intended to allow plotting components of likelihoods. However, the current implementation only works as intended for ""flat"" Likelihoods as created by HistFactory. Likliehoods with more elaborate structures, notably such containing nested instances of RooRealSumFunc and RooRealSumPdf exhibit a broken behavior, resulting in wrong values displayed and retrieved from the workspace. This bugfix disables the component selection mechanisms inside RooRealIntegrals unless specifically requested otherwise, which solves the problem for most scenarios and leaves the user with the option to manually edit the Likelihood to produce the correct results in all other cases.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2033
https://github.com/root-project/root/pull/2033:144,energy efficiency,current,current,144,"component selection handling fix; The RooFit::SelectComponents automatism is intended to allow plotting components of likelihoods. However, the current implementation only works as intended for ""flat"" Likelihoods as created by HistFactory. Likliehoods with more elaborate structures, notably such containing nested instances of RooRealSumFunc and RooRealSumPdf exhibit a broken behavior, resulting in wrong values displayed and retrieved from the workspace. This bugfix disables the component selection mechanisms inside RooRealIntegrals unless specifically requested otherwise, which solves the problem for most scenarios and leaves the user with the option to manually edit the Likelihood to produce the correct results in all other cases.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2033
https://github.com/root-project/root/pull/2033:0,integrability,compon,component,0,"component selection handling fix; The RooFit::SelectComponents automatism is intended to allow plotting components of likelihoods. However, the current implementation only works as intended for ""flat"" Likelihoods as created by HistFactory. Likliehoods with more elaborate structures, notably such containing nested instances of RooRealSumFunc and RooRealSumPdf exhibit a broken behavior, resulting in wrong values displayed and retrieved from the workspace. This bugfix disables the component selection mechanisms inside RooRealIntegrals unless specifically requested otherwise, which solves the problem for most scenarios and leaves the user with the option to manually edit the Likelihood to produce the correct results in all other cases.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2033
https://github.com/root-project/root/pull/2033:104,integrability,compon,components,104,"component selection handling fix; The RooFit::SelectComponents automatism is intended to allow plotting components of likelihoods. However, the current implementation only works as intended for ""flat"" Likelihoods as created by HistFactory. Likliehoods with more elaborate structures, notably such containing nested instances of RooRealSumFunc and RooRealSumPdf exhibit a broken behavior, resulting in wrong values displayed and retrieved from the workspace. This bugfix disables the component selection mechanisms inside RooRealIntegrals unless specifically requested otherwise, which solves the problem for most scenarios and leaves the user with the option to manually edit the Likelihood to produce the correct results in all other cases.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2033
https://github.com/root-project/root/pull/2033:483,integrability,compon,component,483,"component selection handling fix; The RooFit::SelectComponents automatism is intended to allow plotting components of likelihoods. However, the current implementation only works as intended for ""flat"" Likelihoods as created by HistFactory. Likliehoods with more elaborate structures, notably such containing nested instances of RooRealSumFunc and RooRealSumPdf exhibit a broken behavior, resulting in wrong values displayed and retrieved from the workspace. This bugfix disables the component selection mechanisms inside RooRealIntegrals unless specifically requested otherwise, which solves the problem for most scenarios and leaves the user with the option to manually edit the Likelihood to produce the correct results in all other cases.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2033
https://github.com/root-project/root/pull/2033:0,interoperability,compon,component,0,"component selection handling fix; The RooFit::SelectComponents automatism is intended to allow plotting components of likelihoods. However, the current implementation only works as intended for ""flat"" Likelihoods as created by HistFactory. Likliehoods with more elaborate structures, notably such containing nested instances of RooRealSumFunc and RooRealSumPdf exhibit a broken behavior, resulting in wrong values displayed and retrieved from the workspace. This bugfix disables the component selection mechanisms inside RooRealIntegrals unless specifically requested otherwise, which solves the problem for most scenarios and leaves the user with the option to manually edit the Likelihood to produce the correct results in all other cases.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2033
https://github.com/root-project/root/pull/2033:104,interoperability,compon,components,104,"component selection handling fix; The RooFit::SelectComponents automatism is intended to allow plotting components of likelihoods. However, the current implementation only works as intended for ""flat"" Likelihoods as created by HistFactory. Likliehoods with more elaborate structures, notably such containing nested instances of RooRealSumFunc and RooRealSumPdf exhibit a broken behavior, resulting in wrong values displayed and retrieved from the workspace. This bugfix disables the component selection mechanisms inside RooRealIntegrals unless specifically requested otherwise, which solves the problem for most scenarios and leaves the user with the option to manually edit the Likelihood to produce the correct results in all other cases.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2033
https://github.com/root-project/root/pull/2033:483,interoperability,compon,component,483,"component selection handling fix; The RooFit::SelectComponents automatism is intended to allow plotting components of likelihoods. However, the current implementation only works as intended for ""flat"" Likelihoods as created by HistFactory. Likliehoods with more elaborate structures, notably such containing nested instances of RooRealSumFunc and RooRealSumPdf exhibit a broken behavior, resulting in wrong values displayed and retrieved from the workspace. This bugfix disables the component selection mechanisms inside RooRealIntegrals unless specifically requested otherwise, which solves the problem for most scenarios and leaves the user with the option to manually edit the Likelihood to produce the correct results in all other cases.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2033
https://github.com/root-project/root/pull/2033:545,interoperability,specif,specifically,545,"component selection handling fix; The RooFit::SelectComponents automatism is intended to allow plotting components of likelihoods. However, the current implementation only works as intended for ""flat"" Likelihoods as created by HistFactory. Likliehoods with more elaborate structures, notably such containing nested instances of RooRealSumFunc and RooRealSumPdf exhibit a broken behavior, resulting in wrong values displayed and retrieved from the workspace. This bugfix disables the component selection mechanisms inside RooRealIntegrals unless specifically requested otherwise, which solves the problem for most scenarios and leaves the user with the option to manually edit the Likelihood to produce the correct results in all other cases.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2033
https://github.com/root-project/root/pull/2033:0,modifiability,compon,component,0,"component selection handling fix; The RooFit::SelectComponents automatism is intended to allow plotting components of likelihoods. However, the current implementation only works as intended for ""flat"" Likelihoods as created by HistFactory. Likliehoods with more elaborate structures, notably such containing nested instances of RooRealSumFunc and RooRealSumPdf exhibit a broken behavior, resulting in wrong values displayed and retrieved from the workspace. This bugfix disables the component selection mechanisms inside RooRealIntegrals unless specifically requested otherwise, which solves the problem for most scenarios and leaves the user with the option to manually edit the Likelihood to produce the correct results in all other cases.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2033
https://github.com/root-project/root/pull/2033:104,modifiability,compon,components,104,"component selection handling fix; The RooFit::SelectComponents automatism is intended to allow plotting components of likelihoods. However, the current implementation only works as intended for ""flat"" Likelihoods as created by HistFactory. Likliehoods with more elaborate structures, notably such containing nested instances of RooRealSumFunc and RooRealSumPdf exhibit a broken behavior, resulting in wrong values displayed and retrieved from the workspace. This bugfix disables the component selection mechanisms inside RooRealIntegrals unless specifically requested otherwise, which solves the problem for most scenarios and leaves the user with the option to manually edit the Likelihood to produce the correct results in all other cases.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2033
https://github.com/root-project/root/pull/2033:483,modifiability,compon,component,483,"component selection handling fix; The RooFit::SelectComponents automatism is intended to allow plotting components of likelihoods. However, the current implementation only works as intended for ""flat"" Likelihoods as created by HistFactory. Likliehoods with more elaborate structures, notably such containing nested instances of RooRealSumFunc and RooRealSumPdf exhibit a broken behavior, resulting in wrong values displayed and retrieved from the workspace. This bugfix disables the component selection mechanisms inside RooRealIntegrals unless specifically requested otherwise, which solves the problem for most scenarios and leaves the user with the option to manually edit the Likelihood to produce the correct results in all other cases.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2033
https://github.com/root-project/root/pull/2033:613,modifiability,scenario,scenarios,613,"component selection handling fix; The RooFit::SelectComponents automatism is intended to allow plotting components of likelihoods. However, the current implementation only works as intended for ""flat"" Likelihoods as created by HistFactory. Likliehoods with more elaborate structures, notably such containing nested instances of RooRealSumFunc and RooRealSumPdf exhibit a broken behavior, resulting in wrong values displayed and retrieved from the workspace. This bugfix disables the component selection mechanisms inside RooRealIntegrals unless specifically requested otherwise, which solves the problem for most scenarios and leaves the user with the option to manually edit the Likelihood to produce the correct results in all other cases.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2033
https://github.com/root-project/root/pull/2033:63,testability,automat,automatism,63,"component selection handling fix; The RooFit::SelectComponents automatism is intended to allow plotting components of likelihoods. However, the current implementation only works as intended for ""flat"" Likelihoods as created by HistFactory. Likliehoods with more elaborate structures, notably such containing nested instances of RooRealSumFunc and RooRealSumPdf exhibit a broken behavior, resulting in wrong values displayed and retrieved from the workspace. This bugfix disables the component selection mechanisms inside RooRealIntegrals unless specifically requested otherwise, which solves the problem for most scenarios and leaves the user with the option to manually edit the Likelihood to produce the correct results in all other cases.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2033
https://github.com/root-project/root/pull/2033:378,usability,behavi,behavior,378,"component selection handling fix; The RooFit::SelectComponents automatism is intended to allow plotting components of likelihoods. However, the current implementation only works as intended for ""flat"" Likelihoods as created by HistFactory. Likliehoods with more elaborate structures, notably such containing nested instances of RooRealSumFunc and RooRealSumPdf exhibit a broken behavior, resulting in wrong values displayed and retrieved from the workspace. This bugfix disables the component selection mechanisms inside RooRealIntegrals unless specifically requested otherwise, which solves the problem for most scenarios and leaves the user with the option to manually edit the Likelihood to produce the correct results in all other cases.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2033
https://github.com/root-project/root/pull/2033:638,usability,user,user,638,"component selection handling fix; The RooFit::SelectComponents automatism is intended to allow plotting components of likelihoods. However, the current implementation only works as intended for ""flat"" Likelihoods as created by HistFactory. Likliehoods with more elaborate structures, notably such containing nested instances of RooRealSumFunc and RooRealSumPdf exhibit a broken behavior, resulting in wrong values displayed and retrieved from the workspace. This bugfix disables the component selection mechanisms inside RooRealIntegrals unless specifically requested otherwise, which solves the problem for most scenarios and leaves the user with the option to manually edit the Likelihood to produce the correct results in all other cases.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2033
https://github.com/root-project/root/pull/2034:29,deployability,modul,modulemap,29,Add more libc headers to the modulemap;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2034
https://github.com/root-project/root/pull/2034:29,modifiability,modul,modulemap,29,Add more libc headers to the modulemap;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2034
https://github.com/root-project/root/pull/2034:29,safety,modul,modulemap,29,Add more libc headers to the modulemap;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2034
https://github.com/root-project/root/pull/2036:42,energy efficiency,Draw,Draw,42,"TTreeCache vs TTreeReader, TDF and TTree::Draw; Previously it was only done in. TTree::GetClusterIterator. TTree::GetEntry. TTree::GetEntryWithIndex. TTree::GetMaximum. TTree::GetMinimum. TTree::GetReadCache. TTree::SetCacheSize. In particular it was not triggered by TTree::Draw, TDF nor TTreeReader,. they are using only:. TTree::LoadTree and TBranch::GetEntry. The one use case still not covered is. file->GetObject(treename, tree);. auto b = tree->GetBranch(branchname);. b->GetEntry(entryNumber)=;. But it would require to either enable it in the TTree constructor. (too soon?) or TBranch::GetEntry (too often?)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2036
https://github.com/root-project/root/pull/2036:275,energy efficiency,Draw,Draw,275,"TTreeCache vs TTreeReader, TDF and TTree::Draw; Previously it was only done in. TTree::GetClusterIterator. TTree::GetEntry. TTree::GetEntryWithIndex. TTree::GetMaximum. TTree::GetMinimum. TTree::GetReadCache. TTree::SetCacheSize. In particular it was not triggered by TTree::Draw, TDF nor TTreeReader,. they are using only:. TTree::LoadTree and TBranch::GetEntry. The one use case still not covered is. file->GetObject(treename, tree);. auto b = tree->GetBranch(branchname);. b->GetEntry(entryNumber)=;. But it would require to either enable it in the TTree constructor. (too soon?) or TBranch::GetEntry (too often?)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2036
https://github.com/root-project/root/pull/2036:332,energy efficiency,Load,LoadTree,332,"TTreeCache vs TTreeReader, TDF and TTree::Draw; Previously it was only done in. TTree::GetClusterIterator. TTree::GetEntry. TTree::GetEntryWithIndex. TTree::GetMaximum. TTree::GetMinimum. TTree::GetReadCache. TTree::SetCacheSize. In particular it was not triggered by TTree::Draw, TDF nor TTreeReader,. they are using only:. TTree::LoadTree and TBranch::GetEntry. The one use case still not covered is. file->GetObject(treename, tree);. auto b = tree->GetBranch(branchname);. b->GetEntry(entryNumber)=;. But it would require to either enable it in the TTree constructor. (too soon?) or TBranch::GetEntry (too often?)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2036
https://github.com/root-project/root/pull/2036:332,performance,Load,LoadTree,332,"TTreeCache vs TTreeReader, TDF and TTree::Draw; Previously it was only done in. TTree::GetClusterIterator. TTree::GetEntry. TTree::GetEntryWithIndex. TTree::GetMaximum. TTree::GetMinimum. TTree::GetReadCache. TTree::SetCacheSize. In particular it was not triggered by TTree::Draw, TDF nor TTreeReader,. they are using only:. TTree::LoadTree and TBranch::GetEntry. The one use case still not covered is. file->GetObject(treename, tree);. auto b = tree->GetBranch(branchname);. b->GetEntry(entryNumber)=;. But it would require to either enable it in the TTree constructor. (too soon?) or TBranch::GetEntry (too often?)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2036
https://github.com/root-project/root/pull/2037:104,deployability,continu,continuing,104,[TDF] Outline virtual ~TCustomColumnBase() /vtable key function:; cling has a CodeGen problem that I am continuing to study. This seems to work around the issue for now.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2037
https://github.com/root-project/root/pull/2039:18,deployability,depend,dependent,18,Make fit chunking dependent on IMT pool size;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2039
https://github.com/root-project/root/pull/2039:18,integrability,depend,dependent,18,Make fit chunking dependent on IMT pool size;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2039
https://github.com/root-project/root/pull/2039:18,modifiability,depend,dependent,18,Make fit chunking dependent on IMT pool size;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2039
https://github.com/root-project/root/pull/2039:18,safety,depend,dependent,18,Make fit chunking dependent on IMT pool size;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2039
https://github.com/root-project/root/pull/2039:18,testability,depend,dependent,18,Make fit chunking dependent on IMT pool size;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2039
https://github.com/root-project/root/pull/2040:155,deployability,patch,patches,155,"[cxxmodules] Enable 17 tests and exclude 2 tests; Recent change to master fixed some tests which were excluded previously, so I reverted ""excluding tests"" patches and excluded three tests which were failing in current master.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2040
https://github.com/root-project/root/pull/2040:199,deployability,fail,failing,199,"[cxxmodules] Enable 17 tests and exclude 2 tests; Recent change to master fixed some tests which were excluded previously, so I reverted ""excluding tests"" patches and excluded three tests which were failing in current master.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2040
https://github.com/root-project/root/pull/2040:210,energy efficiency,current,current,210,"[cxxmodules] Enable 17 tests and exclude 2 tests; Recent change to master fixed some tests which were excluded previously, so I reverted ""excluding tests"" patches and excluded three tests which were failing in current master.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2040
https://github.com/root-project/root/pull/2040:199,reliability,fail,failing,199,"[cxxmodules] Enable 17 tests and exclude 2 tests; Recent change to master fixed some tests which were excluded previously, so I reverted ""excluding tests"" patches and excluded three tests which were failing in current master.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2040
https://github.com/root-project/root/pull/2040:23,safety,test,tests,23,"[cxxmodules] Enable 17 tests and exclude 2 tests; Recent change to master fixed some tests which were excluded previously, so I reverted ""excluding tests"" patches and excluded three tests which were failing in current master.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2040
https://github.com/root-project/root/pull/2040:43,safety,test,tests,43,"[cxxmodules] Enable 17 tests and exclude 2 tests; Recent change to master fixed some tests which were excluded previously, so I reverted ""excluding tests"" patches and excluded three tests which were failing in current master.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2040
https://github.com/root-project/root/pull/2040:85,safety,test,tests,85,"[cxxmodules] Enable 17 tests and exclude 2 tests; Recent change to master fixed some tests which were excluded previously, so I reverted ""excluding tests"" patches and excluded three tests which were failing in current master.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2040
https://github.com/root-project/root/pull/2040:148,safety,test,tests,148,"[cxxmodules] Enable 17 tests and exclude 2 tests; Recent change to master fixed some tests which were excluded previously, so I reverted ""excluding tests"" patches and excluded three tests which were failing in current master.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2040
https://github.com/root-project/root/pull/2040:155,safety,patch,patches,155,"[cxxmodules] Enable 17 tests and exclude 2 tests; Recent change to master fixed some tests which were excluded previously, so I reverted ""excluding tests"" patches and excluded three tests which were failing in current master.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2040
https://github.com/root-project/root/pull/2040:182,safety,test,tests,182,"[cxxmodules] Enable 17 tests and exclude 2 tests; Recent change to master fixed some tests which were excluded previously, so I reverted ""excluding tests"" patches and excluded three tests which were failing in current master.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2040
https://github.com/root-project/root/pull/2040:155,security,patch,patches,155,"[cxxmodules] Enable 17 tests and exclude 2 tests; Recent change to master fixed some tests which were excluded previously, so I reverted ""excluding tests"" patches and excluded three tests which were failing in current master.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2040
https://github.com/root-project/root/pull/2040:23,testability,test,tests,23,"[cxxmodules] Enable 17 tests and exclude 2 tests; Recent change to master fixed some tests which were excluded previously, so I reverted ""excluding tests"" patches and excluded three tests which were failing in current master.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2040
https://github.com/root-project/root/pull/2040:43,testability,test,tests,43,"[cxxmodules] Enable 17 tests and exclude 2 tests; Recent change to master fixed some tests which were excluded previously, so I reverted ""excluding tests"" patches and excluded three tests which were failing in current master.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2040
https://github.com/root-project/root/pull/2040:85,testability,test,tests,85,"[cxxmodules] Enable 17 tests and exclude 2 tests; Recent change to master fixed some tests which were excluded previously, so I reverted ""excluding tests"" patches and excluded three tests which were failing in current master.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2040
https://github.com/root-project/root/pull/2040:148,testability,test,tests,148,"[cxxmodules] Enable 17 tests and exclude 2 tests; Recent change to master fixed some tests which were excluded previously, so I reverted ""excluding tests"" patches and excluded three tests which were failing in current master.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2040
https://github.com/root-project/root/pull/2040:182,testability,test,tests,182,"[cxxmodules] Enable 17 tests and exclude 2 tests; Recent change to master fixed some tests which were excluded previously, so I reverted ""excluding tests"" patches and excluded three tests which were failing in current master.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2040
https://github.com/root-project/root/pull/2041:130,energy efficiency,CPu,CPuBuffer,130,Add fixes for CUDA compilation of TMVA; This PR fixes the compilation on CUDA for the new MethodDL. . Fix also a remaining bug in CPuBuffer.cxx,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2041
https://github.com/root-project/root/pull/2041:130,performance,CPu,CPuBuffer,130,Add fixes for CUDA compilation of TMVA; This PR fixes the compilation on CUDA for the new MethodDL. . Fix also a remaining bug in CPuBuffer.cxx,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2041
https://github.com/root-project/root/pull/2043:11,deployability,Updat,Update,11,ROOT-9164: Update the list of libs provided by root-config with ROOTDataFrame and ROOTVecOps; to allow present compilation lines to continue to work.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2043
https://github.com/root-project/root/pull/2043:132,deployability,continu,continue,132,ROOT-9164: Update the list of libs provided by root-config with ROOTDataFrame and ROOTVecOps; to allow present compilation lines to continue to work.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2043
https://github.com/root-project/root/pull/2043:11,safety,Updat,Update,11,ROOT-9164: Update the list of libs provided by root-config with ROOTDataFrame and ROOTVecOps; to allow present compilation lines to continue to work.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2043
https://github.com/root-project/root/pull/2043:11,security,Updat,Update,11,ROOT-9164: Update the list of libs provided by root-config with ROOTDataFrame and ROOTVecOps; to allow present compilation lines to continue to work.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2043
https://github.com/root-project/root/pull/2044:17,deployability,fail,failing,17,[cxxmodules] Fix failing modules master; Add RAII to GetNormalizedName,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2044
https://github.com/root-project/root/pull/2044:25,deployability,modul,modules,25,[cxxmodules] Fix failing modules master; Add RAII to GetNormalizedName,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2044
https://github.com/root-project/root/pull/2044:25,modifiability,modul,modules,25,[cxxmodules] Fix failing modules master; Add RAII to GetNormalizedName,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2044
https://github.com/root-project/root/pull/2044:17,reliability,fail,failing,17,[cxxmodules] Fix failing modules master; Add RAII to GetNormalizedName,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2044
https://github.com/root-project/root/pull/2044:25,safety,modul,modules,25,[cxxmodules] Fix failing modules master; Add RAII to GetNormalizedName,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2044
https://github.com/root-project/root/pull/2045:6,safety,Test,Test,6,[TDF] Test that we actually read the friend branch; ...even if it has the same name as a branch in the main tree. This tests ROOT-9319.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2045
https://github.com/root-project/root/pull/2045:119,safety,test,tests,119,[TDF] Test that we actually read the friend branch; ...even if it has the same name as a branch in the main tree. This tests ROOT-9319.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2045
https://github.com/root-project/root/pull/2045:6,testability,Test,Test,6,[TDF] Test that we actually read the friend branch; ...even if it has the same name as a branch in the main tree. This tests ROOT-9319.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2045
https://github.com/root-project/root/pull/2045:119,testability,test,tests,119,[TDF] Test that we actually read the friend branch; ...even if it has the same name as a branch in the main tree. This tests ROOT-9319.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2045
https://github.com/root-project/root/pull/2049:120,deployability,build,builds,120,"[TDF] Better ownership model; Not ready to merge. I am seeing crashes I do not understand locally, checking with our PR builds for a second opinion.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2049
https://github.com/root-project/root/pull/2049:23,energy efficiency,model,model,23,"[TDF] Better ownership model; Not ready to merge. I am seeing crashes I do not understand locally, checking with our PR builds for a second opinion.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2049
https://github.com/root-project/root/pull/2049:23,security,model,model,23,"[TDF] Better ownership model; Not ready to merge. I am seeing crashes I do not understand locally, checking with our PR builds for a second opinion.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2049
https://github.com/root-project/root/pull/2049:79,testability,understand,understand,79,"[TDF] Better ownership model; Not ready to merge. I am seeing crashes I do not understand locally, checking with our PR builds for a second opinion.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2049
https://github.com/root-project/root/pull/2050:25,availability,operat,operations,25,[VecOps] Add Any and All operations;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2050
https://github.com/root-project/root/pull/2051:42,safety,test,test,42,[TDF] Temporarily disable CArraysFromTree test in dataframe_simple; To merge in case these faliures become unbearable.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2051
https://github.com/root-project/root/pull/2051:42,testability,test,test,42,[TDF] Temporarily disable CArraysFromTree test in dataframe_simple; To merge in case these faliures become unbearable.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2051
https://github.com/root-project/root/pull/2053:17,deployability,fail,failing,17,[cxxmodules] Fix failing master by using strcmp for const char*; RooFit was not excluded because of this bug.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2053
https://github.com/root-project/root/pull/2053:17,reliability,fail,failing,17,[cxxmodules] Fix failing master by using strcmp for const char*; RooFit was not excluded because of this bug.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2053
https://github.com/root-project/root/pull/2054:37,performance,lock,locks,37,Actually allow disabling of tree imt locks;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2054
https://github.com/root-project/root/pull/2054:37,security,lock,locks,37,Actually allow disabling of tree imt locks;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2054
https://github.com/root-project/root/pull/2055:336,integrability,compon,components,336,"[TDF] ROOT-9351: Move out of the experimental namespace and impose new naming conventions; This PR moves TDataFrame out of the Experimental namespace together with the entire federation of classes it relates with. It also imposes the new agreed naming scheme: welcome ROOT::RDataFrame, first of a long and successful series of new ROOT components!",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2055
https://github.com/root-project/root/pull/2055:336,interoperability,compon,components,336,"[TDF] ROOT-9351: Move out of the experimental namespace and impose new naming conventions; This PR moves TDataFrame out of the Experimental namespace together with the entire federation of classes it relates with. It also imposes the new agreed naming scheme: welcome ROOT::RDataFrame, first of a long and successful series of new ROOT components!",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2055
https://github.com/root-project/root/pull/2055:336,modifiability,compon,components,336,"[TDF] ROOT-9351: Move out of the experimental namespace and impose new naming conventions; This PR moves TDataFrame out of the Experimental namespace together with the entire federation of classes it relates with. It also imposes the new agreed naming scheme: welcome ROOT::RDataFrame, first of a long and successful series of new ROOT components!",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2055
https://github.com/root-project/root/pull/2056:0,availability,recov,recovering,0,"recovering cmake option descriptions when forcing values; When running ccmake in a root build directory, I noticed that some variable descriptions are empty (usually one sees a one-line description stemming from cmake/modules/RootBuildOptions.cmake). This happens when their value is forced in cmake/modules/SearchInstalledSoftware.cmake. This also affects the comments in builddir/CMakeCache.txt. I claim that when forcing these variables' values, the comment is even more important than when they remain at their defaults or user-set values. In the below patch, I basically ran an editor macro retaining the values of `${opt}_description` (as set by `ROOT_BUILD_OPTION`) and adds a very brief explanation of why the value got changed (usually by inspecting the immediate control flow and/or echoing the status message that is print out anyway). The comments are sometimes sub-optimal (when values are forced to the value that the user has set themselves anyway), but  I guess it's still nice to point out ""you had no choice here"". Unrelated to the main part:. `tmva-cuda` is force set, but nowhere else used, I suspect this should've been `tmva-gpu`. In one place I replaced. ```. if (something). else(). code. ```. by. ```. if (NOT something). code. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2056
https://github.com/root-project/root/pull/2056:793,availability,echo,echoing,793,"recovering cmake option descriptions when forcing values; When running ccmake in a root build directory, I noticed that some variable descriptions are empty (usually one sees a one-line description stemming from cmake/modules/RootBuildOptions.cmake). This happens when their value is forced in cmake/modules/SearchInstalledSoftware.cmake. This also affects the comments in builddir/CMakeCache.txt. I claim that when forcing these variables' values, the comment is even more important than when they remain at their defaults or user-set values. In the below patch, I basically ran an editor macro retaining the values of `${opt}_description` (as set by `ROOT_BUILD_OPTION`) and adds a very brief explanation of why the value got changed (usually by inspecting the immediate control flow and/or echoing the status message that is print out anyway). The comments are sometimes sub-optimal (when values are forced to the value that the user has set themselves anyway), but  I guess it's still nice to point out ""you had no choice here"". Unrelated to the main part:. `tmva-cuda` is force set, but nowhere else used, I suspect this should've been `tmva-gpu`. In one place I replaced. ```. if (something). else(). code. ```. by. ```. if (NOT something). code. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2056
https://github.com/root-project/root/pull/2056:0,deployability,recov,recovering,0,"recovering cmake option descriptions when forcing values; When running ccmake in a root build directory, I noticed that some variable descriptions are empty (usually one sees a one-line description stemming from cmake/modules/RootBuildOptions.cmake). This happens when their value is forced in cmake/modules/SearchInstalledSoftware.cmake. This also affects the comments in builddir/CMakeCache.txt. I claim that when forcing these variables' values, the comment is even more important than when they remain at their defaults or user-set values. In the below patch, I basically ran an editor macro retaining the values of `${opt}_description` (as set by `ROOT_BUILD_OPTION`) and adds a very brief explanation of why the value got changed (usually by inspecting the immediate control flow and/or echoing the status message that is print out anyway). The comments are sometimes sub-optimal (when values are forced to the value that the user has set themselves anyway), but  I guess it's still nice to point out ""you had no choice here"". Unrelated to the main part:. `tmva-cuda` is force set, but nowhere else used, I suspect this should've been `tmva-gpu`. In one place I replaced. ```. if (something). else(). code. ```. by. ```. if (NOT something). code. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2056
https://github.com/root-project/root/pull/2056:88,deployability,build,build,88,"recovering cmake option descriptions when forcing values; When running ccmake in a root build directory, I noticed that some variable descriptions are empty (usually one sees a one-line description stemming from cmake/modules/RootBuildOptions.cmake). This happens when their value is forced in cmake/modules/SearchInstalledSoftware.cmake. This also affects the comments in builddir/CMakeCache.txt. I claim that when forcing these variables' values, the comment is even more important than when they remain at their defaults or user-set values. In the below patch, I basically ran an editor macro retaining the values of `${opt}_description` (as set by `ROOT_BUILD_OPTION`) and adds a very brief explanation of why the value got changed (usually by inspecting the immediate control flow and/or echoing the status message that is print out anyway). The comments are sometimes sub-optimal (when values are forced to the value that the user has set themselves anyway), but  I guess it's still nice to point out ""you had no choice here"". Unrelated to the main part:. `tmva-cuda` is force set, but nowhere else used, I suspect this should've been `tmva-gpu`. In one place I replaced. ```. if (something). else(). code. ```. by. ```. if (NOT something). code. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2056
https://github.com/root-project/root/pull/2056:218,deployability,modul,modules,218,"recovering cmake option descriptions when forcing values; When running ccmake in a root build directory, I noticed that some variable descriptions are empty (usually one sees a one-line description stemming from cmake/modules/RootBuildOptions.cmake). This happens when their value is forced in cmake/modules/SearchInstalledSoftware.cmake. This also affects the comments in builddir/CMakeCache.txt. I claim that when forcing these variables' values, the comment is even more important than when they remain at their defaults or user-set values. In the below patch, I basically ran an editor macro retaining the values of `${opt}_description` (as set by `ROOT_BUILD_OPTION`) and adds a very brief explanation of why the value got changed (usually by inspecting the immediate control flow and/or echoing the status message that is print out anyway). The comments are sometimes sub-optimal (when values are forced to the value that the user has set themselves anyway), but  I guess it's still nice to point out ""you had no choice here"". Unrelated to the main part:. `tmva-cuda` is force set, but nowhere else used, I suspect this should've been `tmva-gpu`. In one place I replaced. ```. if (something). else(). code. ```. by. ```. if (NOT something). code. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2056
https://github.com/root-project/root/pull/2056:300,deployability,modul,modules,300,"recovering cmake option descriptions when forcing values; When running ccmake in a root build directory, I noticed that some variable descriptions are empty (usually one sees a one-line description stemming from cmake/modules/RootBuildOptions.cmake). This happens when their value is forced in cmake/modules/SearchInstalledSoftware.cmake. This also affects the comments in builddir/CMakeCache.txt. I claim that when forcing these variables' values, the comment is even more important than when they remain at their defaults or user-set values. In the below patch, I basically ran an editor macro retaining the values of `${opt}_description` (as set by `ROOT_BUILD_OPTION`) and adds a very brief explanation of why the value got changed (usually by inspecting the immediate control flow and/or echoing the status message that is print out anyway). The comments are sometimes sub-optimal (when values are forced to the value that the user has set themselves anyway), but  I guess it's still nice to point out ""you had no choice here"". Unrelated to the main part:. `tmva-cuda` is force set, but nowhere else used, I suspect this should've been `tmva-gpu`. In one place I replaced. ```. if (something). else(). code. ```. by. ```. if (NOT something). code. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2056
https://github.com/root-project/root/pull/2056:373,deployability,build,builddir,373,"recovering cmake option descriptions when forcing values; When running ccmake in a root build directory, I noticed that some variable descriptions are empty (usually one sees a one-line description stemming from cmake/modules/RootBuildOptions.cmake). This happens when their value is forced in cmake/modules/SearchInstalledSoftware.cmake. This also affects the comments in builddir/CMakeCache.txt. I claim that when forcing these variables' values, the comment is even more important than when they remain at their defaults or user-set values. In the below patch, I basically ran an editor macro retaining the values of `${opt}_description` (as set by `ROOT_BUILD_OPTION`) and adds a very brief explanation of why the value got changed (usually by inspecting the immediate control flow and/or echoing the status message that is print out anyway). The comments are sometimes sub-optimal (when values are forced to the value that the user has set themselves anyway), but  I guess it's still nice to point out ""you had no choice here"". Unrelated to the main part:. `tmva-cuda` is force set, but nowhere else used, I suspect this should've been `tmva-gpu`. In one place I replaced. ```. if (something). else(). code. ```. by. ```. if (NOT something). code. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2056
https://github.com/root-project/root/pull/2056:557,deployability,patch,patch,557,"recovering cmake option descriptions when forcing values; When running ccmake in a root build directory, I noticed that some variable descriptions are empty (usually one sees a one-line description stemming from cmake/modules/RootBuildOptions.cmake). This happens when their value is forced in cmake/modules/SearchInstalledSoftware.cmake. This also affects the comments in builddir/CMakeCache.txt. I claim that when forcing these variables' values, the comment is even more important than when they remain at their defaults or user-set values. In the below patch, I basically ran an editor macro retaining the values of `${opt}_description` (as set by `ROOT_BUILD_OPTION`) and adds a very brief explanation of why the value got changed (usually by inspecting the immediate control flow and/or echoing the status message that is print out anyway). The comments are sometimes sub-optimal (when values are forced to the value that the user has set themselves anyway), but  I guess it's still nice to point out ""you had no choice here"". Unrelated to the main part:. `tmva-cuda` is force set, but nowhere else used, I suspect this should've been `tmva-gpu`. In one place I replaced. ```. if (something). else(). code. ```. by. ```. if (NOT something). code. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2056
https://github.com/root-project/root/pull/2056:878,energy efficiency,optim,optimal,878,"recovering cmake option descriptions when forcing values; When running ccmake in a root build directory, I noticed that some variable descriptions are empty (usually one sees a one-line description stemming from cmake/modules/RootBuildOptions.cmake). This happens when their value is forced in cmake/modules/SearchInstalledSoftware.cmake. This also affects the comments in builddir/CMakeCache.txt. I claim that when forcing these variables' values, the comment is even more important than when they remain at their defaults or user-set values. In the below patch, I basically ran an editor macro retaining the values of `${opt}_description` (as set by `ROOT_BUILD_OPTION`) and adds a very brief explanation of why the value got changed (usually by inspecting the immediate control flow and/or echoing the status message that is print out anyway). The comments are sometimes sub-optimal (when values are forced to the value that the user has set themselves anyway), but  I guess it's still nice to point out ""you had no choice here"". Unrelated to the main part:. `tmva-cuda` is force set, but nowhere else used, I suspect this should've been `tmva-gpu`. In one place I replaced. ```. if (something). else(). code. ```. by. ```. if (NOT something). code. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2056
https://github.com/root-project/root/pull/2056:1148,energy efficiency,gpu,gpu,1148,"recovering cmake option descriptions when forcing values; When running ccmake in a root build directory, I noticed that some variable descriptions are empty (usually one sees a one-line description stemming from cmake/modules/RootBuildOptions.cmake). This happens when their value is forced in cmake/modules/SearchInstalledSoftware.cmake. This also affects the comments in builddir/CMakeCache.txt. I claim that when forcing these variables' values, the comment is even more important than when they remain at their defaults or user-set values. In the below patch, I basically ran an editor macro retaining the values of `${opt}_description` (as set by `ROOT_BUILD_OPTION`) and adds a very brief explanation of why the value got changed (usually by inspecting the immediate control flow and/or echoing the status message that is print out anyway). The comments are sometimes sub-optimal (when values are forced to the value that the user has set themselves anyway), but  I guess it's still nice to point out ""you had no choice here"". Unrelated to the main part:. `tmva-cuda` is force set, but nowhere else used, I suspect this should've been `tmva-gpu`. In one place I replaced. ```. if (something). else(). code. ```. by. ```. if (NOT something). code. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2056
https://github.com/root-project/root/pull/2056:812,integrability,messag,message,812,"recovering cmake option descriptions when forcing values; When running ccmake in a root build directory, I noticed that some variable descriptions are empty (usually one sees a one-line description stemming from cmake/modules/RootBuildOptions.cmake). This happens when their value is forced in cmake/modules/SearchInstalledSoftware.cmake. This also affects the comments in builddir/CMakeCache.txt. I claim that when forcing these variables' values, the comment is even more important than when they remain at their defaults or user-set values. In the below patch, I basically ran an editor macro retaining the values of `${opt}_description` (as set by `ROOT_BUILD_OPTION`) and adds a very brief explanation of why the value got changed (usually by inspecting the immediate control flow and/or echoing the status message that is print out anyway). The comments are sometimes sub-optimal (when values are forced to the value that the user has set themselves anyway), but  I guess it's still nice to point out ""you had no choice here"". Unrelated to the main part:. `tmva-cuda` is force set, but nowhere else used, I suspect this should've been `tmva-gpu`. In one place I replaced. ```. if (something). else(). code. ```. by. ```. if (NOT something). code. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2056
https://github.com/root-project/root/pull/2056:874,integrability,sub,sub-optimal,874,"recovering cmake option descriptions when forcing values; When running ccmake in a root build directory, I noticed that some variable descriptions are empty (usually one sees a one-line description stemming from cmake/modules/RootBuildOptions.cmake). This happens when their value is forced in cmake/modules/SearchInstalledSoftware.cmake. This also affects the comments in builddir/CMakeCache.txt. I claim that when forcing these variables' values, the comment is even more important than when they remain at their defaults or user-set values. In the below patch, I basically ran an editor macro retaining the values of `${opt}_description` (as set by `ROOT_BUILD_OPTION`) and adds a very brief explanation of why the value got changed (usually by inspecting the immediate control flow and/or echoing the status message that is print out anyway). The comments are sometimes sub-optimal (when values are forced to the value that the user has set themselves anyway), but  I guess it's still nice to point out ""you had no choice here"". Unrelated to the main part:. `tmva-cuda` is force set, but nowhere else used, I suspect this should've been `tmva-gpu`. In one place I replaced. ```. if (something). else(). code. ```. by. ```. if (NOT something). code. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2056
https://github.com/root-project/root/pull/2056:812,interoperability,messag,message,812,"recovering cmake option descriptions when forcing values; When running ccmake in a root build directory, I noticed that some variable descriptions are empty (usually one sees a one-line description stemming from cmake/modules/RootBuildOptions.cmake). This happens when their value is forced in cmake/modules/SearchInstalledSoftware.cmake. This also affects the comments in builddir/CMakeCache.txt. I claim that when forcing these variables' values, the comment is even more important than when they remain at their defaults or user-set values. In the below patch, I basically ran an editor macro retaining the values of `${opt}_description` (as set by `ROOT_BUILD_OPTION`) and adds a very brief explanation of why the value got changed (usually by inspecting the immediate control flow and/or echoing the status message that is print out anyway). The comments are sometimes sub-optimal (when values are forced to the value that the user has set themselves anyway), but  I guess it's still nice to point out ""you had no choice here"". Unrelated to the main part:. `tmva-cuda` is force set, but nowhere else used, I suspect this should've been `tmva-gpu`. In one place I replaced. ```. if (something). else(). code. ```. by. ```. if (NOT something). code. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2056
https://github.com/root-project/root/pull/2056:125,modifiability,variab,variable,125,"recovering cmake option descriptions when forcing values; When running ccmake in a root build directory, I noticed that some variable descriptions are empty (usually one sees a one-line description stemming from cmake/modules/RootBuildOptions.cmake). This happens when their value is forced in cmake/modules/SearchInstalledSoftware.cmake. This also affects the comments in builddir/CMakeCache.txt. I claim that when forcing these variables' values, the comment is even more important than when they remain at their defaults or user-set values. In the below patch, I basically ran an editor macro retaining the values of `${opt}_description` (as set by `ROOT_BUILD_OPTION`) and adds a very brief explanation of why the value got changed (usually by inspecting the immediate control flow and/or echoing the status message that is print out anyway). The comments are sometimes sub-optimal (when values are forced to the value that the user has set themselves anyway), but  I guess it's still nice to point out ""you had no choice here"". Unrelated to the main part:. `tmva-cuda` is force set, but nowhere else used, I suspect this should've been `tmva-gpu`. In one place I replaced. ```. if (something). else(). code. ```. by. ```. if (NOT something). code. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2056
https://github.com/root-project/root/pull/2056:218,modifiability,modul,modules,218,"recovering cmake option descriptions when forcing values; When running ccmake in a root build directory, I noticed that some variable descriptions are empty (usually one sees a one-line description stemming from cmake/modules/RootBuildOptions.cmake). This happens when their value is forced in cmake/modules/SearchInstalledSoftware.cmake. This also affects the comments in builddir/CMakeCache.txt. I claim that when forcing these variables' values, the comment is even more important than when they remain at their defaults or user-set values. In the below patch, I basically ran an editor macro retaining the values of `${opt}_description` (as set by `ROOT_BUILD_OPTION`) and adds a very brief explanation of why the value got changed (usually by inspecting the immediate control flow and/or echoing the status message that is print out anyway). The comments are sometimes sub-optimal (when values are forced to the value that the user has set themselves anyway), but  I guess it's still nice to point out ""you had no choice here"". Unrelated to the main part:. `tmva-cuda` is force set, but nowhere else used, I suspect this should've been `tmva-gpu`. In one place I replaced. ```. if (something). else(). code. ```. by. ```. if (NOT something). code. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2056
https://github.com/root-project/root/pull/2056:300,modifiability,modul,modules,300,"recovering cmake option descriptions when forcing values; When running ccmake in a root build directory, I noticed that some variable descriptions are empty (usually one sees a one-line description stemming from cmake/modules/RootBuildOptions.cmake). This happens when their value is forced in cmake/modules/SearchInstalledSoftware.cmake. This also affects the comments in builddir/CMakeCache.txt. I claim that when forcing these variables' values, the comment is even more important than when they remain at their defaults or user-set values. In the below patch, I basically ran an editor macro retaining the values of `${opt}_description` (as set by `ROOT_BUILD_OPTION`) and adds a very brief explanation of why the value got changed (usually by inspecting the immediate control flow and/or echoing the status message that is print out anyway). The comments are sometimes sub-optimal (when values are forced to the value that the user has set themselves anyway), but  I guess it's still nice to point out ""you had no choice here"". Unrelated to the main part:. `tmva-cuda` is force set, but nowhere else used, I suspect this should've been `tmva-gpu`. In one place I replaced. ```. if (something). else(). code. ```. by. ```. if (NOT something). code. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2056
https://github.com/root-project/root/pull/2056:430,modifiability,variab,variables,430,"recovering cmake option descriptions when forcing values; When running ccmake in a root build directory, I noticed that some variable descriptions are empty (usually one sees a one-line description stemming from cmake/modules/RootBuildOptions.cmake). This happens when their value is forced in cmake/modules/SearchInstalledSoftware.cmake. This also affects the comments in builddir/CMakeCache.txt. I claim that when forcing these variables' values, the comment is even more important than when they remain at their defaults or user-set values. In the below patch, I basically ran an editor macro retaining the values of `${opt}_description` (as set by `ROOT_BUILD_OPTION`) and adds a very brief explanation of why the value got changed (usually by inspecting the immediate control flow and/or echoing the status message that is print out anyway). The comments are sometimes sub-optimal (when values are forced to the value that the user has set themselves anyway), but  I guess it's still nice to point out ""you had no choice here"". Unrelated to the main part:. `tmva-cuda` is force set, but nowhere else used, I suspect this should've been `tmva-gpu`. In one place I replaced. ```. if (something). else(). code. ```. by. ```. if (NOT something). code. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2056
https://github.com/root-project/root/pull/2056:1148,performance,gpu,gpu,1148,"recovering cmake option descriptions when forcing values; When running ccmake in a root build directory, I noticed that some variable descriptions are empty (usually one sees a one-line description stemming from cmake/modules/RootBuildOptions.cmake). This happens when their value is forced in cmake/modules/SearchInstalledSoftware.cmake. This also affects the comments in builddir/CMakeCache.txt. I claim that when forcing these variables' values, the comment is even more important than when they remain at their defaults or user-set values. In the below patch, I basically ran an editor macro retaining the values of `${opt}_description` (as set by `ROOT_BUILD_OPTION`) and adds a very brief explanation of why the value got changed (usually by inspecting the immediate control flow and/or echoing the status message that is print out anyway). The comments are sometimes sub-optimal (when values are forced to the value that the user has set themselves anyway), but  I guess it's still nice to point out ""you had no choice here"". Unrelated to the main part:. `tmva-cuda` is force set, but nowhere else used, I suspect this should've been `tmva-gpu`. In one place I replaced. ```. if (something). else(). code. ```. by. ```. if (NOT something). code. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2056
https://github.com/root-project/root/pull/2056:0,reliability,recov,recovering,0,"recovering cmake option descriptions when forcing values; When running ccmake in a root build directory, I noticed that some variable descriptions are empty (usually one sees a one-line description stemming from cmake/modules/RootBuildOptions.cmake). This happens when their value is forced in cmake/modules/SearchInstalledSoftware.cmake. This also affects the comments in builddir/CMakeCache.txt. I claim that when forcing these variables' values, the comment is even more important than when they remain at their defaults or user-set values. In the below patch, I basically ran an editor macro retaining the values of `${opt}_description` (as set by `ROOT_BUILD_OPTION`) and adds a very brief explanation of why the value got changed (usually by inspecting the immediate control flow and/or echoing the status message that is print out anyway). The comments are sometimes sub-optimal (when values are forced to the value that the user has set themselves anyway), but  I guess it's still nice to point out ""you had no choice here"". Unrelated to the main part:. `tmva-cuda` is force set, but nowhere else used, I suspect this should've been `tmva-gpu`. In one place I replaced. ```. if (something). else(). code. ```. by. ```. if (NOT something). code. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2056
https://github.com/root-project/root/pull/2056:0,safety,recov,recovering,0,"recovering cmake option descriptions when forcing values; When running ccmake in a root build directory, I noticed that some variable descriptions are empty (usually one sees a one-line description stemming from cmake/modules/RootBuildOptions.cmake). This happens when their value is forced in cmake/modules/SearchInstalledSoftware.cmake. This also affects the comments in builddir/CMakeCache.txt. I claim that when forcing these variables' values, the comment is even more important than when they remain at their defaults or user-set values. In the below patch, I basically ran an editor macro retaining the values of `${opt}_description` (as set by `ROOT_BUILD_OPTION`) and adds a very brief explanation of why the value got changed (usually by inspecting the immediate control flow and/or echoing the status message that is print out anyway). The comments are sometimes sub-optimal (when values are forced to the value that the user has set themselves anyway), but  I guess it's still nice to point out ""you had no choice here"". Unrelated to the main part:. `tmva-cuda` is force set, but nowhere else used, I suspect this should've been `tmva-gpu`. In one place I replaced. ```. if (something). else(). code. ```. by. ```. if (NOT something). code. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2056
https://github.com/root-project/root/pull/2056:218,safety,modul,modules,218,"recovering cmake option descriptions when forcing values; When running ccmake in a root build directory, I noticed that some variable descriptions are empty (usually one sees a one-line description stemming from cmake/modules/RootBuildOptions.cmake). This happens when their value is forced in cmake/modules/SearchInstalledSoftware.cmake. This also affects the comments in builddir/CMakeCache.txt. I claim that when forcing these variables' values, the comment is even more important than when they remain at their defaults or user-set values. In the below patch, I basically ran an editor macro retaining the values of `${opt}_description` (as set by `ROOT_BUILD_OPTION`) and adds a very brief explanation of why the value got changed (usually by inspecting the immediate control flow and/or echoing the status message that is print out anyway). The comments are sometimes sub-optimal (when values are forced to the value that the user has set themselves anyway), but  I guess it's still nice to point out ""you had no choice here"". Unrelated to the main part:. `tmva-cuda` is force set, but nowhere else used, I suspect this should've been `tmva-gpu`. In one place I replaced. ```. if (something). else(). code. ```. by. ```. if (NOT something). code. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2056
https://github.com/root-project/root/pull/2056:300,safety,modul,modules,300,"recovering cmake option descriptions when forcing values; When running ccmake in a root build directory, I noticed that some variable descriptions are empty (usually one sees a one-line description stemming from cmake/modules/RootBuildOptions.cmake). This happens when their value is forced in cmake/modules/SearchInstalledSoftware.cmake. This also affects the comments in builddir/CMakeCache.txt. I claim that when forcing these variables' values, the comment is even more important than when they remain at their defaults or user-set values. In the below patch, I basically ran an editor macro retaining the values of `${opt}_description` (as set by `ROOT_BUILD_OPTION`) and adds a very brief explanation of why the value got changed (usually by inspecting the immediate control flow and/or echoing the status message that is print out anyway). The comments are sometimes sub-optimal (when values are forced to the value that the user has set themselves anyway), but  I guess it's still nice to point out ""you had no choice here"". Unrelated to the main part:. `tmva-cuda` is force set, but nowhere else used, I suspect this should've been `tmva-gpu`. In one place I replaced. ```. if (something). else(). code. ```. by. ```. if (NOT something). code. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2056
https://github.com/root-project/root/pull/2056:557,safety,patch,patch,557,"recovering cmake option descriptions when forcing values; When running ccmake in a root build directory, I noticed that some variable descriptions are empty (usually one sees a one-line description stemming from cmake/modules/RootBuildOptions.cmake). This happens when their value is forced in cmake/modules/SearchInstalledSoftware.cmake. This also affects the comments in builddir/CMakeCache.txt. I claim that when forcing these variables' values, the comment is even more important than when they remain at their defaults or user-set values. In the below patch, I basically ran an editor macro retaining the values of `${opt}_description` (as set by `ROOT_BUILD_OPTION`) and adds a very brief explanation of why the value got changed (usually by inspecting the immediate control flow and/or echoing the status message that is print out anyway). The comments are sometimes sub-optimal (when values are forced to the value that the user has set themselves anyway), but  I guess it's still nice to point out ""you had no choice here"". Unrelated to the main part:. `tmva-cuda` is force set, but nowhere else used, I suspect this should've been `tmva-gpu`. In one place I replaced. ```. if (something). else(). code. ```. by. ```. if (NOT something). code. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2056
https://github.com/root-project/root/pull/2056:0,security,recov,recovering,0,"recovering cmake option descriptions when forcing values; When running ccmake in a root build directory, I noticed that some variable descriptions are empty (usually one sees a one-line description stemming from cmake/modules/RootBuildOptions.cmake). This happens when their value is forced in cmake/modules/SearchInstalledSoftware.cmake. This also affects the comments in builddir/CMakeCache.txt. I claim that when forcing these variables' values, the comment is even more important than when they remain at their defaults or user-set values. In the below patch, I basically ran an editor macro retaining the values of `${opt}_description` (as set by `ROOT_BUILD_OPTION`) and adds a very brief explanation of why the value got changed (usually by inspecting the immediate control flow and/or echoing the status message that is print out anyway). The comments are sometimes sub-optimal (when values are forced to the value that the user has set themselves anyway), but  I guess it's still nice to point out ""you had no choice here"". Unrelated to the main part:. `tmva-cuda` is force set, but nowhere else used, I suspect this should've been `tmva-gpu`. In one place I replaced. ```. if (something). else(). code. ```. by. ```. if (NOT something). code. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2056
https://github.com/root-project/root/pull/2056:557,security,patch,patch,557,"recovering cmake option descriptions when forcing values; When running ccmake in a root build directory, I noticed that some variable descriptions are empty (usually one sees a one-line description stemming from cmake/modules/RootBuildOptions.cmake). This happens when their value is forced in cmake/modules/SearchInstalledSoftware.cmake. This also affects the comments in builddir/CMakeCache.txt. I claim that when forcing these variables' values, the comment is even more important than when they remain at their defaults or user-set values. In the below patch, I basically ran an editor macro retaining the values of `${opt}_description` (as set by `ROOT_BUILD_OPTION`) and adds a very brief explanation of why the value got changed (usually by inspecting the immediate control flow and/or echoing the status message that is print out anyway). The comments are sometimes sub-optimal (when values are forced to the value that the user has set themselves anyway), but  I guess it's still nice to point out ""you had no choice here"". Unrelated to the main part:. `tmva-cuda` is force set, but nowhere else used, I suspect this should've been `tmva-gpu`. In one place I replaced. ```. if (something). else(). code. ```. by. ```. if (NOT something). code. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2056
https://github.com/root-project/root/pull/2056:773,security,control,control,773,"recovering cmake option descriptions when forcing values; When running ccmake in a root build directory, I noticed that some variable descriptions are empty (usually one sees a one-line description stemming from cmake/modules/RootBuildOptions.cmake). This happens when their value is forced in cmake/modules/SearchInstalledSoftware.cmake. This also affects the comments in builddir/CMakeCache.txt. I claim that when forcing these variables' values, the comment is even more important than when they remain at their defaults or user-set values. In the below patch, I basically ran an editor macro retaining the values of `${opt}_description` (as set by `ROOT_BUILD_OPTION`) and adds a very brief explanation of why the value got changed (usually by inspecting the immediate control flow and/or echoing the status message that is print out anyway). The comments are sometimes sub-optimal (when values are forced to the value that the user has set themselves anyway), but  I guess it's still nice to point out ""you had no choice here"". Unrelated to the main part:. `tmva-cuda` is force set, but nowhere else used, I suspect this should've been `tmva-gpu`. In one place I replaced. ```. if (something). else(). code. ```. by. ```. if (NOT something). code. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2056
https://github.com/root-project/root/pull/2056:773,testability,control,control,773,"recovering cmake option descriptions when forcing values; When running ccmake in a root build directory, I noticed that some variable descriptions are empty (usually one sees a one-line description stemming from cmake/modules/RootBuildOptions.cmake). This happens when their value is forced in cmake/modules/SearchInstalledSoftware.cmake. This also affects the comments in builddir/CMakeCache.txt. I claim that when forcing these variables' values, the comment is even more important than when they remain at their defaults or user-set values. In the below patch, I basically ran an editor macro retaining the values of `${opt}_description` (as set by `ROOT_BUILD_OPTION`) and adds a very brief explanation of why the value got changed (usually by inspecting the immediate control flow and/or echoing the status message that is print out anyway). The comments are sometimes sub-optimal (when values are forced to the value that the user has set themselves anyway), but  I guess it's still nice to point out ""you had no choice here"". Unrelated to the main part:. `tmva-cuda` is force set, but nowhere else used, I suspect this should've been `tmva-gpu`. In one place I replaced. ```. if (something). else(). code. ```. by. ```. if (NOT something). code. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2056
https://github.com/root-project/root/pull/2056:527,usability,user,user-set,527,"recovering cmake option descriptions when forcing values; When running ccmake in a root build directory, I noticed that some variable descriptions are empty (usually one sees a one-line description stemming from cmake/modules/RootBuildOptions.cmake). This happens when their value is forced in cmake/modules/SearchInstalledSoftware.cmake. This also affects the comments in builddir/CMakeCache.txt. I claim that when forcing these variables' values, the comment is even more important than when they remain at their defaults or user-set values. In the below patch, I basically ran an editor macro retaining the values of `${opt}_description` (as set by `ROOT_BUILD_OPTION`) and adds a very brief explanation of why the value got changed (usually by inspecting the immediate control flow and/or echoing the status message that is print out anyway). The comments are sometimes sub-optimal (when values are forced to the value that the user has set themselves anyway), but  I guess it's still nice to point out ""you had no choice here"". Unrelated to the main part:. `tmva-cuda` is force set, but nowhere else used, I suspect this should've been `tmva-gpu`. In one place I replaced. ```. if (something). else(). code. ```. by. ```. if (NOT something). code. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2056
https://github.com/root-project/root/pull/2056:805,usability,statu,status,805,"recovering cmake option descriptions when forcing values; When running ccmake in a root build directory, I noticed that some variable descriptions are empty (usually one sees a one-line description stemming from cmake/modules/RootBuildOptions.cmake). This happens when their value is forced in cmake/modules/SearchInstalledSoftware.cmake. This also affects the comments in builddir/CMakeCache.txt. I claim that when forcing these variables' values, the comment is even more important than when they remain at their defaults or user-set values. In the below patch, I basically ran an editor macro retaining the values of `${opt}_description` (as set by `ROOT_BUILD_OPTION`) and adds a very brief explanation of why the value got changed (usually by inspecting the immediate control flow and/or echoing the status message that is print out anyway). The comments are sometimes sub-optimal (when values are forced to the value that the user has set themselves anyway), but  I guess it's still nice to point out ""you had no choice here"". Unrelated to the main part:. `tmva-cuda` is force set, but nowhere else used, I suspect this should've been `tmva-gpu`. In one place I replaced. ```. if (something). else(). code. ```. by. ```. if (NOT something). code. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2056
https://github.com/root-project/root/pull/2056:932,usability,user,user,932,"recovering cmake option descriptions when forcing values; When running ccmake in a root build directory, I noticed that some variable descriptions are empty (usually one sees a one-line description stemming from cmake/modules/RootBuildOptions.cmake). This happens when their value is forced in cmake/modules/SearchInstalledSoftware.cmake. This also affects the comments in builddir/CMakeCache.txt. I claim that when forcing these variables' values, the comment is even more important than when they remain at their defaults or user-set values. In the below patch, I basically ran an editor macro retaining the values of `${opt}_description` (as set by `ROOT_BUILD_OPTION`) and adds a very brief explanation of why the value got changed (usually by inspecting the immediate control flow and/or echoing the status message that is print out anyway). The comments are sometimes sub-optimal (when values are forced to the value that the user has set themselves anyway), but  I guess it's still nice to point out ""you had no choice here"". Unrelated to the main part:. `tmva-cuda` is force set, but nowhere else used, I suspect this should've been `tmva-gpu`. In one place I replaced. ```. if (something). else(). code. ```. by. ```. if (NOT something). code. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2056
https://github.com/root-project/root/pull/2057:47,safety,test,test,47,[TDF] Delete all output files at the exit of a test case ;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2057
https://github.com/root-project/root/pull/2057:47,testability,test,test,47,[TDF] Delete all output files at the exit of a test case ;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2057
https://github.com/root-project/root/pull/2058:47,safety,test,test,47,[TDF] Delete all output files at the exit of a test case;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2058
https://github.com/root-project/root/pull/2058:47,testability,test,test,47,[TDF] Delete all output files at the exit of a test case;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2058
https://github.com/root-project/root/pull/2059:48,energy efficiency,GPU,GPU,48,More fixed in TMVA Deep Learning for running on GPU;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2059
https://github.com/root-project/root/pull/2059:48,performance,GPU,GPU,48,More fixed in TMVA Deep Learning for running on GPU;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2059
https://github.com/root-project/root/pull/2059:24,usability,Learn,Learning,24,More fixed in TMVA Deep Learning for running on GPU;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2059
https://github.com/root-project/root/pull/2060:31,deployability,depend,depending,31,Do not change the class layout depending on NDEBUG!;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2060
https://github.com/root-project/root/pull/2060:31,integrability,depend,depending,31,Do not change the class layout depending on NDEBUG!;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2060
https://github.com/root-project/root/pull/2060:31,modifiability,depend,depending,31,Do not change the class layout depending on NDEBUG!;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2060
https://github.com/root-project/root/pull/2060:31,safety,depend,depending,31,Do not change the class layout depending on NDEBUG!;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2060
https://github.com/root-project/root/pull/2060:31,testability,depend,depending,31,Do not change the class layout depending on NDEBUG!;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2060
https://github.com/root-project/root/pull/2062:43,interoperability,Prox,Proxied,43,"[TDF] ROOT-9418: Define returns TInterface<Proxied, DS_t>; - Fixes: [https://sft.its.cern.ch/jira/browse/ROOT-9418](https://sft.its.cern.ch/jira/browse/ROOT-9418). - Adds a google test for `Range` with `Define` (with and without jitted functions)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2062
https://github.com/root-project/root/pull/2062:180,safety,test,test,180,"[TDF] ROOT-9418: Define returns TInterface<Proxied, DS_t>; - Fixes: [https://sft.its.cern.ch/jira/browse/ROOT-9418](https://sft.its.cern.ch/jira/browse/ROOT-9418). - Adds a google test for `Range` with `Define` (with and without jitted functions)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2062
https://github.com/root-project/root/pull/2062:180,testability,test,test,180,"[TDF] ROOT-9418: Define returns TInterface<Proxied, DS_t>; - Fixes: [https://sft.its.cern.ch/jira/browse/ROOT-9418](https://sft.its.cern.ch/jira/browse/ROOT-9418). - Adds a google test for `Range` with `Define` (with and without jitted functions)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2062
https://github.com/root-project/root/pull/2066:47,integrability,interfac,interface,47,"[RDF] Re-enable all of dataframe_{cache,simple,interface}; This resolves ROOT-9374. To be merged if said tests pass.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2066
https://github.com/root-project/root/pull/2066:47,interoperability,interfac,interface,47,"[RDF] Re-enable all of dataframe_{cache,simple,interface}; This resolves ROOT-9374. To be merged if said tests pass.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2066
https://github.com/root-project/root/pull/2066:47,modifiability,interfac,interface,47,"[RDF] Re-enable all of dataframe_{cache,simple,interface}; This resolves ROOT-9374. To be merged if said tests pass.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2066
https://github.com/root-project/root/pull/2066:34,performance,cach,cache,34,"[RDF] Re-enable all of dataframe_{cache,simple,interface}; This resolves ROOT-9374. To be merged if said tests pass.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2066
https://github.com/root-project/root/pull/2066:105,safety,test,tests,105,"[RDF] Re-enable all of dataframe_{cache,simple,interface}; This resolves ROOT-9374. To be merged if said tests pass.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2066
https://github.com/root-project/root/pull/2066:40,testability,simpl,simple,40,"[RDF] Re-enable all of dataframe_{cache,simple,interface}; This resolves ROOT-9374. To be merged if said tests pass.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2066
https://github.com/root-project/root/pull/2066:105,testability,test,tests,105,"[RDF] Re-enable all of dataframe_{cache,simple,interface}; This resolves ROOT-9374. To be merged if said tests pass.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2066
https://github.com/root-project/root/pull/2066:40,usability,simpl,simple,40,"[RDF] Re-enable all of dataframe_{cache,simple,interface}; This resolves ROOT-9374. To be merged if said tests pass.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2066
https://github.com/root-project/root/pull/2067:47,safety,test,test,47,[TDF] Delete all output files at the exit of a test case;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2067
https://github.com/root-project/root/pull/2067:47,testability,test,test,47,[TDF] Delete all output files at the exit of a test case;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2067
https://github.com/root-project/root/pull/2068:32,deployability,releas,release,32,[DOC] Small improvements to RDF release notes; - added a couple of clarifications. - entries are now *roughly* ordered by importance. - added an entry on faster jitting of Filters and Defines,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2068
https://github.com/root-project/root/pull/2068:57,integrability,coupl,couple,57,[DOC] Small improvements to RDF release notes; - added a couple of clarifications. - entries are now *roughly* ordered by importance. - added an entry on faster jitting of Filters and Defines,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2068
https://github.com/root-project/root/pull/2068:172,integrability,Filter,Filters,172,[DOC] Small improvements to RDF release notes; - added a couple of clarifications. - entries are now *roughly* ordered by importance. - added an entry on faster jitting of Filters and Defines,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2068
https://github.com/root-project/root/pull/2068:57,modifiability,coupl,couple,57,[DOC] Small improvements to RDF release notes; - added a couple of clarifications. - entries are now *roughly* ordered by importance. - added an entry on faster jitting of Filters and Defines,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2068
https://github.com/root-project/root/pull/2068:57,testability,coupl,couple,57,[DOC] Small improvements to RDF release notes; - added a couple of clarifications. - entries are now *roughly* ordered by importance. - added an entry on faster jitting of Filters and Defines,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2068
https://github.com/root-project/root/pull/2069:50,interoperability,Prox,Proxied,50,"[TDF] Reload ROOT-9418: Define returns TInterface<Proxied, DS_t>; This pr reloads #2062",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2069
https://github.com/root-project/root/pull/2070:39,modifiability,variab,variables,39,Reload #2062; ...with fixed namings of variables/types. This PR replaces #2062,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2070
https://github.com/root-project/root/pull/2071:41,energy efficiency,CPU,CPU,41,Additional improvements for MethodDL for CPU/GPU usage; Make now the possibility to select the architecture of MethodDL at runtime. Use for the evaluation of the network only CPU or Standard architecture and not GPU that is not efficient on a per/event base. Add support for copying weights between different architectures,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2071
https://github.com/root-project/root/pull/2071:45,energy efficiency,GPU,GPU,45,Additional improvements for MethodDL for CPU/GPU usage; Make now the possibility to select the architecture of MethodDL at runtime. Use for the evaluation of the network only CPU or Standard architecture and not GPU that is not efficient on a per/event base. Add support for copying weights between different architectures,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2071
https://github.com/root-project/root/pull/2071:175,energy efficiency,CPU,CPU,175,Additional improvements for MethodDL for CPU/GPU usage; Make now the possibility to select the architecture of MethodDL at runtime. Use for the evaluation of the network only CPU or Standard architecture and not GPU that is not efficient on a per/event base. Add support for copying weights between different architectures,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2071
https://github.com/root-project/root/pull/2071:212,energy efficiency,GPU,GPU,212,Additional improvements for MethodDL for CPU/GPU usage; Make now the possibility to select the architecture of MethodDL at runtime. Use for the evaluation of the network only CPU or Standard architecture and not GPU that is not efficient on a per/event base. Add support for copying weights between different architectures,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2071
https://github.com/root-project/root/pull/2071:247,integrability,event,event,247,Additional improvements for MethodDL for CPU/GPU usage; Make now the possibility to select the architecture of MethodDL at runtime. Use for the evaluation of the network only CPU or Standard architecture and not GPU that is not efficient on a per/event base. Add support for copying weights between different architectures,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2071
https://github.com/root-project/root/pull/2071:95,interoperability,architectur,architecture,95,Additional improvements for MethodDL for CPU/GPU usage; Make now the possibility to select the architecture of MethodDL at runtime. Use for the evaluation of the network only CPU or Standard architecture and not GPU that is not efficient on a per/event base. Add support for copying weights between different architectures,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2071
https://github.com/root-project/root/pull/2071:182,interoperability,Standard,Standard,182,Additional improvements for MethodDL for CPU/GPU usage; Make now the possibility to select the architecture of MethodDL at runtime. Use for the evaluation of the network only CPU or Standard architecture and not GPU that is not efficient on a per/event base. Add support for copying weights between different architectures,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2071
https://github.com/root-project/root/pull/2071:191,interoperability,architectur,architecture,191,Additional improvements for MethodDL for CPU/GPU usage; Make now the possibility to select the architecture of MethodDL at runtime. Use for the evaluation of the network only CPU or Standard architecture and not GPU that is not efficient on a per/event base. Add support for copying weights between different architectures,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2071
https://github.com/root-project/root/pull/2071:309,interoperability,architectur,architectures,309,Additional improvements for MethodDL for CPU/GPU usage; Make now the possibility to select the architecture of MethodDL at runtime. Use for the evaluation of the network only CPU or Standard architecture and not GPU that is not efficient on a per/event base. Add support for copying weights between different architectures,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2071
https://github.com/root-project/root/pull/2071:41,performance,CPU,CPU,41,Additional improvements for MethodDL for CPU/GPU usage; Make now the possibility to select the architecture of MethodDL at runtime. Use for the evaluation of the network only CPU or Standard architecture and not GPU that is not efficient on a per/event base. Add support for copying weights between different architectures,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2071
https://github.com/root-project/root/pull/2071:45,performance,GPU,GPU,45,Additional improvements for MethodDL for CPU/GPU usage; Make now the possibility to select the architecture of MethodDL at runtime. Use for the evaluation of the network only CPU or Standard architecture and not GPU that is not efficient on a per/event base. Add support for copying weights between different architectures,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2071
https://github.com/root-project/root/pull/2071:162,performance,network,network,162,Additional improvements for MethodDL for CPU/GPU usage; Make now the possibility to select the architecture of MethodDL at runtime. Use for the evaluation of the network only CPU or Standard architecture and not GPU that is not efficient on a per/event base. Add support for copying weights between different architectures,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2071
https://github.com/root-project/root/pull/2071:175,performance,CPU,CPU,175,Additional improvements for MethodDL for CPU/GPU usage; Make now the possibility to select the architecture of MethodDL at runtime. Use for the evaluation of the network only CPU or Standard architecture and not GPU that is not efficient on a per/event base. Add support for copying weights between different architectures,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2071
https://github.com/root-project/root/pull/2071:212,performance,GPU,GPU,212,Additional improvements for MethodDL for CPU/GPU usage; Make now the possibility to select the architecture of MethodDL at runtime. Use for the evaluation of the network only CPU or Standard architecture and not GPU that is not efficient on a per/event base. Add support for copying weights between different architectures,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2071
https://github.com/root-project/root/pull/2071:162,security,network,network,162,Additional improvements for MethodDL for CPU/GPU usage; Make now the possibility to select the architecture of MethodDL at runtime. Use for the evaluation of the network only CPU or Standard architecture and not GPU that is not efficient on a per/event base. Add support for copying weights between different architectures,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2071
https://github.com/root-project/root/pull/2071:228,usability,efficien,efficient,228,Additional improvements for MethodDL for CPU/GPU usage; Make now the possibility to select the architecture of MethodDL at runtime. Use for the evaluation of the network only CPU or Standard architecture and not GPU that is not efficient on a per/event base. Add support for copying weights between different architectures,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2071
https://github.com/root-project/root/pull/2071:263,usability,support,support,263,Additional improvements for MethodDL for CPU/GPU usage; Make now the possibility to select the architecture of MethodDL at runtime. Use for the evaluation of the network only CPU or Standard architecture and not GPU that is not efficient on a per/event base. Add support for copying weights between different architectures,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2071
https://github.com/root-project/root/pull/2072:79,deployability,fail,fail,79,"[WIP] Re-enable fast math for VecOps library; We need to check which platforms fail, to then restrict the changes introduced here.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2072
https://github.com/root-project/root/pull/2072:69,interoperability,platform,platforms,69,"[WIP] Re-enable fast math for VecOps library; We need to check which platforms fail, to then restrict the changes introduced here.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2072
https://github.com/root-project/root/pull/2072:79,reliability,fail,fail,79,"[WIP] Re-enable fast math for VecOps library; We need to check which platforms fail, to then restrict the changes introduced here.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2072
https://github.com/root-project/root/pull/2073:41,energy efficiency,CPU,CPU,41,Additional improvements for MethodDL for CPU/GPU usage; Make now the possibility to select the architecture of MethodDL at runtime. Use for the evaluation of the network only CPU or Standard architecture and not GPU that is not efficient on a per/event base. Add support for copying weights between different architectures,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2073
https://github.com/root-project/root/pull/2073:45,energy efficiency,GPU,GPU,45,Additional improvements for MethodDL for CPU/GPU usage; Make now the possibility to select the architecture of MethodDL at runtime. Use for the evaluation of the network only CPU or Standard architecture and not GPU that is not efficient on a per/event base. Add support for copying weights between different architectures,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2073
https://github.com/root-project/root/pull/2073:175,energy efficiency,CPU,CPU,175,Additional improvements for MethodDL for CPU/GPU usage; Make now the possibility to select the architecture of MethodDL at runtime. Use for the evaluation of the network only CPU or Standard architecture and not GPU that is not efficient on a per/event base. Add support for copying weights between different architectures,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2073
https://github.com/root-project/root/pull/2073:212,energy efficiency,GPU,GPU,212,Additional improvements for MethodDL for CPU/GPU usage; Make now the possibility to select the architecture of MethodDL at runtime. Use for the evaluation of the network only CPU or Standard architecture and not GPU that is not efficient on a per/event base. Add support for copying weights between different architectures,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2073
https://github.com/root-project/root/pull/2073:247,integrability,event,event,247,Additional improvements for MethodDL for CPU/GPU usage; Make now the possibility to select the architecture of MethodDL at runtime. Use for the evaluation of the network only CPU or Standard architecture and not GPU that is not efficient on a per/event base. Add support for copying weights between different architectures,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2073
https://github.com/root-project/root/pull/2073:95,interoperability,architectur,architecture,95,Additional improvements for MethodDL for CPU/GPU usage; Make now the possibility to select the architecture of MethodDL at runtime. Use for the evaluation of the network only CPU or Standard architecture and not GPU that is not efficient on a per/event base. Add support for copying weights between different architectures,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2073
https://github.com/root-project/root/pull/2073:182,interoperability,Standard,Standard,182,Additional improvements for MethodDL for CPU/GPU usage; Make now the possibility to select the architecture of MethodDL at runtime. Use for the evaluation of the network only CPU or Standard architecture and not GPU that is not efficient on a per/event base. Add support for copying weights between different architectures,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2073
https://github.com/root-project/root/pull/2073:191,interoperability,architectur,architecture,191,Additional improvements for MethodDL for CPU/GPU usage; Make now the possibility to select the architecture of MethodDL at runtime. Use for the evaluation of the network only CPU or Standard architecture and not GPU that is not efficient on a per/event base. Add support for copying weights between different architectures,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2073
https://github.com/root-project/root/pull/2073:309,interoperability,architectur,architectures,309,Additional improvements for MethodDL for CPU/GPU usage; Make now the possibility to select the architecture of MethodDL at runtime. Use for the evaluation of the network only CPU or Standard architecture and not GPU that is not efficient on a per/event base. Add support for copying weights between different architectures,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2073
https://github.com/root-project/root/pull/2073:41,performance,CPU,CPU,41,Additional improvements for MethodDL for CPU/GPU usage; Make now the possibility to select the architecture of MethodDL at runtime. Use for the evaluation of the network only CPU or Standard architecture and not GPU that is not efficient on a per/event base. Add support for copying weights between different architectures,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2073
https://github.com/root-project/root/pull/2073:45,performance,GPU,GPU,45,Additional improvements for MethodDL for CPU/GPU usage; Make now the possibility to select the architecture of MethodDL at runtime. Use for the evaluation of the network only CPU or Standard architecture and not GPU that is not efficient on a per/event base. Add support for copying weights between different architectures,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2073
https://github.com/root-project/root/pull/2073:162,performance,network,network,162,Additional improvements for MethodDL for CPU/GPU usage; Make now the possibility to select the architecture of MethodDL at runtime. Use for the evaluation of the network only CPU or Standard architecture and not GPU that is not efficient on a per/event base. Add support for copying weights between different architectures,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2073
https://github.com/root-project/root/pull/2073:175,performance,CPU,CPU,175,Additional improvements for MethodDL for CPU/GPU usage; Make now the possibility to select the architecture of MethodDL at runtime. Use for the evaluation of the network only CPU or Standard architecture and not GPU that is not efficient on a per/event base. Add support for copying weights between different architectures,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2073
https://github.com/root-project/root/pull/2073:212,performance,GPU,GPU,212,Additional improvements for MethodDL for CPU/GPU usage; Make now the possibility to select the architecture of MethodDL at runtime. Use for the evaluation of the network only CPU or Standard architecture and not GPU that is not efficient on a per/event base. Add support for copying weights between different architectures,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2073
https://github.com/root-project/root/pull/2073:162,security,network,network,162,Additional improvements for MethodDL for CPU/GPU usage; Make now the possibility to select the architecture of MethodDL at runtime. Use for the evaluation of the network only CPU or Standard architecture and not GPU that is not efficient on a per/event base. Add support for copying weights between different architectures,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2073
https://github.com/root-project/root/pull/2073:228,usability,efficien,efficient,228,Additional improvements for MethodDL for CPU/GPU usage; Make now the possibility to select the architecture of MethodDL at runtime. Use for the evaluation of the network only CPU or Standard architecture and not GPU that is not efficient on a per/event base. Add support for copying weights between different architectures,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2073
https://github.com/root-project/root/pull/2073:263,usability,support,support,263,Additional improvements for MethodDL for CPU/GPU usage; Make now the possibility to select the architecture of MethodDL at runtime. Use for the evaluation of the network only CPU or Standard architecture and not GPU that is not efficient on a per/event base. Add support for copying weights between different architectures,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2073
https://github.com/root-project/root/pull/2076:241,testability,simpl,simplifies,241,"Rewrite TTree:GetLeaf() using C++11 constructs; This is a remnant of [ROOT-9254](https://sft.its.cern.ch/jira/browse/ROOT-9254). We don't need the support for dots in `TTree::GetLeaf()` anymore, but I was dragging the branch along, and this simplifies the function and makes it easy to read, so might be worth merging.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2076
https://github.com/root-project/root/pull/2076:147,usability,support,support,147,"Rewrite TTree:GetLeaf() using C++11 constructs; This is a remnant of [ROOT-9254](https://sft.its.cern.ch/jira/browse/ROOT-9254). We don't need the support for dots in `TTree::GetLeaf()` anymore, but I was dragging the branch along, and this simplifies the function and makes it easy to read, so might be worth merging.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2076
https://github.com/root-project/root/pull/2076:241,usability,simpl,simplifies,241,"Rewrite TTree:GetLeaf() using C++11 constructs; This is a remnant of [ROOT-9254](https://sft.its.cern.ch/jira/browse/ROOT-9254). We don't need the support for dots in `TTree::GetLeaf()` anymore, but I was dragging the branch along, and this simplifies the function and makes it easy to read, so might be worth merging.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2076
https://github.com/root-project/root/pull/2077:46,usability,support,support,46,[RDF] Disable dataframe_cache pytest until we support template methods;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2077
https://github.com/root-project/root/pull/2078:201,deployability,releas,releases,201,"[ROOT-9417] Removing obsolete code from TFile (compression algorithm and level of ; StreamerInfo should the same as in TFile). It is looks like it is old code that breaks reading files by older ROOT releases, which were written by 6.13/02 and directly defined compression algorithm for the files (ZLIB or any other except of default LZ4).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2078
https://github.com/root-project/root/pull/2078:317,safety,except,except,317,"[ROOT-9417] Removing obsolete code from TFile (compression algorithm and level of ; StreamerInfo should the same as in TFile). It is looks like it is old code that breaks reading files by older ROOT releases, which were written by 6.13/02 and directly defined compression algorithm for the files (ZLIB or any other except of default LZ4).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2078
https://github.com/root-project/root/pull/2083:27,integrability,interfac,interface,27,"[RDF] Re-enable dataframe_{interface,simple};",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2083
https://github.com/root-project/root/pull/2083:27,interoperability,interfac,interface,27,"[RDF] Re-enable dataframe_{interface,simple};",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2083
https://github.com/root-project/root/pull/2083:27,modifiability,interfac,interface,27,"[RDF] Re-enable dataframe_{interface,simple};",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2083
https://github.com/root-project/root/pull/2083:37,testability,simpl,simple,37,"[RDF] Re-enable dataframe_{interface,simple};",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2083
https://github.com/root-project/root/pull/2083:37,usability,simpl,simple,37,"[RDF] Re-enable dataframe_{interface,simple};",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2083
https://github.com/root-project/root/pull/2084:21,safety,test,test,21,[RDF] Re-enabled all test cases in dataframe_simple;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2084
https://github.com/root-project/root/pull/2084:21,testability,test,test,21,[RDF] Re-enabled all test cases in dataframe_simple;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2084
https://github.com/root-project/root/pull/2085:25,safety,test,test,25,[RDF] Fix name change in test;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2085
https://github.com/root-project/root/pull/2085:25,testability,test,test,25,[RDF] Fix name change in test;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2085
https://github.com/root-project/root/pull/2087:33,performance,cach,cache,33,[cling] Unroll the pointer-check cache loop.;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2087
https://github.com/root-project/root/pull/2088:41,integrability,interfac,interfaces,41,"[RDF] Fix inconsistency in RDF::Snapshot interfaces for jitted calls; now Snapshot accepts to identify columns:. - A regex as a string_view. - A vector<string>. - A initializer_list<string>. This allows users to invoke it as follows:. 1. tdf.Snapshot(""t"", filename, ""an*"");. 2. tdf.Snapshot(""t"", filename, {""ans""});. 3. tdf.Snapshot(""t"", filename, {{""ans""}});. Before this change, 2. did not compile because of the ambiguity.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2088
https://github.com/root-project/root/pull/2088:41,interoperability,interfac,interfaces,41,"[RDF] Fix inconsistency in RDF::Snapshot interfaces for jitted calls; now Snapshot accepts to identify columns:. - A regex as a string_view. - A vector<string>. - A initializer_list<string>. This allows users to invoke it as follows:. 1. tdf.Snapshot(""t"", filename, ""an*"");. 2. tdf.Snapshot(""t"", filename, {""ans""});. 3. tdf.Snapshot(""t"", filename, {{""ans""}});. Before this change, 2. did not compile because of the ambiguity.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2088
https://github.com/root-project/root/pull/2088:41,modifiability,interfac,interfaces,41,"[RDF] Fix inconsistency in RDF::Snapshot interfaces for jitted calls; now Snapshot accepts to identify columns:. - A regex as a string_view. - A vector<string>. - A initializer_list<string>. This allows users to invoke it as follows:. 1. tdf.Snapshot(""t"", filename, ""an*"");. 2. tdf.Snapshot(""t"", filename, {""ans""});. 3. tdf.Snapshot(""t"", filename, {{""ans""}});. Before this change, 2. did not compile because of the ambiguity.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2088
https://github.com/root-project/root/pull/2088:94,security,ident,identify,94,"[RDF] Fix inconsistency in RDF::Snapshot interfaces for jitted calls; now Snapshot accepts to identify columns:. - A regex as a string_view. - A vector<string>. - A initializer_list<string>. This allows users to invoke it as follows:. 1. tdf.Snapshot(""t"", filename, ""an*"");. 2. tdf.Snapshot(""t"", filename, {""ans""});. 3. tdf.Snapshot(""t"", filename, {{""ans""}});. Before this change, 2. did not compile because of the ambiguity.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2088
https://github.com/root-project/root/pull/2088:203,usability,user,users,203,"[RDF] Fix inconsistency in RDF::Snapshot interfaces for jitted calls; now Snapshot accepts to identify columns:. - A regex as a string_view. - A vector<string>. - A initializer_list<string>. This allows users to invoke it as follows:. 1. tdf.Snapshot(""t"", filename, ""an*"");. 2. tdf.Snapshot(""t"", filename, {""ans""});. 3. tdf.Snapshot(""t"", filename, {{""ans""}});. Before this change, 2. did not compile because of the ambiguity.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2088
https://github.com/root-project/root/pull/2089:0,energy efficiency,Optim,Optimize,0,"Optimize call to GetBasket(fWriteBasket); According to my benchmarks with gcc 8.1, it brings ~3% performance improvement in the serialization of floats.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2089
https://github.com/root-project/root/pull/2089:0,performance,Optimiz,Optimize,0,"Optimize call to GetBasket(fWriteBasket); According to my benchmarks with gcc 8.1, it brings ~3% performance improvement in the serialization of floats.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2089
https://github.com/root-project/root/pull/2089:97,performance,perform,performance,97,"Optimize call to GetBasket(fWriteBasket); According to my benchmarks with gcc 8.1, it brings ~3% performance improvement in the serialization of floats.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2089
https://github.com/root-project/root/pull/2089:97,usability,perform,performance,97,"Optimize call to GetBasket(fWriteBasket); According to my benchmarks with gcc 8.1, it brings ~3% performance improvement in the serialization of floats.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2089
https://github.com/root-project/root/pull/2093:73,deployability,patch,patch,73,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:269,deployability,patch,patch,269,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:952,deployability,patch,patch,952,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:1259,deployability,patch,patch,1259,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:143,energy efficiency,load,loaded,143,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:231,energy efficiency,load,loading,231,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:395,energy efficiency,load,loaded,395,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:433,energy efficiency,load,load,433,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:560,energy efficiency,optim,optimization,560,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:1034,energy efficiency,Cpu,Cpu,1034,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:1129,energy efficiency,cpu,cpu,1129,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:1341,energy efficiency,Cpu,Cpu,1341,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:1436,energy efficiency,cpu,cpu,1436,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:143,performance,load,loaded,143,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:194,performance,perform,performance,194,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:231,performance,load,loading,231,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:395,performance,load,loaded,395,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:433,performance,load,load,433,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:560,performance,optimiz,optimization,560,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:740,performance,perform,performant,740,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:1014,performance,Time,Time,1014,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:1034,performance,Cpu,Cpu,1034,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:1038,performance,Time,Time,1038,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:1117,performance,memor,memory,1117,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:1129,performance,cpu,cpu,1129,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:1133,performance,time,time,1133,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:1162,performance,time,time,1162,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:1191,performance,memor,memory,1191,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:1220,performance,memor,memory,1220,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:1321,performance,Time,Time,1321,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:1341,performance,Cpu,Cpu,1341,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:1345,performance,Time,Time,1345,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:1424,performance,memor,memory,1424,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:1436,performance,cpu,cpu,1436,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:1440,performance,time,time,1440,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:1469,performance,time,time,1469,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:1498,performance,memor,memory,1498,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:1527,performance,memor,memory,1527,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:1572,performance,time,time,1572,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:1583,performance,time,times,1583,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:1593,performance,memor,memory,1593,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:73,safety,patch,patch,73,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:269,safety,patch,patch,269,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:952,safety,patch,patch,952,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:1259,safety,patch,patch,1259,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:73,security,patch,patch,73,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:269,security,patch,patch,269,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:517,security,ident,identifier,517,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:576,security,hash,hashing,576,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:770,security,hash,hash,770,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:836,security,hash,hash-table-in-response-to-googles-new-fast-hash-table,836,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:952,security,patch,patch,952,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:1259,security,patch,patch,1259,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:194,usability,perform,performance,194,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:740,usability,perform,performant,740,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:1117,usability,memor,memory,1117,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:1191,usability,memor,memory,1191,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:1220,usability,memor,memory,1220,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:1424,usability,memor,memory,1424,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:1498,usability,memor,memory,1498,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:1527,usability,memor,memory,1527,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2093:1593,usability,memor,memory,1593,"[cxxmodules] Autoload less libraries; In previous allmodules&autoloading patch, we used callback from. DeserializationListener to get Decl and loaded corresponding libraries. It worked, but the performance was bad because ROOT was loading. excessive libraries. In this patch, we use TCling::LazyFunctionCreatorAutoloadForModule. This. function gets callback when ""mangled_name"" was not found in loaded. libraries thus we have to the load corresponding library and lookup. again. I used unordered_map to store mangled identifier and library pair. I'm. doing an optimization by hashing mangled name and storing library not by. name but by uint8 and hold uint8-name information in another vector. Also tried std::map but unorderd_map was more performant. There are. better hash table like:. https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/. we can try to use them if this part gets crucial. With this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. W/o this patch:. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. So it improves time by 4x times and memory by 2x.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2093
https://github.com/root-project/root/pull/2097:1146,deployability,contain,containers,1146,"[PyROOT] Pretty printing feature using cling::printValue; ~~TBD: Pretty-printing feature for RVec~~. Pretty printing feature for PyROOT! **ROOT.VecOps.RVec:**. ```python. >>> v = ROOT.ROOT.VecOps.RVec('float')(3). >>> for i in range(3): v[i] = i. >>> print(v). { 0, 1, 2 }. ```. **std.vector:**. ```python. >>> v = ROOT.std.vector('float')(5). >>> for i in range(len(v)): v[i] = i. >>> print(v). { 0.00000f, 1.00000f, 2.00000f, 3.00000f, 4.00000f }. ```. **std.map:**. ```python. >>> m = ROOT.std.map(""string"", ""int"")(). >>> m[""foo""] = 42. >>> m[""bar""] = -1. >>> print(m). { ""bar"" => -1, ""foo"" => 42 }. ```. **ROOT.RDataFrame:**. ```python. >>> f = ROOT.TFile(""test.root"", ""RECREATE""). >>> tree = ROOT.TTree(""foo"", ""bar""). >>> [do sth with the tree ...]. >>> df = ROOT.RDataFrame(""foo"", ""test.root""). >>> print(df). A data frame built on top of the foo dataset. ```. **Recursive pretty-printing:**. ```python. >>> v = ROOT.std.vector(""vector<float>"")(2). >>> v[0].push_back(1). >>> v[0].push_back(2). >>> v[1].push_back(-3). >>> v[1].push_back(-4). >>> print(v). { { 1.00000f, 2.00000f }, { -3.00000f, -4.00000f } }. ```. **Uncommon types in STL containers:**. ```python. >>> v = ROOT.std.vector(""TObject"")(2). >>> v[0] = ROOT.TObject(). >>> v[1] = ROOT.TObject(). >>> print(v). { @0x3fbb980, @0x3fbb990 }. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2097
https://github.com/root-project/root/pull/2097:661,safety,test,test,661,"[PyROOT] Pretty printing feature using cling::printValue; ~~TBD: Pretty-printing feature for RVec~~. Pretty printing feature for PyROOT! **ROOT.VecOps.RVec:**. ```python. >>> v = ROOT.ROOT.VecOps.RVec('float')(3). >>> for i in range(3): v[i] = i. >>> print(v). { 0, 1, 2 }. ```. **std.vector:**. ```python. >>> v = ROOT.std.vector('float')(5). >>> for i in range(len(v)): v[i] = i. >>> print(v). { 0.00000f, 1.00000f, 2.00000f, 3.00000f, 4.00000f }. ```. **std.map:**. ```python. >>> m = ROOT.std.map(""string"", ""int"")(). >>> m[""foo""] = 42. >>> m[""bar""] = -1. >>> print(m). { ""bar"" => -1, ""foo"" => 42 }. ```. **ROOT.RDataFrame:**. ```python. >>> f = ROOT.TFile(""test.root"", ""RECREATE""). >>> tree = ROOT.TTree(""foo"", ""bar""). >>> [do sth with the tree ...]. >>> df = ROOT.RDataFrame(""foo"", ""test.root""). >>> print(df). A data frame built on top of the foo dataset. ```. **Recursive pretty-printing:**. ```python. >>> v = ROOT.std.vector(""vector<float>"")(2). >>> v[0].push_back(1). >>> v[0].push_back(2). >>> v[1].push_back(-3). >>> v[1].push_back(-4). >>> print(v). { { 1.00000f, 2.00000f }, { -3.00000f, -4.00000f } }. ```. **Uncommon types in STL containers:**. ```python. >>> v = ROOT.std.vector(""TObject"")(2). >>> v[0] = ROOT.TObject(). >>> v[1] = ROOT.TObject(). >>> print(v). { @0x3fbb980, @0x3fbb990 }. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2097
https://github.com/root-project/root/pull/2097:788,safety,test,test,788,"[PyROOT] Pretty printing feature using cling::printValue; ~~TBD: Pretty-printing feature for RVec~~. Pretty printing feature for PyROOT! **ROOT.VecOps.RVec:**. ```python. >>> v = ROOT.ROOT.VecOps.RVec('float')(3). >>> for i in range(3): v[i] = i. >>> print(v). { 0, 1, 2 }. ```. **std.vector:**. ```python. >>> v = ROOT.std.vector('float')(5). >>> for i in range(len(v)): v[i] = i. >>> print(v). { 0.00000f, 1.00000f, 2.00000f, 3.00000f, 4.00000f }. ```. **std.map:**. ```python. >>> m = ROOT.std.map(""string"", ""int"")(). >>> m[""foo""] = 42. >>> m[""bar""] = -1. >>> print(m). { ""bar"" => -1, ""foo"" => 42 }. ```. **ROOT.RDataFrame:**. ```python. >>> f = ROOT.TFile(""test.root"", ""RECREATE""). >>> tree = ROOT.TTree(""foo"", ""bar""). >>> [do sth with the tree ...]. >>> df = ROOT.RDataFrame(""foo"", ""test.root""). >>> print(df). A data frame built on top of the foo dataset. ```. **Recursive pretty-printing:**. ```python. >>> v = ROOT.std.vector(""vector<float>"")(2). >>> v[0].push_back(1). >>> v[0].push_back(2). >>> v[1].push_back(-3). >>> v[1].push_back(-4). >>> print(v). { { 1.00000f, 2.00000f }, { -3.00000f, -4.00000f } }. ```. **Uncommon types in STL containers:**. ```python. >>> v = ROOT.std.vector(""TObject"")(2). >>> v[0] = ROOT.TObject(). >>> v[1] = ROOT.TObject(). >>> print(v). { @0x3fbb980, @0x3fbb990 }. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2097
https://github.com/root-project/root/pull/2097:661,testability,test,test,661,"[PyROOT] Pretty printing feature using cling::printValue; ~~TBD: Pretty-printing feature for RVec~~. Pretty printing feature for PyROOT! **ROOT.VecOps.RVec:**. ```python. >>> v = ROOT.ROOT.VecOps.RVec('float')(3). >>> for i in range(3): v[i] = i. >>> print(v). { 0, 1, 2 }. ```. **std.vector:**. ```python. >>> v = ROOT.std.vector('float')(5). >>> for i in range(len(v)): v[i] = i. >>> print(v). { 0.00000f, 1.00000f, 2.00000f, 3.00000f, 4.00000f }. ```. **std.map:**. ```python. >>> m = ROOT.std.map(""string"", ""int"")(). >>> m[""foo""] = 42. >>> m[""bar""] = -1. >>> print(m). { ""bar"" => -1, ""foo"" => 42 }. ```. **ROOT.RDataFrame:**. ```python. >>> f = ROOT.TFile(""test.root"", ""RECREATE""). >>> tree = ROOT.TTree(""foo"", ""bar""). >>> [do sth with the tree ...]. >>> df = ROOT.RDataFrame(""foo"", ""test.root""). >>> print(df). A data frame built on top of the foo dataset. ```. **Recursive pretty-printing:**. ```python. >>> v = ROOT.std.vector(""vector<float>"")(2). >>> v[0].push_back(1). >>> v[0].push_back(2). >>> v[1].push_back(-3). >>> v[1].push_back(-4). >>> print(v). { { 1.00000f, 2.00000f }, { -3.00000f, -4.00000f } }. ```. **Uncommon types in STL containers:**. ```python. >>> v = ROOT.std.vector(""TObject"")(2). >>> v[0] = ROOT.TObject(). >>> v[1] = ROOT.TObject(). >>> print(v). { @0x3fbb980, @0x3fbb990 }. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2097
https://github.com/root-project/root/pull/2097:788,testability,test,test,788,"[PyROOT] Pretty printing feature using cling::printValue; ~~TBD: Pretty-printing feature for RVec~~. Pretty printing feature for PyROOT! **ROOT.VecOps.RVec:**. ```python. >>> v = ROOT.ROOT.VecOps.RVec('float')(3). >>> for i in range(3): v[i] = i. >>> print(v). { 0, 1, 2 }. ```. **std.vector:**. ```python. >>> v = ROOT.std.vector('float')(5). >>> for i in range(len(v)): v[i] = i. >>> print(v). { 0.00000f, 1.00000f, 2.00000f, 3.00000f, 4.00000f }. ```. **std.map:**. ```python. >>> m = ROOT.std.map(""string"", ""int"")(). >>> m[""foo""] = 42. >>> m[""bar""] = -1. >>> print(m). { ""bar"" => -1, ""foo"" => 42 }. ```. **ROOT.RDataFrame:**. ```python. >>> f = ROOT.TFile(""test.root"", ""RECREATE""). >>> tree = ROOT.TTree(""foo"", ""bar""). >>> [do sth with the tree ...]. >>> df = ROOT.RDataFrame(""foo"", ""test.root""). >>> print(df). A data frame built on top of the foo dataset. ```. **Recursive pretty-printing:**. ```python. >>> v = ROOT.std.vector(""vector<float>"")(2). >>> v[0].push_back(1). >>> v[0].push_back(2). >>> v[1].push_back(-3). >>> v[1].push_back(-4). >>> print(v). { { 1.00000f, 2.00000f }, { -3.00000f, -4.00000f } }. ```. **Uncommon types in STL containers:**. ```python. >>> v = ROOT.std.vector(""TObject"")(2). >>> v[0] = ROOT.TObject(). >>> v[1] = ROOT.TObject(). >>> print(v). { @0x3fbb980, @0x3fbb990 }. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2097
https://github.com/root-project/root/pull/2100:11,deployability,Updat,Update,11,[RDF][NFC] Update cheat sheet with links to the RDFInterface methods; The result is visible here: https://root.cern/doc/master/classROOT_1_1RDataFrame.html,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2100
https://github.com/root-project/root/pull/2100:11,safety,Updat,Update,11,[RDF][NFC] Update cheat sheet with links to the RDFInterface methods; The result is visible here: https://root.cern/doc/master/classROOT_1_1RDataFrame.html,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2100
https://github.com/root-project/root/pull/2100:11,security,Updat,Update,11,[RDF][NFC] Update cheat sheet with links to the RDFInterface methods; The result is visible here: https://root.cern/doc/master/classROOT_1_1RDataFrame.html,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2100
https://github.com/root-project/root/pull/2101:103,availability,failur,failures,103,[VecOps] Fix VecOps tutorials; Functionality not backported to 614 was showcased. This fixes all these failures: http://cdash.cern.ch/testDetails.php?test=45078185&build=514176,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2101
https://github.com/root-project/root/pull/2101:103,deployability,fail,failures,103,[VecOps] Fix VecOps tutorials; Functionality not backported to 614 was showcased. This fixes all these failures: http://cdash.cern.ch/testDetails.php?test=45078185&build=514176,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2101
https://github.com/root-project/root/pull/2101:164,deployability,build,build,164,[VecOps] Fix VecOps tutorials; Functionality not backported to 614 was showcased. This fixes all these failures: http://cdash.cern.ch/testDetails.php?test=45078185&build=514176,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2101
https://github.com/root-project/root/pull/2101:103,performance,failur,failures,103,[VecOps] Fix VecOps tutorials; Functionality not backported to 614 was showcased. This fixes all these failures: http://cdash.cern.ch/testDetails.php?test=45078185&build=514176,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2101
https://github.com/root-project/root/pull/2101:103,reliability,fail,failures,103,[VecOps] Fix VecOps tutorials; Functionality not backported to 614 was showcased. This fixes all these failures: http://cdash.cern.ch/testDetails.php?test=45078185&build=514176,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2101
https://github.com/root-project/root/pull/2101:134,safety,test,testDetails,134,[VecOps] Fix VecOps tutorials; Functionality not backported to 614 was showcased. This fixes all these failures: http://cdash.cern.ch/testDetails.php?test=45078185&build=514176,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2101
https://github.com/root-project/root/pull/2101:150,safety,test,test,150,[VecOps] Fix VecOps tutorials; Functionality not backported to 614 was showcased. This fixes all these failures: http://cdash.cern.ch/testDetails.php?test=45078185&build=514176,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2101
https://github.com/root-project/root/pull/2101:134,testability,test,testDetails,134,[VecOps] Fix VecOps tutorials; Functionality not backported to 614 was showcased. This fixes all these failures: http://cdash.cern.ch/testDetails.php?test=45078185&build=514176,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2101
https://github.com/root-project/root/pull/2101:150,testability,test,test,150,[VecOps] Fix VecOps tutorials; Functionality not backported to 614 was showcased. This fixes all these failures: http://cdash.cern.ch/testDetails.php?test=45078185&build=514176,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2101
https://github.com/root-project/root/pull/2102:297,energy efficiency,CPU,CPU,297,"Improve TH1::Merge for histogram with labels; Add possibilities to pass options in TH1::Merge. Print a warning in case of duplicate labels. Add an option to force merge numeric (bin centre by bin center values) and an option to skip duplicate labels check, which can be quite expensive in term of CPU time",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2102
https://github.com/root-project/root/pull/2102:297,performance,CPU,CPU,297,"Improve TH1::Merge for histogram with labels; Add possibilities to pass options in TH1::Merge. Print a warning in case of duplicate labels. Add an option to force merge numeric (bin centre by bin center values) and an option to skip duplicate labels check, which can be quite expensive in term of CPU time",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2102
https://github.com/root-project/root/pull/2102:301,performance,time,time,301,"Improve TH1::Merge for histogram with labels; Add possibilities to pass options in TH1::Merge. Print a warning in case of duplicate labels. Add an option to force merge numeric (bin centre by bin center values) and an option to skip duplicate labels check, which can be quite expensive in term of CPU time",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2102
https://github.com/root-project/root/pull/2103:15,availability,failur,failures,15,[DF] Fix 32bit failures; This works around an ABI compatibility issue between cling and gcc. on 32bit machines in which they disagree in the way arguments should. be passed to such a function.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2103
https://github.com/root-project/root/pull/2103:15,deployability,fail,failures,15,[DF] Fix 32bit failures; This works around an ABI compatibility issue between cling and gcc. on 32bit machines in which they disagree in the way arguments should. be passed to such a function.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2103
https://github.com/root-project/root/pull/2103:50,interoperability,compatib,compatibility,50,[DF] Fix 32bit failures; This works around an ABI compatibility issue between cling and gcc. on 32bit machines in which they disagree in the way arguments should. be passed to such a function.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2103
https://github.com/root-project/root/pull/2103:15,performance,failur,failures,15,[DF] Fix 32bit failures; This works around an ABI compatibility issue between cling and gcc. on 32bit machines in which they disagree in the way arguments should. be passed to such a function.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2103
https://github.com/root-project/root/pull/2103:15,reliability,fail,failures,15,[DF] Fix 32bit failures; This works around an ABI compatibility issue between cling and gcc. on 32bit machines in which they disagree in the way arguments should. be passed to such a function.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2103
https://github.com/root-project/root/pull/2104:15,availability,failur,failures,15,[DF] Fix 32bit failures; This works around an ABI compatibility issue between cling and gcc. on 32bit machines in which they disagree in the way arguments should. be passed to such a function.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2104
https://github.com/root-project/root/pull/2104:15,deployability,fail,failures,15,[DF] Fix 32bit failures; This works around an ABI compatibility issue between cling and gcc. on 32bit machines in which they disagree in the way arguments should. be passed to such a function.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2104
https://github.com/root-project/root/pull/2104:50,interoperability,compatib,compatibility,50,[DF] Fix 32bit failures; This works around an ABI compatibility issue between cling and gcc. on 32bit machines in which they disagree in the way arguments should. be passed to such a function.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2104
https://github.com/root-project/root/pull/2104:15,performance,failur,failures,15,[DF] Fix 32bit failures; This works around an ABI compatibility issue between cling and gcc. on 32bit machines in which they disagree in the way arguments should. be passed to such a function.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2104
https://github.com/root-project/root/pull/2104:15,reliability,fail,failures,15,[DF] Fix 32bit failures; This works around an ABI compatibility issue between cling and gcc. on 32bit machines in which they disagree in the way arguments should. be passed to such a function.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2104
https://github.com/root-project/root/pull/2105:176,interoperability,format,formats,176,[DF][DOC] Small amendments to user guide; * move table of contents before cheat-sheet. * add cheat-sheet to table of contents. * mention that we also read CSV's and other data formats,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2105
https://github.com/root-project/root/pull/2105:58,performance,content,contents,58,[DF][DOC] Small amendments to user guide; * move table of contents before cheat-sheet. * add cheat-sheet to table of contents. * mention that we also read CSV's and other data formats,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2105
https://github.com/root-project/root/pull/2105:117,performance,content,contents,117,[DF][DOC] Small amendments to user guide; * move table of contents before cheat-sheet. * add cheat-sheet to table of contents. * mention that we also read CSV's and other data formats,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2105
https://github.com/root-project/root/pull/2105:30,usability,user,user,30,[DF][DOC] Small amendments to user guide; * move table of contents before cheat-sheet. * add cheat-sheet to table of contents. * mention that we also read CSV's and other data formats,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2105
https://github.com/root-project/root/pull/2105:35,usability,guid,guide,35,[DF][DOC] Small amendments to user guide; * move table of contents before cheat-sheet. * add cheat-sheet to table of contents. * mention that we also read CSV's and other data formats,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2105
https://github.com/root-project/root/pull/2107:184,reliability,doe,does,184,"[VecOps] Disable finite math functions for old glibc; These functions (enabled when -ffast-math is used) were only added. in glibc 2.15. However, SLC 6 still uses glibc 2.12 and clang does. not check before emitting the symbols, so linkage with clang is. broken when fast math is enabled.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2107
https://github.com/root-project/root/pull/2108:11,integrability,compon,component,11,"bugfix for component selection handling fix; In #2033, an override switch for component selection was introduced. Unfortunately, this switch was not used at all the appropriate places yet. This PR adds the missing calls.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2108
https://github.com/root-project/root/pull/2108:78,integrability,compon,component,78,"bugfix for component selection handling fix; In #2033, an override switch for component selection was introduced. Unfortunately, this switch was not used at all the appropriate places yet. This PR adds the missing calls.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2108
https://github.com/root-project/root/pull/2108:11,interoperability,compon,component,11,"bugfix for component selection handling fix; In #2033, an override switch for component selection was introduced. Unfortunately, this switch was not used at all the appropriate places yet. This PR adds the missing calls.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2108
https://github.com/root-project/root/pull/2108:78,interoperability,compon,component,78,"bugfix for component selection handling fix; In #2033, an override switch for component selection was introduced. Unfortunately, this switch was not used at all the appropriate places yet. This PR adds the missing calls.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2108
https://github.com/root-project/root/pull/2108:11,modifiability,compon,component,11,"bugfix for component selection handling fix; In #2033, an override switch for component selection was introduced. Unfortunately, this switch was not used at all the appropriate places yet. This PR adds the missing calls.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2108
https://github.com/root-project/root/pull/2108:78,modifiability,compon,component,78,"bugfix for component selection handling fix; In #2033, an override switch for component selection was introduced. Unfortunately, this switch was not used at all the appropriate places yet. This PR adds the missing calls.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2108
https://github.com/root-project/root/pull/2109:30,usability,user,user,30,[DF][DOC] Small amendments to user guide;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2109
https://github.com/root-project/root/pull/2109:35,usability,guid,guide,35,[DF][DOC] Small amendments to user guide;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2109
https://github.com/root-project/root/pull/2110:53,interoperability,architectur,architecture,53,Fixes in TMVA DeepLearning for Selecting the Correct architecture ;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2110
https://github.com/root-project/root/pull/2111:58,deployability,patch,patches,58,Merge fixes in TMVA for Deep Learning from master to 6.14 patches;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2111
https://github.com/root-project/root/pull/2111:58,safety,patch,patches,58,Merge fixes in TMVA for Deep Learning from master to 6.14 patches;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2111
https://github.com/root-project/root/pull/2111:58,security,patch,patches,58,Merge fixes in TMVA for Deep Learning from master to 6.14 patches;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2111
https://github.com/root-project/root/pull/2111:29,usability,Learn,Learning,29,Merge fixes in TMVA for Deep Learning from master to 6.14 patches;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2111
https://github.com/root-project/root/pull/2112:88,availability,failur,failure,88,"[cxxmodules] Add missing guard; This was causing roottest-root-core-execStatusBitsCheck failure. TEmulatedTuple is injected to AST by creating virtual file called. `input_line_<number>`. This is the same way as we inject ""ClassDef(name,. id)"" and we need to `undef __ROOTCLING__` in that case (because it's not. ROOTCLING).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2112
https://github.com/root-project/root/pull/2112:88,deployability,fail,failure,88,"[cxxmodules] Add missing guard; This was causing roottest-root-core-execStatusBitsCheck failure. TEmulatedTuple is injected to AST by creating virtual file called. `input_line_<number>`. This is the same way as we inject ""ClassDef(name,. id)"" and we need to `undef __ROOTCLING__` in that case (because it's not. ROOTCLING).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2112
https://github.com/root-project/root/pull/2112:63,energy efficiency,core,core-execStatusBitsCheck,63,"[cxxmodules] Add missing guard; This was causing roottest-root-core-execStatusBitsCheck failure. TEmulatedTuple is injected to AST by creating virtual file called. `input_line_<number>`. This is the same way as we inject ""ClassDef(name,. id)"" and we need to `undef __ROOTCLING__` in that case (because it's not. ROOTCLING).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2112
https://github.com/root-project/root/pull/2112:115,integrability,inject,injected,115,"[cxxmodules] Add missing guard; This was causing roottest-root-core-execStatusBitsCheck failure. TEmulatedTuple is injected to AST by creating virtual file called. `input_line_<number>`. This is the same way as we inject ""ClassDef(name,. id)"" and we need to `undef __ROOTCLING__` in that case (because it's not. ROOTCLING).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2112
https://github.com/root-project/root/pull/2112:214,integrability,inject,inject,214,"[cxxmodules] Add missing guard; This was causing roottest-root-core-execStatusBitsCheck failure. TEmulatedTuple is injected to AST by creating virtual file called. `input_line_<number>`. This is the same way as we inject ""ClassDef(name,. id)"" and we need to `undef __ROOTCLING__` in that case (because it's not. ROOTCLING).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2112
https://github.com/root-project/root/pull/2112:88,performance,failur,failure,88,"[cxxmodules] Add missing guard; This was causing roottest-root-core-execStatusBitsCheck failure. TEmulatedTuple is injected to AST by creating virtual file called. `input_line_<number>`. This is the same way as we inject ""ClassDef(name,. id)"" and we need to `undef __ROOTCLING__` in that case (because it's not. ROOTCLING).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2112
https://github.com/root-project/root/pull/2112:88,reliability,fail,failure,88,"[cxxmodules] Add missing guard; This was causing roottest-root-core-execStatusBitsCheck failure. TEmulatedTuple is injected to AST by creating virtual file called. `input_line_<number>`. This is the same way as we inject ""ClassDef(name,. id)"" and we need to `undef __ROOTCLING__` in that case (because it's not. ROOTCLING).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2112
https://github.com/root-project/root/pull/2112:115,security,inject,injected,115,"[cxxmodules] Add missing guard; This was causing roottest-root-core-execStatusBitsCheck failure. TEmulatedTuple is injected to AST by creating virtual file called. `input_line_<number>`. This is the same way as we inject ""ClassDef(name,. id)"" and we need to `undef __ROOTCLING__` in that case (because it's not. ROOTCLING).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2112
https://github.com/root-project/root/pull/2112:214,security,inject,inject,214,"[cxxmodules] Add missing guard; This was causing roottest-root-core-execStatusBitsCheck failure. TEmulatedTuple is injected to AST by creating virtual file called. `input_line_<number>`. This is the same way as we inject ""ClassDef(name,. id)"" and we need to `undef __ROOTCLING__` in that case (because it's not. ROOTCLING).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2112
https://github.com/root-project/root/pull/2114:46,availability,failur,failure,46,"Fix for ROOT-9336 observed in TH1::Merge; The failure seen in ROOT-9336 merging ATLAS histogram was caused by a bug in TH1::IsEmpty and . TH1::ResetStats/GetStats . TH1::ResetStats was setting the entries to zero for histograms with labels and the function TH1::IsEmpty was assuming than an histogram is empty if fTsumw AND entries == 0. Now we fix the protected function Th1::IsEmpty used in TH1Merger for the case when both fTSumw=0 and fEntries=0, but in reality the bin contents are not zero. We Add in this case a check to all bin contents, including underflow/overflows. We fix also TH1::GetStats() for the case of labels histograms. In this case when you have fTSumw=0 and fEntries !=0 (happening for the cases after calling SetBinContent or TH1::ResetStats) you want to compute the correct fTsumw and fTsumw2 values. With these fixes now ResetStats() works correctly and set the correct histogram statistics (e.g. number of entries). .",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2114
https://github.com/root-project/root/pull/2114:18,deployability,observ,observed,18,"Fix for ROOT-9336 observed in TH1::Merge; The failure seen in ROOT-9336 merging ATLAS histogram was caused by a bug in TH1::IsEmpty and . TH1::ResetStats/GetStats . TH1::ResetStats was setting the entries to zero for histograms with labels and the function TH1::IsEmpty was assuming than an histogram is empty if fTsumw AND entries == 0. Now we fix the protected function Th1::IsEmpty used in TH1Merger for the case when both fTSumw=0 and fEntries=0, but in reality the bin contents are not zero. We Add in this case a check to all bin contents, including underflow/overflows. We fix also TH1::GetStats() for the case of labels histograms. In this case when you have fTSumw=0 and fEntries !=0 (happening for the cases after calling SetBinContent or TH1::ResetStats) you want to compute the correct fTsumw and fTsumw2 values. With these fixes now ResetStats() works correctly and set the correct histogram statistics (e.g. number of entries). .",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2114
https://github.com/root-project/root/pull/2114:46,deployability,fail,failure,46,"Fix for ROOT-9336 observed in TH1::Merge; The failure seen in ROOT-9336 merging ATLAS histogram was caused by a bug in TH1::IsEmpty and . TH1::ResetStats/GetStats . TH1::ResetStats was setting the entries to zero for histograms with labels and the function TH1::IsEmpty was assuming than an histogram is empty if fTsumw AND entries == 0. Now we fix the protected function Th1::IsEmpty used in TH1Merger for the case when both fTSumw=0 and fEntries=0, but in reality the bin contents are not zero. We Add in this case a check to all bin contents, including underflow/overflows. We fix also TH1::GetStats() for the case of labels histograms. In this case when you have fTSumw=0 and fEntries !=0 (happening for the cases after calling SetBinContent or TH1::ResetStats) you want to compute the correct fTsumw and fTsumw2 values. With these fixes now ResetStats() works correctly and set the correct histogram statistics (e.g. number of entries). .",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2114
https://github.com/root-project/root/pull/2114:46,performance,failur,failure,46,"Fix for ROOT-9336 observed in TH1::Merge; The failure seen in ROOT-9336 merging ATLAS histogram was caused by a bug in TH1::IsEmpty and . TH1::ResetStats/GetStats . TH1::ResetStats was setting the entries to zero for histograms with labels and the function TH1::IsEmpty was assuming than an histogram is empty if fTsumw AND entries == 0. Now we fix the protected function Th1::IsEmpty used in TH1Merger for the case when both fTSumw=0 and fEntries=0, but in reality the bin contents are not zero. We Add in this case a check to all bin contents, including underflow/overflows. We fix also TH1::GetStats() for the case of labels histograms. In this case when you have fTSumw=0 and fEntries !=0 (happening for the cases after calling SetBinContent or TH1::ResetStats) you want to compute the correct fTsumw and fTsumw2 values. With these fixes now ResetStats() works correctly and set the correct histogram statistics (e.g. number of entries). .",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2114
https://github.com/root-project/root/pull/2114:475,performance,content,contents,475,"Fix for ROOT-9336 observed in TH1::Merge; The failure seen in ROOT-9336 merging ATLAS histogram was caused by a bug in TH1::IsEmpty and . TH1::ResetStats/GetStats . TH1::ResetStats was setting the entries to zero for histograms with labels and the function TH1::IsEmpty was assuming than an histogram is empty if fTsumw AND entries == 0. Now we fix the protected function Th1::IsEmpty used in TH1Merger for the case when both fTSumw=0 and fEntries=0, but in reality the bin contents are not zero. We Add in this case a check to all bin contents, including underflow/overflows. We fix also TH1::GetStats() for the case of labels histograms. In this case when you have fTSumw=0 and fEntries !=0 (happening for the cases after calling SetBinContent or TH1::ResetStats) you want to compute the correct fTsumw and fTsumw2 values. With these fixes now ResetStats() works correctly and set the correct histogram statistics (e.g. number of entries). .",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2114
https://github.com/root-project/root/pull/2114:537,performance,content,contents,537,"Fix for ROOT-9336 observed in TH1::Merge; The failure seen in ROOT-9336 merging ATLAS histogram was caused by a bug in TH1::IsEmpty and . TH1::ResetStats/GetStats . TH1::ResetStats was setting the entries to zero for histograms with labels and the function TH1::IsEmpty was assuming than an histogram is empty if fTsumw AND entries == 0. Now we fix the protected function Th1::IsEmpty used in TH1Merger for the case when both fTSumw=0 and fEntries=0, but in reality the bin contents are not zero. We Add in this case a check to all bin contents, including underflow/overflows. We fix also TH1::GetStats() for the case of labels histograms. In this case when you have fTSumw=0 and fEntries !=0 (happening for the cases after calling SetBinContent or TH1::ResetStats) you want to compute the correct fTsumw and fTsumw2 values. With these fixes now ResetStats() works correctly and set the correct histogram statistics (e.g. number of entries). .",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2114
https://github.com/root-project/root/pull/2114:46,reliability,fail,failure,46,"Fix for ROOT-9336 observed in TH1::Merge; The failure seen in ROOT-9336 merging ATLAS histogram was caused by a bug in TH1::IsEmpty and . TH1::ResetStats/GetStats . TH1::ResetStats was setting the entries to zero for histograms with labels and the function TH1::IsEmpty was assuming than an histogram is empty if fTsumw AND entries == 0. Now we fix the protected function Th1::IsEmpty used in TH1Merger for the case when both fTSumw=0 and fEntries=0, but in reality the bin contents are not zero. We Add in this case a check to all bin contents, including underflow/overflows. We fix also TH1::GetStats() for the case of labels histograms. In this case when you have fTSumw=0 and fEntries !=0 (happening for the cases after calling SetBinContent or TH1::ResetStats) you want to compute the correct fTsumw and fTsumw2 values. With these fixes now ResetStats() works correctly and set the correct histogram statistics (e.g. number of entries). .",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2114
https://github.com/root-project/root/pull/2114:18,testability,observ,observed,18,"Fix for ROOT-9336 observed in TH1::Merge; The failure seen in ROOT-9336 merging ATLAS histogram was caused by a bug in TH1::IsEmpty and . TH1::ResetStats/GetStats . TH1::ResetStats was setting the entries to zero for histograms with labels and the function TH1::IsEmpty was assuming than an histogram is empty if fTsumw AND entries == 0. Now we fix the protected function Th1::IsEmpty used in TH1Merger for the case when both fTSumw=0 and fEntries=0, but in reality the bin contents are not zero. We Add in this case a check to all bin contents, including underflow/overflows. We fix also TH1::GetStats() for the case of labels histograms. In this case when you have fTSumw=0 and fEntries !=0 (happening for the cases after calling SetBinContent or TH1::ResetStats) you want to compute the correct fTsumw and fTsumw2 values. With these fixes now ResetStats() works correctly and set the correct histogram statistics (e.g. number of entries). .",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2114
https://github.com/root-project/root/pull/2116:130,deployability,contain,contains,130,"[TREEPROCMT] Pass per-tree number of entries to thread-local TChains; This ensures that each thread-local TChain knows which tree contains. which global entry number without having to open all intermediate. files to check how many entries they contain, resulting in much. less contention in TTreeProcessorMT when multiple threads are loading. the right file to process. An artificial example running on 342 files of about 2MB each, with 8 cores, release build of ROOT, has the following timings:. * current master, 8 cores: ~10s. * with this fix, 8 cores: ~3.5s. * no imt (current master and with the fix): ~1s. To merge after #2115.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2116
https://github.com/root-project/root/pull/2116:244,deployability,contain,contain,244,"[TREEPROCMT] Pass per-tree number of entries to thread-local TChains; This ensures that each thread-local TChain knows which tree contains. which global entry number without having to open all intermediate. files to check how many entries they contain, resulting in much. less contention in TTreeProcessorMT when multiple threads are loading. the right file to process. An artificial example running on 342 files of about 2MB each, with 8 cores, release build of ROOT, has the following timings:. * current master, 8 cores: ~10s. * with this fix, 8 cores: ~3.5s. * no imt (current master and with the fix): ~1s. To merge after #2115.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2116
https://github.com/root-project/root/pull/2116:446,deployability,releas,release,446,"[TREEPROCMT] Pass per-tree number of entries to thread-local TChains; This ensures that each thread-local TChain knows which tree contains. which global entry number without having to open all intermediate. files to check how many entries they contain, resulting in much. less contention in TTreeProcessorMT when multiple threads are loading. the right file to process. An artificial example running on 342 files of about 2MB each, with 8 cores, release build of ROOT, has the following timings:. * current master, 8 cores: ~10s. * with this fix, 8 cores: ~3.5s. * no imt (current master and with the fix): ~1s. To merge after #2115.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2116
https://github.com/root-project/root/pull/2116:454,deployability,build,build,454,"[TREEPROCMT] Pass per-tree number of entries to thread-local TChains; This ensures that each thread-local TChain knows which tree contains. which global entry number without having to open all intermediate. files to check how many entries they contain, resulting in much. less contention in TTreeProcessorMT when multiple threads are loading. the right file to process. An artificial example running on 342 files of about 2MB each, with 8 cores, release build of ROOT, has the following timings:. * current master, 8 cores: ~10s. * with this fix, 8 cores: ~3.5s. * no imt (current master and with the fix): ~1s. To merge after #2115.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2116
https://github.com/root-project/root/pull/2116:334,energy efficiency,load,loading,334,"[TREEPROCMT] Pass per-tree number of entries to thread-local TChains; This ensures that each thread-local TChain knows which tree contains. which global entry number without having to open all intermediate. files to check how many entries they contain, resulting in much. less contention in TTreeProcessorMT when multiple threads are loading. the right file to process. An artificial example running on 342 files of about 2MB each, with 8 cores, release build of ROOT, has the following timings:. * current master, 8 cores: ~10s. * with this fix, 8 cores: ~3.5s. * no imt (current master and with the fix): ~1s. To merge after #2115.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2116
https://github.com/root-project/root/pull/2116:439,energy efficiency,core,cores,439,"[TREEPROCMT] Pass per-tree number of entries to thread-local TChains; This ensures that each thread-local TChain knows which tree contains. which global entry number without having to open all intermediate. files to check how many entries they contain, resulting in much. less contention in TTreeProcessorMT when multiple threads are loading. the right file to process. An artificial example running on 342 files of about 2MB each, with 8 cores, release build of ROOT, has the following timings:. * current master, 8 cores: ~10s. * with this fix, 8 cores: ~3.5s. * no imt (current master and with the fix): ~1s. To merge after #2115.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2116
https://github.com/root-project/root/pull/2116:499,energy efficiency,current,current,499,"[TREEPROCMT] Pass per-tree number of entries to thread-local TChains; This ensures that each thread-local TChain knows which tree contains. which global entry number without having to open all intermediate. files to check how many entries they contain, resulting in much. less contention in TTreeProcessorMT when multiple threads are loading. the right file to process. An artificial example running on 342 files of about 2MB each, with 8 cores, release build of ROOT, has the following timings:. * current master, 8 cores: ~10s. * with this fix, 8 cores: ~3.5s. * no imt (current master and with the fix): ~1s. To merge after #2115.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2116
https://github.com/root-project/root/pull/2116:517,energy efficiency,core,cores,517,"[TREEPROCMT] Pass per-tree number of entries to thread-local TChains; This ensures that each thread-local TChain knows which tree contains. which global entry number without having to open all intermediate. files to check how many entries they contain, resulting in much. less contention in TTreeProcessorMT when multiple threads are loading. the right file to process. An artificial example running on 342 files of about 2MB each, with 8 cores, release build of ROOT, has the following timings:. * current master, 8 cores: ~10s. * with this fix, 8 cores: ~3.5s. * no imt (current master and with the fix): ~1s. To merge after #2115.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2116
https://github.com/root-project/root/pull/2116:549,energy efficiency,core,cores,549,"[TREEPROCMT] Pass per-tree number of entries to thread-local TChains; This ensures that each thread-local TChain knows which tree contains. which global entry number without having to open all intermediate. files to check how many entries they contain, resulting in much. less contention in TTreeProcessorMT when multiple threads are loading. the right file to process. An artificial example running on 342 files of about 2MB each, with 8 cores, release build of ROOT, has the following timings:. * current master, 8 cores: ~10s. * with this fix, 8 cores: ~3.5s. * no imt (current master and with the fix): ~1s. To merge after #2115.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2116
https://github.com/root-project/root/pull/2116:573,energy efficiency,current,current,573,"[TREEPROCMT] Pass per-tree number of entries to thread-local TChains; This ensures that each thread-local TChain knows which tree contains. which global entry number without having to open all intermediate. files to check how many entries they contain, resulting in much. less contention in TTreeProcessorMT when multiple threads are loading. the right file to process. An artificial example running on 342 files of about 2MB each, with 8 cores, release build of ROOT, has the following timings:. * current master, 8 cores: ~10s. * with this fix, 8 cores: ~3.5s. * no imt (current master and with the fix): ~1s. To merge after #2115.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2116
https://github.com/root-project/root/pull/2116:193,modifiability,interm,intermediate,193,"[TREEPROCMT] Pass per-tree number of entries to thread-local TChains; This ensures that each thread-local TChain knows which tree contains. which global entry number without having to open all intermediate. files to check how many entries they contain, resulting in much. less contention in TTreeProcessorMT when multiple threads are loading. the right file to process. An artificial example running on 342 files of about 2MB each, with 8 cores, release build of ROOT, has the following timings:. * current master, 8 cores: ~10s. * with this fix, 8 cores: ~3.5s. * no imt (current master and with the fix): ~1s. To merge after #2115.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2116
https://github.com/root-project/root/pull/2116:277,performance,content,contention,277,"[TREEPROCMT] Pass per-tree number of entries to thread-local TChains; This ensures that each thread-local TChain knows which tree contains. which global entry number without having to open all intermediate. files to check how many entries they contain, resulting in much. less contention in TTreeProcessorMT when multiple threads are loading. the right file to process. An artificial example running on 342 files of about 2MB each, with 8 cores, release build of ROOT, has the following timings:. * current master, 8 cores: ~10s. * with this fix, 8 cores: ~3.5s. * no imt (current master and with the fix): ~1s. To merge after #2115.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2116
https://github.com/root-project/root/pull/2116:334,performance,load,loading,334,"[TREEPROCMT] Pass per-tree number of entries to thread-local TChains; This ensures that each thread-local TChain knows which tree contains. which global entry number without having to open all intermediate. files to check how many entries they contain, resulting in much. less contention in TTreeProcessorMT when multiple threads are loading. the right file to process. An artificial example running on 342 files of about 2MB each, with 8 cores, release build of ROOT, has the following timings:. * current master, 8 cores: ~10s. * with this fix, 8 cores: ~3.5s. * no imt (current master and with the fix): ~1s. To merge after #2115.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2116
https://github.com/root-project/root/pull/2117:147,availability,redund,redundant,147,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:194,availability,redund,redundant,194,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:755,availability,sli,sliding,755,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:806,availability,operat,operation,806,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:933,availability,operat,operation,933,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:1028,availability,operat,operation,1028,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:1187,availability,operat,operation,1187,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:0,deployability,Api,Api,0,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:16,deployability,API,API,16,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:77,deployability,API,API,77,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:147,deployability,redundan,redundant,147,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:194,deployability,redundan,redundant,194,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:586,deployability,modul,module,586,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:707,deployability,log,logic,707,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:1236,deployability,log,logic,1236,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:1330,deployability,modul,module,1330,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:1486,deployability,API,API,1486,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:120,energy efficiency,current,currently,120,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:1526,energy efficiency,reduc,reduced,1526,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:0,integrability,Api,Api,0,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:16,integrability,API,API,16,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:77,integrability,API,API,77,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:625,integrability,sub,sub-class,625,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:745,integrability,filter,filter,745,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:1391,integrability,filter,filter,1391,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:1486,integrability,API,API,1486,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:0,interoperability,Api,Api,0,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:16,interoperability,API,API,16,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:77,interoperability,API,API,77,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:1221,interoperability,share,share,1221,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:1486,interoperability,API,API,1486,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:92,modifiability,layer,layers,92,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:389,modifiability,design decis,design decisions,389,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:586,modifiability,modul,module,586,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:657,modifiability,layer,layer,657,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:922,modifiability,layer,layer,922,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:982,modifiability,paramet,parameters,982,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:1018,modifiability,layer,layer,1018,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:1076,modifiability,paramet,parameters,1076,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:1164,modifiability,layer,layer,1164,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:1307,modifiability,layer,layer,1307,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:1330,modifiability,modul,module,1330,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:687,performance,network,network,687,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:147,reliability,redundan,redundant,147,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:194,reliability,redundan,redundant,194,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:755,reliability,sli,sliding,755,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:147,safety,redund,redundant,147,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:194,safety,redund,redundant,194,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:586,safety,modul,module,586,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:707,safety,log,logic,707,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:772,safety,input,input,772,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:823,safety,input,input,823,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:1236,safety,log,logic,1236,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:1330,safety,modul,module,1330,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:571,security,auth,authors,571,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:687,security,network,network,687,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:707,security,log,logic,707,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:1236,security,log,logic,1236,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:1361,security,stride,strides,1361,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:212,testability,context,context,212,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:707,testability,log,logic,707,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:1236,testability,log,logic,1236,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:455,usability,experien,experience,455,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:535,usability,experien,experienced,535,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:772,usability,input,input,772,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:823,usability,input,input,823,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2117:972,usability,learn,learnable,972,"Api redesign; # API Redesign. ## Goal. The goal is this PR is to improve the API of the CNN layers (MaxPooling and Conv currently), by eliminating redundant constructor arguments and fields. By redundant in this context, I refer to arguments that can be directly computed from others, and fields that unnecesseraly exist in multiple classes. ## Key points. Below some discussion points on design decisions I made, but still consider debatable. . Since my experience in production level C++ is very limited I highly value opinions from experienced colleagues and previous authors of the module. ### Making `MaxPoolingLayer` a sub-class of `ConvLayer`. Every layer type in a convolutional network follows the logic existing in our `ConvLayer`:. A filter is sliding over the input and at each step applies an operation to the input elements within its receptive field to produce a single output element. * In a convolutional layer this operation is a linear combination with learnable parameters. * In an average pooling layer the operation is a linear combination with constant parameters (and equal to the inverse of the receptive field's size). * In a max pooling layer its a non linear operation. As we can see they all share the same logic and therefore fields. ## Results. 1. Common fields between the 2 layer types in the CNN module are now not duplicated (strides sizes, padding sizes, filter sizes). The same for the 4 `protected` methods in `ConvLayer`. 2. We now have a cleaner API, as the constructor arguments where reduced from 26 to 16 without any change in the functionality).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2117
https://github.com/root-project/root/pull/2118:475,deployability,modul,module,475,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:550,deployability,version,versions,550,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:855,deployability,modul,module,855,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:925,deployability,modul,module,925,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:14,energy efficiency,GPU,GPU,14,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:87,energy efficiency,optim,optimal,87,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:545,energy efficiency,CPU,CPU,545,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:550,integrability,version,versions,550,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:214,interoperability,share,share,214,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:294,interoperability,share,share,294,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:781,interoperability,architectur,architecture,781,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:475,modifiability,modul,module,475,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:494,modifiability,extens,extensive,494,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:550,modifiability,version,versions,550,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:641,modifiability,refact,refactored,641,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:855,modifiability,modul,module,855,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:889,modifiability,refact,refactor,889,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:925,modifiability,modul,module,925,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:14,performance,GPU,GPU,14,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:111,performance,perform,performance,111,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:257,performance,synch,synchronization,257,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:545,performance,CPU,CPU,545,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:641,performance,refactor,refactored,641,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:866,performance,time,time,866,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:889,performance,refactor,refactor,889,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:339,safety,safe,safe,339,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:347,safety,compl,complement,347,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:387,safety,compl,complete,387,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:396,safety,test,testing,396,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:452,safety,test,tests,452,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:475,safety,modul,module,475,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:714,safety,test,tests,714,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:855,safety,modul,module,855,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:902,safety,test,tests,902,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:925,safety,modul,module,925,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:347,security,compl,complement,347,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:387,security,compl,complete,387,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:396,testability,test,testing,396,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:413,testability,assert,assert,413,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:452,testability,test,tests,452,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:714,testability,test,tests,714,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:881,testability,plan,plan,881,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:902,testability,test,tests,902,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2118:111,usability,perform,performance,111,"Im2col on the GPU; # Goal. This PR implements `Im2Col` in CUDA in (what I consider) an optimal way in terms of performance. I achieve that by assigning one thread per output element. This means that threads do not share their write address and therefore no synchronization is required. They do share read address which is of course thread safe. I complement the new functionality with a complete testing suite to assert correctness. # Extra tasks. The tests within the `CNN` module suffer from extensive code duplication as the `Reference` and `CPU` versions do exactly the same thing (the CUDA one's would just worsen the issue). Instead I refactored the `Im2Col` one's using templated arguments: As a result the tests are now defined only once and called independently from each architecture using templates. This approach is also followed in the `DNN` module. If time allows, I plan to refactor all tests within the `CNN` module in a similar manner.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2118
https://github.com/root-project/root/pull/2119:31,deployability,updat,updates,31,Backports of tutorial filename updates;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2119
https://github.com/root-project/root/pull/2119:31,safety,updat,updates,31,Backports of tutorial filename updates;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2119
https://github.com/root-project/root/pull/2119:31,security,updat,updates,31,Backports of tutorial filename updates;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2119
https://github.com/root-project/root/pull/2121:80,security,ident,identical,80,[WIP][IO] Do not process StreamerInfo Record at file opening if we processed an identical one already;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2121
https://github.com/root-project/root/pull/2122:133,deployability,patch,patch,133,"[cmake] Split ROOT_SHOW_OPTIONS into a more generic ROOT_GET_OPTIONS.; Export in ROOTConfig.cmake the list of all options, too. This patch is a prerequisite to fix ROOT-9405.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2122
https://github.com/root-project/root/pull/2122:133,safety,patch,patch,133,"[cmake] Split ROOT_SHOW_OPTIONS into a more generic ROOT_GET_OPTIONS.; Export in ROOTConfig.cmake the list of all options, too. This patch is a prerequisite to fix ROOT-9405.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2122
https://github.com/root-project/root/pull/2122:133,security,patch,patch,133,"[cmake] Split ROOT_SHOW_OPTIONS into a more generic ROOT_GET_OPTIONS.; Export in ROOTConfig.cmake the list of all options, too. This patch is a prerequisite to fix ROOT-9405.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2122
https://github.com/root-project/root/pull/2123:264,availability,state,state,264,"Add missing cling transaction; This was discovered running. ```. root.exe -b -l -q roottest/root/meta/execUnloading.C. ```. but does **not** solve its instability (it sometimes properly inform the TClass of the unloading and sometimes doesn't):. ```. 35c35. < The state of MyClass is: 1. ---. > The state of MyClass is: 3. 37,38c37,40. < <<data>> unloaded. < <<method>> unloaded. ---. > <<data>> is unloaded, but still valid. > <<method>> is unloaded, but still valid. > The unloaded data member data should not be in the list of data members. > The unloaded function member method should not be in the list of data members. ```. So it seems in that in some case the unloading is not done.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2123
https://github.com/root-project/root/pull/2123:299,availability,state,state,299,"Add missing cling transaction; This was discovered running. ```. root.exe -b -l -q roottest/root/meta/execUnloading.C. ```. but does **not** solve its instability (it sometimes properly inform the TClass of the unloading and sometimes doesn't):. ```. 35c35. < The state of MyClass is: 1. ---. > The state of MyClass is: 3. 37,38c37,40. < <<data>> unloaded. < <<method>> unloaded. ---. > <<data>> is unloaded, but still valid. > <<method>> is unloaded, but still valid. > The unloaded data member data should not be in the list of data members. > The unloaded function member method should not be in the list of data members. ```. So it seems in that in some case the unloading is not done.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2123
https://github.com/root-project/root/pull/2123:211,deployability,unload,unloading,211,"Add missing cling transaction; This was discovered running. ```. root.exe -b -l -q roottest/root/meta/execUnloading.C. ```. but does **not** solve its instability (it sometimes properly inform the TClass of the unloading and sometimes doesn't):. ```. 35c35. < The state of MyClass is: 1. ---. > The state of MyClass is: 3. 37,38c37,40. < <<data>> unloaded. < <<method>> unloaded. ---. > <<data>> is unloaded, but still valid. > <<method>> is unloaded, but still valid. > The unloaded data member data should not be in the list of data members. > The unloaded function member method should not be in the list of data members. ```. So it seems in that in some case the unloading is not done.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2123
https://github.com/root-project/root/pull/2123:347,deployability,unload,unloaded,347,"Add missing cling transaction; This was discovered running. ```. root.exe -b -l -q roottest/root/meta/execUnloading.C. ```. but does **not** solve its instability (it sometimes properly inform the TClass of the unloading and sometimes doesn't):. ```. 35c35. < The state of MyClass is: 1. ---. > The state of MyClass is: 3. 37,38c37,40. < <<data>> unloaded. < <<method>> unloaded. ---. > <<data>> is unloaded, but still valid. > <<method>> is unloaded, but still valid. > The unloaded data member data should not be in the list of data members. > The unloaded function member method should not be in the list of data members. ```. So it seems in that in some case the unloading is not done.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2123
https://github.com/root-project/root/pull/2123:370,deployability,unload,unloaded,370,"Add missing cling transaction; This was discovered running. ```. root.exe -b -l -q roottest/root/meta/execUnloading.C. ```. but does **not** solve its instability (it sometimes properly inform the TClass of the unloading and sometimes doesn't):. ```. 35c35. < The state of MyClass is: 1. ---. > The state of MyClass is: 3. 37,38c37,40. < <<data>> unloaded. < <<method>> unloaded. ---. > <<data>> is unloaded, but still valid. > <<method>> is unloaded, but still valid. > The unloaded data member data should not be in the list of data members. > The unloaded function member method should not be in the list of data members. ```. So it seems in that in some case the unloading is not done.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2123
https://github.com/root-project/root/pull/2123:399,deployability,unload,unloaded,399,"Add missing cling transaction; This was discovered running. ```. root.exe -b -l -q roottest/root/meta/execUnloading.C. ```. but does **not** solve its instability (it sometimes properly inform the TClass of the unloading and sometimes doesn't):. ```. 35c35. < The state of MyClass is: 1. ---. > The state of MyClass is: 3. 37,38c37,40. < <<data>> unloaded. < <<method>> unloaded. ---. > <<data>> is unloaded, but still valid. > <<method>> is unloaded, but still valid. > The unloaded data member data should not be in the list of data members. > The unloaded function member method should not be in the list of data members. ```. So it seems in that in some case the unloading is not done.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2123
https://github.com/root-project/root/pull/2123:442,deployability,unload,unloaded,442,"Add missing cling transaction; This was discovered running. ```. root.exe -b -l -q roottest/root/meta/execUnloading.C. ```. but does **not** solve its instability (it sometimes properly inform the TClass of the unloading and sometimes doesn't):. ```. 35c35. < The state of MyClass is: 1. ---. > The state of MyClass is: 3. 37,38c37,40. < <<data>> unloaded. < <<method>> unloaded. ---. > <<data>> is unloaded, but still valid. > <<method>> is unloaded, but still valid. > The unloaded data member data should not be in the list of data members. > The unloaded function member method should not be in the list of data members. ```. So it seems in that in some case the unloading is not done.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2123
https://github.com/root-project/root/pull/2123:475,deployability,unload,unloaded,475,"Add missing cling transaction; This was discovered running. ```. root.exe -b -l -q roottest/root/meta/execUnloading.C. ```. but does **not** solve its instability (it sometimes properly inform the TClass of the unloading and sometimes doesn't):. ```. 35c35. < The state of MyClass is: 1. ---. > The state of MyClass is: 3. 37,38c37,40. < <<data>> unloaded. < <<method>> unloaded. ---. > <<data>> is unloaded, but still valid. > <<method>> is unloaded, but still valid. > The unloaded data member data should not be in the list of data members. > The unloaded function member method should not be in the list of data members. ```. So it seems in that in some case the unloading is not done.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2123
https://github.com/root-project/root/pull/2123:550,deployability,unload,unloaded,550,"Add missing cling transaction; This was discovered running. ```. root.exe -b -l -q roottest/root/meta/execUnloading.C. ```. but does **not** solve its instability (it sometimes properly inform the TClass of the unloading and sometimes doesn't):. ```. 35c35. < The state of MyClass is: 1. ---. > The state of MyClass is: 3. 37,38c37,40. < <<data>> unloaded. < <<method>> unloaded. ---. > <<data>> is unloaded, but still valid. > <<method>> is unloaded, but still valid. > The unloaded data member data should not be in the list of data members. > The unloaded function member method should not be in the list of data members. ```. So it seems in that in some case the unloading is not done.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2123
https://github.com/root-project/root/pull/2123:667,deployability,unload,unloading,667,"Add missing cling transaction; This was discovered running. ```. root.exe -b -l -q roottest/root/meta/execUnloading.C. ```. but does **not** solve its instability (it sometimes properly inform the TClass of the unloading and sometimes doesn't):. ```. 35c35. < The state of MyClass is: 1. ---. > The state of MyClass is: 3. 37,38c37,40. < <<data>> unloaded. < <<method>> unloaded. ---. > <<data>> is unloaded, but still valid. > <<method>> is unloaded, but still valid. > The unloaded data member data should not be in the list of data members. > The unloaded function member method should not be in the list of data members. ```. So it seems in that in some case the unloading is not done.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2123
https://github.com/root-project/root/pull/2123:40,integrability,discover,discovered,40,"Add missing cling transaction; This was discovered running. ```. root.exe -b -l -q roottest/root/meta/execUnloading.C. ```. but does **not** solve its instability (it sometimes properly inform the TClass of the unloading and sometimes doesn't):. ```. 35c35. < The state of MyClass is: 1. ---. > The state of MyClass is: 3. 37,38c37,40. < <<data>> unloaded. < <<method>> unloaded. ---. > <<data>> is unloaded, but still valid. > <<method>> is unloaded, but still valid. > The unloaded data member data should not be in the list of data members. > The unloaded function member method should not be in the list of data members. ```. So it seems in that in some case the unloading is not done.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2123
https://github.com/root-project/root/pull/2123:264,integrability,state,state,264,"Add missing cling transaction; This was discovered running. ```. root.exe -b -l -q roottest/root/meta/execUnloading.C. ```. but does **not** solve its instability (it sometimes properly inform the TClass of the unloading and sometimes doesn't):. ```. 35c35. < The state of MyClass is: 1. ---. > The state of MyClass is: 3. 37,38c37,40. < <<data>> unloaded. < <<method>> unloaded. ---. > <<data>> is unloaded, but still valid. > <<method>> is unloaded, but still valid. > The unloaded data member data should not be in the list of data members. > The unloaded function member method should not be in the list of data members. ```. So it seems in that in some case the unloading is not done.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2123
https://github.com/root-project/root/pull/2123:299,integrability,state,state,299,"Add missing cling transaction; This was discovered running. ```. root.exe -b -l -q roottest/root/meta/execUnloading.C. ```. but does **not** solve its instability (it sometimes properly inform the TClass of the unloading and sometimes doesn't):. ```. 35c35. < The state of MyClass is: 1. ---. > The state of MyClass is: 3. 37,38c37,40. < <<data>> unloaded. < <<method>> unloaded. ---. > <<data>> is unloaded, but still valid. > <<method>> is unloaded, but still valid. > The unloaded data member data should not be in the list of data members. > The unloaded function member method should not be in the list of data members. ```. So it seems in that in some case the unloading is not done.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2123
https://github.com/root-project/root/pull/2123:40,interoperability,discover,discovered,40,"Add missing cling transaction; This was discovered running. ```. root.exe -b -l -q roottest/root/meta/execUnloading.C. ```. but does **not** solve its instability (it sometimes properly inform the TClass of the unloading and sometimes doesn't):. ```. 35c35. < The state of MyClass is: 1. ---. > The state of MyClass is: 3. 37,38c37,40. < <<data>> unloaded. < <<method>> unloaded. ---. > <<data>> is unloaded, but still valid. > <<method>> is unloaded, but still valid. > The unloaded data member data should not be in the list of data members. > The unloaded function member method should not be in the list of data members. ```. So it seems in that in some case the unloading is not done.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2123
https://github.com/root-project/root/pull/2123:128,reliability,doe,does,128,"Add missing cling transaction; This was discovered running. ```. root.exe -b -l -q roottest/root/meta/execUnloading.C. ```. but does **not** solve its instability (it sometimes properly inform the TClass of the unloading and sometimes doesn't):. ```. 35c35. < The state of MyClass is: 1. ---. > The state of MyClass is: 3. 37,38c37,40. < <<data>> unloaded. < <<method>> unloaded. ---. > <<data>> is unloaded, but still valid. > <<method>> is unloaded, but still valid. > The unloaded data member data should not be in the list of data members. > The unloaded function member method should not be in the list of data members. ```. So it seems in that in some case the unloading is not done.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2123
https://github.com/root-project/root/pull/2123:235,reliability,doe,doesn,235,"Add missing cling transaction; This was discovered running. ```. root.exe -b -l -q roottest/root/meta/execUnloading.C. ```. but does **not** solve its instability (it sometimes properly inform the TClass of the unloading and sometimes doesn't):. ```. 35c35. < The state of MyClass is: 1. ---. > The state of MyClass is: 3. 37,38c37,40. < <<data>> unloaded. < <<method>> unloaded. ---. > <<data>> is unloaded, but still valid. > <<method>> is unloaded, but still valid. > The unloaded data member data should not be in the list of data members. > The unloaded function member method should not be in the list of data members. ```. So it seems in that in some case the unloading is not done.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2123
https://github.com/root-project/root/pull/2123:419,safety,valid,valid,419,"Add missing cling transaction; This was discovered running. ```. root.exe -b -l -q roottest/root/meta/execUnloading.C. ```. but does **not** solve its instability (it sometimes properly inform the TClass of the unloading and sometimes doesn't):. ```. 35c35. < The state of MyClass is: 1. ---. > The state of MyClass is: 3. 37,38c37,40. < <<data>> unloaded. < <<method>> unloaded. ---. > <<data>> is unloaded, but still valid. > <<method>> is unloaded, but still valid. > The unloaded data member data should not be in the list of data members. > The unloaded function member method should not be in the list of data members. ```. So it seems in that in some case the unloading is not done.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2123
https://github.com/root-project/root/pull/2123:462,safety,valid,valid,462,"Add missing cling transaction; This was discovered running. ```. root.exe -b -l -q roottest/root/meta/execUnloading.C. ```. but does **not** solve its instability (it sometimes properly inform the TClass of the unloading and sometimes doesn't):. ```. 35c35. < The state of MyClass is: 1. ---. > The state of MyClass is: 3. 37,38c37,40. < <<data>> unloaded. < <<method>> unloaded. ---. > <<data>> is unloaded, but still valid. > <<method>> is unloaded, but still valid. > The unloaded data member data should not be in the list of data members. > The unloaded function member method should not be in the list of data members. ```. So it seems in that in some case the unloading is not done.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2123
https://github.com/root-project/root/pull/2123:40,usability,discov,discovered,40,"Add missing cling transaction; This was discovered running. ```. root.exe -b -l -q roottest/root/meta/execUnloading.C. ```. but does **not** solve its instability (it sometimes properly inform the TClass of the unloading and sometimes doesn't):. ```. 35c35. < The state of MyClass is: 1. ---. > The state of MyClass is: 3. 37,38c37,40. < <<data>> unloaded. < <<method>> unloaded. ---. > <<data>> is unloaded, but still valid. > <<method>> is unloaded, but still valid. > The unloaded data member data should not be in the list of data members. > The unloaded function member method should not be in the list of data members. ```. So it seems in that in some case the unloading is not done.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2123
https://github.com/root-project/root/pull/2126:41,usability,clear,clear,41,[DF] Use auto instead of auto* when it's clear type is a pointer;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2126
https://github.com/root-project/root/pull/2128:100,availability,slo,slow,100,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:277,deployability,Modul,Modules,277,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:295,deployability,patch,patch,295,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:602,deployability,patch,patch,602,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:376,energy efficiency,Cpu,Cpu,376,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:471,energy efficiency,cpu,cpu,471,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:683,energy efficiency,Cpu,Cpu,683,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:778,energy efficiency,cpu,cpu,778,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:277,modifiability,Modul,Modules,277,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:264,performance,perform,performance,264,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:356,performance,Time,Time,356,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:376,performance,Cpu,Cpu,376,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:380,performance,Time,Time,380,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:459,performance,memor,memory,459,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:471,performance,cpu,cpu,471,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:475,performance,time,time,475,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:504,performance,time,time,504,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:533,performance,memor,memory,533,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:562,performance,memor,memory,562,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:663,performance,Time,Time,663,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:683,performance,Cpu,Cpu,683,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:687,performance,Time,Time,687,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:766,performance,memor,memory,766,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:778,performance,cpu,cpu,778,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:782,performance,time,time,782,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:811,performance,time,time,811,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:840,performance,memor,memory,840,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:869,performance,memor,memory,869,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:100,reliability,slo,slow,100,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:137,safety,input,input,137,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:277,safety,Modul,Modules,277,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:295,safety,patch,patch,295,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:602,safety,patch,patch,602,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:295,security,patch,patch,295,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:602,security,patch,patch,602,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:137,usability,input,input,137,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:264,usability,perform,performance,264,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:459,usability,memor,memory,459,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:533,usability,memor,memory,533,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:562,usability,memor,memory,562,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:766,usability,memor,memory,766,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:840,usability,memor,memory,840,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2128:869,usability,memor,memory,869,"Use IsLibraryLoaded when you already know that file is a library; TCling::IsLoaded was impressively slow because it's allowing ""header"". input file. If you already know that your file is a library, it's better. to use IsLibraryLoaded as this makes a difference in performance. Modules, w/o this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.08 seconds Cpu Time = 0.07 seconds. (TFile *) 0x5563018a1d30. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 1.524314 seconds. sys time = 0.157075 seconds. res memory = 546.867 Mbytes. vir memory = 895.184 Mbytes. ```. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.06 seconds Cpu Time = 0.04 seconds. (TFile *) 0x555b420dca90. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.470026 seconds. sys time = 0.056668 seconds. res memory = 299.688 Mbytes. vir memory = 560.188 Mbytes. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2128
https://github.com/root-project/root/pull/2131:497,deployability,contain,contain,497,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:564,deployability,contain,contain,564,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:586,deployability,Modul,Modules,586,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:603,deployability,patch,patch,603,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:900,deployability,Modul,Modules,900,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:918,deployability,patch,patch,918,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:684,energy efficiency,Cpu,Cpu,684,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:779,energy efficiency,cpu,cpu,779,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:999,energy efficiency,Cpu,Cpu,999,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:1094,energy efficiency,cpu,cpu,1094,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:29,integrability,Filter,Filter,29,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:43,integrability,filter,filter,43,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:245,integrability,filter,filter,245,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:393,integrability,filter,filter,393,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:586,modifiability,Modul,Modules,586,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:900,modifiability,Modul,Modules,900,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:664,performance,Time,Time,664,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:684,performance,Cpu,Cpu,684,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:688,performance,Time,Time,688,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:767,performance,memor,memory,767,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:779,performance,cpu,cpu,779,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:783,performance,time,time,783,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:812,performance,time,time,812,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:841,performance,memor,memory,841,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:870,performance,memor,memory,870,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:979,performance,Time,Time,979,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:999,performance,Cpu,Cpu,999,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:1003,performance,Time,Time,1003,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:1082,performance,memor,memory,1082,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:1094,performance,cpu,cpu,1094,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:1098,performance,time,time,1098,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:1127,performance,time,time,1127,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:1156,performance,memor,memory,1156,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:1184,performance,memor,memory,1184,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:488,reliability,doe,doesn,488,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:586,safety,Modul,Modules,586,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:603,safety,patch,patch,603,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:900,safety,Modul,Modules,900,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:918,safety,patch,patch,918,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:140,security,hash,hash-elf-sections-,140,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:266,security,hash,hash,266,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:358,security,hash,hash,358,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:603,security,patch,patch,603,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:918,security,patch,patch,918,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:767,usability,memor,memory,767,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:841,usability,memor,memory,841,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:870,usability,memor,memory,870,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:1082,usability,memor,memory,1082,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:1156,usability,memor,memory,1156,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2131:1184,usability,memor,memory,1184,"[cxxmodules] Implement Bloom Filter; Bloom filter in header section of so files is well described by:. https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2. and. lld/ELF/SyntheticSections.cpp. The point is that the static linker puts bloom filter value to .gnu.hash section. in so files. We just have to read this value and compare to the. mangled_name hash that we're looking for. Bloom filter is a false posive. probability data structure, so it might say ""yes"" to library which. ""doesn't"" contain mangled_name, but it won't say ""no"" to library which. ""do"" contain mangled_name. Modules W/O this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.04 seconds Cpu Time = 0.03 seconds. (TFile *) 0x562b37a14fe0. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.362307 seconds. sys time = 0.039741 seconds. res memory = 278.215 Mbytes. vir memory = 448.973 Mbytes. ```. Modules With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.05 seconds Cpu Time = 0.05 seconds. (TFile *) 0x564410677780. Processing /home/yuka/CERN/ROOT/memory.C... cpu time = 0.356471 seconds. sys time = 0.079519 seconds. res memory = 266.73 Mbytes. vir memory = 423.59 Mbytes. ```. This difference become bigger when we need to lookup more libraries in. experiments.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2131
https://github.com/root-project/root/pull/2132:23,energy efficiency,Cpu,Cpu,23,TMVA/DNN/Architectures/Cpu:CpuMatrix.h: Disable debugging macro.; This fixes https://sft.its.cern.ch/jira/browse/ROOT-9444.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2132
https://github.com/root-project/root/pull/2132:27,energy efficiency,Cpu,CpuMatrix,27,TMVA/DNN/Architectures/Cpu:CpuMatrix.h: Disable debugging macro.; This fixes https://sft.its.cern.ch/jira/browse/ROOT-9444.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2132
https://github.com/root-project/root/pull/2132:9,interoperability,Architectur,Architectures,9,TMVA/DNN/Architectures/Cpu:CpuMatrix.h: Disable debugging macro.; This fixes https://sft.its.cern.ch/jira/browse/ROOT-9444.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2132
https://github.com/root-project/root/pull/2132:23,performance,Cpu,Cpu,23,TMVA/DNN/Architectures/Cpu:CpuMatrix.h: Disable debugging macro.; This fixes https://sft.its.cern.ch/jira/browse/ROOT-9444.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2132
https://github.com/root-project/root/pull/2132:27,performance,Cpu,CpuMatrix,27,TMVA/DNN/Architectures/Cpu:CpuMatrix.h: Disable debugging macro.; This fixes https://sft.its.cern.ch/jira/browse/ROOT-9444.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2132
https://github.com/root-project/root/pull/2133:23,energy efficiency,Cpu,Cpu,23,TMVA/DNN/Architectures/Cpu:CpuMatrix.h: Disable debugging macro.; This fixes https://sft.its.cern.ch/jira/browse/ROOT-9444.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2133
https://github.com/root-project/root/pull/2133:27,energy efficiency,Cpu,CpuMatrix,27,TMVA/DNN/Architectures/Cpu:CpuMatrix.h: Disable debugging macro.; This fixes https://sft.its.cern.ch/jira/browse/ROOT-9444.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2133
https://github.com/root-project/root/pull/2133:9,interoperability,Architectur,Architectures,9,TMVA/DNN/Architectures/Cpu:CpuMatrix.h: Disable debugging macro.; This fixes https://sft.its.cern.ch/jira/browse/ROOT-9444.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2133
https://github.com/root-project/root/pull/2133:23,performance,Cpu,Cpu,23,TMVA/DNN/Architectures/Cpu:CpuMatrix.h: Disable debugging macro.; This fixes https://sft.its.cern.ch/jira/browse/ROOT-9444.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2133
https://github.com/root-project/root/pull/2133:27,performance,Cpu,CpuMatrix,27,TMVA/DNN/Architectures/Cpu:CpuMatrix.h: Disable debugging macro.; This fixes https://sft.its.cern.ch/jira/browse/ROOT-9444.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2133
https://github.com/root-project/root/pull/2134:41,integrability,buffer,buffer,41,"Avoid virtual function call in Fill() if buffer map not needed; According to my benchmarks, speeds up filling into a ramdisk without compression by 5% - 10%.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2134
https://github.com/root-project/root/pull/2134:0,safety,Avoid,Avoid,0,"Avoid virtual function call in Fill() if buffer map not needed; According to my benchmarks, speeds up filling into a ramdisk without compression by 5% - 10%.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2134
https://github.com/root-project/root/pull/2135:17,deployability,fail,failing,17,[cxxmodules] Fix failing fedora build (ROOT-9445); Fedora was calling LazyFunctionCreatorAutoloadForModule from rootcling where fInterpreter was not initialized yet.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2135
https://github.com/root-project/root/pull/2135:32,deployability,build,build,32,[cxxmodules] Fix failing fedora build (ROOT-9445); Fedora was calling LazyFunctionCreatorAutoloadForModule from rootcling where fInterpreter was not initialized yet.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2135
https://github.com/root-project/root/pull/2135:17,reliability,fail,failing,17,[cxxmodules] Fix failing fedora build (ROOT-9445); Fedora was calling LazyFunctionCreatorAutoloadForModule from rootcling where fInterpreter was not initialized yet.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2135
https://github.com/root-project/root/pull/2136:41,deployability,build,building,41,"[TREEPROCMT] Pass number of entries when building friend chains ; This is a backport of #2116. Changes are mostly refactorings that prepare for the last commit, ""Pass number of entries when building friend chains"", which is the actual fix for ROOT-9437. An artificial example running on 342 files of about 2MB each, with 8 cores, BUILD_TYPE=Release, has the following timings:. * current master, 8 cores: ~10s. * with this fix, 8 cores: ~3.5s. * no imt (current master and with the fix): ~1s.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2136
https://github.com/root-project/root/pull/2136:190,deployability,build,building,190,"[TREEPROCMT] Pass number of entries when building friend chains ; This is a backport of #2116. Changes are mostly refactorings that prepare for the last commit, ""Pass number of entries when building friend chains"", which is the actual fix for ROOT-9437. An artificial example running on 342 files of about 2MB each, with 8 cores, BUILD_TYPE=Release, has the following timings:. * current master, 8 cores: ~10s. * with this fix, 8 cores: ~3.5s. * no imt (current master and with the fix): ~1s.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2136
https://github.com/root-project/root/pull/2136:341,deployability,Releas,Release,341,"[TREEPROCMT] Pass number of entries when building friend chains ; This is a backport of #2116. Changes are mostly refactorings that prepare for the last commit, ""Pass number of entries when building friend chains"", which is the actual fix for ROOT-9437. An artificial example running on 342 files of about 2MB each, with 8 cores, BUILD_TYPE=Release, has the following timings:. * current master, 8 cores: ~10s. * with this fix, 8 cores: ~3.5s. * no imt (current master and with the fix): ~1s.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2136
https://github.com/root-project/root/pull/2136:323,energy efficiency,core,cores,323,"[TREEPROCMT] Pass number of entries when building friend chains ; This is a backport of #2116. Changes are mostly refactorings that prepare for the last commit, ""Pass number of entries when building friend chains"", which is the actual fix for ROOT-9437. An artificial example running on 342 files of about 2MB each, with 8 cores, BUILD_TYPE=Release, has the following timings:. * current master, 8 cores: ~10s. * with this fix, 8 cores: ~3.5s. * no imt (current master and with the fix): ~1s.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2136
https://github.com/root-project/root/pull/2136:380,energy efficiency,current,current,380,"[TREEPROCMT] Pass number of entries when building friend chains ; This is a backport of #2116. Changes are mostly refactorings that prepare for the last commit, ""Pass number of entries when building friend chains"", which is the actual fix for ROOT-9437. An artificial example running on 342 files of about 2MB each, with 8 cores, BUILD_TYPE=Release, has the following timings:. * current master, 8 cores: ~10s. * with this fix, 8 cores: ~3.5s. * no imt (current master and with the fix): ~1s.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2136
https://github.com/root-project/root/pull/2136:398,energy efficiency,core,cores,398,"[TREEPROCMT] Pass number of entries when building friend chains ; This is a backport of #2116. Changes are mostly refactorings that prepare for the last commit, ""Pass number of entries when building friend chains"", which is the actual fix for ROOT-9437. An artificial example running on 342 files of about 2MB each, with 8 cores, BUILD_TYPE=Release, has the following timings:. * current master, 8 cores: ~10s. * with this fix, 8 cores: ~3.5s. * no imt (current master and with the fix): ~1s.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2136
https://github.com/root-project/root/pull/2136:430,energy efficiency,core,cores,430,"[TREEPROCMT] Pass number of entries when building friend chains ; This is a backport of #2116. Changes are mostly refactorings that prepare for the last commit, ""Pass number of entries when building friend chains"", which is the actual fix for ROOT-9437. An artificial example running on 342 files of about 2MB each, with 8 cores, BUILD_TYPE=Release, has the following timings:. * current master, 8 cores: ~10s. * with this fix, 8 cores: ~3.5s. * no imt (current master and with the fix): ~1s.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2136
https://github.com/root-project/root/pull/2136:454,energy efficiency,current,current,454,"[TREEPROCMT] Pass number of entries when building friend chains ; This is a backport of #2116. Changes are mostly refactorings that prepare for the last commit, ""Pass number of entries when building friend chains"", which is the actual fix for ROOT-9437. An artificial example running on 342 files of about 2MB each, with 8 cores, BUILD_TYPE=Release, has the following timings:. * current master, 8 cores: ~10s. * with this fix, 8 cores: ~3.5s. * no imt (current master and with the fix): ~1s.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2136
https://github.com/root-project/root/pull/2136:114,modifiability,refact,refactorings,114,"[TREEPROCMT] Pass number of entries when building friend chains ; This is a backport of #2116. Changes are mostly refactorings that prepare for the last commit, ""Pass number of entries when building friend chains"", which is the actual fix for ROOT-9437. An artificial example running on 342 files of about 2MB each, with 8 cores, BUILD_TYPE=Release, has the following timings:. * current master, 8 cores: ~10s. * with this fix, 8 cores: ~3.5s. * no imt (current master and with the fix): ~1s.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2136
https://github.com/root-project/root/pull/2136:114,performance,refactor,refactorings,114,"[TREEPROCMT] Pass number of entries when building friend chains ; This is a backport of #2116. Changes are mostly refactorings that prepare for the last commit, ""Pass number of entries when building friend chains"", which is the actual fix for ROOT-9437. An artificial example running on 342 files of about 2MB each, with 8 cores, BUILD_TYPE=Release, has the following timings:. * current master, 8 cores: ~10s. * with this fix, 8 cores: ~3.5s. * no imt (current master and with the fix): ~1s.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2136
https://github.com/root-project/root/pull/2137:382,availability,sLi,sLibraries,382,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:301,deployability,modul,modules,301,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:444,deployability,patch,patch,444,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:525,energy efficiency,Cpu,Cpu,525,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:594,energy efficiency,cpu,cpu,594,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:794,energy efficiency,Cpu,Cpu,794,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:863,energy efficiency,cpu,cpu,863,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:993,energy efficiency,cpu,cpu,993,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:301,modifiability,modul,modules,301,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:52,performance,memor,memory,52,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:321,performance,memor,memory,321,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:505,performance,Time,Time,505,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:525,performance,Cpu,Cpu,525,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:529,performance,Time,Time,529,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:582,performance,memor,memory,582,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:594,performance,cpu,cpu,594,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:598,performance,time,time,598,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:627,performance,time,time,627,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:656,performance,memor,memory,656,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:685,performance,memor,memory,685,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:774,performance,Time,Time,774,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:794,performance,Cpu,Cpu,794,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:798,performance,Time,Time,798,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:851,performance,memor,memory,851,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:863,performance,cpu,cpu,863,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:867,performance,time,time,867,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:896,performance,time,time,896,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:925,performance,memor,memory,925,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:954,performance,memor,memory,954,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:993,performance,cpu,cpu,993,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:997,performance,time,time,997,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:249,reliability,doe,doesn,249,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:382,reliability,sLi,sLibraries,382,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:301,safety,modul,modules,301,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:356,safety,avoid,avoid,356,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:444,safety,patch,patch,444,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:444,security,patch,patch,444,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:52,usability,memor,memory,52,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:321,usability,memor,memory,321,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:582,usability,memor,memory,582,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:656,usability,memor,memory,656,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:685,usability,memor,memory,685,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:851,usability,memor,memory,851,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:925,usability,memor,memory,925,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2137:954,usability,memor,memory,954,"[cxxmodules] Respect LD_LIBRARY_PATH order and save memory; std::set was not good because it sorted libraries by alphabetical order. and didn't preserve LD_LIBRARY_PATH order information. We can use. std::vector instead. (Erasing rarely happens and doesn't cost so much). Path prefix like ""/home/yuka/modules/lib/"" costs memory, I. think it makes sense to avoid path duplication in sLibraries and make sPaths. vector for this prefix. With this patch. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.14 seconds Cpu Time = 0.14 seconds. (TFile *) 0x31eb0d0. Processing memory.C... cpu time = 0.861813 seconds. sys time = 0.155326 seconds. res memory = 178.988 Mbytes. vir memory = 435.332 Mbytes. ```. w/o. ```. Processing tutorials/hsimple.C... hsimple : Real Time = 0.21 seconds Cpu Time = 0.20 seconds. (TFile *) 0x30db6e0. Processing memory.C... cpu time = 1.266833 seconds. sys time = 0.227562 seconds. res memory = 178.965 Mbytes. vir memory = 435.301 Mbytes. ```. Actually cpu time improved",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2137
https://github.com/root-project/root/pull/2138:9,availability,toler,tolerance,9,"Increase tolerance in stressHistogram buffer tests; The buffer tests for histograms have slightly different rounding errors between buffered/not buffered histograms which exceed a few epsilons, so the test fails if the tolerances are too strict. *Note:* This test doesn't fail on Jenkins, but *does* fail on my machine without this patch.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2138
https://github.com/root-project/root/pull/2138:89,availability,sli,slightly,89,"Increase tolerance in stressHistogram buffer tests; The buffer tests for histograms have slightly different rounding errors between buffered/not buffered histograms which exceed a few epsilons, so the test fails if the tolerances are too strict. *Note:* This test doesn't fail on Jenkins, but *does* fail on my machine without this patch.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2138
https://github.com/root-project/root/pull/2138:117,availability,error,errors,117,"Increase tolerance in stressHistogram buffer tests; The buffer tests for histograms have slightly different rounding errors between buffered/not buffered histograms which exceed a few epsilons, so the test fails if the tolerances are too strict. *Note:* This test doesn't fail on Jenkins, but *does* fail on my machine without this patch.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2138
https://github.com/root-project/root/pull/2138:219,availability,toler,tolerances,219,"Increase tolerance in stressHistogram buffer tests; The buffer tests for histograms have slightly different rounding errors between buffered/not buffered histograms which exceed a few epsilons, so the test fails if the tolerances are too strict. *Note:* This test doesn't fail on Jenkins, but *does* fail on my machine without this patch.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2138
https://github.com/root-project/root/pull/2138:206,deployability,fail,fails,206,"Increase tolerance in stressHistogram buffer tests; The buffer tests for histograms have slightly different rounding errors between buffered/not buffered histograms which exceed a few epsilons, so the test fails if the tolerances are too strict. *Note:* This test doesn't fail on Jenkins, but *does* fail on my machine without this patch.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2138
https://github.com/root-project/root/pull/2138:272,deployability,fail,fail,272,"Increase tolerance in stressHistogram buffer tests; The buffer tests for histograms have slightly different rounding errors between buffered/not buffered histograms which exceed a few epsilons, so the test fails if the tolerances are too strict. *Note:* This test doesn't fail on Jenkins, but *does* fail on my machine without this patch.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2138
https://github.com/root-project/root/pull/2138:300,deployability,fail,fail,300,"Increase tolerance in stressHistogram buffer tests; The buffer tests for histograms have slightly different rounding errors between buffered/not buffered histograms which exceed a few epsilons, so the test fails if the tolerances are too strict. *Note:* This test doesn't fail on Jenkins, but *does* fail on my machine without this patch.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2138
https://github.com/root-project/root/pull/2138:332,deployability,patch,patch,332,"Increase tolerance in stressHistogram buffer tests; The buffer tests for histograms have slightly different rounding errors between buffered/not buffered histograms which exceed a few epsilons, so the test fails if the tolerances are too strict. *Note:* This test doesn't fail on Jenkins, but *does* fail on my machine without this patch.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2138
https://github.com/root-project/root/pull/2138:38,integrability,buffer,buffer,38,"Increase tolerance in stressHistogram buffer tests; The buffer tests for histograms have slightly different rounding errors between buffered/not buffered histograms which exceed a few epsilons, so the test fails if the tolerances are too strict. *Note:* This test doesn't fail on Jenkins, but *does* fail on my machine without this patch.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2138
https://github.com/root-project/root/pull/2138:56,integrability,buffer,buffer,56,"Increase tolerance in stressHistogram buffer tests; The buffer tests for histograms have slightly different rounding errors between buffered/not buffered histograms which exceed a few epsilons, so the test fails if the tolerances are too strict. *Note:* This test doesn't fail on Jenkins, but *does* fail on my machine without this patch.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2138
https://github.com/root-project/root/pull/2138:132,integrability,buffer,buffered,132,"Increase tolerance in stressHistogram buffer tests; The buffer tests for histograms have slightly different rounding errors between buffered/not buffered histograms which exceed a few epsilons, so the test fails if the tolerances are too strict. *Note:* This test doesn't fail on Jenkins, but *does* fail on my machine without this patch.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2138
https://github.com/root-project/root/pull/2138:145,integrability,buffer,buffered,145,"Increase tolerance in stressHistogram buffer tests; The buffer tests for histograms have slightly different rounding errors between buffered/not buffered histograms which exceed a few epsilons, so the test fails if the tolerances are too strict. *Note:* This test doesn't fail on Jenkins, but *does* fail on my machine without this patch.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2138
https://github.com/root-project/root/pull/2138:117,performance,error,errors,117,"Increase tolerance in stressHistogram buffer tests; The buffer tests for histograms have slightly different rounding errors between buffered/not buffered histograms which exceed a few epsilons, so the test fails if the tolerances are too strict. *Note:* This test doesn't fail on Jenkins, but *does* fail on my machine without this patch.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2138
https://github.com/root-project/root/pull/2138:9,reliability,toleran,tolerance,9,"Increase tolerance in stressHistogram buffer tests; The buffer tests for histograms have slightly different rounding errors between buffered/not buffered histograms which exceed a few epsilons, so the test fails if the tolerances are too strict. *Note:* This test doesn't fail on Jenkins, but *does* fail on my machine without this patch.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2138
https://github.com/root-project/root/pull/2138:89,reliability,sli,slightly,89,"Increase tolerance in stressHistogram buffer tests; The buffer tests for histograms have slightly different rounding errors between buffered/not buffered histograms which exceed a few epsilons, so the test fails if the tolerances are too strict. *Note:* This test doesn't fail on Jenkins, but *does* fail on my machine without this patch.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2138
https://github.com/root-project/root/pull/2138:206,reliability,fail,fails,206,"Increase tolerance in stressHistogram buffer tests; The buffer tests for histograms have slightly different rounding errors between buffered/not buffered histograms which exceed a few epsilons, so the test fails if the tolerances are too strict. *Note:* This test doesn't fail on Jenkins, but *does* fail on my machine without this patch.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2138
https://github.com/root-project/root/pull/2138:219,reliability,toleran,tolerances,219,"Increase tolerance in stressHistogram buffer tests; The buffer tests for histograms have slightly different rounding errors between buffered/not buffered histograms which exceed a few epsilons, so the test fails if the tolerances are too strict. *Note:* This test doesn't fail on Jenkins, but *does* fail on my machine without this patch.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2138
https://github.com/root-project/root/pull/2138:264,reliability,doe,doesn,264,"Increase tolerance in stressHistogram buffer tests; The buffer tests for histograms have slightly different rounding errors between buffered/not buffered histograms which exceed a few epsilons, so the test fails if the tolerances are too strict. *Note:* This test doesn't fail on Jenkins, but *does* fail on my machine without this patch.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2138
https://github.com/root-project/root/pull/2138:272,reliability,fail,fail,272,"Increase tolerance in stressHistogram buffer tests; The buffer tests for histograms have slightly different rounding errors between buffered/not buffered histograms which exceed a few epsilons, so the test fails if the tolerances are too strict. *Note:* This test doesn't fail on Jenkins, but *does* fail on my machine without this patch.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2138
https://github.com/root-project/root/pull/2138:294,reliability,doe,does,294,"Increase tolerance in stressHistogram buffer tests; The buffer tests for histograms have slightly different rounding errors between buffered/not buffered histograms which exceed a few epsilons, so the test fails if the tolerances are too strict. *Note:* This test doesn't fail on Jenkins, but *does* fail on my machine without this patch.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2138
https://github.com/root-project/root/pull/2138:300,reliability,fail,fail,300,"Increase tolerance in stressHistogram buffer tests; The buffer tests for histograms have slightly different rounding errors between buffered/not buffered histograms which exceed a few epsilons, so the test fails if the tolerances are too strict. *Note:* This test doesn't fail on Jenkins, but *does* fail on my machine without this patch.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2138
https://github.com/root-project/root/pull/2138:45,safety,test,tests,45,"Increase tolerance in stressHistogram buffer tests; The buffer tests for histograms have slightly different rounding errors between buffered/not buffered histograms which exceed a few epsilons, so the test fails if the tolerances are too strict. *Note:* This test doesn't fail on Jenkins, but *does* fail on my machine without this patch.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2138
https://github.com/root-project/root/pull/2138:63,safety,test,tests,63,"Increase tolerance in stressHistogram buffer tests; The buffer tests for histograms have slightly different rounding errors between buffered/not buffered histograms which exceed a few epsilons, so the test fails if the tolerances are too strict. *Note:* This test doesn't fail on Jenkins, but *does* fail on my machine without this patch.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2138
https://github.com/root-project/root/pull/2138:117,safety,error,errors,117,"Increase tolerance in stressHistogram buffer tests; The buffer tests for histograms have slightly different rounding errors between buffered/not buffered histograms which exceed a few epsilons, so the test fails if the tolerances are too strict. *Note:* This test doesn't fail on Jenkins, but *does* fail on my machine without this patch.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2138
https://github.com/root-project/root/pull/2138:201,safety,test,test,201,"Increase tolerance in stressHistogram buffer tests; The buffer tests for histograms have slightly different rounding errors between buffered/not buffered histograms which exceed a few epsilons, so the test fails if the tolerances are too strict. *Note:* This test doesn't fail on Jenkins, but *does* fail on my machine without this patch.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2138
https://github.com/root-project/root/pull/2138:259,safety,test,test,259,"Increase tolerance in stressHistogram buffer tests; The buffer tests for histograms have slightly different rounding errors between buffered/not buffered histograms which exceed a few epsilons, so the test fails if the tolerances are too strict. *Note:* This test doesn't fail on Jenkins, but *does* fail on my machine without this patch.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2138
https://github.com/root-project/root/pull/2138:332,safety,patch,patch,332,"Increase tolerance in stressHistogram buffer tests; The buffer tests for histograms have slightly different rounding errors between buffered/not buffered histograms which exceed a few epsilons, so the test fails if the tolerances are too strict. *Note:* This test doesn't fail on Jenkins, but *does* fail on my machine without this patch.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2138
https://github.com/root-project/root/pull/2138:332,security,patch,patch,332,"Increase tolerance in stressHistogram buffer tests; The buffer tests for histograms have slightly different rounding errors between buffered/not buffered histograms which exceed a few epsilons, so the test fails if the tolerances are too strict. *Note:* This test doesn't fail on Jenkins, but *does* fail on my machine without this patch.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2138
https://github.com/root-project/root/pull/2138:45,testability,test,tests,45,"Increase tolerance in stressHistogram buffer tests; The buffer tests for histograms have slightly different rounding errors between buffered/not buffered histograms which exceed a few epsilons, so the test fails if the tolerances are too strict. *Note:* This test doesn't fail on Jenkins, but *does* fail on my machine without this patch.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2138
https://github.com/root-project/root/pull/2138:63,testability,test,tests,63,"Increase tolerance in stressHistogram buffer tests; The buffer tests for histograms have slightly different rounding errors between buffered/not buffered histograms which exceed a few epsilons, so the test fails if the tolerances are too strict. *Note:* This test doesn't fail on Jenkins, but *does* fail on my machine without this patch.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2138
https://github.com/root-project/root/pull/2138:201,testability,test,test,201,"Increase tolerance in stressHistogram buffer tests; The buffer tests for histograms have slightly different rounding errors between buffered/not buffered histograms which exceed a few epsilons, so the test fails if the tolerances are too strict. *Note:* This test doesn't fail on Jenkins, but *does* fail on my machine without this patch.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2138
https://github.com/root-project/root/pull/2138:259,testability,test,test,259,"Increase tolerance in stressHistogram buffer tests; The buffer tests for histograms have slightly different rounding errors between buffered/not buffered histograms which exceed a few epsilons, so the test fails if the tolerances are too strict. *Note:* This test doesn't fail on Jenkins, but *does* fail on my machine without this patch.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2138
https://github.com/root-project/root/pull/2138:117,usability,error,errors,117,"Increase tolerance in stressHistogram buffer tests; The buffer tests for histograms have slightly different rounding errors between buffered/not buffered histograms which exceed a few epsilons, so the test fails if the tolerances are too strict. *Note:* This test doesn't fail on Jenkins, but *does* fail on my machine without this patch.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2138
https://github.com/root-project/root/pull/2143:81,availability,cluster,clusters,81,"[TREEPROCMT] Improve concurrency; TTreeProcessorMT now spawns tasks that process clusters from tasks that process files:. this should decrease the amount of file switches that each thread-local. TChain performs during an event loop, as each thread will tend to. process clusters that belong to the same file. In addition, when no friends and no TEntryList are present, we can avoid the preliminary full sweep of. input files, since we we can use local rather than global entry numbers. In this case TTreeProcessorMT spawns one task per input file which first retrieves cluster boundaries. for that file and then spawns one sub-task per cluster. I also added myself to the list of authors. @etejedor there are a couple of things I am not super happy with in this implementation:. - each thread-local `TTreeView` duplicates all info about the dataset (file names, friend names, friend file names...). - `TTreeProcessorMT` has to query all of this information from `TTreeView`. - ~~the per-file task should only call `Internal::MakeClusters` once (just noticed, that's an easy refactoring)~~ fixed and squashed. Moving the dataset info from `TTreeView` to `TTreeProcessorMT`, on the other hand, would mean adding even more parameters to `TTreeView::GetTreeReader`. What do you think?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2143
https://github.com/root-project/root/pull/2143:270,availability,cluster,clusters,270,"[TREEPROCMT] Improve concurrency; TTreeProcessorMT now spawns tasks that process clusters from tasks that process files:. this should decrease the amount of file switches that each thread-local. TChain performs during an event loop, as each thread will tend to. process clusters that belong to the same file. In addition, when no friends and no TEntryList are present, we can avoid the preliminary full sweep of. input files, since we we can use local rather than global entry numbers. In this case TTreeProcessorMT spawns one task per input file which first retrieves cluster boundaries. for that file and then spawns one sub-task per cluster. I also added myself to the list of authors. @etejedor there are a couple of things I am not super happy with in this implementation:. - each thread-local `TTreeView` duplicates all info about the dataset (file names, friend names, friend file names...). - `TTreeProcessorMT` has to query all of this information from `TTreeView`. - ~~the per-file task should only call `Internal::MakeClusters` once (just noticed, that's an easy refactoring)~~ fixed and squashed. Moving the dataset info from `TTreeView` to `TTreeProcessorMT`, on the other hand, would mean adding even more parameters to `TTreeView::GetTreeReader`. What do you think?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2143
https://github.com/root-project/root/pull/2143:569,availability,cluster,cluster,569,"[TREEPROCMT] Improve concurrency; TTreeProcessorMT now spawns tasks that process clusters from tasks that process files:. this should decrease the amount of file switches that each thread-local. TChain performs during an event loop, as each thread will tend to. process clusters that belong to the same file. In addition, when no friends and no TEntryList are present, we can avoid the preliminary full sweep of. input files, since we we can use local rather than global entry numbers. In this case TTreeProcessorMT spawns one task per input file which first retrieves cluster boundaries. for that file and then spawns one sub-task per cluster. I also added myself to the list of authors. @etejedor there are a couple of things I am not super happy with in this implementation:. - each thread-local `TTreeView` duplicates all info about the dataset (file names, friend names, friend file names...). - `TTreeProcessorMT` has to query all of this information from `TTreeView`. - ~~the per-file task should only call `Internal::MakeClusters` once (just noticed, that's an easy refactoring)~~ fixed and squashed. Moving the dataset info from `TTreeView` to `TTreeProcessorMT`, on the other hand, would mean adding even more parameters to `TTreeView::GetTreeReader`. What do you think?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2143
https://github.com/root-project/root/pull/2143:636,availability,cluster,cluster,636,"[TREEPROCMT] Improve concurrency; TTreeProcessorMT now spawns tasks that process clusters from tasks that process files:. this should decrease the amount of file switches that each thread-local. TChain performs during an event loop, as each thread will tend to. process clusters that belong to the same file. In addition, when no friends and no TEntryList are present, we can avoid the preliminary full sweep of. input files, since we we can use local rather than global entry numbers. In this case TTreeProcessorMT spawns one task per input file which first retrieves cluster boundaries. for that file and then spawns one sub-task per cluster. I also added myself to the list of authors. @etejedor there are a couple of things I am not super happy with in this implementation:. - each thread-local `TTreeView` duplicates all info about the dataset (file names, friend names, friend file names...). - `TTreeProcessorMT` has to query all of this information from `TTreeView`. - ~~the per-file task should only call `Internal::MakeClusters` once (just noticed, that's an easy refactoring)~~ fixed and squashed. Moving the dataset info from `TTreeView` to `TTreeProcessorMT`, on the other hand, would mean adding even more parameters to `TTreeView::GetTreeReader`. What do you think?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2143
https://github.com/root-project/root/pull/2143:81,deployability,cluster,clusters,81,"[TREEPROCMT] Improve concurrency; TTreeProcessorMT now spawns tasks that process clusters from tasks that process files:. this should decrease the amount of file switches that each thread-local. TChain performs during an event loop, as each thread will tend to. process clusters that belong to the same file. In addition, when no friends and no TEntryList are present, we can avoid the preliminary full sweep of. input files, since we we can use local rather than global entry numbers. In this case TTreeProcessorMT spawns one task per input file which first retrieves cluster boundaries. for that file and then spawns one sub-task per cluster. I also added myself to the list of authors. @etejedor there are a couple of things I am not super happy with in this implementation:. - each thread-local `TTreeView` duplicates all info about the dataset (file names, friend names, friend file names...). - `TTreeProcessorMT` has to query all of this information from `TTreeView`. - ~~the per-file task should only call `Internal::MakeClusters` once (just noticed, that's an easy refactoring)~~ fixed and squashed. Moving the dataset info from `TTreeView` to `TTreeProcessorMT`, on the other hand, would mean adding even more parameters to `TTreeView::GetTreeReader`. What do you think?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2143
https://github.com/root-project/root/pull/2143:270,deployability,cluster,clusters,270,"[TREEPROCMT] Improve concurrency; TTreeProcessorMT now spawns tasks that process clusters from tasks that process files:. this should decrease the amount of file switches that each thread-local. TChain performs during an event loop, as each thread will tend to. process clusters that belong to the same file. In addition, when no friends and no TEntryList are present, we can avoid the preliminary full sweep of. input files, since we we can use local rather than global entry numbers. In this case TTreeProcessorMT spawns one task per input file which first retrieves cluster boundaries. for that file and then spawns one sub-task per cluster. I also added myself to the list of authors. @etejedor there are a couple of things I am not super happy with in this implementation:. - each thread-local `TTreeView` duplicates all info about the dataset (file names, friend names, friend file names...). - `TTreeProcessorMT` has to query all of this information from `TTreeView`. - ~~the per-file task should only call `Internal::MakeClusters` once (just noticed, that's an easy refactoring)~~ fixed and squashed. Moving the dataset info from `TTreeView` to `TTreeProcessorMT`, on the other hand, would mean adding even more parameters to `TTreeView::GetTreeReader`. What do you think?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2143
https://github.com/root-project/root/pull/2143:569,deployability,cluster,cluster,569,"[TREEPROCMT] Improve concurrency; TTreeProcessorMT now spawns tasks that process clusters from tasks that process files:. this should decrease the amount of file switches that each thread-local. TChain performs during an event loop, as each thread will tend to. process clusters that belong to the same file. In addition, when no friends and no TEntryList are present, we can avoid the preliminary full sweep of. input files, since we we can use local rather than global entry numbers. In this case TTreeProcessorMT spawns one task per input file which first retrieves cluster boundaries. for that file and then spawns one sub-task per cluster. I also added myself to the list of authors. @etejedor there are a couple of things I am not super happy with in this implementation:. - each thread-local `TTreeView` duplicates all info about the dataset (file names, friend names, friend file names...). - `TTreeProcessorMT` has to query all of this information from `TTreeView`. - ~~the per-file task should only call `Internal::MakeClusters` once (just noticed, that's an easy refactoring)~~ fixed and squashed. Moving the dataset info from `TTreeView` to `TTreeProcessorMT`, on the other hand, would mean adding even more parameters to `TTreeView::GetTreeReader`. What do you think?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2143
https://github.com/root-project/root/pull/2143:636,deployability,cluster,cluster,636,"[TREEPROCMT] Improve concurrency; TTreeProcessorMT now spawns tasks that process clusters from tasks that process files:. this should decrease the amount of file switches that each thread-local. TChain performs during an event loop, as each thread will tend to. process clusters that belong to the same file. In addition, when no friends and no TEntryList are present, we can avoid the preliminary full sweep of. input files, since we we can use local rather than global entry numbers. In this case TTreeProcessorMT spawns one task per input file which first retrieves cluster boundaries. for that file and then spawns one sub-task per cluster. I also added myself to the list of authors. @etejedor there are a couple of things I am not super happy with in this implementation:. - each thread-local `TTreeView` duplicates all info about the dataset (file names, friend names, friend file names...). - `TTreeProcessorMT` has to query all of this information from `TTreeView`. - ~~the per-file task should only call `Internal::MakeClusters` once (just noticed, that's an easy refactoring)~~ fixed and squashed. Moving the dataset info from `TTreeView` to `TTreeProcessorMT`, on the other hand, would mean adding even more parameters to `TTreeView::GetTreeReader`. What do you think?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2143
https://github.com/root-project/root/pull/2143:221,integrability,event,event,221,"[TREEPROCMT] Improve concurrency; TTreeProcessorMT now spawns tasks that process clusters from tasks that process files:. this should decrease the amount of file switches that each thread-local. TChain performs during an event loop, as each thread will tend to. process clusters that belong to the same file. In addition, when no friends and no TEntryList are present, we can avoid the preliminary full sweep of. input files, since we we can use local rather than global entry numbers. In this case TTreeProcessorMT spawns one task per input file which first retrieves cluster boundaries. for that file and then spawns one sub-task per cluster. I also added myself to the list of authors. @etejedor there are a couple of things I am not super happy with in this implementation:. - each thread-local `TTreeView` duplicates all info about the dataset (file names, friend names, friend file names...). - `TTreeProcessorMT` has to query all of this information from `TTreeView`. - ~~the per-file task should only call `Internal::MakeClusters` once (just noticed, that's an easy refactoring)~~ fixed and squashed. Moving the dataset info from `TTreeView` to `TTreeProcessorMT`, on the other hand, would mean adding even more parameters to `TTreeView::GetTreeReader`. What do you think?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2143
https://github.com/root-project/root/pull/2143:623,integrability,sub,sub-task,623,"[TREEPROCMT] Improve concurrency; TTreeProcessorMT now spawns tasks that process clusters from tasks that process files:. this should decrease the amount of file switches that each thread-local. TChain performs during an event loop, as each thread will tend to. process clusters that belong to the same file. In addition, when no friends and no TEntryList are present, we can avoid the preliminary full sweep of. input files, since we we can use local rather than global entry numbers. In this case TTreeProcessorMT spawns one task per input file which first retrieves cluster boundaries. for that file and then spawns one sub-task per cluster. I also added myself to the list of authors. @etejedor there are a couple of things I am not super happy with in this implementation:. - each thread-local `TTreeView` duplicates all info about the dataset (file names, friend names, friend file names...). - `TTreeProcessorMT` has to query all of this information from `TTreeView`. - ~~the per-file task should only call `Internal::MakeClusters` once (just noticed, that's an easy refactoring)~~ fixed and squashed. Moving the dataset info from `TTreeView` to `TTreeProcessorMT`, on the other hand, would mean adding even more parameters to `TTreeView::GetTreeReader`. What do you think?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2143
https://github.com/root-project/root/pull/2143:711,integrability,coupl,couple,711,"[TREEPROCMT] Improve concurrency; TTreeProcessorMT now spawns tasks that process clusters from tasks that process files:. this should decrease the amount of file switches that each thread-local. TChain performs during an event loop, as each thread will tend to. process clusters that belong to the same file. In addition, when no friends and no TEntryList are present, we can avoid the preliminary full sweep of. input files, since we we can use local rather than global entry numbers. In this case TTreeProcessorMT spawns one task per input file which first retrieves cluster boundaries. for that file and then spawns one sub-task per cluster. I also added myself to the list of authors. @etejedor there are a couple of things I am not super happy with in this implementation:. - each thread-local `TTreeView` duplicates all info about the dataset (file names, friend names, friend file names...). - `TTreeProcessorMT` has to query all of this information from `TTreeView`. - ~~the per-file task should only call `Internal::MakeClusters` once (just noticed, that's an easy refactoring)~~ fixed and squashed. Moving the dataset info from `TTreeView` to `TTreeProcessorMT`, on the other hand, would mean adding even more parameters to `TTreeView::GetTreeReader`. What do you think?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2143
https://github.com/root-project/root/pull/2143:711,modifiability,coupl,couple,711,"[TREEPROCMT] Improve concurrency; TTreeProcessorMT now spawns tasks that process clusters from tasks that process files:. this should decrease the amount of file switches that each thread-local. TChain performs during an event loop, as each thread will tend to. process clusters that belong to the same file. In addition, when no friends and no TEntryList are present, we can avoid the preliminary full sweep of. input files, since we we can use local rather than global entry numbers. In this case TTreeProcessorMT spawns one task per input file which first retrieves cluster boundaries. for that file and then spawns one sub-task per cluster. I also added myself to the list of authors. @etejedor there are a couple of things I am not super happy with in this implementation:. - each thread-local `TTreeView` duplicates all info about the dataset (file names, friend names, friend file names...). - `TTreeProcessorMT` has to query all of this information from `TTreeView`. - ~~the per-file task should only call `Internal::MakeClusters` once (just noticed, that's an easy refactoring)~~ fixed and squashed. Moving the dataset info from `TTreeView` to `TTreeProcessorMT`, on the other hand, would mean adding even more parameters to `TTreeView::GetTreeReader`. What do you think?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2143
https://github.com/root-project/root/pull/2143:1074,modifiability,refact,refactoring,1074,"[TREEPROCMT] Improve concurrency; TTreeProcessorMT now spawns tasks that process clusters from tasks that process files:. this should decrease the amount of file switches that each thread-local. TChain performs during an event loop, as each thread will tend to. process clusters that belong to the same file. In addition, when no friends and no TEntryList are present, we can avoid the preliminary full sweep of. input files, since we we can use local rather than global entry numbers. In this case TTreeProcessorMT spawns one task per input file which first retrieves cluster boundaries. for that file and then spawns one sub-task per cluster. I also added myself to the list of authors. @etejedor there are a couple of things I am not super happy with in this implementation:. - each thread-local `TTreeView` duplicates all info about the dataset (file names, friend names, friend file names...). - `TTreeProcessorMT` has to query all of this information from `TTreeView`. - ~~the per-file task should only call `Internal::MakeClusters` once (just noticed, that's an easy refactoring)~~ fixed and squashed. Moving the dataset info from `TTreeView` to `TTreeProcessorMT`, on the other hand, would mean adding even more parameters to `TTreeView::GetTreeReader`. What do you think?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2143
https://github.com/root-project/root/pull/2143:1220,modifiability,paramet,parameters,1220,"[TREEPROCMT] Improve concurrency; TTreeProcessorMT now spawns tasks that process clusters from tasks that process files:. this should decrease the amount of file switches that each thread-local. TChain performs during an event loop, as each thread will tend to. process clusters that belong to the same file. In addition, when no friends and no TEntryList are present, we can avoid the preliminary full sweep of. input files, since we we can use local rather than global entry numbers. In this case TTreeProcessorMT spawns one task per input file which first retrieves cluster boundaries. for that file and then spawns one sub-task per cluster. I also added myself to the list of authors. @etejedor there are a couple of things I am not super happy with in this implementation:. - each thread-local `TTreeView` duplicates all info about the dataset (file names, friend names, friend file names...). - `TTreeProcessorMT` has to query all of this information from `TTreeView`. - ~~the per-file task should only call `Internal::MakeClusters` once (just noticed, that's an easy refactoring)~~ fixed and squashed. Moving the dataset info from `TTreeView` to `TTreeProcessorMT`, on the other hand, would mean adding even more parameters to `TTreeView::GetTreeReader`. What do you think?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2143
https://github.com/root-project/root/pull/2143:21,performance,concurren,concurrency,21,"[TREEPROCMT] Improve concurrency; TTreeProcessorMT now spawns tasks that process clusters from tasks that process files:. this should decrease the amount of file switches that each thread-local. TChain performs during an event loop, as each thread will tend to. process clusters that belong to the same file. In addition, when no friends and no TEntryList are present, we can avoid the preliminary full sweep of. input files, since we we can use local rather than global entry numbers. In this case TTreeProcessorMT spawns one task per input file which first retrieves cluster boundaries. for that file and then spawns one sub-task per cluster. I also added myself to the list of authors. @etejedor there are a couple of things I am not super happy with in this implementation:. - each thread-local `TTreeView` duplicates all info about the dataset (file names, friend names, friend file names...). - `TTreeProcessorMT` has to query all of this information from `TTreeView`. - ~~the per-file task should only call `Internal::MakeClusters` once (just noticed, that's an easy refactoring)~~ fixed and squashed. Moving the dataset info from `TTreeView` to `TTreeProcessorMT`, on the other hand, would mean adding even more parameters to `TTreeView::GetTreeReader`. What do you think?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2143
https://github.com/root-project/root/pull/2143:202,performance,perform,performs,202,"[TREEPROCMT] Improve concurrency; TTreeProcessorMT now spawns tasks that process clusters from tasks that process files:. this should decrease the amount of file switches that each thread-local. TChain performs during an event loop, as each thread will tend to. process clusters that belong to the same file. In addition, when no friends and no TEntryList are present, we can avoid the preliminary full sweep of. input files, since we we can use local rather than global entry numbers. In this case TTreeProcessorMT spawns one task per input file which first retrieves cluster boundaries. for that file and then spawns one sub-task per cluster. I also added myself to the list of authors. @etejedor there are a couple of things I am not super happy with in this implementation:. - each thread-local `TTreeView` duplicates all info about the dataset (file names, friend names, friend file names...). - `TTreeProcessorMT` has to query all of this information from `TTreeView`. - ~~the per-file task should only call `Internal::MakeClusters` once (just noticed, that's an easy refactoring)~~ fixed and squashed. Moving the dataset info from `TTreeView` to `TTreeProcessorMT`, on the other hand, would mean adding even more parameters to `TTreeView::GetTreeReader`. What do you think?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2143
https://github.com/root-project/root/pull/2143:1074,performance,refactor,refactoring,1074,"[TREEPROCMT] Improve concurrency; TTreeProcessorMT now spawns tasks that process clusters from tasks that process files:. this should decrease the amount of file switches that each thread-local. TChain performs during an event loop, as each thread will tend to. process clusters that belong to the same file. In addition, when no friends and no TEntryList are present, we can avoid the preliminary full sweep of. input files, since we we can use local rather than global entry numbers. In this case TTreeProcessorMT spawns one task per input file which first retrieves cluster boundaries. for that file and then spawns one sub-task per cluster. I also added myself to the list of authors. @etejedor there are a couple of things I am not super happy with in this implementation:. - each thread-local `TTreeView` duplicates all info about the dataset (file names, friend names, friend file names...). - `TTreeProcessorMT` has to query all of this information from `TTreeView`. - ~~the per-file task should only call `Internal::MakeClusters` once (just noticed, that's an easy refactoring)~~ fixed and squashed. Moving the dataset info from `TTreeView` to `TTreeProcessorMT`, on the other hand, would mean adding even more parameters to `TTreeView::GetTreeReader`. What do you think?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2143
https://github.com/root-project/root/pull/2143:376,safety,avoid,avoid,376,"[TREEPROCMT] Improve concurrency; TTreeProcessorMT now spawns tasks that process clusters from tasks that process files:. this should decrease the amount of file switches that each thread-local. TChain performs during an event loop, as each thread will tend to. process clusters that belong to the same file. In addition, when no friends and no TEntryList are present, we can avoid the preliminary full sweep of. input files, since we we can use local rather than global entry numbers. In this case TTreeProcessorMT spawns one task per input file which first retrieves cluster boundaries. for that file and then spawns one sub-task per cluster. I also added myself to the list of authors. @etejedor there are a couple of things I am not super happy with in this implementation:. - each thread-local `TTreeView` duplicates all info about the dataset (file names, friend names, friend file names...). - `TTreeProcessorMT` has to query all of this information from `TTreeView`. - ~~the per-file task should only call `Internal::MakeClusters` once (just noticed, that's an easy refactoring)~~ fixed and squashed. Moving the dataset info from `TTreeView` to `TTreeProcessorMT`, on the other hand, would mean adding even more parameters to `TTreeView::GetTreeReader`. What do you think?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2143
https://github.com/root-project/root/pull/2143:413,safety,input,input,413,"[TREEPROCMT] Improve concurrency; TTreeProcessorMT now spawns tasks that process clusters from tasks that process files:. this should decrease the amount of file switches that each thread-local. TChain performs during an event loop, as each thread will tend to. process clusters that belong to the same file. In addition, when no friends and no TEntryList are present, we can avoid the preliminary full sweep of. input files, since we we can use local rather than global entry numbers. In this case TTreeProcessorMT spawns one task per input file which first retrieves cluster boundaries. for that file and then spawns one sub-task per cluster. I also added myself to the list of authors. @etejedor there are a couple of things I am not super happy with in this implementation:. - each thread-local `TTreeView` duplicates all info about the dataset (file names, friend names, friend file names...). - `TTreeProcessorMT` has to query all of this information from `TTreeView`. - ~~the per-file task should only call `Internal::MakeClusters` once (just noticed, that's an easy refactoring)~~ fixed and squashed. Moving the dataset info from `TTreeView` to `TTreeProcessorMT`, on the other hand, would mean adding even more parameters to `TTreeView::GetTreeReader`. What do you think?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2143
https://github.com/root-project/root/pull/2143:536,safety,input,input,536,"[TREEPROCMT] Improve concurrency; TTreeProcessorMT now spawns tasks that process clusters from tasks that process files:. this should decrease the amount of file switches that each thread-local. TChain performs during an event loop, as each thread will tend to. process clusters that belong to the same file. In addition, when no friends and no TEntryList are present, we can avoid the preliminary full sweep of. input files, since we we can use local rather than global entry numbers. In this case TTreeProcessorMT spawns one task per input file which first retrieves cluster boundaries. for that file and then spawns one sub-task per cluster. I also added myself to the list of authors. @etejedor there are a couple of things I am not super happy with in this implementation:. - each thread-local `TTreeView` duplicates all info about the dataset (file names, friend names, friend file names...). - `TTreeProcessorMT` has to query all of this information from `TTreeView`. - ~~the per-file task should only call `Internal::MakeClusters` once (just noticed, that's an easy refactoring)~~ fixed and squashed. Moving the dataset info from `TTreeView` to `TTreeProcessorMT`, on the other hand, would mean adding even more parameters to `TTreeView::GetTreeReader`. What do you think?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2143
https://github.com/root-project/root/pull/2143:680,security,auth,authors,680,"[TREEPROCMT] Improve concurrency; TTreeProcessorMT now spawns tasks that process clusters from tasks that process files:. this should decrease the amount of file switches that each thread-local. TChain performs during an event loop, as each thread will tend to. process clusters that belong to the same file. In addition, when no friends and no TEntryList are present, we can avoid the preliminary full sweep of. input files, since we we can use local rather than global entry numbers. In this case TTreeProcessorMT spawns one task per input file which first retrieves cluster boundaries. for that file and then spawns one sub-task per cluster. I also added myself to the list of authors. @etejedor there are a couple of things I am not super happy with in this implementation:. - each thread-local `TTreeView` duplicates all info about the dataset (file names, friend names, friend file names...). - `TTreeProcessorMT` has to query all of this information from `TTreeView`. - ~~the per-file task should only call `Internal::MakeClusters` once (just noticed, that's an easy refactoring)~~ fixed and squashed. Moving the dataset info from `TTreeView` to `TTreeProcessorMT`, on the other hand, would mean adding even more parameters to `TTreeView::GetTreeReader`. What do you think?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2143
https://github.com/root-project/root/pull/2143:711,testability,coupl,couple,711,"[TREEPROCMT] Improve concurrency; TTreeProcessorMT now spawns tasks that process clusters from tasks that process files:. this should decrease the amount of file switches that each thread-local. TChain performs during an event loop, as each thread will tend to. process clusters that belong to the same file. In addition, when no friends and no TEntryList are present, we can avoid the preliminary full sweep of. input files, since we we can use local rather than global entry numbers. In this case TTreeProcessorMT spawns one task per input file which first retrieves cluster boundaries. for that file and then spawns one sub-task per cluster. I also added myself to the list of authors. @etejedor there are a couple of things I am not super happy with in this implementation:. - each thread-local `TTreeView` duplicates all info about the dataset (file names, friend names, friend file names...). - `TTreeProcessorMT` has to query all of this information from `TTreeView`. - ~~the per-file task should only call `Internal::MakeClusters` once (just noticed, that's an easy refactoring)~~ fixed and squashed. Moving the dataset info from `TTreeView` to `TTreeProcessorMT`, on the other hand, would mean adding even more parameters to `TTreeView::GetTreeReader`. What do you think?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2143
https://github.com/root-project/root/pull/2143:202,usability,perform,performs,202,"[TREEPROCMT] Improve concurrency; TTreeProcessorMT now spawns tasks that process clusters from tasks that process files:. this should decrease the amount of file switches that each thread-local. TChain performs during an event loop, as each thread will tend to. process clusters that belong to the same file. In addition, when no friends and no TEntryList are present, we can avoid the preliminary full sweep of. input files, since we we can use local rather than global entry numbers. In this case TTreeProcessorMT spawns one task per input file which first retrieves cluster boundaries. for that file and then spawns one sub-task per cluster. I also added myself to the list of authors. @etejedor there are a couple of things I am not super happy with in this implementation:. - each thread-local `TTreeView` duplicates all info about the dataset (file names, friend names, friend file names...). - `TTreeProcessorMT` has to query all of this information from `TTreeView`. - ~~the per-file task should only call `Internal::MakeClusters` once (just noticed, that's an easy refactoring)~~ fixed and squashed. Moving the dataset info from `TTreeView` to `TTreeProcessorMT`, on the other hand, would mean adding even more parameters to `TTreeView::GetTreeReader`. What do you think?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2143
https://github.com/root-project/root/pull/2143:413,usability,input,input,413,"[TREEPROCMT] Improve concurrency; TTreeProcessorMT now spawns tasks that process clusters from tasks that process files:. this should decrease the amount of file switches that each thread-local. TChain performs during an event loop, as each thread will tend to. process clusters that belong to the same file. In addition, when no friends and no TEntryList are present, we can avoid the preliminary full sweep of. input files, since we we can use local rather than global entry numbers. In this case TTreeProcessorMT spawns one task per input file which first retrieves cluster boundaries. for that file and then spawns one sub-task per cluster. I also added myself to the list of authors. @etejedor there are a couple of things I am not super happy with in this implementation:. - each thread-local `TTreeView` duplicates all info about the dataset (file names, friend names, friend file names...). - `TTreeProcessorMT` has to query all of this information from `TTreeView`. - ~~the per-file task should only call `Internal::MakeClusters` once (just noticed, that's an easy refactoring)~~ fixed and squashed. Moving the dataset info from `TTreeView` to `TTreeProcessorMT`, on the other hand, would mean adding even more parameters to `TTreeView::GetTreeReader`. What do you think?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2143
https://github.com/root-project/root/pull/2143:536,usability,input,input,536,"[TREEPROCMT] Improve concurrency; TTreeProcessorMT now spawns tasks that process clusters from tasks that process files:. this should decrease the amount of file switches that each thread-local. TChain performs during an event loop, as each thread will tend to. process clusters that belong to the same file. In addition, when no friends and no TEntryList are present, we can avoid the preliminary full sweep of. input files, since we we can use local rather than global entry numbers. In this case TTreeProcessorMT spawns one task per input file which first retrieves cluster boundaries. for that file and then spawns one sub-task per cluster. I also added myself to the list of authors. @etejedor there are a couple of things I am not super happy with in this implementation:. - each thread-local `TTreeView` duplicates all info about the dataset (file names, friend names, friend file names...). - `TTreeProcessorMT` has to query all of this information from `TTreeView`. - ~~the per-file task should only call `Internal::MakeClusters` once (just noticed, that's an easy refactoring)~~ fixed and squashed. Moving the dataset info from `TTreeView` to `TTreeProcessorMT`, on the other hand, would mean adding even more parameters to `TTreeView::GetTreeReader`. What do you think?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2143
https://github.com/root-project/root/pull/2144:38,availability,error,error,38,[DF] Use human readable type names in error message;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2144
https://github.com/root-project/root/pull/2144:44,integrability,messag,message,44,[DF] Use human readable type names in error message;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2144
https://github.com/root-project/root/pull/2144:44,interoperability,messag,message,44,[DF] Use human readable type names in error message;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2144
https://github.com/root-project/root/pull/2144:38,performance,error,error,38,[DF] Use human readable type names in error message;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2144
https://github.com/root-project/root/pull/2144:38,safety,error,error,38,[DF] Use human readable type names in error message;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2144
https://github.com/root-project/root/pull/2144:38,usability,error,error,38,[DF] Use human readable type names in error message;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2144
https://github.com/root-project/root/pull/2145:38,availability,error,error,38,[DF] Use human readable type names in error message;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2145
https://github.com/root-project/root/pull/2145:44,integrability,messag,message,44,[DF] Use human readable type names in error message;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2145
https://github.com/root-project/root/pull/2145:44,interoperability,messag,message,44,[DF] Use human readable type names in error message;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2145
https://github.com/root-project/root/pull/2145:38,performance,error,error,38,[DF] Use human readable type names in error message;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2145
https://github.com/root-project/root/pull/2145:38,safety,error,error,38,[DF] Use human readable type names in error message;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2145
https://github.com/root-project/root/pull/2145:38,usability,error,error,38,[DF] Use human readable type names in error message;,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2145
https://github.com/root-project/root/pull/2147:85,availability,operat,operators,85,"[VecOps][Wip] Introduce the RStrongBool type for representing the results of logical operators; Before, the boolean type considered by the vecops was int.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2147
https://github.com/root-project/root/pull/2147:77,deployability,log,logical,77,"[VecOps][Wip] Introduce the RStrongBool type for representing the results of logical operators; Before, the boolean type considered by the vecops was int.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2147
https://github.com/root-project/root/pull/2147:77,safety,log,logical,77,"[VecOps][Wip] Introduce the RStrongBool type for representing the results of logical operators; Before, the boolean type considered by the vecops was int.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2147
https://github.com/root-project/root/pull/2147:77,security,log,logical,77,"[VecOps][Wip] Introduce the RStrongBool type for representing the results of logical operators; Before, the boolean type considered by the vecops was int.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2147
https://github.com/root-project/root/pull/2147:77,testability,log,logical,77,"[VecOps][Wip] Introduce the RStrongBool type for representing the results of logical operators; Before, the boolean type considered by the vecops was int.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2147
https://github.com/root-project/root/pull/2148:73,availability,failur,failures,73,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:581,availability,Failur,Failures,581,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:823,availability,error,error,823,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:1088,availability,failur,failures,1088,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:1221,availability,error,error,1221,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:39,deployability,depend,dependency,39,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:73,deployability,fail,failures,73,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:201,deployability,BUILD,BUILDTYPE,201,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:415,deployability,BUILD,BUILDTYPE,415,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:581,deployability,Fail,Failures,581,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:769,deployability,depend,dependency,769,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:987,deployability,depend,depending,987,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:1088,deployability,fail,failures,1088,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:1198,deployability,fail,fails,1198,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:39,integrability,depend,dependency,39,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:769,integrability,depend,dependency,769,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:987,integrability,depend,depending,987,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:39,modifiability,depend,dependency,39,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:769,modifiability,depend,dependency,769,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:865,modifiability,variab,variables,865,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:987,modifiability,depend,depending,987,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:73,performance,failur,failures,73,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:581,performance,Failur,Failures,581,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:823,performance,error,error,823,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:1088,performance,failur,failures,1088,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:1221,performance,error,error,1221,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:73,reliability,fail,failures,73,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:581,reliability,Fail,Failures,581,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:667,reliability,doe,doesn,667,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:1088,reliability,fail,failures,1088,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:1198,reliability,fail,fails,1198,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:39,safety,depend,dependency,39,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:68,safety,test,test,68,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:243,safety,test,testReport,243,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:476,safety,test,testReport,476,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:769,safety,depend,dependency,769,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:823,safety,error,error,823,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:987,safety,depend,depending,987,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:1221,safety,error,error,1221,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:39,testability,depend,dependency,39,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:68,testability,test,test,68,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:243,testability,test,testReport,243,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:476,testability,test,testReport,476,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:769,testability,depend,dependency,769,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:987,testability,depend,depending,987,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:823,usability,error,error,823,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:1017,usability,stop,stopped,1017,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2148:1221,usability,error,error,1221,"[cxxmodules] Fix nightlies by autoload dependency libraries; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/lastCompletedBuild/testReport/projectroot.roottest.root.meta/evolution/roottest_root_meta_evolution_execMixedBaseClass_v2/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2148
https://github.com/root-project/root/pull/2150:109,availability,error,error,109,"[ROOT-9441] Always fail if Python or its libraries are not found; This is necessary to give the user a clear error message, since otherwise the build will go on and fail anyway with a cryptic message. See [ROOT-9441](https://sft.its.cern.ch/jira/browse/ROOT-9441).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2150
https://github.com/root-project/root/pull/2150:19,deployability,fail,fail,19,"[ROOT-9441] Always fail if Python or its libraries are not found; This is necessary to give the user a clear error message, since otherwise the build will go on and fail anyway with a cryptic message. See [ROOT-9441](https://sft.its.cern.ch/jira/browse/ROOT-9441).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2150
https://github.com/root-project/root/pull/2150:144,deployability,build,build,144,"[ROOT-9441] Always fail if Python or its libraries are not found; This is necessary to give the user a clear error message, since otherwise the build will go on and fail anyway with a cryptic message. See [ROOT-9441](https://sft.its.cern.ch/jira/browse/ROOT-9441).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2150
https://github.com/root-project/root/pull/2150:165,deployability,fail,fail,165,"[ROOT-9441] Always fail if Python or its libraries are not found; This is necessary to give the user a clear error message, since otherwise the build will go on and fail anyway with a cryptic message. See [ROOT-9441](https://sft.its.cern.ch/jira/browse/ROOT-9441).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2150
https://github.com/root-project/root/pull/2150:115,integrability,messag,message,115,"[ROOT-9441] Always fail if Python or its libraries are not found; This is necessary to give the user a clear error message, since otherwise the build will go on and fail anyway with a cryptic message. See [ROOT-9441](https://sft.its.cern.ch/jira/browse/ROOT-9441).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2150
https://github.com/root-project/root/pull/2150:192,integrability,messag,message,192,"[ROOT-9441] Always fail if Python or its libraries are not found; This is necessary to give the user a clear error message, since otherwise the build will go on and fail anyway with a cryptic message. See [ROOT-9441](https://sft.its.cern.ch/jira/browse/ROOT-9441).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2150
https://github.com/root-project/root/pull/2150:115,interoperability,messag,message,115,"[ROOT-9441] Always fail if Python or its libraries are not found; This is necessary to give the user a clear error message, since otherwise the build will go on and fail anyway with a cryptic message. See [ROOT-9441](https://sft.its.cern.ch/jira/browse/ROOT-9441).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2150
https://github.com/root-project/root/pull/2150:192,interoperability,messag,message,192,"[ROOT-9441] Always fail if Python or its libraries are not found; This is necessary to give the user a clear error message, since otherwise the build will go on and fail anyway with a cryptic message. See [ROOT-9441](https://sft.its.cern.ch/jira/browse/ROOT-9441).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2150
https://github.com/root-project/root/pull/2150:109,performance,error,error,109,"[ROOT-9441] Always fail if Python or its libraries are not found; This is necessary to give the user a clear error message, since otherwise the build will go on and fail anyway with a cryptic message. See [ROOT-9441](https://sft.its.cern.ch/jira/browse/ROOT-9441).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2150
https://github.com/root-project/root/pull/2150:19,reliability,fail,fail,19,"[ROOT-9441] Always fail if Python or its libraries are not found; This is necessary to give the user a clear error message, since otherwise the build will go on and fail anyway with a cryptic message. See [ROOT-9441](https://sft.its.cern.ch/jira/browse/ROOT-9441).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2150
https://github.com/root-project/root/pull/2150:165,reliability,fail,fail,165,"[ROOT-9441] Always fail if Python or its libraries are not found; This is necessary to give the user a clear error message, since otherwise the build will go on and fail anyway with a cryptic message. See [ROOT-9441](https://sft.its.cern.ch/jira/browse/ROOT-9441).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2150
https://github.com/root-project/root/pull/2150:109,safety,error,error,109,"[ROOT-9441] Always fail if Python or its libraries are not found; This is necessary to give the user a clear error message, since otherwise the build will go on and fail anyway with a cryptic message. See [ROOT-9441](https://sft.its.cern.ch/jira/browse/ROOT-9441).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2150
https://github.com/root-project/root/pull/2150:96,usability,user,user,96,"[ROOT-9441] Always fail if Python or its libraries are not found; This is necessary to give the user a clear error message, since otherwise the build will go on and fail anyway with a cryptic message. See [ROOT-9441](https://sft.its.cern.ch/jira/browse/ROOT-9441).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2150
https://github.com/root-project/root/pull/2150:103,usability,clear,clear,103,"[ROOT-9441] Always fail if Python or its libraries are not found; This is necessary to give the user a clear error message, since otherwise the build will go on and fail anyway with a cryptic message. See [ROOT-9441](https://sft.its.cern.ch/jira/browse/ROOT-9441).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2150
https://github.com/root-project/root/pull/2150:109,usability,error,error,109,"[ROOT-9441] Always fail if Python or its libraries are not found; This is necessary to give the user a clear error message, since otherwise the build will go on and fail anyway with a cryptic message. See [ROOT-9441](https://sft.its.cern.ch/jira/browse/ROOT-9441).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2150
https://github.com/root-project/root/pull/2152:20,performance,parallel,parallel,20,"[TREE] Only trigger parallel GetEntry if number of branches > 1; Hi, please check this makes sense :smile:",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2152
https://github.com/root-project/root/pull/2154:29,availability,failur,failures,29,"Testing jenkins; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2154
https://github.com/root-project/root/pull/2154:295,availability,Failur,Failures,295,"Testing jenkins; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2154
https://github.com/root-project/root/pull/2154:537,availability,error,error,537,"Testing jenkins; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2154
https://github.com/root-project/root/pull/2154:802,availability,failur,failures,802,"Testing jenkins; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2154
https://github.com/root-project/root/pull/2154:935,availability,error,error,935,"Testing jenkins; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2154
https://github.com/root-project/root/pull/2154:29,deployability,fail,failures,29,"Testing jenkins; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2154
https://github.com/root-project/root/pull/2154:157,deployability,BUILD,BUILDTYPE,157,"Testing jenkins; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2154
https://github.com/root-project/root/pull/2154:295,deployability,Fail,Failures,295,"Testing jenkins; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2154
https://github.com/root-project/root/pull/2154:483,deployability,depend,dependency,483,"Testing jenkins; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2154
https://github.com/root-project/root/pull/2154:701,deployability,depend,depending,701,"Testing jenkins; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2154
https://github.com/root-project/root/pull/2154:802,deployability,fail,failures,802,"Testing jenkins; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2154
https://github.com/root-project/root/pull/2154:912,deployability,fail,fails,912,"Testing jenkins; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2154
https://github.com/root-project/root/pull/2154:483,integrability,depend,dependency,483,"Testing jenkins; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2154
https://github.com/root-project/root/pull/2154:701,integrability,depend,depending,701,"Testing jenkins; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2154
https://github.com/root-project/root/pull/2154:483,modifiability,depend,dependency,483,"Testing jenkins; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2154
https://github.com/root-project/root/pull/2154:579,modifiability,variab,variables,579,"Testing jenkins; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2154
https://github.com/root-project/root/pull/2154:701,modifiability,depend,depending,701,"Testing jenkins; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2154
https://github.com/root-project/root/pull/2154:29,performance,failur,failures,29,"Testing jenkins; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2154
https://github.com/root-project/root/pull/2154:295,performance,Failur,Failures,295,"Testing jenkins; We had test failures in runtime nightlies such as this one:. https://epsft-jenkins.cern.ch/view/ROOT/job/root-nightly-runtime-cxxmodules/95/BUILDTYPE=Debug,COMPILER=gcc62,LABEL=slc6/testReport/junit/projectroot.roottest.root.math/smatrix/roottest_root_math_smatrix_testKalman/. Failures were due to what @pcanal commented in #2135, that some so files in. roottest doesn't have external linkage. (It means that if you call. dlopen(libfoo.so), linux kernel can't find dependency libraries and it. emits ""undefined symbol"" error when they try to initialize global. variables in libfoo.so but couldn't find symbol definition). With pch, rootmap files were providing information about the depending library. However we stopped generating rootmap files in #2127 and that's why we. got these failures. To fix this issue, I implemented a callback to. TCling which gets called when DynamicLibraryManager fails with. ""undefined error"". I'm open to suggestion especially in DynamicLibraryManager.cpp.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/2154
