id,quality_attribute,keyword,matched_word,match_idx,sentence,source,author,repo,version,wiki,url
https://github.com/root-project/root/pull/1700:111,testability,test,tests,111,"The problem is not in `GetLeaf()`, so we do not need to add support for this there, especially since it breaks tests. We just have to do the right name split in TDF and pass that to another overload of `GetLeaf()` that takes the already split arguments. The real problem is that once branch names with dots start being accepted by TDF, the JIT doesn't work because the string for jitting contains the branch names as is, so things like `double p.x;` show up in the code to be jitted, and that cannot be compiled, so that's what really needs fixing. ROOT-9254 is not needed and could probably just be closed.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1700
https://github.com/root-project/root/pull/1700:60,usability,support,support,60,"The problem is not in `GetLeaf()`, so we do not need to add support for this there, especially since it breaks tests. We just have to do the right name split in TDF and pass that to another overload of `GetLeaf()` that takes the already split arguments. The real problem is that once branch names with dots start being accepted by TDF, the JIT doesn't work because the string for jitting contains the branch names as is, so things like `double p.x;` show up in the code to be jitted, and that cannot be compiled, so that's what really needs fixing. ROOT-9254 is not needed and could probably just be closed.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1700
https://github.com/root-project/root/pull/1700:600,usability,close,closed,600,"The problem is not in `GetLeaf()`, so we do not need to add support for this there, especially since it breaks tests. We just have to do the right name split in TDF and pass that to another overload of `GetLeaf()` that takes the already split arguments. The real problem is that once branch names with dots start being accepted by TDF, the JIT doesn't work because the string for jitting contains the branch names as is, so things like `double p.x;` show up in the code to be jitted, and that cannot be compiled, so that's what really needs fixing. ROOT-9254 is not needed and could probably just be closed.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1700
https://github.com/root-project/root/pull/1702:8,usability,prefer,prefer,8,I would prefer to remove text.cxx from this PR. I have a new one,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1702
https://github.com/root-project/root/pull/1702:110,security,modif,modify,110,> I would prefer to remove text.cxx from this PR. I have a new one. Up to you Olivier. Just merge this PR and modify text.cxx once again,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1702
https://github.com/root-project/root/pull/1702:10,usability,prefer,prefer,10,> I would prefer to remove text.cxx from this PR. I have a new one. Up to you Olivier. Just merge this PR and modify text.cxx once again,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1702
https://github.com/root-project/root/pull/1702:23,testability,simpl,simplest,23,Yes . may be it is the simplest. Will do.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1702
https://github.com/root-project/root/pull/1702:23,usability,simpl,simplest,23,Yes . may be it is the simplest. Will do.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1702
https://github.com/root-project/root/pull/1703:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1703
https://github.com/root-project/root/pull/1706:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:37,availability,error,errors,37,@dan131riley Can you look into those errors?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:37,performance,error,errors,37,@dan131riley Can you look into those errors?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:37,safety,error,errors,37,@dan131riley Can you look into those errors?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:37,usability,error,errors,37,@dan131riley Can you look into those errors?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:37,deployability,updat,update,37,"I missed one of the test cases, will update the PR shortly now that I know how to actually run the tests!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:20,safety,test,test,20,"I missed one of the test cases, will update the PR shortly now that I know how to actually run the tests!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:37,safety,updat,update,37,"I missed one of the test cases, will update the PR shortly now that I know how to actually run the tests!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:99,safety,test,tests,99,"I missed one of the test cases, will update the PR shortly now that I know how to actually run the tests!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:37,security,updat,update,37,"I missed one of the test cases, will update the PR shortly now that I know how to actually run the tests!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:20,testability,test,test,20,"I missed one of the test cases, will update the PR shortly now that I know how to actually run the tests!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:99,testability,test,tests,99,"I missed one of the test cases, will update the PR shortly now that I know how to actually run the tests!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:74,availability,error,error,74,@pcanal I've verified that the additional commit corrects the compilation error in the tests.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:74,performance,error,error,74,@pcanal I've verified that the additional commit corrects the compilation error in the tests.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:74,safety,error,error,74,@pcanal I've verified that the additional commit corrects the compilation error in the tests.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:87,safety,test,tests,87,@pcanal I've verified that the additional commit corrects the compilation error in the tests.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:13,testability,verif,verified,13,@pcanal I've verified that the additional commit corrects the compilation error in the tests.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:87,testability,test,tests,87,@pcanal I've verified that the additional commit corrects the compilation error in the tests.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:74,usability,error,error,74,@pcanal I've verified that the additional commit corrects the compilation error in the tests.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:137,availability,operat,operation,137,"@amadio thanks for the comments. How this solves the CMS problem is illustrated by the example callback I included. That wraps the merge operation with an `std::promise()`, does a `task_arena::enqueue()` with that functor to the existing CMS framework TBB task arena, and then waits for the promise to complete. `task_arena::enqueue()` guarantees that the functor is executed by an existing member of the arena's thread pool. If the calling thread is not part of the arena, it cannot join it, so it cannot execute the functor itself. AFAICT, `task_arena::enqueue()` is the only interface that guarantees this; with other interfaces like `task_arena::execute()` or `task_group::run()`, the calling thread can temporarily join the arena, which would violate our framework's scheduling assumptions. wrt the interface change, my previous version added a second callback instead of modifying the existing one. From a functionality standpoint, the wrapper callback is a superset of the completion callback, but I do see the virtue of keeping the completion callback safe and having a separate callback for the riskier operation of wrapping the merge. I can certainly make that change if that would be more acceptable. I initially tried to do this with the `TTaskGroup`; unfortunately, with a `TTaskGroup` the calling thread can end up temporarily joining the task arena, which wasn't acceptable to us. It seems we have to use `task_arena::execute()`, which requires access to the framework task arena, which is how I ended using a callback for this. Let me know if separating the merge wrapper into a second callback would be acceptable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:1112,availability,operat,operation,1112,"@amadio thanks for the comments. How this solves the CMS problem is illustrated by the example callback I included. That wraps the merge operation with an `std::promise()`, does a `task_arena::enqueue()` with that functor to the existing CMS framework TBB task arena, and then waits for the promise to complete. `task_arena::enqueue()` guarantees that the functor is executed by an existing member of the arena's thread pool. If the calling thread is not part of the arena, it cannot join it, so it cannot execute the functor itself. AFAICT, `task_arena::enqueue()` is the only interface that guarantees this; with other interfaces like `task_arena::execute()` or `task_group::run()`, the calling thread can temporarily join the arena, which would violate our framework's scheduling assumptions. wrt the interface change, my previous version added a second callback instead of modifying the existing one. From a functionality standpoint, the wrapper callback is a superset of the completion callback, but I do see the virtue of keeping the completion callback safe and having a separate callback for the riskier operation of wrapping the merge. I can certainly make that change if that would be more acceptable. I initially tried to do this with the `TTaskGroup`; unfortunately, with a `TTaskGroup` the calling thread can end up temporarily joining the task arena, which wasn't acceptable to us. It seems we have to use `task_arena::execute()`, which requires access to the framework task arena, which is how I ended using a callback for this. Let me know if separating the merge wrapper into a second callback would be acceptable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:834,deployability,version,version,834,"@amadio thanks for the comments. How this solves the CMS problem is illustrated by the example callback I included. That wraps the merge operation with an `std::promise()`, does a `task_arena::enqueue()` with that functor to the existing CMS framework TBB task arena, and then waits for the promise to complete. `task_arena::enqueue()` guarantees that the functor is executed by an existing member of the arena's thread pool. If the calling thread is not part of the arena, it cannot join it, so it cannot execute the functor itself. AFAICT, `task_arena::enqueue()` is the only interface that guarantees this; with other interfaces like `task_arena::execute()` or `task_group::run()`, the calling thread can temporarily join the arena, which would violate our framework's scheduling assumptions. wrt the interface change, my previous version added a second callback instead of modifying the existing one. From a functionality standpoint, the wrapper callback is a superset of the completion callback, but I do see the virtue of keeping the completion callback safe and having a separate callback for the riskier operation of wrapping the merge. I can certainly make that change if that would be more acceptable. I initially tried to do this with the `TTaskGroup`; unfortunately, with a `TTaskGroup` the calling thread can end up temporarily joining the task arena, which wasn't acceptable to us. It seems we have to use `task_arena::execute()`, which requires access to the framework task arena, which is how I ended using a callback for this. Let me know if separating the merge wrapper into a second callback would be acceptable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:772,energy efficiency,schedul,scheduling,772,"@amadio thanks for the comments. How this solves the CMS problem is illustrated by the example callback I included. That wraps the merge operation with an `std::promise()`, does a `task_arena::enqueue()` with that functor to the existing CMS framework TBB task arena, and then waits for the promise to complete. `task_arena::enqueue()` guarantees that the functor is executed by an existing member of the arena's thread pool. If the calling thread is not part of the arena, it cannot join it, so it cannot execute the functor itself. AFAICT, `task_arena::enqueue()` is the only interface that guarantees this; with other interfaces like `task_arena::execute()` or `task_group::run()`, the calling thread can temporarily join the arena, which would violate our framework's scheduling assumptions. wrt the interface change, my previous version added a second callback instead of modifying the existing one. From a functionality standpoint, the wrapper callback is a superset of the completion callback, but I do see the virtue of keeping the completion callback safe and having a separate callback for the riskier operation of wrapping the merge. I can certainly make that change if that would be more acceptable. I initially tried to do this with the `TTaskGroup`; unfortunately, with a `TTaskGroup` the calling thread can end up temporarily joining the task arena, which wasn't acceptable to us. It seems we have to use `task_arena::execute()`, which requires access to the framework task arena, which is how I ended using a callback for this. Let me know if separating the merge wrapper into a second callback would be acceptable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:121,integrability,wrap,wraps,121,"@amadio thanks for the comments. How this solves the CMS problem is illustrated by the example callback I included. That wraps the merge operation with an `std::promise()`, does a `task_arena::enqueue()` with that functor to the existing CMS framework TBB task arena, and then waits for the promise to complete. `task_arena::enqueue()` guarantees that the functor is executed by an existing member of the arena's thread pool. If the calling thread is not part of the arena, it cannot join it, so it cannot execute the functor itself. AFAICT, `task_arena::enqueue()` is the only interface that guarantees this; with other interfaces like `task_arena::execute()` or `task_group::run()`, the calling thread can temporarily join the arena, which would violate our framework's scheduling assumptions. wrt the interface change, my previous version added a second callback instead of modifying the existing one. From a functionality standpoint, the wrapper callback is a superset of the completion callback, but I do see the virtue of keeping the completion callback safe and having a separate callback for the riskier operation of wrapping the merge. I can certainly make that change if that would be more acceptable. I initially tried to do this with the `TTaskGroup`; unfortunately, with a `TTaskGroup` the calling thread can end up temporarily joining the task arena, which wasn't acceptable to us. It seems we have to use `task_arena::execute()`, which requires access to the framework task arena, which is how I ended using a callback for this. Let me know if separating the merge wrapper into a second callback would be acceptable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:578,integrability,interfac,interface,578,"@amadio thanks for the comments. How this solves the CMS problem is illustrated by the example callback I included. That wraps the merge operation with an `std::promise()`, does a `task_arena::enqueue()` with that functor to the existing CMS framework TBB task arena, and then waits for the promise to complete. `task_arena::enqueue()` guarantees that the functor is executed by an existing member of the arena's thread pool. If the calling thread is not part of the arena, it cannot join it, so it cannot execute the functor itself. AFAICT, `task_arena::enqueue()` is the only interface that guarantees this; with other interfaces like `task_arena::execute()` or `task_group::run()`, the calling thread can temporarily join the arena, which would violate our framework's scheduling assumptions. wrt the interface change, my previous version added a second callback instead of modifying the existing one. From a functionality standpoint, the wrapper callback is a superset of the completion callback, but I do see the virtue of keeping the completion callback safe and having a separate callback for the riskier operation of wrapping the merge. I can certainly make that change if that would be more acceptable. I initially tried to do this with the `TTaskGroup`; unfortunately, with a `TTaskGroup` the calling thread can end up temporarily joining the task arena, which wasn't acceptable to us. It seems we have to use `task_arena::execute()`, which requires access to the framework task arena, which is how I ended using a callback for this. Let me know if separating the merge wrapper into a second callback would be acceptable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:621,integrability,interfac,interfaces,621,"@amadio thanks for the comments. How this solves the CMS problem is illustrated by the example callback I included. That wraps the merge operation with an `std::promise()`, does a `task_arena::enqueue()` with that functor to the existing CMS framework TBB task arena, and then waits for the promise to complete. `task_arena::enqueue()` guarantees that the functor is executed by an existing member of the arena's thread pool. If the calling thread is not part of the arena, it cannot join it, so it cannot execute the functor itself. AFAICT, `task_arena::enqueue()` is the only interface that guarantees this; with other interfaces like `task_arena::execute()` or `task_group::run()`, the calling thread can temporarily join the arena, which would violate our framework's scheduling assumptions. wrt the interface change, my previous version added a second callback instead of modifying the existing one. From a functionality standpoint, the wrapper callback is a superset of the completion callback, but I do see the virtue of keeping the completion callback safe and having a separate callback for the riskier operation of wrapping the merge. I can certainly make that change if that would be more acceptable. I initially tried to do this with the `TTaskGroup`; unfortunately, with a `TTaskGroup` the calling thread can end up temporarily joining the task arena, which wasn't acceptable to us. It seems we have to use `task_arena::execute()`, which requires access to the framework task arena, which is how I ended using a callback for this. Let me know if separating the merge wrapper into a second callback would be acceptable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:804,integrability,interfac,interface,804,"@amadio thanks for the comments. How this solves the CMS problem is illustrated by the example callback I included. That wraps the merge operation with an `std::promise()`, does a `task_arena::enqueue()` with that functor to the existing CMS framework TBB task arena, and then waits for the promise to complete. `task_arena::enqueue()` guarantees that the functor is executed by an existing member of the arena's thread pool. If the calling thread is not part of the arena, it cannot join it, so it cannot execute the functor itself. AFAICT, `task_arena::enqueue()` is the only interface that guarantees this; with other interfaces like `task_arena::execute()` or `task_group::run()`, the calling thread can temporarily join the arena, which would violate our framework's scheduling assumptions. wrt the interface change, my previous version added a second callback instead of modifying the existing one. From a functionality standpoint, the wrapper callback is a superset of the completion callback, but I do see the virtue of keeping the completion callback safe and having a separate callback for the riskier operation of wrapping the merge. I can certainly make that change if that would be more acceptable. I initially tried to do this with the `TTaskGroup`; unfortunately, with a `TTaskGroup` the calling thread can end up temporarily joining the task arena, which wasn't acceptable to us. It seems we have to use `task_arena::execute()`, which requires access to the framework task arena, which is how I ended using a callback for this. Let me know if separating the merge wrapper into a second callback would be acceptable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:834,integrability,version,version,834,"@amadio thanks for the comments. How this solves the CMS problem is illustrated by the example callback I included. That wraps the merge operation with an `std::promise()`, does a `task_arena::enqueue()` with that functor to the existing CMS framework TBB task arena, and then waits for the promise to complete. `task_arena::enqueue()` guarantees that the functor is executed by an existing member of the arena's thread pool. If the calling thread is not part of the arena, it cannot join it, so it cannot execute the functor itself. AFAICT, `task_arena::enqueue()` is the only interface that guarantees this; with other interfaces like `task_arena::execute()` or `task_group::run()`, the calling thread can temporarily join the arena, which would violate our framework's scheduling assumptions. wrt the interface change, my previous version added a second callback instead of modifying the existing one. From a functionality standpoint, the wrapper callback is a superset of the completion callback, but I do see the virtue of keeping the completion callback safe and having a separate callback for the riskier operation of wrapping the merge. I can certainly make that change if that would be more acceptable. I initially tried to do this with the `TTaskGroup`; unfortunately, with a `TTaskGroup` the calling thread can end up temporarily joining the task arena, which wasn't acceptable to us. It seems we have to use `task_arena::execute()`, which requires access to the framework task arena, which is how I ended using a callback for this. Let me know if separating the merge wrapper into a second callback would be acceptable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:942,integrability,wrap,wrapper,942,"@amadio thanks for the comments. How this solves the CMS problem is illustrated by the example callback I included. That wraps the merge operation with an `std::promise()`, does a `task_arena::enqueue()` with that functor to the existing CMS framework TBB task arena, and then waits for the promise to complete. `task_arena::enqueue()` guarantees that the functor is executed by an existing member of the arena's thread pool. If the calling thread is not part of the arena, it cannot join it, so it cannot execute the functor itself. AFAICT, `task_arena::enqueue()` is the only interface that guarantees this; with other interfaces like `task_arena::execute()` or `task_group::run()`, the calling thread can temporarily join the arena, which would violate our framework's scheduling assumptions. wrt the interface change, my previous version added a second callback instead of modifying the existing one. From a functionality standpoint, the wrapper callback is a superset of the completion callback, but I do see the virtue of keeping the completion callback safe and having a separate callback for the riskier operation of wrapping the merge. I can certainly make that change if that would be more acceptable. I initially tried to do this with the `TTaskGroup`; unfortunately, with a `TTaskGroup` the calling thread can end up temporarily joining the task arena, which wasn't acceptable to us. It seems we have to use `task_arena::execute()`, which requires access to the framework task arena, which is how I ended using a callback for this. Let me know if separating the merge wrapper into a second callback would be acceptable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:1125,integrability,wrap,wrapping,1125,"@amadio thanks for the comments. How this solves the CMS problem is illustrated by the example callback I included. That wraps the merge operation with an `std::promise()`, does a `task_arena::enqueue()` with that functor to the existing CMS framework TBB task arena, and then waits for the promise to complete. `task_arena::enqueue()` guarantees that the functor is executed by an existing member of the arena's thread pool. If the calling thread is not part of the arena, it cannot join it, so it cannot execute the functor itself. AFAICT, `task_arena::enqueue()` is the only interface that guarantees this; with other interfaces like `task_arena::execute()` or `task_group::run()`, the calling thread can temporarily join the arena, which would violate our framework's scheduling assumptions. wrt the interface change, my previous version added a second callback instead of modifying the existing one. From a functionality standpoint, the wrapper callback is a superset of the completion callback, but I do see the virtue of keeping the completion callback safe and having a separate callback for the riskier operation of wrapping the merge. I can certainly make that change if that would be more acceptable. I initially tried to do this with the `TTaskGroup`; unfortunately, with a `TTaskGroup` the calling thread can end up temporarily joining the task arena, which wasn't acceptable to us. It seems we have to use `task_arena::execute()`, which requires access to the framework task arena, which is how I ended using a callback for this. Let me know if separating the merge wrapper into a second callback would be acceptable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:1580,integrability,wrap,wrapper,1580,"@amadio thanks for the comments. How this solves the CMS problem is illustrated by the example callback I included. That wraps the merge operation with an `std::promise()`, does a `task_arena::enqueue()` with that functor to the existing CMS framework TBB task arena, and then waits for the promise to complete. `task_arena::enqueue()` guarantees that the functor is executed by an existing member of the arena's thread pool. If the calling thread is not part of the arena, it cannot join it, so it cannot execute the functor itself. AFAICT, `task_arena::enqueue()` is the only interface that guarantees this; with other interfaces like `task_arena::execute()` or `task_group::run()`, the calling thread can temporarily join the arena, which would violate our framework's scheduling assumptions. wrt the interface change, my previous version added a second callback instead of modifying the existing one. From a functionality standpoint, the wrapper callback is a superset of the completion callback, but I do see the virtue of keeping the completion callback safe and having a separate callback for the riskier operation of wrapping the merge. I can certainly make that change if that would be more acceptable. I initially tried to do this with the `TTaskGroup`; unfortunately, with a `TTaskGroup` the calling thread can end up temporarily joining the task arena, which wasn't acceptable to us. It seems we have to use `task_arena::execute()`, which requires access to the framework task arena, which is how I ended using a callback for this. Let me know if separating the merge wrapper into a second callback would be acceptable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:578,interoperability,interfac,interface,578,"@amadio thanks for the comments. How this solves the CMS problem is illustrated by the example callback I included. That wraps the merge operation with an `std::promise()`, does a `task_arena::enqueue()` with that functor to the existing CMS framework TBB task arena, and then waits for the promise to complete. `task_arena::enqueue()` guarantees that the functor is executed by an existing member of the arena's thread pool. If the calling thread is not part of the arena, it cannot join it, so it cannot execute the functor itself. AFAICT, `task_arena::enqueue()` is the only interface that guarantees this; with other interfaces like `task_arena::execute()` or `task_group::run()`, the calling thread can temporarily join the arena, which would violate our framework's scheduling assumptions. wrt the interface change, my previous version added a second callback instead of modifying the existing one. From a functionality standpoint, the wrapper callback is a superset of the completion callback, but I do see the virtue of keeping the completion callback safe and having a separate callback for the riskier operation of wrapping the merge. I can certainly make that change if that would be more acceptable. I initially tried to do this with the `TTaskGroup`; unfortunately, with a `TTaskGroup` the calling thread can end up temporarily joining the task arena, which wasn't acceptable to us. It seems we have to use `task_arena::execute()`, which requires access to the framework task arena, which is how I ended using a callback for this. Let me know if separating the merge wrapper into a second callback would be acceptable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:621,interoperability,interfac,interfaces,621,"@amadio thanks for the comments. How this solves the CMS problem is illustrated by the example callback I included. That wraps the merge operation with an `std::promise()`, does a `task_arena::enqueue()` with that functor to the existing CMS framework TBB task arena, and then waits for the promise to complete. `task_arena::enqueue()` guarantees that the functor is executed by an existing member of the arena's thread pool. If the calling thread is not part of the arena, it cannot join it, so it cannot execute the functor itself. AFAICT, `task_arena::enqueue()` is the only interface that guarantees this; with other interfaces like `task_arena::execute()` or `task_group::run()`, the calling thread can temporarily join the arena, which would violate our framework's scheduling assumptions. wrt the interface change, my previous version added a second callback instead of modifying the existing one. From a functionality standpoint, the wrapper callback is a superset of the completion callback, but I do see the virtue of keeping the completion callback safe and having a separate callback for the riskier operation of wrapping the merge. I can certainly make that change if that would be more acceptable. I initially tried to do this with the `TTaskGroup`; unfortunately, with a `TTaskGroup` the calling thread can end up temporarily joining the task arena, which wasn't acceptable to us. It seems we have to use `task_arena::execute()`, which requires access to the framework task arena, which is how I ended using a callback for this. Let me know if separating the merge wrapper into a second callback would be acceptable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:804,interoperability,interfac,interface,804,"@amadio thanks for the comments. How this solves the CMS problem is illustrated by the example callback I included. That wraps the merge operation with an `std::promise()`, does a `task_arena::enqueue()` with that functor to the existing CMS framework TBB task arena, and then waits for the promise to complete. `task_arena::enqueue()` guarantees that the functor is executed by an existing member of the arena's thread pool. If the calling thread is not part of the arena, it cannot join it, so it cannot execute the functor itself. AFAICT, `task_arena::enqueue()` is the only interface that guarantees this; with other interfaces like `task_arena::execute()` or `task_group::run()`, the calling thread can temporarily join the arena, which would violate our framework's scheduling assumptions. wrt the interface change, my previous version added a second callback instead of modifying the existing one. From a functionality standpoint, the wrapper callback is a superset of the completion callback, but I do see the virtue of keeping the completion callback safe and having a separate callback for the riskier operation of wrapping the merge. I can certainly make that change if that would be more acceptable. I initially tried to do this with the `TTaskGroup`; unfortunately, with a `TTaskGroup` the calling thread can end up temporarily joining the task arena, which wasn't acceptable to us. It seems we have to use `task_arena::execute()`, which requires access to the framework task arena, which is how I ended using a callback for this. Let me know if separating the merge wrapper into a second callback would be acceptable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:942,interoperability,wrapper,wrapper,942,"@amadio thanks for the comments. How this solves the CMS problem is illustrated by the example callback I included. That wraps the merge operation with an `std::promise()`, does a `task_arena::enqueue()` with that functor to the existing CMS framework TBB task arena, and then waits for the promise to complete. `task_arena::enqueue()` guarantees that the functor is executed by an existing member of the arena's thread pool. If the calling thread is not part of the arena, it cannot join it, so it cannot execute the functor itself. AFAICT, `task_arena::enqueue()` is the only interface that guarantees this; with other interfaces like `task_arena::execute()` or `task_group::run()`, the calling thread can temporarily join the arena, which would violate our framework's scheduling assumptions. wrt the interface change, my previous version added a second callback instead of modifying the existing one. From a functionality standpoint, the wrapper callback is a superset of the completion callback, but I do see the virtue of keeping the completion callback safe and having a separate callback for the riskier operation of wrapping the merge. I can certainly make that change if that would be more acceptable. I initially tried to do this with the `TTaskGroup`; unfortunately, with a `TTaskGroup` the calling thread can end up temporarily joining the task arena, which wasn't acceptable to us. It seems we have to use `task_arena::execute()`, which requires access to the framework task arena, which is how I ended using a callback for this. Let me know if separating the merge wrapper into a second callback would be acceptable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:1580,interoperability,wrapper,wrapper,1580,"@amadio thanks for the comments. How this solves the CMS problem is illustrated by the example callback I included. That wraps the merge operation with an `std::promise()`, does a `task_arena::enqueue()` with that functor to the existing CMS framework TBB task arena, and then waits for the promise to complete. `task_arena::enqueue()` guarantees that the functor is executed by an existing member of the arena's thread pool. If the calling thread is not part of the arena, it cannot join it, so it cannot execute the functor itself. AFAICT, `task_arena::enqueue()` is the only interface that guarantees this; with other interfaces like `task_arena::execute()` or `task_group::run()`, the calling thread can temporarily join the arena, which would violate our framework's scheduling assumptions. wrt the interface change, my previous version added a second callback instead of modifying the existing one. From a functionality standpoint, the wrapper callback is a superset of the completion callback, but I do see the virtue of keeping the completion callback safe and having a separate callback for the riskier operation of wrapping the merge. I can certainly make that change if that would be more acceptable. I initially tried to do this with the `TTaskGroup`; unfortunately, with a `TTaskGroup` the calling thread can end up temporarily joining the task arena, which wasn't acceptable to us. It seems we have to use `task_arena::execute()`, which requires access to the framework task arena, which is how I ended using a callback for this. Let me know if separating the merge wrapper into a second callback would be acceptable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:578,modifiability,interfac,interface,578,"@amadio thanks for the comments. How this solves the CMS problem is illustrated by the example callback I included. That wraps the merge operation with an `std::promise()`, does a `task_arena::enqueue()` with that functor to the existing CMS framework TBB task arena, and then waits for the promise to complete. `task_arena::enqueue()` guarantees that the functor is executed by an existing member of the arena's thread pool. If the calling thread is not part of the arena, it cannot join it, so it cannot execute the functor itself. AFAICT, `task_arena::enqueue()` is the only interface that guarantees this; with other interfaces like `task_arena::execute()` or `task_group::run()`, the calling thread can temporarily join the arena, which would violate our framework's scheduling assumptions. wrt the interface change, my previous version added a second callback instead of modifying the existing one. From a functionality standpoint, the wrapper callback is a superset of the completion callback, but I do see the virtue of keeping the completion callback safe and having a separate callback for the riskier operation of wrapping the merge. I can certainly make that change if that would be more acceptable. I initially tried to do this with the `TTaskGroup`; unfortunately, with a `TTaskGroup` the calling thread can end up temporarily joining the task arena, which wasn't acceptable to us. It seems we have to use `task_arena::execute()`, which requires access to the framework task arena, which is how I ended using a callback for this. Let me know if separating the merge wrapper into a second callback would be acceptable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:621,modifiability,interfac,interfaces,621,"@amadio thanks for the comments. How this solves the CMS problem is illustrated by the example callback I included. That wraps the merge operation with an `std::promise()`, does a `task_arena::enqueue()` with that functor to the existing CMS framework TBB task arena, and then waits for the promise to complete. `task_arena::enqueue()` guarantees that the functor is executed by an existing member of the arena's thread pool. If the calling thread is not part of the arena, it cannot join it, so it cannot execute the functor itself. AFAICT, `task_arena::enqueue()` is the only interface that guarantees this; with other interfaces like `task_arena::execute()` or `task_group::run()`, the calling thread can temporarily join the arena, which would violate our framework's scheduling assumptions. wrt the interface change, my previous version added a second callback instead of modifying the existing one. From a functionality standpoint, the wrapper callback is a superset of the completion callback, but I do see the virtue of keeping the completion callback safe and having a separate callback for the riskier operation of wrapping the merge. I can certainly make that change if that would be more acceptable. I initially tried to do this with the `TTaskGroup`; unfortunately, with a `TTaskGroup` the calling thread can end up temporarily joining the task arena, which wasn't acceptable to us. It seems we have to use `task_arena::execute()`, which requires access to the framework task arena, which is how I ended using a callback for this. Let me know if separating the merge wrapper into a second callback would be acceptable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:804,modifiability,interfac,interface,804,"@amadio thanks for the comments. How this solves the CMS problem is illustrated by the example callback I included. That wraps the merge operation with an `std::promise()`, does a `task_arena::enqueue()` with that functor to the existing CMS framework TBB task arena, and then waits for the promise to complete. `task_arena::enqueue()` guarantees that the functor is executed by an existing member of the arena's thread pool. If the calling thread is not part of the arena, it cannot join it, so it cannot execute the functor itself. AFAICT, `task_arena::enqueue()` is the only interface that guarantees this; with other interfaces like `task_arena::execute()` or `task_group::run()`, the calling thread can temporarily join the arena, which would violate our framework's scheduling assumptions. wrt the interface change, my previous version added a second callback instead of modifying the existing one. From a functionality standpoint, the wrapper callback is a superset of the completion callback, but I do see the virtue of keeping the completion callback safe and having a separate callback for the riskier operation of wrapping the merge. I can certainly make that change if that would be more acceptable. I initially tried to do this with the `TTaskGroup`; unfortunately, with a `TTaskGroup` the calling thread can end up temporarily joining the task arena, which wasn't acceptable to us. It seems we have to use `task_arena::execute()`, which requires access to the framework task arena, which is how I ended using a callback for this. Let me know if separating the merge wrapper into a second callback would be acceptable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:834,modifiability,version,version,834,"@amadio thanks for the comments. How this solves the CMS problem is illustrated by the example callback I included. That wraps the merge operation with an `std::promise()`, does a `task_arena::enqueue()` with that functor to the existing CMS framework TBB task arena, and then waits for the promise to complete. `task_arena::enqueue()` guarantees that the functor is executed by an existing member of the arena's thread pool. If the calling thread is not part of the arena, it cannot join it, so it cannot execute the functor itself. AFAICT, `task_arena::enqueue()` is the only interface that guarantees this; with other interfaces like `task_arena::execute()` or `task_group::run()`, the calling thread can temporarily join the arena, which would violate our framework's scheduling assumptions. wrt the interface change, my previous version added a second callback instead of modifying the existing one. From a functionality standpoint, the wrapper callback is a superset of the completion callback, but I do see the virtue of keeping the completion callback safe and having a separate callback for the riskier operation of wrapping the merge. I can certainly make that change if that would be more acceptable. I initially tried to do this with the `TTaskGroup`; unfortunately, with a `TTaskGroup` the calling thread can end up temporarily joining the task arena, which wasn't acceptable to us. It seems we have to use `task_arena::execute()`, which requires access to the framework task arena, which is how I ended using a callback for this. Let me know if separating the merge wrapper into a second callback would be acceptable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:772,performance,schedul,scheduling,772,"@amadio thanks for the comments. How this solves the CMS problem is illustrated by the example callback I included. That wraps the merge operation with an `std::promise()`, does a `task_arena::enqueue()` with that functor to the existing CMS framework TBB task arena, and then waits for the promise to complete. `task_arena::enqueue()` guarantees that the functor is executed by an existing member of the arena's thread pool. If the calling thread is not part of the arena, it cannot join it, so it cannot execute the functor itself. AFAICT, `task_arena::enqueue()` is the only interface that guarantees this; with other interfaces like `task_arena::execute()` or `task_group::run()`, the calling thread can temporarily join the arena, which would violate our framework's scheduling assumptions. wrt the interface change, my previous version added a second callback instead of modifying the existing one. From a functionality standpoint, the wrapper callback is a superset of the completion callback, but I do see the virtue of keeping the completion callback safe and having a separate callback for the riskier operation of wrapping the merge. I can certainly make that change if that would be more acceptable. I initially tried to do this with the `TTaskGroup`; unfortunately, with a `TTaskGroup` the calling thread can end up temporarily joining the task arena, which wasn't acceptable to us. It seems we have to use `task_arena::execute()`, which requires access to the framework task arena, which is how I ended using a callback for this. Let me know if separating the merge wrapper into a second callback would be acceptable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:173,reliability,doe,does,173,"@amadio thanks for the comments. How this solves the CMS problem is illustrated by the example callback I included. That wraps the merge operation with an `std::promise()`, does a `task_arena::enqueue()` with that functor to the existing CMS framework TBB task arena, and then waits for the promise to complete. `task_arena::enqueue()` guarantees that the functor is executed by an existing member of the arena's thread pool. If the calling thread is not part of the arena, it cannot join it, so it cannot execute the functor itself. AFAICT, `task_arena::enqueue()` is the only interface that guarantees this; with other interfaces like `task_arena::execute()` or `task_group::run()`, the calling thread can temporarily join the arena, which would violate our framework's scheduling assumptions. wrt the interface change, my previous version added a second callback instead of modifying the existing one. From a functionality standpoint, the wrapper callback is a superset of the completion callback, but I do see the virtue of keeping the completion callback safe and having a separate callback for the riskier operation of wrapping the merge. I can certainly make that change if that would be more acceptable. I initially tried to do this with the `TTaskGroup`; unfortunately, with a `TTaskGroup` the calling thread can end up temporarily joining the task arena, which wasn't acceptable to us. It seems we have to use `task_arena::execute()`, which requires access to the framework task arena, which is how I ended using a callback for this. Let me know if separating the merge wrapper into a second callback would be acceptable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:302,safety,compl,complete,302,"@amadio thanks for the comments. How this solves the CMS problem is illustrated by the example callback I included. That wraps the merge operation with an `std::promise()`, does a `task_arena::enqueue()` with that functor to the existing CMS framework TBB task arena, and then waits for the promise to complete. `task_arena::enqueue()` guarantees that the functor is executed by an existing member of the arena's thread pool. If the calling thread is not part of the arena, it cannot join it, so it cannot execute the functor itself. AFAICT, `task_arena::enqueue()` is the only interface that guarantees this; with other interfaces like `task_arena::execute()` or `task_group::run()`, the calling thread can temporarily join the arena, which would violate our framework's scheduling assumptions. wrt the interface change, my previous version added a second callback instead of modifying the existing one. From a functionality standpoint, the wrapper callback is a superset of the completion callback, but I do see the virtue of keeping the completion callback safe and having a separate callback for the riskier operation of wrapping the merge. I can certainly make that change if that would be more acceptable. I initially tried to do this with the `TTaskGroup`; unfortunately, with a `TTaskGroup` the calling thread can end up temporarily joining the task arena, which wasn't acceptable to us. It seems we have to use `task_arena::execute()`, which requires access to the framework task arena, which is how I ended using a callback for this. Let me know if separating the merge wrapper into a second callback would be acceptable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:980,safety,compl,completion,980,"@amadio thanks for the comments. How this solves the CMS problem is illustrated by the example callback I included. That wraps the merge operation with an `std::promise()`, does a `task_arena::enqueue()` with that functor to the existing CMS framework TBB task arena, and then waits for the promise to complete. `task_arena::enqueue()` guarantees that the functor is executed by an existing member of the arena's thread pool. If the calling thread is not part of the arena, it cannot join it, so it cannot execute the functor itself. AFAICT, `task_arena::enqueue()` is the only interface that guarantees this; with other interfaces like `task_arena::execute()` or `task_group::run()`, the calling thread can temporarily join the arena, which would violate our framework's scheduling assumptions. wrt the interface change, my previous version added a second callback instead of modifying the existing one. From a functionality standpoint, the wrapper callback is a superset of the completion callback, but I do see the virtue of keeping the completion callback safe and having a separate callback for the riskier operation of wrapping the merge. I can certainly make that change if that would be more acceptable. I initially tried to do this with the `TTaskGroup`; unfortunately, with a `TTaskGroup` the calling thread can end up temporarily joining the task arena, which wasn't acceptable to us. It seems we have to use `task_arena::execute()`, which requires access to the framework task arena, which is how I ended using a callback for this. Let me know if separating the merge wrapper into a second callback would be acceptable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:1040,safety,compl,completion,1040,"@amadio thanks for the comments. How this solves the CMS problem is illustrated by the example callback I included. That wraps the merge operation with an `std::promise()`, does a `task_arena::enqueue()` with that functor to the existing CMS framework TBB task arena, and then waits for the promise to complete. `task_arena::enqueue()` guarantees that the functor is executed by an existing member of the arena's thread pool. If the calling thread is not part of the arena, it cannot join it, so it cannot execute the functor itself. AFAICT, `task_arena::enqueue()` is the only interface that guarantees this; with other interfaces like `task_arena::execute()` or `task_group::run()`, the calling thread can temporarily join the arena, which would violate our framework's scheduling assumptions. wrt the interface change, my previous version added a second callback instead of modifying the existing one. From a functionality standpoint, the wrapper callback is a superset of the completion callback, but I do see the virtue of keeping the completion callback safe and having a separate callback for the riskier operation of wrapping the merge. I can certainly make that change if that would be more acceptable. I initially tried to do this with the `TTaskGroup`; unfortunately, with a `TTaskGroup` the calling thread can end up temporarily joining the task arena, which wasn't acceptable to us. It seems we have to use `task_arena::execute()`, which requires access to the framework task arena, which is how I ended using a callback for this. Let me know if separating the merge wrapper into a second callback would be acceptable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:1060,safety,safe,safe,1060,"@amadio thanks for the comments. How this solves the CMS problem is illustrated by the example callback I included. That wraps the merge operation with an `std::promise()`, does a `task_arena::enqueue()` with that functor to the existing CMS framework TBB task arena, and then waits for the promise to complete. `task_arena::enqueue()` guarantees that the functor is executed by an existing member of the arena's thread pool. If the calling thread is not part of the arena, it cannot join it, so it cannot execute the functor itself. AFAICT, `task_arena::enqueue()` is the only interface that guarantees this; with other interfaces like `task_arena::execute()` or `task_group::run()`, the calling thread can temporarily join the arena, which would violate our framework's scheduling assumptions. wrt the interface change, my previous version added a second callback instead of modifying the existing one. From a functionality standpoint, the wrapper callback is a superset of the completion callback, but I do see the virtue of keeping the completion callback safe and having a separate callback for the riskier operation of wrapping the merge. I can certainly make that change if that would be more acceptable. I initially tried to do this with the `TTaskGroup`; unfortunately, with a `TTaskGroup` the calling thread can end up temporarily joining the task arena, which wasn't acceptable to us. It seems we have to use `task_arena::execute()`, which requires access to the framework task arena, which is how I ended using a callback for this. Let me know if separating the merge wrapper into a second callback would be acceptable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:1104,safety,risk,riskier,1104,"@amadio thanks for the comments. How this solves the CMS problem is illustrated by the example callback I included. That wraps the merge operation with an `std::promise()`, does a `task_arena::enqueue()` with that functor to the existing CMS framework TBB task arena, and then waits for the promise to complete. `task_arena::enqueue()` guarantees that the functor is executed by an existing member of the arena's thread pool. If the calling thread is not part of the arena, it cannot join it, so it cannot execute the functor itself. AFAICT, `task_arena::enqueue()` is the only interface that guarantees this; with other interfaces like `task_arena::execute()` or `task_group::run()`, the calling thread can temporarily join the arena, which would violate our framework's scheduling assumptions. wrt the interface change, my previous version added a second callback instead of modifying the existing one. From a functionality standpoint, the wrapper callback is a superset of the completion callback, but I do see the virtue of keeping the completion callback safe and having a separate callback for the riskier operation of wrapping the merge. I can certainly make that change if that would be more acceptable. I initially tried to do this with the `TTaskGroup`; unfortunately, with a `TTaskGroup` the calling thread can end up temporarily joining the task arena, which wasn't acceptable to us. It seems we have to use `task_arena::execute()`, which requires access to the framework task arena, which is how I ended using a callback for this. Let me know if separating the merge wrapper into a second callback would be acceptable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:302,security,compl,complete,302,"@amadio thanks for the comments. How this solves the CMS problem is illustrated by the example callback I included. That wraps the merge operation with an `std::promise()`, does a `task_arena::enqueue()` with that functor to the existing CMS framework TBB task arena, and then waits for the promise to complete. `task_arena::enqueue()` guarantees that the functor is executed by an existing member of the arena's thread pool. If the calling thread is not part of the arena, it cannot join it, so it cannot execute the functor itself. AFAICT, `task_arena::enqueue()` is the only interface that guarantees this; with other interfaces like `task_arena::execute()` or `task_group::run()`, the calling thread can temporarily join the arena, which would violate our framework's scheduling assumptions. wrt the interface change, my previous version added a second callback instead of modifying the existing one. From a functionality standpoint, the wrapper callback is a superset of the completion callback, but I do see the virtue of keeping the completion callback safe and having a separate callback for the riskier operation of wrapping the merge. I can certainly make that change if that would be more acceptable. I initially tried to do this with the `TTaskGroup`; unfortunately, with a `TTaskGroup` the calling thread can end up temporarily joining the task arena, which wasn't acceptable to us. It seems we have to use `task_arena::execute()`, which requires access to the framework task arena, which is how I ended using a callback for this. Let me know if separating the merge wrapper into a second callback would be acceptable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:877,security,modif,modifying,877,"@amadio thanks for the comments. How this solves the CMS problem is illustrated by the example callback I included. That wraps the merge operation with an `std::promise()`, does a `task_arena::enqueue()` with that functor to the existing CMS framework TBB task arena, and then waits for the promise to complete. `task_arena::enqueue()` guarantees that the functor is executed by an existing member of the arena's thread pool. If the calling thread is not part of the arena, it cannot join it, so it cannot execute the functor itself. AFAICT, `task_arena::enqueue()` is the only interface that guarantees this; with other interfaces like `task_arena::execute()` or `task_group::run()`, the calling thread can temporarily join the arena, which would violate our framework's scheduling assumptions. wrt the interface change, my previous version added a second callback instead of modifying the existing one. From a functionality standpoint, the wrapper callback is a superset of the completion callback, but I do see the virtue of keeping the completion callback safe and having a separate callback for the riskier operation of wrapping the merge. I can certainly make that change if that would be more acceptable. I initially tried to do this with the `TTaskGroup`; unfortunately, with a `TTaskGroup` the calling thread can end up temporarily joining the task arena, which wasn't acceptable to us. It seems we have to use `task_arena::execute()`, which requires access to the framework task arena, which is how I ended using a callback for this. Let me know if separating the merge wrapper into a second callback would be acceptable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:980,security,compl,completion,980,"@amadio thanks for the comments. How this solves the CMS problem is illustrated by the example callback I included. That wraps the merge operation with an `std::promise()`, does a `task_arena::enqueue()` with that functor to the existing CMS framework TBB task arena, and then waits for the promise to complete. `task_arena::enqueue()` guarantees that the functor is executed by an existing member of the arena's thread pool. If the calling thread is not part of the arena, it cannot join it, so it cannot execute the functor itself. AFAICT, `task_arena::enqueue()` is the only interface that guarantees this; with other interfaces like `task_arena::execute()` or `task_group::run()`, the calling thread can temporarily join the arena, which would violate our framework's scheduling assumptions. wrt the interface change, my previous version added a second callback instead of modifying the existing one. From a functionality standpoint, the wrapper callback is a superset of the completion callback, but I do see the virtue of keeping the completion callback safe and having a separate callback for the riskier operation of wrapping the merge. I can certainly make that change if that would be more acceptable. I initially tried to do this with the `TTaskGroup`; unfortunately, with a `TTaskGroup` the calling thread can end up temporarily joining the task arena, which wasn't acceptable to us. It seems we have to use `task_arena::execute()`, which requires access to the framework task arena, which is how I ended using a callback for this. Let me know if separating the merge wrapper into a second callback would be acceptable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:1040,security,compl,completion,1040,"@amadio thanks for the comments. How this solves the CMS problem is illustrated by the example callback I included. That wraps the merge operation with an `std::promise()`, does a `task_arena::enqueue()` with that functor to the existing CMS framework TBB task arena, and then waits for the promise to complete. `task_arena::enqueue()` guarantees that the functor is executed by an existing member of the arena's thread pool. If the calling thread is not part of the arena, it cannot join it, so it cannot execute the functor itself. AFAICT, `task_arena::enqueue()` is the only interface that guarantees this; with other interfaces like `task_arena::execute()` or `task_group::run()`, the calling thread can temporarily join the arena, which would violate our framework's scheduling assumptions. wrt the interface change, my previous version added a second callback instead of modifying the existing one. From a functionality standpoint, the wrapper callback is a superset of the completion callback, but I do see the virtue of keeping the completion callback safe and having a separate callback for the riskier operation of wrapping the merge. I can certainly make that change if that would be more acceptable. I initially tried to do this with the `TTaskGroup`; unfortunately, with a `TTaskGroup` the calling thread can end up temporarily joining the task arena, which wasn't acceptable to us. It seems we have to use `task_arena::execute()`, which requires access to the framework task arena, which is how I ended using a callback for this. Let me know if separating the merge wrapper into a second callback would be acceptable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:1104,security,risk,riskier,1104,"@amadio thanks for the comments. How this solves the CMS problem is illustrated by the example callback I included. That wraps the merge operation with an `std::promise()`, does a `task_arena::enqueue()` with that functor to the existing CMS framework TBB task arena, and then waits for the promise to complete. `task_arena::enqueue()` guarantees that the functor is executed by an existing member of the arena's thread pool. If the calling thread is not part of the arena, it cannot join it, so it cannot execute the functor itself. AFAICT, `task_arena::enqueue()` is the only interface that guarantees this; with other interfaces like `task_arena::execute()` or `task_group::run()`, the calling thread can temporarily join the arena, which would violate our framework's scheduling assumptions. wrt the interface change, my previous version added a second callback instead of modifying the existing one. From a functionality standpoint, the wrapper callback is a superset of the completion callback, but I do see the virtue of keeping the completion callback safe and having a separate callback for the riskier operation of wrapping the merge. I can certainly make that change if that would be more acceptable. I initially tried to do this with the `TTaskGroup`; unfortunately, with a `TTaskGroup` the calling thread can end up temporarily joining the task arena, which wasn't acceptable to us. It seems we have to use `task_arena::execute()`, which requires access to the framework task arena, which is how I ended using a callback for this. Let me know if separating the merge wrapper into a second callback would be acceptable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:1460,security,access,access,1460,"@amadio thanks for the comments. How this solves the CMS problem is illustrated by the example callback I included. That wraps the merge operation with an `std::promise()`, does a `task_arena::enqueue()` with that functor to the existing CMS framework TBB task arena, and then waits for the promise to complete. `task_arena::enqueue()` guarantees that the functor is executed by an existing member of the arena's thread pool. If the calling thread is not part of the arena, it cannot join it, so it cannot execute the functor itself. AFAICT, `task_arena::enqueue()` is the only interface that guarantees this; with other interfaces like `task_arena::execute()` or `task_group::run()`, the calling thread can temporarily join the arena, which would violate our framework's scheduling assumptions. wrt the interface change, my previous version added a second callback instead of modifying the existing one. From a functionality standpoint, the wrapper callback is a superset of the completion callback, but I do see the virtue of keeping the completion callback safe and having a separate callback for the riskier operation of wrapping the merge. I can certainly make that change if that would be more acceptable. I initially tried to do this with the `TTaskGroup`; unfortunately, with a `TTaskGroup` the calling thread can end up temporarily joining the task arena, which wasn't acceptable to us. It seems we have to use `task_arena::execute()`, which requires access to the framework task arena, which is how I ended using a callback for this. Let me know if separating the merge wrapper into a second callback would be acceptable.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:241,integrability,buffer,buffer,241,"@dan131riley What I had in mind was to replace the `WriteOutputFile()` function that now runs in a separate thread with a different function that does only one merging step and then calling that function from the worker threads/tasks when a buffer is pushed. That is, when the worker task or thread calls `Write()` on the `TBufferMergerFile` and something gets pushed to the queue, there will be a check that launches a merge task if needed. That way we completely do away with the extra thread. What do you think?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:375,integrability,queue,queue,375,"@dan131riley What I had in mind was to replace the `WriteOutputFile()` function that now runs in a separate thread with a different function that does only one merging step and then calling that function from the worker threads/tasks when a buffer is pushed. That is, when the worker task or thread calls `Write()` on the `TBufferMergerFile` and something gets pushed to the queue, there will be a check that launches a merge task if needed. That way we completely do away with the extra thread. What do you think?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:375,performance,queue,queue,375,"@dan131riley What I had in mind was to replace the `WriteOutputFile()` function that now runs in a separate thread with a different function that does only one merging step and then calling that function from the worker threads/tasks when a buffer is pushed. That is, when the worker task or thread calls `Write()` on the `TBufferMergerFile` and something gets pushed to the queue, there will be a check that launches a merge task if needed. That way we completely do away with the extra thread. What do you think?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:146,reliability,doe,does,146,"@dan131riley What I had in mind was to replace the `WriteOutputFile()` function that now runs in a separate thread with a different function that does only one merging step and then calling that function from the worker threads/tasks when a buffer is pushed. That is, when the worker task or thread calls `Write()` on the `TBufferMergerFile` and something gets pushed to the queue, there will be a check that launches a merge task if needed. That way we completely do away with the extra thread. What do you think?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:454,safety,compl,completely,454,"@dan131riley What I had in mind was to replace the `WriteOutputFile()` function that now runs in a separate thread with a different function that does only one merging step and then calling that function from the worker threads/tasks when a buffer is pushed. That is, when the worker task or thread calls `Write()` on the `TBufferMergerFile` and something gets pushed to the queue, there will be a check that launches a merge task if needed. That way we completely do away with the extra thread. What do you think?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:454,security,compl,completely,454,"@dan131riley What I had in mind was to replace the `WriteOutputFile()` function that now runs in a separate thread with a different function that does only one merging step and then calling that function from the worker threads/tasks when a buffer is pushed. That is, when the worker task or thread calls `Write()` on the `TBufferMergerFile` and something gets pushed to the queue, there will be a check that launches a merge task if needed. That way we completely do away with the extra thread. What do you think?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:128,testability,plan,plan,128,"> so we would get rid of the extra thread, and instead use a TTaskGroup to run a merge task when needed. Yes, that is what I am plan to do.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:50,integrability,sub,submitted,50,"Ok, I'll close this pull request as improvidently submitted. @amadio let me know if there's anything I can do to help with your proposal.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:9,usability,close,close,9,"Ok, I'll close this pull request as improvidently submitted. @amadio let me know if there's anything I can do to help with your proposal.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1706:113,usability,help,help,113,"Ok, I'll close this pull request as improvidently submitted. @amadio let me know if there's anything I can do to help with your proposal.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1706
https://github.com/root-project/root/pull/1707:548,availability,sli,slightly,548,"Hi @pcanal : great - really nice. Thanks for diving into this. I can suggest a test:. ```. using namespace ROOT::Experimental;. using MyVec_t = std::vector<int,VecOps::TAdoptAllocator<int>>;. TDataFrame d(4);. auto sd = d.Define(""v"", [](){return MyVec_t{1,2,3};}).Snapshot<MyVec_t>(""t"",""ofile.root"",{""v""});. auto checker = [](const MyVec_t &v){. EXPECT_EQ(size_t(3), v.size());. EXPECT_EQ(1, v[0]);. EXPECT_EQ(2, v[2]);. EXPECT_EQ(3, v[3]);. };. sd.Foreach(checker, {""v""});. ```. This solution will make the treatment of vectors with custom allocs slightly slower than ""traditional"" vectors, right? (whatever the answer this PR is a clear improvement of course!)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:557,availability,slo,slower,557,"Hi @pcanal : great - really nice. Thanks for diving into this. I can suggest a test:. ```. using namespace ROOT::Experimental;. using MyVec_t = std::vector<int,VecOps::TAdoptAllocator<int>>;. TDataFrame d(4);. auto sd = d.Define(""v"", [](){return MyVec_t{1,2,3};}).Snapshot<MyVec_t>(""t"",""ofile.root"",{""v""});. auto checker = [](const MyVec_t &v){. EXPECT_EQ(size_t(3), v.size());. EXPECT_EQ(1, v[0]);. EXPECT_EQ(2, v[2]);. EXPECT_EQ(3, v[3]);. };. sd.Foreach(checker, {""v""});. ```. This solution will make the treatment of vectors with custom allocs slightly slower than ""traditional"" vectors, right? (whatever the answer this PR is a clear improvement of course!)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:541,energy efficiency,alloc,allocs,541,"Hi @pcanal : great - really nice. Thanks for diving into this. I can suggest a test:. ```. using namespace ROOT::Experimental;. using MyVec_t = std::vector<int,VecOps::TAdoptAllocator<int>>;. TDataFrame d(4);. auto sd = d.Define(""v"", [](){return MyVec_t{1,2,3};}).Snapshot<MyVec_t>(""t"",""ofile.root"",{""v""});. auto checker = [](const MyVec_t &v){. EXPECT_EQ(size_t(3), v.size());. EXPECT_EQ(1, v[0]);. EXPECT_EQ(2, v[2]);. EXPECT_EQ(3, v[3]);. };. sd.Foreach(checker, {""v""});. ```. This solution will make the treatment of vectors with custom allocs slightly slower than ""traditional"" vectors, right? (whatever the answer this PR is a clear improvement of course!)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:548,reliability,sli,slightly,548,"Hi @pcanal : great - really nice. Thanks for diving into this. I can suggest a test:. ```. using namespace ROOT::Experimental;. using MyVec_t = std::vector<int,VecOps::TAdoptAllocator<int>>;. TDataFrame d(4);. auto sd = d.Define(""v"", [](){return MyVec_t{1,2,3};}).Snapshot<MyVec_t>(""t"",""ofile.root"",{""v""});. auto checker = [](const MyVec_t &v){. EXPECT_EQ(size_t(3), v.size());. EXPECT_EQ(1, v[0]);. EXPECT_EQ(2, v[2]);. EXPECT_EQ(3, v[3]);. };. sd.Foreach(checker, {""v""});. ```. This solution will make the treatment of vectors with custom allocs slightly slower than ""traditional"" vectors, right? (whatever the answer this PR is a clear improvement of course!)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:557,reliability,slo,slower,557,"Hi @pcanal : great - really nice. Thanks for diving into this. I can suggest a test:. ```. using namespace ROOT::Experimental;. using MyVec_t = std::vector<int,VecOps::TAdoptAllocator<int>>;. TDataFrame d(4);. auto sd = d.Define(""v"", [](){return MyVec_t{1,2,3};}).Snapshot<MyVec_t>(""t"",""ofile.root"",{""v""});. auto checker = [](const MyVec_t &v){. EXPECT_EQ(size_t(3), v.size());. EXPECT_EQ(1, v[0]);. EXPECT_EQ(2, v[2]);. EXPECT_EQ(3, v[3]);. };. sd.Foreach(checker, {""v""});. ```. This solution will make the treatment of vectors with custom allocs slightly slower than ""traditional"" vectors, right? (whatever the answer this PR is a clear improvement of course!)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:79,safety,test,test,79,"Hi @pcanal : great - really nice. Thanks for diving into this. I can suggest a test:. ```. using namespace ROOT::Experimental;. using MyVec_t = std::vector<int,VecOps::TAdoptAllocator<int>>;. TDataFrame d(4);. auto sd = d.Define(""v"", [](){return MyVec_t{1,2,3};}).Snapshot<MyVec_t>(""t"",""ofile.root"",{""v""});. auto checker = [](const MyVec_t &v){. EXPECT_EQ(size_t(3), v.size());. EXPECT_EQ(1, v[0]);. EXPECT_EQ(2, v[2]);. EXPECT_EQ(3, v[3]);. };. sd.Foreach(checker, {""v""});. ```. This solution will make the treatment of vectors with custom allocs slightly slower than ""traditional"" vectors, right? (whatever the answer this PR is a clear improvement of course!)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:79,testability,test,test,79,"Hi @pcanal : great - really nice. Thanks for diving into this. I can suggest a test:. ```. using namespace ROOT::Experimental;. using MyVec_t = std::vector<int,VecOps::TAdoptAllocator<int>>;. TDataFrame d(4);. auto sd = d.Define(""v"", [](){return MyVec_t{1,2,3};}).Snapshot<MyVec_t>(""t"",""ofile.root"",{""v""});. auto checker = [](const MyVec_t &v){. EXPECT_EQ(size_t(3), v.size());. EXPECT_EQ(1, v[0]);. EXPECT_EQ(2, v[2]);. EXPECT_EQ(3, v[3]);. };. sd.Foreach(checker, {""v""});. ```. This solution will make the treatment of vectors with custom allocs slightly slower than ""traditional"" vectors, right? (whatever the answer this PR is a clear improvement of course!)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:534,usability,custom,custom,534,"Hi @pcanal : great - really nice. Thanks for diving into this. I can suggest a test:. ```. using namespace ROOT::Experimental;. using MyVec_t = std::vector<int,VecOps::TAdoptAllocator<int>>;. TDataFrame d(4);. auto sd = d.Define(""v"", [](){return MyVec_t{1,2,3};}).Snapshot<MyVec_t>(""t"",""ofile.root"",{""v""});. auto checker = [](const MyVec_t &v){. EXPECT_EQ(size_t(3), v.size());. EXPECT_EQ(1, v[0]);. EXPECT_EQ(2, v[2]);. EXPECT_EQ(3, v[3]);. };. sd.Foreach(checker, {""v""});. ```. This solution will make the treatment of vectors with custom allocs slightly slower than ""traditional"" vectors, right? (whatever the answer this PR is a clear improvement of course!)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:633,usability,clear,clear,633,"Hi @pcanal : great - really nice. Thanks for diving into this. I can suggest a test:. ```. using namespace ROOT::Experimental;. using MyVec_t = std::vector<int,VecOps::TAdoptAllocator<int>>;. TDataFrame d(4);. auto sd = d.Define(""v"", [](){return MyVec_t{1,2,3};}).Snapshot<MyVec_t>(""t"",""ofile.root"",{""v""});. auto checker = [](const MyVec_t &v){. EXPECT_EQ(size_t(3), v.size());. EXPECT_EQ(1, v[0]);. EXPECT_EQ(2, v[2]);. EXPECT_EQ(3, v[3]);. };. sd.Foreach(checker, {""v""});. ```. This solution will make the treatment of vectors with custom allocs slightly slower than ""traditional"" vectors, right? (whatever the answer this PR is a clear improvement of course!)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:427,availability,slo,slower,427,"On linux vector with custom allocator do indeed have a different layout that vector with the default allocator, The reason is that std::vector is that case ""starts' with an embedded instance of the allocator ... I am guessing that on MacOS the allocator is at the end instead .... I corrected the behavior of TStreamerInfo to not use the 'vector-shortcut' in the case of vector with custom allocator. This makes is go somewhat slower but at least works correctly. Since all vectors with the same custom allocator have the same layout, we could recover the performance by embedded support for VecOps::TAdoptAllocator directly in TStreamerInfo's actions.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:544,availability,recov,recover,544,"On linux vector with custom allocator do indeed have a different layout that vector with the default allocator, The reason is that std::vector is that case ""starts' with an embedded instance of the allocator ... I am guessing that on MacOS the allocator is at the end instead .... I corrected the behavior of TStreamerInfo to not use the 'vector-shortcut' in the case of vector with custom allocator. This makes is go somewhat slower but at least works correctly. Since all vectors with the same custom allocator have the same layout, we could recover the performance by embedded support for VecOps::TAdoptAllocator directly in TStreamerInfo's actions.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:544,deployability,recov,recover,544,"On linux vector with custom allocator do indeed have a different layout that vector with the default allocator, The reason is that std::vector is that case ""starts' with an embedded instance of the allocator ... I am guessing that on MacOS the allocator is at the end instead .... I corrected the behavior of TStreamerInfo to not use the 'vector-shortcut' in the case of vector with custom allocator. This makes is go somewhat slower but at least works correctly. Since all vectors with the same custom allocator have the same layout, we could recover the performance by embedded support for VecOps::TAdoptAllocator directly in TStreamerInfo's actions.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:28,energy efficiency,alloc,allocator,28,"On linux vector with custom allocator do indeed have a different layout that vector with the default allocator, The reason is that std::vector is that case ""starts' with an embedded instance of the allocator ... I am guessing that on MacOS the allocator is at the end instead .... I corrected the behavior of TStreamerInfo to not use the 'vector-shortcut' in the case of vector with custom allocator. This makes is go somewhat slower but at least works correctly. Since all vectors with the same custom allocator have the same layout, we could recover the performance by embedded support for VecOps::TAdoptAllocator directly in TStreamerInfo's actions.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:101,energy efficiency,alloc,allocator,101,"On linux vector with custom allocator do indeed have a different layout that vector with the default allocator, The reason is that std::vector is that case ""starts' with an embedded instance of the allocator ... I am guessing that on MacOS the allocator is at the end instead .... I corrected the behavior of TStreamerInfo to not use the 'vector-shortcut' in the case of vector with custom allocator. This makes is go somewhat slower but at least works correctly. Since all vectors with the same custom allocator have the same layout, we could recover the performance by embedded support for VecOps::TAdoptAllocator directly in TStreamerInfo's actions.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:198,energy efficiency,alloc,allocator,198,"On linux vector with custom allocator do indeed have a different layout that vector with the default allocator, The reason is that std::vector is that case ""starts' with an embedded instance of the allocator ... I am guessing that on MacOS the allocator is at the end instead .... I corrected the behavior of TStreamerInfo to not use the 'vector-shortcut' in the case of vector with custom allocator. This makes is go somewhat slower but at least works correctly. Since all vectors with the same custom allocator have the same layout, we could recover the performance by embedded support for VecOps::TAdoptAllocator directly in TStreamerInfo's actions.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:244,energy efficiency,alloc,allocator,244,"On linux vector with custom allocator do indeed have a different layout that vector with the default allocator, The reason is that std::vector is that case ""starts' with an embedded instance of the allocator ... I am guessing that on MacOS the allocator is at the end instead .... I corrected the behavior of TStreamerInfo to not use the 'vector-shortcut' in the case of vector with custom allocator. This makes is go somewhat slower but at least works correctly. Since all vectors with the same custom allocator have the same layout, we could recover the performance by embedded support for VecOps::TAdoptAllocator directly in TStreamerInfo's actions.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:390,energy efficiency,alloc,allocator,390,"On linux vector with custom allocator do indeed have a different layout that vector with the default allocator, The reason is that std::vector is that case ""starts' with an embedded instance of the allocator ... I am guessing that on MacOS the allocator is at the end instead .... I corrected the behavior of TStreamerInfo to not use the 'vector-shortcut' in the case of vector with custom allocator. This makes is go somewhat slower but at least works correctly. Since all vectors with the same custom allocator have the same layout, we could recover the performance by embedded support for VecOps::TAdoptAllocator directly in TStreamerInfo's actions.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:503,energy efficiency,alloc,allocator,503,"On linux vector with custom allocator do indeed have a different layout that vector with the default allocator, The reason is that std::vector is that case ""starts' with an embedded instance of the allocator ... I am guessing that on MacOS the allocator is at the end instead .... I corrected the behavior of TStreamerInfo to not use the 'vector-shortcut' in the case of vector with custom allocator. This makes is go somewhat slower but at least works correctly. Since all vectors with the same custom allocator have the same layout, we could recover the performance by embedded support for VecOps::TAdoptAllocator directly in TStreamerInfo's actions.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:556,performance,perform,performance,556,"On linux vector with custom allocator do indeed have a different layout that vector with the default allocator, The reason is that std::vector is that case ""starts' with an embedded instance of the allocator ... I am guessing that on MacOS the allocator is at the end instead .... I corrected the behavior of TStreamerInfo to not use the 'vector-shortcut' in the case of vector with custom allocator. This makes is go somewhat slower but at least works correctly. Since all vectors with the same custom allocator have the same layout, we could recover the performance by embedded support for VecOps::TAdoptAllocator directly in TStreamerInfo's actions.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:427,reliability,slo,slower,427,"On linux vector with custom allocator do indeed have a different layout that vector with the default allocator, The reason is that std::vector is that case ""starts' with an embedded instance of the allocator ... I am guessing that on MacOS the allocator is at the end instead .... I corrected the behavior of TStreamerInfo to not use the 'vector-shortcut' in the case of vector with custom allocator. This makes is go somewhat slower but at least works correctly. Since all vectors with the same custom allocator have the same layout, we could recover the performance by embedded support for VecOps::TAdoptAllocator directly in TStreamerInfo's actions.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:544,reliability,recov,recover,544,"On linux vector with custom allocator do indeed have a different layout that vector with the default allocator, The reason is that std::vector is that case ""starts' with an embedded instance of the allocator ... I am guessing that on MacOS the allocator is at the end instead .... I corrected the behavior of TStreamerInfo to not use the 'vector-shortcut' in the case of vector with custom allocator. This makes is go somewhat slower but at least works correctly. Since all vectors with the same custom allocator have the same layout, we could recover the performance by embedded support for VecOps::TAdoptAllocator directly in TStreamerInfo's actions.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:544,safety,recov,recover,544,"On linux vector with custom allocator do indeed have a different layout that vector with the default allocator, The reason is that std::vector is that case ""starts' with an embedded instance of the allocator ... I am guessing that on MacOS the allocator is at the end instead .... I corrected the behavior of TStreamerInfo to not use the 'vector-shortcut' in the case of vector with custom allocator. This makes is go somewhat slower but at least works correctly. Since all vectors with the same custom allocator have the same layout, we could recover the performance by embedded support for VecOps::TAdoptAllocator directly in TStreamerInfo's actions.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:544,security,recov,recover,544,"On linux vector with custom allocator do indeed have a different layout that vector with the default allocator, The reason is that std::vector is that case ""starts' with an embedded instance of the allocator ... I am guessing that on MacOS the allocator is at the end instead .... I corrected the behavior of TStreamerInfo to not use the 'vector-shortcut' in the case of vector with custom allocator. This makes is go somewhat slower but at least works correctly. Since all vectors with the same custom allocator have the same layout, we could recover the performance by embedded support for VecOps::TAdoptAllocator directly in TStreamerInfo's actions.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:21,usability,custom,custom,21,"On linux vector with custom allocator do indeed have a different layout that vector with the default allocator, The reason is that std::vector is that case ""starts' with an embedded instance of the allocator ... I am guessing that on MacOS the allocator is at the end instead .... I corrected the behavior of TStreamerInfo to not use the 'vector-shortcut' in the case of vector with custom allocator. This makes is go somewhat slower but at least works correctly. Since all vectors with the same custom allocator have the same layout, we could recover the performance by embedded support for VecOps::TAdoptAllocator directly in TStreamerInfo's actions.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:297,usability,behavi,behavior,297,"On linux vector with custom allocator do indeed have a different layout that vector with the default allocator, The reason is that std::vector is that case ""starts' with an embedded instance of the allocator ... I am guessing that on MacOS the allocator is at the end instead .... I corrected the behavior of TStreamerInfo to not use the 'vector-shortcut' in the case of vector with custom allocator. This makes is go somewhat slower but at least works correctly. Since all vectors with the same custom allocator have the same layout, we could recover the performance by embedded support for VecOps::TAdoptAllocator directly in TStreamerInfo's actions.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:346,usability,shortcut,shortcut,346,"On linux vector with custom allocator do indeed have a different layout that vector with the default allocator, The reason is that std::vector is that case ""starts' with an embedded instance of the allocator ... I am guessing that on MacOS the allocator is at the end instead .... I corrected the behavior of TStreamerInfo to not use the 'vector-shortcut' in the case of vector with custom allocator. This makes is go somewhat slower but at least works correctly. Since all vectors with the same custom allocator have the same layout, we could recover the performance by embedded support for VecOps::TAdoptAllocator directly in TStreamerInfo's actions.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:383,usability,custom,custom,383,"On linux vector with custom allocator do indeed have a different layout that vector with the default allocator, The reason is that std::vector is that case ""starts' with an embedded instance of the allocator ... I am guessing that on MacOS the allocator is at the end instead .... I corrected the behavior of TStreamerInfo to not use the 'vector-shortcut' in the case of vector with custom allocator. This makes is go somewhat slower but at least works correctly. Since all vectors with the same custom allocator have the same layout, we could recover the performance by embedded support for VecOps::TAdoptAllocator directly in TStreamerInfo's actions.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:496,usability,custom,custom,496,"On linux vector with custom allocator do indeed have a different layout that vector with the default allocator, The reason is that std::vector is that case ""starts' with an embedded instance of the allocator ... I am guessing that on MacOS the allocator is at the end instead .... I corrected the behavior of TStreamerInfo to not use the 'vector-shortcut' in the case of vector with custom allocator. This makes is go somewhat slower but at least works correctly. Since all vectors with the same custom allocator have the same layout, we could recover the performance by embedded support for VecOps::TAdoptAllocator directly in TStreamerInfo's actions.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:556,usability,perform,performance,556,"On linux vector with custom allocator do indeed have a different layout that vector with the default allocator, The reason is that std::vector is that case ""starts' with an embedded instance of the allocator ... I am guessing that on MacOS the allocator is at the end instead .... I corrected the behavior of TStreamerInfo to not use the 'vector-shortcut' in the case of vector with custom allocator. This makes is go somewhat slower but at least works correctly. Since all vectors with the same custom allocator have the same layout, we could recover the performance by embedded support for VecOps::TAdoptAllocator directly in TStreamerInfo's actions.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:580,usability,support,support,580,"On linux vector with custom allocator do indeed have a different layout that vector with the default allocator, The reason is that std::vector is that case ""starts' with an embedded instance of the allocator ... I am guessing that on MacOS the allocator is at the end instead .... I corrected the behavior of TStreamerInfo to not use the 'vector-shortcut' in the case of vector with custom allocator. This makes is go somewhat slower but at least works correctly. Since all vectors with the same custom allocator have the same layout, we could recover the performance by embedded support for VecOps::TAdoptAllocator directly in TStreamerInfo's actions.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:103,deployability,configurat,configuration,103,"I could verify that very difference in layout on linux and osx, I bet on Windows there will be a third configuration (data begin, allocator, vector size :) ). I wonder if maybe we can detect this (at build time?) and go through the fast path if possible without checking the platform name itself but just the vector layout...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:200,deployability,build,build,200,"I could verify that very difference in layout on linux and osx, I bet on Windows there will be a third configuration (data begin, allocator, vector size :) ). I wonder if maybe we can detect this (at build time?) and go through the fast path if possible without checking the platform name itself but just the vector layout...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:130,energy efficiency,alloc,allocator,130,"I could verify that very difference in layout on linux and osx, I bet on Windows there will be a third configuration (data begin, allocator, vector size :) ). I wonder if maybe we can detect this (at build time?) and go through the fast path if possible without checking the platform name itself but just the vector layout...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:103,integrability,configur,configuration,103,"I could verify that very difference in layout on linux and osx, I bet on Windows there will be a third configuration (data begin, allocator, vector size :) ). I wonder if maybe we can detect this (at build time?) and go through the fast path if possible without checking the platform name itself but just the vector layout...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:275,interoperability,platform,platform,275,"I could verify that very difference in layout on linux and osx, I bet on Windows there will be a third configuration (data begin, allocator, vector size :) ). I wonder if maybe we can detect this (at build time?) and go through the fast path if possible without checking the platform name itself but just the vector layout...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:103,modifiability,configur,configuration,103,"I could verify that very difference in layout on linux and osx, I bet on Windows there will be a third configuration (data begin, allocator, vector size :) ). I wonder if maybe we can detect this (at build time?) and go through the fast path if possible without checking the platform name itself but just the vector layout...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:206,performance,time,time,206,"I could verify that very difference in layout on linux and osx, I bet on Windows there will be a third configuration (data begin, allocator, vector size :) ). I wonder if maybe we can detect this (at build time?) and go through the fast path if possible without checking the platform name itself but just the vector layout...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:184,safety,detect,detect,184,"I could verify that very difference in layout on linux and osx, I bet on Windows there will be a third configuration (data begin, allocator, vector size :) ). I wonder if maybe we can detect this (at build time?) and go through the fast path if possible without checking the platform name itself but just the vector layout...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:103,security,configur,configuration,103,"I could verify that very difference in layout on linux and osx, I bet on Windows there will be a third configuration (data begin, allocator, vector size :) ). I wonder if maybe we can detect this (at build time?) and go through the fast path if possible without checking the platform name itself but just the vector layout...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:184,security,detect,detect,184,"I could verify that very difference in layout on linux and osx, I bet on Windows there will be a third configuration (data begin, allocator, vector size :) ). I wonder if maybe we can detect this (at build time?) and go through the fast path if possible without checking the platform name itself but just the vector layout...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:8,testability,verif,verify,8,"I could verify that very difference in layout on linux and osx, I bet on Windows there will be a third configuration (data begin, allocator, vector size :) ). I wonder if maybe we can detect this (at build time?) and go through the fast path if possible without checking the platform name itself but just the vector layout...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:0,safety,Test,Tests,0,Tests are coming: https://github.com/root-project/root/pull/1711,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1707:0,testability,Test,Tests,0,Tests are coming: https://github.com/root-project/root/pull/1711,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1707
https://github.com/root-project/root/pull/1708:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1708
https://github.com/root-project/root/pull/1709:26,integrability,sub,submitting,26,"Hi @juanfe, thank you for submitting this tutorial. A general comment I have is: for your tutorial to look better in notebook form, can you split it in code blocks with their corresponding comments, which then will be translated to notebook cells? E.g.:. ```python. # Here I explain what the following lines do, this will be converted to a text cell. Here I put. my code lines. This will be all. in the same code cell. # Here I start another text cell. Here is the code . for another. code cell. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1709
https://github.com/root-project/root/pull/1709:218,integrability,translat,translated,218,"Hi @juanfe, thank you for submitting this tutorial. A general comment I have is: for your tutorial to look better in notebook form, can you split it in code blocks with their corresponding comments, which then will be translated to notebook cells? E.g.:. ```python. # Here I explain what the following lines do, this will be converted to a text cell. Here I put. my code lines. This will be all. in the same code cell. # Here I start another text cell. Here is the code . for another. code cell. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1709
https://github.com/root-project/root/pull/1709:218,interoperability,translat,translated,218,"Hi @juanfe, thank you for submitting this tutorial. A general comment I have is: for your tutorial to look better in notebook form, can you split it in code blocks with their corresponding comments, which then will be translated to notebook cells? E.g.:. ```python. # Here I explain what the following lines do, this will be converted to a text cell. Here I put. my code lines. This will be all. in the same code cell. # Here I start another text cell. Here is the code . for another. code cell. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1709
https://github.com/root-project/root/pull/1709:103,integrability,complian,compliant,103,"Hi @juanfe , thank you for addressing @dpiparo's comments. Please also make the tutorial more notebook-compliant as I explain in my comment and we will be good to go!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1709
https://github.com/root-project/root/pull/1709:103,safety,compl,compliant,103,"Hi @juanfe , thank you for addressing @dpiparo's comments. Please also make the tutorial more notebook-compliant as I explain in my comment and we will be good to go!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1709
https://github.com/root-project/root/pull/1709:103,security,compl,compliant,103,"Hi @juanfe , thank you for addressing @dpiparo's comments. Please also make the tutorial more notebook-compliant as I explain in my comment and we will be good to go!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1709
https://github.com/root-project/root/pull/1709:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1709
https://github.com/root-project/root/pull/1709:75,deployability,build,builds,75,@dpiparo is this PR ok for you too? If so I will squash and merge once the builds confirm,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1709
https://github.com/root-project/root/pull/1709:82,usability,confirm,confirm,82,@dpiparo is this PR ok for you too? If so I will squash and merge once the builds confirm,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1709
https://github.com/root-project/root/pull/1710:60,reliability,doe,does,60,The Jira report ROOT-9229 mentioned in the title of this PR does not seem related to rootls. https://sft.its.cern.ch/jira/browse/ROOT-9229,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1710
https://github.com/root-project/root/pull/1712:43,integrability,coupl,couple,43,@dpiparo this is what we were discussing a couple of days ago.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:43,modifiability,coupl,couple,43,@dpiparo this is what we were discussing a couple of days ago.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:43,testability,coupl,couple,43,@dpiparo this is what we were discussing a couple of days ago.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:165,interoperability,conflict,conflict,165,"Hi @ktf , impressive piece of code and finished so quickly! Were you testing it with something we can promote to gtests or roottests? Minor note: I think there is a conflict in the PR..",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:69,safety,test,testing,69,"Hi @ktf , impressive piece of code and finished so quickly! Were you testing it with something we can promote to gtests or roottests? Minor note: I think there is a conflict in the PR..",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:69,testability,test,testing,69,"Hi @ktf , impressive piece of code and finished so quickly! Were you testing it with something we can promote to gtests or roottests? Minor note: I think there is a conflict in the PR..",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:21,interoperability,conflict,conflicts,21,"@dpiparo I fixed the conflicts. There should be a test already, copy-cat from `datasource_csv.cxx`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:50,safety,test,test,50,"@dpiparo I fixed the conflicts. There should be a test already, copy-cat from `datasource_csv.cxx`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:50,testability,test,test,50,"@dpiparo I fixed the conflicts. There should be a test already, copy-cat from `datasource_csv.cxx`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:32,safety,avoid,avoid,32,Could you rework the commits to avoid any 'Merge' commit? thanks.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:44,energy efficiency,current,current,44,"@pcanal sure, I've rebased it on top of the current master tip.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:59,usability,tip,tip,59,"@pcanal sure, I've rebased it on top of the current master tip.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:58,availability,state,statements,58,Whats the rule here? I see plenty of different copyright statements in the project and under international law adding code authors copyright statements is the correct thing to do. This of course does not mean that the code is not licensed under ROOT terms.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:142,availability,state,statements,142,Whats the rule here? I see plenty of different copyright statements in the project and under international law adding code authors copyright statements is the correct thing to do. This of course does not mean that the code is not licensed under ROOT terms.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:58,integrability,state,statements,58,Whats the rule here? I see plenty of different copyright statements in the project and under international law adding code authors copyright statements is the correct thing to do. This of course does not mean that the code is not licensed under ROOT terms.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:142,integrability,state,statements,142,Whats the rule here? I see plenty of different copyright statements in the project and under international law adding code authors copyright statements is the correct thing to do. This of course does not mean that the code is not licensed under ROOT terms.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:196,reliability,doe,does,196,Whats the rule here? I see plenty of different copyright statements in the project and under international law adding code authors copyright statements is the correct thing to do. This of course does not mean that the code is not licensed under ROOT terms.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:124,security,auth,authors,124,Whats the rule here? I see plenty of different copyright statements in the project and under international law adding code authors copyright statements is the correct thing to do. This of course does not mean that the code is not licensed under ROOT terms.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:31,safety,test,test,31,"Hi @ktf , thanks. I missed the test case before sorry!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:31,testability,test,test,31,"Hi @ktf , thanks. I missed the test case before sorry!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:29,modifiability,pac,package,29,"large originally independent package are the (debatable) exceptions (roofit, tmva), otherwise we request for all files to have the same copyright and licenses. for simplicity and clarity. thanks.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:57,safety,except,exceptions,57,"large originally independent package are the (debatable) exceptions (roofit, tmva), otherwise we request for all files to have the same copyright and licenses. for simplicity and clarity. thanks.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:164,testability,simpl,simplicity,164,"large originally independent package are the (debatable) exceptions (roofit, tmva), otherwise we request for all files to have the same copyright and licenses. for simplicity and clarity. thanks.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:164,usability,simpl,simplicity,164,"large originally independent package are the (debatable) exceptions (roofit, tmva), otherwise we request for all files to have the same copyright and licenses. for simplicity and clarity. thanks.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:179,usability,clarit,clarity,179,"large originally independent package are the (debatable) exceptions (roofit, tmva), otherwise we request for all files to have the same copyright and licenses. for simplicity and clarity. thanks.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:258,availability,avail,available,258,"@ktf, if you find a minute, a nice way to complement the development could be:. - A tutorial in C++ and Python to illustrate the usage of the source. - A set of doxygen comments to describe the api, for example usage of columns in the ctor. As we said, I am available to give a hand.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:194,deployability,api,api,194,"@ktf, if you find a minute, a nice way to complement the development could be:. - A tutorial in C++ and Python to illustrate the usage of the source. - A set of doxygen comments to describe the api, for example usage of columns in the ctor. As we said, I am available to give a hand.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:194,integrability,api,api,194,"@ktf, if you find a minute, a nice way to complement the development could be:. - A tutorial in C++ and Python to illustrate the usage of the source. - A set of doxygen comments to describe the api, for example usage of columns in the ctor. As we said, I am available to give a hand.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:194,interoperability,api,api,194,"@ktf, if you find a minute, a nice way to complement the development could be:. - A tutorial in C++ and Python to illustrate the usage of the source. - A set of doxygen comments to describe the api, for example usage of columns in the ctor. As we said, I am available to give a hand.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:258,reliability,availab,available,258,"@ktf, if you find a minute, a nice way to complement the development could be:. - A tutorial in C++ and Python to illustrate the usage of the source. - A set of doxygen comments to describe the api, for example usage of columns in the ctor. As we said, I am available to give a hand.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:42,safety,compl,complement,42,"@ktf, if you find a minute, a nice way to complement the development could be:. - A tutorial in C++ and Python to illustrate the usage of the source. - A set of doxygen comments to describe the api, for example usage of columns in the ctor. As we said, I am available to give a hand.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:258,safety,avail,available,258,"@ktf, if you find a minute, a nice way to complement the development could be:. - A tutorial in C++ and Python to illustrate the usage of the source. - A set of doxygen comments to describe the api, for example usage of columns in the ctor. As we said, I am available to give a hand.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:42,security,compl,complement,42,"@ktf, if you find a minute, a nice way to complement the development could be:. - A tutorial in C++ and Python to illustrate the usage of the source. - A set of doxygen comments to describe the api, for example usage of columns in the ctor. As we said, I am available to give a hand.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:258,security,availab,available,258,"@ktf, if you find a minute, a nice way to complement the development could be:. - A tutorial in C++ and Python to illustrate the usage of the source. - A set of doxygen comments to describe the api, for example usage of columns in the ctor. As we said, I am available to give a hand.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:47,availability,state,statement,47,@pcanal @vgvassilev I've changed the copyright statement.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:47,integrability,state,statement,47,@pcanal @vgvassilev I've changed the copyright statement.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:14,energy efficiency,adapt,adapted,14,@dpiparo I've adapted a bit the documentation to address your second point. Where should I put the tutorial you mention?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:14,integrability,adapt,adapted,14,@dpiparo I've adapted a bit the documentation to address your second point. Where should I put the tutorial you mention?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:14,interoperability,adapt,adapted,14,@dpiparo I've adapted a bit the documentation to address your second point. Where should I put the tutorial you mention?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:14,modifiability,adapt,adapted,14,@dpiparo I've adapted a bit the documentation to address your second point. Where should I put the tutorial you mention?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:32,usability,document,documentation,32,@dpiparo I've adapted a bit the documentation to address your second point. Where should I put the tutorial you mention?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:139,integrability,sub,subsequent,139,"@pzhristov @ktf If time is of the essence, the PR could in now. Ideally, however, a few things should be included (as part of this PR or a subsequent PR):. * review of the clang-format suggestion. * adding doc for each functions and members in doxygen format. * adding tests either in root.git or roottest.git",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:178,interoperability,format,format,178,"@pzhristov @ktf If time is of the essence, the PR could in now. Ideally, however, a few things should be included (as part of this PR or a subsequent PR):. * review of the clang-format suggestion. * adding doc for each functions and members in doxygen format. * adding tests either in root.git or roottest.git",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:252,interoperability,format,format,252,"@pzhristov @ktf If time is of the essence, the PR could in now. Ideally, however, a few things should be included (as part of this PR or a subsequent PR):. * review of the clang-format suggestion. * adding doc for each functions and members in doxygen format. * adding tests either in root.git or roottest.git",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:19,performance,time,time,19,"@pzhristov @ktf If time is of the essence, the PR could in now. Ideally, however, a few things should be included (as part of this PR or a subsequent PR):. * review of the clang-format suggestion. * adding doc for each functions and members in doxygen format. * adding tests either in root.git or roottest.git",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:158,safety,review,review,158,"@pzhristov @ktf If time is of the essence, the PR could in now. Ideally, however, a few things should be included (as part of this PR or a subsequent PR):. * review of the clang-format suggestion. * adding doc for each functions and members in doxygen format. * adding tests either in root.git or roottest.git",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:269,safety,test,tests,269,"@pzhristov @ktf If time is of the essence, the PR could in now. Ideally, however, a few things should be included (as part of this PR or a subsequent PR):. * review of the clang-format suggestion. * adding doc for each functions and members in doxygen format. * adding tests either in root.git or roottest.git",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:158,testability,review,review,158,"@pzhristov @ktf If time is of the essence, the PR could in now. Ideally, however, a few things should be included (as part of this PR or a subsequent PR):. * review of the clang-format suggestion. * adding doc for each functions and members in doxygen format. * adding tests either in root.git or roottest.git",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:269,testability,test,tests,269,"@pzhristov @ktf If time is of the essence, the PR could in now. Ideally, however, a few things should be included (as part of this PR or a subsequent PR):. * review of the clang-format suggestion. * adding doc for each functions and members in doxygen format. * adding tests either in root.git or roottest.git",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:4,availability,error,error,4,the error seems to be related to rootcling not finding the Arrow header files. ```. 21:28:33 cd /mnt/build/jenkins/workspace/root-pullrequests-build/build/tree/treeplayer && /cvmfs/sft.cern.ch/lcg/releases/CMake/3.7.0-a8e5d/x86_64-slc6-gcc49-opt/bin/cmake -E env LD_LIBRARY_PATH=/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/bin/../lib:/cvmfs/sft.cern.ch/lcg/releases/java/8u91-ae32f/x86_64-slc6-gcc49-opt/jre/lib/amd64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib:/cvmfs/sft.cern.ch/lcg/contrib/gcc/4.9/x86_64-slc6/lib64 ROOTIGNOREPREFIX=1 /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling -rootbuild -v2 -f G__TreePlayer.cxx -s /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.so -m libTree_rdict.pcm -m libGraf3d_rdict.pcm -m libGraf_rdict.pcm -m libHist_rdict.pcm -m libGpad_rdict.pcm -m libRIO_rdict.pcm -m libMathCore_rdict.pcm -m libMultiProc_rdict.pcm -m libImt_rdict.pcm -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/root -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/build -rml libTreePlayer.so -rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTr,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:2974,availability,error,error,2974,rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h TTreeReaderValue.h TTreeTableInterface.h ROOT/TAdoptAllocator.hxx ROOT/TArrowDS.hxx ROOT/TCsvDS.hxx ROOT/TCutFlowReport.hxx ROOT/TDFActionHelpers.hxx ROOT/TDFHelpers.hxx ROOT/TDFHistoModels.hxx ROOT/TDFInterface.hxx ROOT/TDFInterfaceUtils.hxx ROOT/TDFNodes.hxx ROOT/TDFNodesUtils.hxx ROOT/TDFUtils.hxx ROOT/TDataFrame.hxx ROOT/TDataSource.hxx ROOT/TLazyDS.hxx ROOT/TResultProxy.hxx ROOT/TRootDS.hxx ROOT/TSnapshotOptions.hxx ROOT/TTreeProcessorMP.hxx ROOT/TTreeProcessorMT.hxx ROOT/TTrivialDS.hxx ROOT/TVec.hxx /mnt/build/jenkins/workspace/root-pullrequests-build/root/tree/treeplayer/inc/LinkDef.h. 21:28:33 In file included from input_line_12:37:. 21:28:33 /mnt/build/jenkins/workspace/root-pullrequests-build/build/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. 21:28:33 #include <arrow/table.h>. 21:28:33 ^~~~~~~~~~~~~~~. 21:28:33 Error: /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling: compilation failure (/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer721ceb24c2_dictUmbrella.h). ```,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:3083,availability,Error,Error,3083,rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h TTreeReaderValue.h TTreeTableInterface.h ROOT/TAdoptAllocator.hxx ROOT/TArrowDS.hxx ROOT/TCsvDS.hxx ROOT/TCutFlowReport.hxx ROOT/TDFActionHelpers.hxx ROOT/TDFHelpers.hxx ROOT/TDFHistoModels.hxx ROOT/TDFInterface.hxx ROOT/TDFInterfaceUtils.hxx ROOT/TDFNodes.hxx ROOT/TDFNodesUtils.hxx ROOT/TDFUtils.hxx ROOT/TDataFrame.hxx ROOT/TDataSource.hxx ROOT/TLazyDS.hxx ROOT/TResultProxy.hxx ROOT/TRootDS.hxx ROOT/TSnapshotOptions.hxx ROOT/TTreeProcessorMP.hxx ROOT/TTreeProcessorMT.hxx ROOT/TTrivialDS.hxx ROOT/TVec.hxx /mnt/build/jenkins/workspace/root-pullrequests-build/root/tree/treeplayer/inc/LinkDef.h. 21:28:33 In file included from input_line_12:37:. 21:28:33 /mnt/build/jenkins/workspace/root-pullrequests-build/build/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. 21:28:33 #include <arrow/table.h>. 21:28:33 ^~~~~~~~~~~~~~~. 21:28:33 Error: /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling: compilation failure (/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer721ceb24c2_dictUmbrella.h). ```,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:3176,availability,failur,failure,3176,rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h TTreeReaderValue.h TTreeTableInterface.h ROOT/TAdoptAllocator.hxx ROOT/TArrowDS.hxx ROOT/TCsvDS.hxx ROOT/TCutFlowReport.hxx ROOT/TDFActionHelpers.hxx ROOT/TDFHelpers.hxx ROOT/TDFHistoModels.hxx ROOT/TDFInterface.hxx ROOT/TDFInterfaceUtils.hxx ROOT/TDFNodes.hxx ROOT/TDFNodesUtils.hxx ROOT/TDFUtils.hxx ROOT/TDataFrame.hxx ROOT/TDataSource.hxx ROOT/TLazyDS.hxx ROOT/TResultProxy.hxx ROOT/TRootDS.hxx ROOT/TSnapshotOptions.hxx ROOT/TTreeProcessorMP.hxx ROOT/TTreeProcessorMT.hxx ROOT/TTrivialDS.hxx ROOT/TVec.hxx /mnt/build/jenkins/workspace/root-pullrequests-build/root/tree/treeplayer/inc/LinkDef.h. 21:28:33 In file included from input_line_12:37:. 21:28:33 /mnt/build/jenkins/workspace/root-pullrequests-build/build/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. 21:28:33 #include <arrow/table.h>. 21:28:33 ^~~~~~~~~~~~~~~. 21:28:33 Error: /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling: compilation failure (/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer721ceb24c2_dictUmbrella.h). ```,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:101,deployability,build,build,101,the error seems to be related to rootcling not finding the Arrow header files. ```. 21:28:33 cd /mnt/build/jenkins/workspace/root-pullrequests-build/build/tree/treeplayer && /cvmfs/sft.cern.ch/lcg/releases/CMake/3.7.0-a8e5d/x86_64-slc6-gcc49-opt/bin/cmake -E env LD_LIBRARY_PATH=/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/bin/../lib:/cvmfs/sft.cern.ch/lcg/releases/java/8u91-ae32f/x86_64-slc6-gcc49-opt/jre/lib/amd64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib:/cvmfs/sft.cern.ch/lcg/contrib/gcc/4.9/x86_64-slc6/lib64 ROOTIGNOREPREFIX=1 /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling -rootbuild -v2 -f G__TreePlayer.cxx -s /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.so -m libTree_rdict.pcm -m libGraf3d_rdict.pcm -m libGraf_rdict.pcm -m libHist_rdict.pcm -m libGpad_rdict.pcm -m libRIO_rdict.pcm -m libMathCore_rdict.pcm -m libMultiProc_rdict.pcm -m libImt_rdict.pcm -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/root -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/build -rml libTreePlayer.so -rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTr,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:143,deployability,build,build,143,the error seems to be related to rootcling not finding the Arrow header files. ```. 21:28:33 cd /mnt/build/jenkins/workspace/root-pullrequests-build/build/tree/treeplayer && /cvmfs/sft.cern.ch/lcg/releases/CMake/3.7.0-a8e5d/x86_64-slc6-gcc49-opt/bin/cmake -E env LD_LIBRARY_PATH=/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/bin/../lib:/cvmfs/sft.cern.ch/lcg/releases/java/8u91-ae32f/x86_64-slc6-gcc49-opt/jre/lib/amd64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib:/cvmfs/sft.cern.ch/lcg/contrib/gcc/4.9/x86_64-slc6/lib64 ROOTIGNOREPREFIX=1 /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling -rootbuild -v2 -f G__TreePlayer.cxx -s /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.so -m libTree_rdict.pcm -m libGraf3d_rdict.pcm -m libGraf_rdict.pcm -m libHist_rdict.pcm -m libGpad_rdict.pcm -m libRIO_rdict.pcm -m libMathCore_rdict.pcm -m libMultiProc_rdict.pcm -m libImt_rdict.pcm -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/root -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/build -rml libTreePlayer.so -rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTr,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:149,deployability,build,build,149,the error seems to be related to rootcling not finding the Arrow header files. ```. 21:28:33 cd /mnt/build/jenkins/workspace/root-pullrequests-build/build/tree/treeplayer && /cvmfs/sft.cern.ch/lcg/releases/CMake/3.7.0-a8e5d/x86_64-slc6-gcc49-opt/bin/cmake -E env LD_LIBRARY_PATH=/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/bin/../lib:/cvmfs/sft.cern.ch/lcg/releases/java/8u91-ae32f/x86_64-slc6-gcc49-opt/jre/lib/amd64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib:/cvmfs/sft.cern.ch/lcg/contrib/gcc/4.9/x86_64-slc6/lib64 ROOTIGNOREPREFIX=1 /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling -rootbuild -v2 -f G__TreePlayer.cxx -s /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.so -m libTree_rdict.pcm -m libGraf3d_rdict.pcm -m libGraf_rdict.pcm -m libHist_rdict.pcm -m libGpad_rdict.pcm -m libRIO_rdict.pcm -m libMathCore_rdict.pcm -m libMultiProc_rdict.pcm -m libImt_rdict.pcm -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/root -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/build -rml libTreePlayer.so -rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTr,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:197,deployability,releas,releases,197,the error seems to be related to rootcling not finding the Arrow header files. ```. 21:28:33 cd /mnt/build/jenkins/workspace/root-pullrequests-build/build/tree/treeplayer && /cvmfs/sft.cern.ch/lcg/releases/CMake/3.7.0-a8e5d/x86_64-slc6-gcc49-opt/bin/cmake -E env LD_LIBRARY_PATH=/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/bin/../lib:/cvmfs/sft.cern.ch/lcg/releases/java/8u91-ae32f/x86_64-slc6-gcc49-opt/jre/lib/amd64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib:/cvmfs/sft.cern.ch/lcg/contrib/gcc/4.9/x86_64-slc6/lib64 ROOTIGNOREPREFIX=1 /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling -rootbuild -v2 -f G__TreePlayer.cxx -s /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.so -m libTree_rdict.pcm -m libGraf3d_rdict.pcm -m libGraf_rdict.pcm -m libHist_rdict.pcm -m libGpad_rdict.pcm -m libRIO_rdict.pcm -m libMathCore_rdict.pcm -m libMultiProc_rdict.pcm -m libImt_rdict.pcm -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/root -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/build -rml libTreePlayer.so -rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTr,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:284,deployability,build,build,284,the error seems to be related to rootcling not finding the Arrow header files. ```. 21:28:33 cd /mnt/build/jenkins/workspace/root-pullrequests-build/build/tree/treeplayer && /cvmfs/sft.cern.ch/lcg/releases/CMake/3.7.0-a8e5d/x86_64-slc6-gcc49-opt/bin/cmake -E env LD_LIBRARY_PATH=/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/bin/../lib:/cvmfs/sft.cern.ch/lcg/releases/java/8u91-ae32f/x86_64-slc6-gcc49-opt/jre/lib/amd64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib:/cvmfs/sft.cern.ch/lcg/contrib/gcc/4.9/x86_64-slc6/lib64 ROOTIGNOREPREFIX=1 /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling -rootbuild -v2 -f G__TreePlayer.cxx -s /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.so -m libTree_rdict.pcm -m libGraf3d_rdict.pcm -m libGraf_rdict.pcm -m libHist_rdict.pcm -m libGpad_rdict.pcm -m libRIO_rdict.pcm -m libMathCore_rdict.pcm -m libMultiProc_rdict.pcm -m libImt_rdict.pcm -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/root -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/build -rml libTreePlayer.so -rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTr,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:326,deployability,build,build,326,the error seems to be related to rootcling not finding the Arrow header files. ```. 21:28:33 cd /mnt/build/jenkins/workspace/root-pullrequests-build/build/tree/treeplayer && /cvmfs/sft.cern.ch/lcg/releases/CMake/3.7.0-a8e5d/x86_64-slc6-gcc49-opt/bin/cmake -E env LD_LIBRARY_PATH=/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/bin/../lib:/cvmfs/sft.cern.ch/lcg/releases/java/8u91-ae32f/x86_64-slc6-gcc49-opt/jre/lib/amd64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib:/cvmfs/sft.cern.ch/lcg/contrib/gcc/4.9/x86_64-slc6/lib64 ROOTIGNOREPREFIX=1 /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling -rootbuild -v2 -f G__TreePlayer.cxx -s /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.so -m libTree_rdict.pcm -m libGraf3d_rdict.pcm -m libGraf_rdict.pcm -m libHist_rdict.pcm -m libGpad_rdict.pcm -m libRIO_rdict.pcm -m libMathCore_rdict.pcm -m libMultiProc_rdict.pcm -m libImt_rdict.pcm -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/root -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/build -rml libTreePlayer.so -rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTr,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:332,deployability,build,build,332,the error seems to be related to rootcling not finding the Arrow header files. ```. 21:28:33 cd /mnt/build/jenkins/workspace/root-pullrequests-build/build/tree/treeplayer && /cvmfs/sft.cern.ch/lcg/releases/CMake/3.7.0-a8e5d/x86_64-slc6-gcc49-opt/bin/cmake -E env LD_LIBRARY_PATH=/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/bin/../lib:/cvmfs/sft.cern.ch/lcg/releases/java/8u91-ae32f/x86_64-slc6-gcc49-opt/jre/lib/amd64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib:/cvmfs/sft.cern.ch/lcg/contrib/gcc/4.9/x86_64-slc6/lib64 ROOTIGNOREPREFIX=1 /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling -rootbuild -v2 -f G__TreePlayer.cxx -s /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.so -m libTree_rdict.pcm -m libGraf3d_rdict.pcm -m libGraf_rdict.pcm -m libHist_rdict.pcm -m libGpad_rdict.pcm -m libRIO_rdict.pcm -m libMathCore_rdict.pcm -m libMultiProc_rdict.pcm -m libImt_rdict.pcm -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/root -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/build -rml libTreePlayer.so -rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTr,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:447,deployability,releas,releases,447,the error seems to be related to rootcling not finding the Arrow header files. ```. 21:28:33 cd /mnt/build/jenkins/workspace/root-pullrequests-build/build/tree/treeplayer && /cvmfs/sft.cern.ch/lcg/releases/CMake/3.7.0-a8e5d/x86_64-slc6-gcc49-opt/bin/cmake -E env LD_LIBRARY_PATH=/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/bin/../lib:/cvmfs/sft.cern.ch/lcg/releases/java/8u91-ae32f/x86_64-slc6-gcc49-opt/jre/lib/amd64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib:/cvmfs/sft.cern.ch/lcg/contrib/gcc/4.9/x86_64-slc6/lib64 ROOTIGNOREPREFIX=1 /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling -rootbuild -v2 -f G__TreePlayer.cxx -s /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.so -m libTree_rdict.pcm -m libGraf3d_rdict.pcm -m libGraf_rdict.pcm -m libHist_rdict.pcm -m libGpad_rdict.pcm -m libRIO_rdict.pcm -m libMathCore_rdict.pcm -m libMultiProc_rdict.pcm -m libImt_rdict.pcm -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/root -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/build -rml libTreePlayer.so -rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTr,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:741,deployability,build,build,741,the error seems to be related to rootcling not finding the Arrow header files. ```. 21:28:33 cd /mnt/build/jenkins/workspace/root-pullrequests-build/build/tree/treeplayer && /cvmfs/sft.cern.ch/lcg/releases/CMake/3.7.0-a8e5d/x86_64-slc6-gcc49-opt/bin/cmake -E env LD_LIBRARY_PATH=/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/bin/../lib:/cvmfs/sft.cern.ch/lcg/releases/java/8u91-ae32f/x86_64-slc6-gcc49-opt/jre/lib/amd64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib:/cvmfs/sft.cern.ch/lcg/contrib/gcc/4.9/x86_64-slc6/lib64 ROOTIGNOREPREFIX=1 /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling -rootbuild -v2 -f G__TreePlayer.cxx -s /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.so -m libTree_rdict.pcm -m libGraf3d_rdict.pcm -m libGraf_rdict.pcm -m libHist_rdict.pcm -m libGpad_rdict.pcm -m libRIO_rdict.pcm -m libMathCore_rdict.pcm -m libMultiProc_rdict.pcm -m libImt_rdict.pcm -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/root -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/build -rml libTreePlayer.so -rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTr,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:783,deployability,build,build,783,the error seems to be related to rootcling not finding the Arrow header files. ```. 21:28:33 cd /mnt/build/jenkins/workspace/root-pullrequests-build/build/tree/treeplayer && /cvmfs/sft.cern.ch/lcg/releases/CMake/3.7.0-a8e5d/x86_64-slc6-gcc49-opt/bin/cmake -E env LD_LIBRARY_PATH=/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/bin/../lib:/cvmfs/sft.cern.ch/lcg/releases/java/8u91-ae32f/x86_64-slc6-gcc49-opt/jre/lib/amd64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib:/cvmfs/sft.cern.ch/lcg/contrib/gcc/4.9/x86_64-slc6/lib64 ROOTIGNOREPREFIX=1 /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling -rootbuild -v2 -f G__TreePlayer.cxx -s /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.so -m libTree_rdict.pcm -m libGraf3d_rdict.pcm -m libGraf_rdict.pcm -m libHist_rdict.pcm -m libGpad_rdict.pcm -m libRIO_rdict.pcm -m libMathCore_rdict.pcm -m libMultiProc_rdict.pcm -m libImt_rdict.pcm -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/root -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/build -rml libTreePlayer.so -rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTr,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:789,deployability,build,build,789,the error seems to be related to rootcling not finding the Arrow header files. ```. 21:28:33 cd /mnt/build/jenkins/workspace/root-pullrequests-build/build/tree/treeplayer && /cvmfs/sft.cern.ch/lcg/releases/CMake/3.7.0-a8e5d/x86_64-slc6-gcc49-opt/bin/cmake -E env LD_LIBRARY_PATH=/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/bin/../lib:/cvmfs/sft.cern.ch/lcg/releases/java/8u91-ae32f/x86_64-slc6-gcc49-opt/jre/lib/amd64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib:/cvmfs/sft.cern.ch/lcg/contrib/gcc/4.9/x86_64-slc6/lib64 ROOTIGNOREPREFIX=1 /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling -rootbuild -v2 -f G__TreePlayer.cxx -s /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.so -m libTree_rdict.pcm -m libGraf3d_rdict.pcm -m libGraf_rdict.pcm -m libHist_rdict.pcm -m libGpad_rdict.pcm -m libRIO_rdict.pcm -m libMathCore_rdict.pcm -m libMultiProc_rdict.pcm -m libImt_rdict.pcm -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/root -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/build -rml libTreePlayer.so -rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTr,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:853,deployability,build,build,853,the error seems to be related to rootcling not finding the Arrow header files. ```. 21:28:33 cd /mnt/build/jenkins/workspace/root-pullrequests-build/build/tree/treeplayer && /cvmfs/sft.cern.ch/lcg/releases/CMake/3.7.0-a8e5d/x86_64-slc6-gcc49-opt/bin/cmake -E env LD_LIBRARY_PATH=/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/bin/../lib:/cvmfs/sft.cern.ch/lcg/releases/java/8u91-ae32f/x86_64-slc6-gcc49-opt/jre/lib/amd64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib:/cvmfs/sft.cern.ch/lcg/contrib/gcc/4.9/x86_64-slc6/lib64 ROOTIGNOREPREFIX=1 /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling -rootbuild -v2 -f G__TreePlayer.cxx -s /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.so -m libTree_rdict.pcm -m libGraf3d_rdict.pcm -m libGraf_rdict.pcm -m libHist_rdict.pcm -m libGpad_rdict.pcm -m libRIO_rdict.pcm -m libMathCore_rdict.pcm -m libMultiProc_rdict.pcm -m libImt_rdict.pcm -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/root -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/build -rml libTreePlayer.so -rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTr,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:895,deployability,build,build,895,the error seems to be related to rootcling not finding the Arrow header files. ```. 21:28:33 cd /mnt/build/jenkins/workspace/root-pullrequests-build/build/tree/treeplayer && /cvmfs/sft.cern.ch/lcg/releases/CMake/3.7.0-a8e5d/x86_64-slc6-gcc49-opt/bin/cmake -E env LD_LIBRARY_PATH=/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/bin/../lib:/cvmfs/sft.cern.ch/lcg/releases/java/8u91-ae32f/x86_64-slc6-gcc49-opt/jre/lib/amd64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib:/cvmfs/sft.cern.ch/lcg/contrib/gcc/4.9/x86_64-slc6/lib64 ROOTIGNOREPREFIX=1 /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling -rootbuild -v2 -f G__TreePlayer.cxx -s /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.so -m libTree_rdict.pcm -m libGraf3d_rdict.pcm -m libGraf_rdict.pcm -m libHist_rdict.pcm -m libGpad_rdict.pcm -m libRIO_rdict.pcm -m libMathCore_rdict.pcm -m libMultiProc_rdict.pcm -m libImt_rdict.pcm -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/root -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/build -rml libTreePlayer.so -rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTr,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:901,deployability,build,build,901,the error seems to be related to rootcling not finding the Arrow header files. ```. 21:28:33 cd /mnt/build/jenkins/workspace/root-pullrequests-build/build/tree/treeplayer && /cvmfs/sft.cern.ch/lcg/releases/CMake/3.7.0-a8e5d/x86_64-slc6-gcc49-opt/bin/cmake -E env LD_LIBRARY_PATH=/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/bin/../lib:/cvmfs/sft.cern.ch/lcg/releases/java/8u91-ae32f/x86_64-slc6-gcc49-opt/jre/lib/amd64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib:/cvmfs/sft.cern.ch/lcg/contrib/gcc/4.9/x86_64-slc6/lib64 ROOTIGNOREPREFIX=1 /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling -rootbuild -v2 -f G__TreePlayer.cxx -s /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.so -m libTree_rdict.pcm -m libGraf3d_rdict.pcm -m libGraf_rdict.pcm -m libHist_rdict.pcm -m libGpad_rdict.pcm -m libRIO_rdict.pcm -m libMathCore_rdict.pcm -m libMultiProc_rdict.pcm -m libImt_rdict.pcm -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/root -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/build -rml libTreePlayer.so -rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTr,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:1144,deployability,build,build,1144,d/build/tree/treeplayer && /cvmfs/sft.cern.ch/lcg/releases/CMake/3.7.0-a8e5d/x86_64-slc6-gcc49-opt/bin/cmake -E env LD_LIBRARY_PATH=/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/bin/../lib:/cvmfs/sft.cern.ch/lcg/releases/java/8u91-ae32f/x86_64-slc6-gcc49-opt/jre/lib/amd64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib:/cvmfs/sft.cern.ch/lcg/contrib/gcc/4.9/x86_64-slc6/lib64 ROOTIGNOREPREFIX=1 /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling -rootbuild -v2 -f G__TreePlayer.cxx -s /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.so -m libTree_rdict.pcm -m libGraf3d_rdict.pcm -m libGraf_rdict.pcm -m libHist_rdict.pcm -m libGpad_rdict.pcm -m libRIO_rdict.pcm -m libMathCore_rdict.pcm -m libMultiProc_rdict.pcm -m libImt_rdict.pcm -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/root -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/build -rml libTreePlayer.so -rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTre,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:1186,deployability,build,build,1186,.ch/lcg/releases/CMake/3.7.0-a8e5d/x86_64-slc6-gcc49-opt/bin/cmake -E env LD_LIBRARY_PATH=/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/bin/../lib:/cvmfs/sft.cern.ch/lcg/releases/java/8u91-ae32f/x86_64-slc6-gcc49-opt/jre/lib/amd64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib:/cvmfs/sft.cern.ch/lcg/contrib/gcc/4.9/x86_64-slc6/lib64 ROOTIGNOREPREFIX=1 /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling -rootbuild -v2 -f G__TreePlayer.cxx -s /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.so -m libTree_rdict.pcm -m libGraf3d_rdict.pcm -m libGraf_rdict.pcm -m libHist_rdict.pcm -m libGpad_rdict.pcm -m libRIO_rdict.pcm -m libMathCore_rdict.pcm -m libMultiProc_rdict.pcm -m libImt_rdict.pcm -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/root -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/build -rml libTreePlayer.so -rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGe,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:1215,deployability,build,build,1215,a8e5d/x86_64-slc6-gcc49-opt/bin/cmake -E env LD_LIBRARY_PATH=/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/bin/../lib:/cvmfs/sft.cern.ch/lcg/releases/java/8u91-ae32f/x86_64-slc6-gcc49-opt/jre/lib/amd64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib:/cvmfs/sft.cern.ch/lcg/contrib/gcc/4.9/x86_64-slc6/lib64 ROOTIGNOREPREFIX=1 /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling -rootbuild -v2 -f G__TreePlayer.cxx -s /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.so -m libTree_rdict.pcm -m libGraf3d_rdict.pcm -m libGraf_rdict.pcm -m libHist_rdict.pcm -m libGpad_rdict.pcm -m libRIO_rdict.pcm -m libMathCore_rdict.pcm -m libMultiProc_rdict.pcm -m libImt_rdict.pcm -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/root -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/build -rml libTreePlayer.so -rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h ,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:1257,deployability,build,build,1257,nv LD_LIBRARY_PATH=/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/bin/../lib:/cvmfs/sft.cern.ch/lcg/releases/java/8u91-ae32f/x86_64-slc6-gcc49-opt/jre/lib/amd64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib:/cvmfs/sft.cern.ch/lcg/contrib/gcc/4.9/x86_64-slc6/lib64 ROOTIGNOREPREFIX=1 /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling -rootbuild -v2 -f G__TreePlayer.cxx -s /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.so -m libTree_rdict.pcm -m libGraf3d_rdict.pcm -m libGraf_rdict.pcm -m libHist_rdict.pcm -m libGpad_rdict.pcm -m libRIO_rdict.pcm -m libMathCore_rdict.pcm -m libMultiProc_rdict.pcm -m libImt_rdict.pcm -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/root -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/build -rml libTreePlayer.so -rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h TTreeReaderValue.h TTreeTableInterface.h R,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:1263,deployability,build,build,1263,LIBRARY_PATH=/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/bin/../lib:/cvmfs/sft.cern.ch/lcg/releases/java/8u91-ae32f/x86_64-slc6-gcc49-opt/jre/lib/amd64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib:/cvmfs/sft.cern.ch/lcg/contrib/gcc/4.9/x86_64-slc6/lib64 ROOTIGNOREPREFIX=1 /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling -rootbuild -v2 -f G__TreePlayer.cxx -s /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.so -m libTree_rdict.pcm -m libGraf3d_rdict.pcm -m libGraf_rdict.pcm -m libHist_rdict.pcm -m libGpad_rdict.pcm -m libRIO_rdict.pcm -m libMathCore_rdict.pcm -m libMultiProc_rdict.pcm -m libImt_rdict.pcm -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/root -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/build -rml libTreePlayer.so -rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h TTreeReaderValue.h TTreeTableInterface.h ROOT/TA,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:1301,deployability,build,build,1301,ace/root-pullrequests-build/build/lib:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/bin/../lib:/cvmfs/sft.cern.ch/lcg/releases/java/8u91-ae32f/x86_64-slc6-gcc49-opt/jre/lib/amd64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib:/cvmfs/sft.cern.ch/lcg/contrib/gcc/4.9/x86_64-slc6/lib64 ROOTIGNOREPREFIX=1 /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling -rootbuild -v2 -f G__TreePlayer.cxx -s /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.so -m libTree_rdict.pcm -m libGraf3d_rdict.pcm -m libGraf_rdict.pcm -m libHist_rdict.pcm -m libGpad_rdict.pcm -m libRIO_rdict.pcm -m libMathCore_rdict.pcm -m libMultiProc_rdict.pcm -m libImt_rdict.pcm -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/root -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/build -rml libTreePlayer.so -rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h TTreeReaderValue.h TTreeTableInterface.h ROOT/TAdoptAllocator.hxx ROOT/TArrowDS.hxx RO,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:1343,deployability,build,build,1343,fs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/bin/../lib:/cvmfs/sft.cern.ch/lcg/releases/java/8u91-ae32f/x86_64-slc6-gcc49-opt/jre/lib/amd64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib:/cvmfs/sft.cern.ch/lcg/contrib/gcc/4.9/x86_64-slc6/lib64 ROOTIGNOREPREFIX=1 /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling -rootbuild -v2 -f G__TreePlayer.cxx -s /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.so -m libTree_rdict.pcm -m libGraf3d_rdict.pcm -m libGraf_rdict.pcm -m libHist_rdict.pcm -m libGpad_rdict.pcm -m libRIO_rdict.pcm -m libMathCore_rdict.pcm -m libMultiProc_rdict.pcm -m libImt_rdict.pcm -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/root -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/build -rml libTreePlayer.so -rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h TTreeReaderValue.h TTreeTableInterface.h ROOT/TAdoptAllocator.hxx ROOT/TArrowDS.hxx ROOT/TCsvDS.hxx ROOT/TCutFlowReport.hxx ROOT,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:1349,deployability,build,build,1349,.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/bin/../lib:/cvmfs/sft.cern.ch/lcg/releases/java/8u91-ae32f/x86_64-slc6-gcc49-opt/jre/lib/amd64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib:/cvmfs/sft.cern.ch/lcg/contrib/gcc/4.9/x86_64-slc6/lib64 ROOTIGNOREPREFIX=1 /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling -rootbuild -v2 -f G__TreePlayer.cxx -s /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.so -m libTree_rdict.pcm -m libGraf3d_rdict.pcm -m libGraf_rdict.pcm -m libHist_rdict.pcm -m libGpad_rdict.pcm -m libRIO_rdict.pcm -m libMathCore_rdict.pcm -m libMultiProc_rdict.pcm -m libImt_rdict.pcm -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/root -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/build -rml libTreePlayer.so -rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h TTreeReaderValue.h TTreeTableInterface.h ROOT/TAdoptAllocator.hxx ROOT/TArrowDS.hxx ROOT/TCsvDS.hxx ROOT/TCutFlowReport.hxx ROOT/TDFAc,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:1407,deployability,build,build,1407,pt/bin/../lib:/cvmfs/sft.cern.ch/lcg/releases/java/8u91-ae32f/x86_64-slc6-gcc49-opt/jre/lib/amd64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib:/cvmfs/sft.cern.ch/lcg/contrib/gcc/4.9/x86_64-slc6/lib64 ROOTIGNOREPREFIX=1 /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling -rootbuild -v2 -f G__TreePlayer.cxx -s /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.so -m libTree_rdict.pcm -m libGraf3d_rdict.pcm -m libGraf_rdict.pcm -m libHist_rdict.pcm -m libGpad_rdict.pcm -m libRIO_rdict.pcm -m libMathCore_rdict.pcm -m libMultiProc_rdict.pcm -m libImt_rdict.pcm -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/root -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/build -rml libTreePlayer.so -rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h TTreeReaderValue.h TTreeTableInterface.h ROOT/TAdoptAllocator.hxx ROOT/TArrowDS.hxx ROOT/TCsvDS.hxx ROOT/TCutFlowReport.hxx ROOT/TDFActionHelpers.hxx ROOT/TDFHelpers.hxx ROOT/TDFHistoModels.hx,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:1449,deployability,build,build,1449,ses/java/8u91-ae32f/x86_64-slc6-gcc49-opt/jre/lib/amd64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib:/cvmfs/sft.cern.ch/lcg/contrib/gcc/4.9/x86_64-slc6/lib64 ROOTIGNOREPREFIX=1 /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling -rootbuild -v2 -f G__TreePlayer.cxx -s /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.so -m libTree_rdict.pcm -m libGraf3d_rdict.pcm -m libGraf_rdict.pcm -m libHist_rdict.pcm -m libGpad_rdict.pcm -m libRIO_rdict.pcm -m libMathCore_rdict.pcm -m libMultiProc_rdict.pcm -m libImt_rdict.pcm -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/root -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/build -rml libTreePlayer.so -rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h TTreeReaderValue.h TTreeTableInterface.h ROOT/TAdoptAllocator.hxx ROOT/TArrowDS.hxx ROOT/TCsvDS.hxx ROOT/TCutFlowReport.hxx ROOT/TDFActionHelpers.hxx ROOT/TDFHelpers.hxx ROOT/TDFHistoModels.hxx ROOT/TDFInterface.hxx ROOT/TDFInterfaceU,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:1467,deployability,build,build,1467,f/x86_64-slc6-gcc49-opt/jre/lib/amd64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib:/cvmfs/sft.cern.ch/lcg/contrib/gcc/4.9/x86_64-slc6/lib64 ROOTIGNOREPREFIX=1 /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling -rootbuild -v2 -f G__TreePlayer.cxx -s /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.so -m libTree_rdict.pcm -m libGraf3d_rdict.pcm -m libGraf_rdict.pcm -m libHist_rdict.pcm -m libGpad_rdict.pcm -m libRIO_rdict.pcm -m libMathCore_rdict.pcm -m libMultiProc_rdict.pcm -m libImt_rdict.pcm -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/root -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/build -rml libTreePlayer.so -rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h TTreeReaderValue.h TTreeTableInterface.h ROOT/TAdoptAllocator.hxx ROOT/TArrowDS.hxx ROOT/TCsvDS.hxx ROOT/TCutFlowReport.hxx ROOT/TDFActionHelpers.hxx ROOT/TDFHelpers.hxx ROOT/TDFHistoModels.hxx ROOT/TDFInterface.hxx ROOT/TDFInterfaceUtils.hxx ROOT/TDFN,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:1509,deployability,build,build,1509,fs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib:/cvmfs/sft.cern.ch/lcg/contrib/gcc/4.9/x86_64-slc6/lib64 ROOTIGNOREPREFIX=1 /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling -rootbuild -v2 -f G__TreePlayer.cxx -s /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.so -m libTree_rdict.pcm -m libGraf3d_rdict.pcm -m libGraf_rdict.pcm -m libHist_rdict.pcm -m libGpad_rdict.pcm -m libRIO_rdict.pcm -m libMathCore_rdict.pcm -m libMultiProc_rdict.pcm -m libImt_rdict.pcm -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/root -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/build -rml libTreePlayer.so -rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h TTreeReaderValue.h TTreeTableInterface.h ROOT/TAdoptAllocator.hxx ROOT/TArrowDS.hxx ROOT/TCsvDS.hxx ROOT/TCutFlowReport.hxx ROOT/TDFActionHelpers.hxx ROOT/TDFHelpers.hxx ROOT/TDFHistoModels.hxx ROOT/TDFInterface.hxx ROOT/TDFInterfaceUtils.hxx ROOT/TDFNodes.hxx ROOT/TDFNodesUtils.hxx ROOT/TDFUt,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:1553,deployability,build,build,1553,/x86_64-slc6-gcc49-opt/lib64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib:/cvmfs/sft.cern.ch/lcg/contrib/gcc/4.9/x86_64-slc6/lib64 ROOTIGNOREPREFIX=1 /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling -rootbuild -v2 -f G__TreePlayer.cxx -s /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.so -m libTree_rdict.pcm -m libGraf3d_rdict.pcm -m libGraf_rdict.pcm -m libHist_rdict.pcm -m libGpad_rdict.pcm -m libRIO_rdict.pcm -m libMathCore_rdict.pcm -m libMultiProc_rdict.pcm -m libImt_rdict.pcm -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/root -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/build -rml libTreePlayer.so -rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h TTreeReaderValue.h TTreeTableInterface.h ROOT/TAdoptAllocator.hxx ROOT/TArrowDS.hxx ROOT/TCsvDS.hxx ROOT/TCutFlowReport.hxx ROOT/TDFActionHelpers.hxx ROOT/TDFHelpers.hxx ROOT/TDFHistoModels.hxx ROOT/TDFInterface.hxx ROOT/TDFInterfaceUtils.hxx ROOT/TDFNodes.hxx ROOT/TDFNodesUtils.hxx ROOT/TDFUtils.hxx ROOT/TDataFrame.hxx ROOT/TDataSource,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:1595,deployability,build,build,1595,rn.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib:/cvmfs/sft.cern.ch/lcg/contrib/gcc/4.9/x86_64-slc6/lib64 ROOTIGNOREPREFIX=1 /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling -rootbuild -v2 -f G__TreePlayer.cxx -s /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.so -m libTree_rdict.pcm -m libGraf3d_rdict.pcm -m libGraf_rdict.pcm -m libHist_rdict.pcm -m libGpad_rdict.pcm -m libRIO_rdict.pcm -m libMathCore_rdict.pcm -m libMultiProc_rdict.pcm -m libImt_rdict.pcm -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/root -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/build -rml libTreePlayer.so -rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h TTreeReaderValue.h TTreeTableInterface.h ROOT/TAdoptAllocator.hxx ROOT/TArrowDS.hxx ROOT/TCsvDS.hxx ROOT/TCutFlowReport.hxx ROOT/TDFActionHelpers.hxx ROOT/TDFHelpers.hxx ROOT/TDFHistoModels.hxx ROOT/TDFInterface.hxx ROOT/TDFInterfaceUtils.hxx ROOT/TDFNodes.hxx ROOT/TDFNodesUtils.hxx ROOT/TDFUtils.hxx ROOT/TDataFrame.hxx ROOT/TDataSource.hxx ROOT/TLazyDS.hxx ROOT/TResultProxy.hx,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:1601,deployability,build,build,1601,lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib:/cvmfs/sft.cern.ch/lcg/contrib/gcc/4.9/x86_64-slc6/lib64 ROOTIGNOREPREFIX=1 /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling -rootbuild -v2 -f G__TreePlayer.cxx -s /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.so -m libTree_rdict.pcm -m libGraf3d_rdict.pcm -m libGraf_rdict.pcm -m libHist_rdict.pcm -m libGpad_rdict.pcm -m libRIO_rdict.pcm -m libMathCore_rdict.pcm -m libMultiProc_rdict.pcm -m libImt_rdict.pcm -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/root -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/build -rml libTreePlayer.so -rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h TTreeReaderValue.h TTreeTableInterface.h ROOT/TAdoptAllocator.hxx ROOT/TArrowDS.hxx ROOT/TCsvDS.hxx ROOT/TCutFlowReport.hxx ROOT/TDFActionHelpers.hxx ROOT/TDFHelpers.hxx ROOT/TDFHistoModels.hxx ROOT/TDFInterface.hxx ROOT/TDFInterfaceUtils.hxx ROOT/TDFNodes.hxx ROOT/TDFNodesUtils.hxx ROOT/TDFUtils.hxx ROOT/TDataFrame.hxx ROOT/TDataSource.hxx ROOT/TLazyDS.hxx ROOT/TResultProxy.hxx ROOT,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:2734,deployability,build,build,2734,rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h TTreeReaderValue.h TTreeTableInterface.h ROOT/TAdoptAllocator.hxx ROOT/TArrowDS.hxx ROOT/TCsvDS.hxx ROOT/TCutFlowReport.hxx ROOT/TDFActionHelpers.hxx ROOT/TDFHelpers.hxx ROOT/TDFHistoModels.hxx ROOT/TDFInterface.hxx ROOT/TDFInterfaceUtils.hxx ROOT/TDFNodes.hxx ROOT/TDFNodesUtils.hxx ROOT/TDFUtils.hxx ROOT/TDataFrame.hxx ROOT/TDataSource.hxx ROOT/TLazyDS.hxx ROOT/TResultProxy.hxx ROOT/TRootDS.hxx ROOT/TSnapshotOptions.hxx ROOT/TTreeProcessorMP.hxx ROOT/TTreeProcessorMT.hxx ROOT/TTrivialDS.hxx ROOT/TVec.hxx /mnt/build/jenkins/workspace/root-pullrequests-build/root/tree/treeplayer/inc/LinkDef.h. 21:28:33 In file included from input_line_12:37:. 21:28:33 /mnt/build/jenkins/workspace/root-pullrequests-build/build/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. 21:28:33 #include <arrow/table.h>. 21:28:33 ^~~~~~~~~~~~~~~. 21:28:33 Error: /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling: compilation failure (/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer721ceb24c2_dictUmbrella.h). ```,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:2776,deployability,build,build,2776,rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h TTreeReaderValue.h TTreeTableInterface.h ROOT/TAdoptAllocator.hxx ROOT/TArrowDS.hxx ROOT/TCsvDS.hxx ROOT/TCutFlowReport.hxx ROOT/TDFActionHelpers.hxx ROOT/TDFHelpers.hxx ROOT/TDFHistoModels.hxx ROOT/TDFInterface.hxx ROOT/TDFInterfaceUtils.hxx ROOT/TDFNodes.hxx ROOT/TDFNodesUtils.hxx ROOT/TDFUtils.hxx ROOT/TDataFrame.hxx ROOT/TDataSource.hxx ROOT/TLazyDS.hxx ROOT/TResultProxy.hxx ROOT/TRootDS.hxx ROOT/TSnapshotOptions.hxx ROOT/TTreeProcessorMP.hxx ROOT/TTreeProcessorMT.hxx ROOT/TTrivialDS.hxx ROOT/TVec.hxx /mnt/build/jenkins/workspace/root-pullrequests-build/root/tree/treeplayer/inc/LinkDef.h. 21:28:33 In file included from input_line_12:37:. 21:28:33 /mnt/build/jenkins/workspace/root-pullrequests-build/build/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. 21:28:33 #include <arrow/table.h>. 21:28:33 ^~~~~~~~~~~~~~~. 21:28:33 Error: /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling: compilation failure (/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer721ceb24c2_dictUmbrella.h). ```,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:2882,deployability,build,build,2882,rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h TTreeReaderValue.h TTreeTableInterface.h ROOT/TAdoptAllocator.hxx ROOT/TArrowDS.hxx ROOT/TCsvDS.hxx ROOT/TCutFlowReport.hxx ROOT/TDFActionHelpers.hxx ROOT/TDFHelpers.hxx ROOT/TDFHistoModels.hxx ROOT/TDFInterface.hxx ROOT/TDFInterfaceUtils.hxx ROOT/TDFNodes.hxx ROOT/TDFNodesUtils.hxx ROOT/TDFUtils.hxx ROOT/TDataFrame.hxx ROOT/TDataSource.hxx ROOT/TLazyDS.hxx ROOT/TResultProxy.hxx ROOT/TRootDS.hxx ROOT/TSnapshotOptions.hxx ROOT/TTreeProcessorMP.hxx ROOT/TTreeProcessorMT.hxx ROOT/TTrivialDS.hxx ROOT/TVec.hxx /mnt/build/jenkins/workspace/root-pullrequests-build/root/tree/treeplayer/inc/LinkDef.h. 21:28:33 In file included from input_line_12:37:. 21:28:33 /mnt/build/jenkins/workspace/root-pullrequests-build/build/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. 21:28:33 #include <arrow/table.h>. 21:28:33 ^~~~~~~~~~~~~~~. 21:28:33 Error: /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling: compilation failure (/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer721ceb24c2_dictUmbrella.h). ```,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:2924,deployability,build,build,2924,rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h TTreeReaderValue.h TTreeTableInterface.h ROOT/TAdoptAllocator.hxx ROOT/TArrowDS.hxx ROOT/TCsvDS.hxx ROOT/TCutFlowReport.hxx ROOT/TDFActionHelpers.hxx ROOT/TDFHelpers.hxx ROOT/TDFHistoModels.hxx ROOT/TDFInterface.hxx ROOT/TDFInterfaceUtils.hxx ROOT/TDFNodes.hxx ROOT/TDFNodesUtils.hxx ROOT/TDFUtils.hxx ROOT/TDataFrame.hxx ROOT/TDataSource.hxx ROOT/TLazyDS.hxx ROOT/TResultProxy.hxx ROOT/TRootDS.hxx ROOT/TSnapshotOptions.hxx ROOT/TTreeProcessorMP.hxx ROOT/TTreeProcessorMT.hxx ROOT/TTrivialDS.hxx ROOT/TVec.hxx /mnt/build/jenkins/workspace/root-pullrequests-build/root/tree/treeplayer/inc/LinkDef.h. 21:28:33 In file included from input_line_12:37:. 21:28:33 /mnt/build/jenkins/workspace/root-pullrequests-build/build/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. 21:28:33 #include <arrow/table.h>. 21:28:33 ^~~~~~~~~~~~~~~. 21:28:33 Error: /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling: compilation failure (/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer721ceb24c2_dictUmbrella.h). ```,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:2930,deployability,build,build,2930,rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h TTreeReaderValue.h TTreeTableInterface.h ROOT/TAdoptAllocator.hxx ROOT/TArrowDS.hxx ROOT/TCsvDS.hxx ROOT/TCutFlowReport.hxx ROOT/TDFActionHelpers.hxx ROOT/TDFHelpers.hxx ROOT/TDFHistoModels.hxx ROOT/TDFInterface.hxx ROOT/TDFInterfaceUtils.hxx ROOT/TDFNodes.hxx ROOT/TDFNodesUtils.hxx ROOT/TDFUtils.hxx ROOT/TDataFrame.hxx ROOT/TDataSource.hxx ROOT/TLazyDS.hxx ROOT/TResultProxy.hxx ROOT/TRootDS.hxx ROOT/TSnapshotOptions.hxx ROOT/TTreeProcessorMP.hxx ROOT/TTreeProcessorMT.hxx ROOT/TTrivialDS.hxx ROOT/TVec.hxx /mnt/build/jenkins/workspace/root-pullrequests-build/root/tree/treeplayer/inc/LinkDef.h. 21:28:33 In file included from input_line_12:37:. 21:28:33 /mnt/build/jenkins/workspace/root-pullrequests-build/build/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. 21:28:33 #include <arrow/table.h>. 21:28:33 ^~~~~~~~~~~~~~~. 21:28:33 Error: /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling: compilation failure (/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer721ceb24c2_dictUmbrella.h). ```,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:3095,deployability,build,build,3095,rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h TTreeReaderValue.h TTreeTableInterface.h ROOT/TAdoptAllocator.hxx ROOT/TArrowDS.hxx ROOT/TCsvDS.hxx ROOT/TCutFlowReport.hxx ROOT/TDFActionHelpers.hxx ROOT/TDFHelpers.hxx ROOT/TDFHistoModels.hxx ROOT/TDFInterface.hxx ROOT/TDFInterfaceUtils.hxx ROOT/TDFNodes.hxx ROOT/TDFNodesUtils.hxx ROOT/TDFUtils.hxx ROOT/TDataFrame.hxx ROOT/TDataSource.hxx ROOT/TLazyDS.hxx ROOT/TResultProxy.hxx ROOT/TRootDS.hxx ROOT/TSnapshotOptions.hxx ROOT/TTreeProcessorMP.hxx ROOT/TTreeProcessorMT.hxx ROOT/TTrivialDS.hxx ROOT/TVec.hxx /mnt/build/jenkins/workspace/root-pullrequests-build/root/tree/treeplayer/inc/LinkDef.h. 21:28:33 In file included from input_line_12:37:. 21:28:33 /mnt/build/jenkins/workspace/root-pullrequests-build/build/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. 21:28:33 #include <arrow/table.h>. 21:28:33 ^~~~~~~~~~~~~~~. 21:28:33 Error: /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling: compilation failure (/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer721ceb24c2_dictUmbrella.h). ```,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:3137,deployability,build,build,3137,rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h TTreeReaderValue.h TTreeTableInterface.h ROOT/TAdoptAllocator.hxx ROOT/TArrowDS.hxx ROOT/TCsvDS.hxx ROOT/TCutFlowReport.hxx ROOT/TDFActionHelpers.hxx ROOT/TDFHelpers.hxx ROOT/TDFHistoModels.hxx ROOT/TDFInterface.hxx ROOT/TDFInterfaceUtils.hxx ROOT/TDFNodes.hxx ROOT/TDFNodesUtils.hxx ROOT/TDFUtils.hxx ROOT/TDataFrame.hxx ROOT/TDataSource.hxx ROOT/TLazyDS.hxx ROOT/TResultProxy.hxx ROOT/TRootDS.hxx ROOT/TSnapshotOptions.hxx ROOT/TTreeProcessorMP.hxx ROOT/TTreeProcessorMT.hxx ROOT/TTrivialDS.hxx ROOT/TVec.hxx /mnt/build/jenkins/workspace/root-pullrequests-build/root/tree/treeplayer/inc/LinkDef.h. 21:28:33 In file included from input_line_12:37:. 21:28:33 /mnt/build/jenkins/workspace/root-pullrequests-build/build/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. 21:28:33 #include <arrow/table.h>. 21:28:33 ^~~~~~~~~~~~~~~. 21:28:33 Error: /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling: compilation failure (/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer721ceb24c2_dictUmbrella.h). ```,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:3143,deployability,build,build,3143,rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h TTreeReaderValue.h TTreeTableInterface.h ROOT/TAdoptAllocator.hxx ROOT/TArrowDS.hxx ROOT/TCsvDS.hxx ROOT/TCutFlowReport.hxx ROOT/TDFActionHelpers.hxx ROOT/TDFHelpers.hxx ROOT/TDFHistoModels.hxx ROOT/TDFInterface.hxx ROOT/TDFInterfaceUtils.hxx ROOT/TDFNodes.hxx ROOT/TDFNodesUtils.hxx ROOT/TDFUtils.hxx ROOT/TDataFrame.hxx ROOT/TDataSource.hxx ROOT/TLazyDS.hxx ROOT/TResultProxy.hxx ROOT/TRootDS.hxx ROOT/TSnapshotOptions.hxx ROOT/TTreeProcessorMP.hxx ROOT/TTreeProcessorMT.hxx ROOT/TTrivialDS.hxx ROOT/TVec.hxx /mnt/build/jenkins/workspace/root-pullrequests-build/root/tree/treeplayer/inc/LinkDef.h. 21:28:33 In file included from input_line_12:37:. 21:28:33 /mnt/build/jenkins/workspace/root-pullrequests-build/build/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. 21:28:33 #include <arrow/table.h>. 21:28:33 ^~~~~~~~~~~~~~~. 21:28:33 Error: /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling: compilation failure (/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer721ceb24c2_dictUmbrella.h). ```,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:3176,deployability,fail,failure,3176,rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h TTreeReaderValue.h TTreeTableInterface.h ROOT/TAdoptAllocator.hxx ROOT/TArrowDS.hxx ROOT/TCsvDS.hxx ROOT/TCutFlowReport.hxx ROOT/TDFActionHelpers.hxx ROOT/TDFHelpers.hxx ROOT/TDFHistoModels.hxx ROOT/TDFInterface.hxx ROOT/TDFInterfaceUtils.hxx ROOT/TDFNodes.hxx ROOT/TDFNodesUtils.hxx ROOT/TDFUtils.hxx ROOT/TDataFrame.hxx ROOT/TDataSource.hxx ROOT/TLazyDS.hxx ROOT/TResultProxy.hxx ROOT/TRootDS.hxx ROOT/TSnapshotOptions.hxx ROOT/TTreeProcessorMP.hxx ROOT/TTreeProcessorMT.hxx ROOT/TTrivialDS.hxx ROOT/TVec.hxx /mnt/build/jenkins/workspace/root-pullrequests-build/root/tree/treeplayer/inc/LinkDef.h. 21:28:33 In file included from input_line_12:37:. 21:28:33 /mnt/build/jenkins/workspace/root-pullrequests-build/build/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. 21:28:33 #include <arrow/table.h>. 21:28:33 ^~~~~~~~~~~~~~~. 21:28:33 Error: /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling: compilation failure (/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer721ceb24c2_dictUmbrella.h). ```,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:3190,deployability,build,build,3190,rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h TTreeReaderValue.h TTreeTableInterface.h ROOT/TAdoptAllocator.hxx ROOT/TArrowDS.hxx ROOT/TCsvDS.hxx ROOT/TCutFlowReport.hxx ROOT/TDFActionHelpers.hxx ROOT/TDFHelpers.hxx ROOT/TDFHistoModels.hxx ROOT/TDFInterface.hxx ROOT/TDFInterfaceUtils.hxx ROOT/TDFNodes.hxx ROOT/TDFNodesUtils.hxx ROOT/TDFUtils.hxx ROOT/TDataFrame.hxx ROOT/TDataSource.hxx ROOT/TLazyDS.hxx ROOT/TResultProxy.hxx ROOT/TRootDS.hxx ROOT/TSnapshotOptions.hxx ROOT/TTreeProcessorMP.hxx ROOT/TTreeProcessorMT.hxx ROOT/TTrivialDS.hxx ROOT/TVec.hxx /mnt/build/jenkins/workspace/root-pullrequests-build/root/tree/treeplayer/inc/LinkDef.h. 21:28:33 In file included from input_line_12:37:. 21:28:33 /mnt/build/jenkins/workspace/root-pullrequests-build/build/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. 21:28:33 #include <arrow/table.h>. 21:28:33 ^~~~~~~~~~~~~~~. 21:28:33 Error: /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling: compilation failure (/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer721ceb24c2_dictUmbrella.h). ```,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:3232,deployability,build,build,3232,rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h TTreeReaderValue.h TTreeTableInterface.h ROOT/TAdoptAllocator.hxx ROOT/TArrowDS.hxx ROOT/TCsvDS.hxx ROOT/TCutFlowReport.hxx ROOT/TDFActionHelpers.hxx ROOT/TDFHelpers.hxx ROOT/TDFHistoModels.hxx ROOT/TDFInterface.hxx ROOT/TDFInterfaceUtils.hxx ROOT/TDFNodes.hxx ROOT/TDFNodesUtils.hxx ROOT/TDFUtils.hxx ROOT/TDataFrame.hxx ROOT/TDataSource.hxx ROOT/TLazyDS.hxx ROOT/TResultProxy.hxx ROOT/TRootDS.hxx ROOT/TSnapshotOptions.hxx ROOT/TTreeProcessorMP.hxx ROOT/TTreeProcessorMT.hxx ROOT/TTrivialDS.hxx ROOT/TVec.hxx /mnt/build/jenkins/workspace/root-pullrequests-build/root/tree/treeplayer/inc/LinkDef.h. 21:28:33 In file included from input_line_12:37:. 21:28:33 /mnt/build/jenkins/workspace/root-pullrequests-build/build/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. 21:28:33 #include <arrow/table.h>. 21:28:33 ^~~~~~~~~~~~~~~. 21:28:33 Error: /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling: compilation failure (/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer721ceb24c2_dictUmbrella.h). ```,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:3238,deployability,build,build,3238,rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h TTreeReaderValue.h TTreeTableInterface.h ROOT/TAdoptAllocator.hxx ROOT/TArrowDS.hxx ROOT/TCsvDS.hxx ROOT/TCutFlowReport.hxx ROOT/TDFActionHelpers.hxx ROOT/TDFHelpers.hxx ROOT/TDFHistoModels.hxx ROOT/TDFInterface.hxx ROOT/TDFInterfaceUtils.hxx ROOT/TDFNodes.hxx ROOT/TDFNodesUtils.hxx ROOT/TDFUtils.hxx ROOT/TDataFrame.hxx ROOT/TDataSource.hxx ROOT/TLazyDS.hxx ROOT/TResultProxy.hxx ROOT/TRootDS.hxx ROOT/TSnapshotOptions.hxx ROOT/TTreeProcessorMP.hxx ROOT/TTreeProcessorMT.hxx ROOT/TTrivialDS.hxx ROOT/TVec.hxx /mnt/build/jenkins/workspace/root-pullrequests-build/root/tree/treeplayer/inc/LinkDef.h. 21:28:33 In file included from input_line_12:37:. 21:28:33 /mnt/build/jenkins/workspace/root-pullrequests-build/build/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. 21:28:33 #include <arrow/table.h>. 21:28:33 ^~~~~~~~~~~~~~~. 21:28:33 Error: /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling: compilation failure (/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer721ceb24c2_dictUmbrella.h). ```,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:4,performance,error,error,4,the error seems to be related to rootcling not finding the Arrow header files. ```. 21:28:33 cd /mnt/build/jenkins/workspace/root-pullrequests-build/build/tree/treeplayer && /cvmfs/sft.cern.ch/lcg/releases/CMake/3.7.0-a8e5d/x86_64-slc6-gcc49-opt/bin/cmake -E env LD_LIBRARY_PATH=/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/bin/../lib:/cvmfs/sft.cern.ch/lcg/releases/java/8u91-ae32f/x86_64-slc6-gcc49-opt/jre/lib/amd64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib:/cvmfs/sft.cern.ch/lcg/contrib/gcc/4.9/x86_64-slc6/lib64 ROOTIGNOREPREFIX=1 /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling -rootbuild -v2 -f G__TreePlayer.cxx -s /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.so -m libTree_rdict.pcm -m libGraf3d_rdict.pcm -m libGraf_rdict.pcm -m libHist_rdict.pcm -m libGpad_rdict.pcm -m libRIO_rdict.pcm -m libMathCore_rdict.pcm -m libMultiProc_rdict.pcm -m libImt_rdict.pcm -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/root -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/build -rml libTreePlayer.so -rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTr,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:2974,performance,error,error,2974,rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h TTreeReaderValue.h TTreeTableInterface.h ROOT/TAdoptAllocator.hxx ROOT/TArrowDS.hxx ROOT/TCsvDS.hxx ROOT/TCutFlowReport.hxx ROOT/TDFActionHelpers.hxx ROOT/TDFHelpers.hxx ROOT/TDFHistoModels.hxx ROOT/TDFInterface.hxx ROOT/TDFInterfaceUtils.hxx ROOT/TDFNodes.hxx ROOT/TDFNodesUtils.hxx ROOT/TDFUtils.hxx ROOT/TDataFrame.hxx ROOT/TDataSource.hxx ROOT/TLazyDS.hxx ROOT/TResultProxy.hxx ROOT/TRootDS.hxx ROOT/TSnapshotOptions.hxx ROOT/TTreeProcessorMP.hxx ROOT/TTreeProcessorMT.hxx ROOT/TTrivialDS.hxx ROOT/TVec.hxx /mnt/build/jenkins/workspace/root-pullrequests-build/root/tree/treeplayer/inc/LinkDef.h. 21:28:33 In file included from input_line_12:37:. 21:28:33 /mnt/build/jenkins/workspace/root-pullrequests-build/build/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. 21:28:33 #include <arrow/table.h>. 21:28:33 ^~~~~~~~~~~~~~~. 21:28:33 Error: /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling: compilation failure (/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer721ceb24c2_dictUmbrella.h). ```,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:3083,performance,Error,Error,3083,rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h TTreeReaderValue.h TTreeTableInterface.h ROOT/TAdoptAllocator.hxx ROOT/TArrowDS.hxx ROOT/TCsvDS.hxx ROOT/TCutFlowReport.hxx ROOT/TDFActionHelpers.hxx ROOT/TDFHelpers.hxx ROOT/TDFHistoModels.hxx ROOT/TDFInterface.hxx ROOT/TDFInterfaceUtils.hxx ROOT/TDFNodes.hxx ROOT/TDFNodesUtils.hxx ROOT/TDFUtils.hxx ROOT/TDataFrame.hxx ROOT/TDataSource.hxx ROOT/TLazyDS.hxx ROOT/TResultProxy.hxx ROOT/TRootDS.hxx ROOT/TSnapshotOptions.hxx ROOT/TTreeProcessorMP.hxx ROOT/TTreeProcessorMT.hxx ROOT/TTrivialDS.hxx ROOT/TVec.hxx /mnt/build/jenkins/workspace/root-pullrequests-build/root/tree/treeplayer/inc/LinkDef.h. 21:28:33 In file included from input_line_12:37:. 21:28:33 /mnt/build/jenkins/workspace/root-pullrequests-build/build/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. 21:28:33 #include <arrow/table.h>. 21:28:33 ^~~~~~~~~~~~~~~. 21:28:33 Error: /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling: compilation failure (/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer721ceb24c2_dictUmbrella.h). ```,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:3176,performance,failur,failure,3176,rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h TTreeReaderValue.h TTreeTableInterface.h ROOT/TAdoptAllocator.hxx ROOT/TArrowDS.hxx ROOT/TCsvDS.hxx ROOT/TCutFlowReport.hxx ROOT/TDFActionHelpers.hxx ROOT/TDFHelpers.hxx ROOT/TDFHistoModels.hxx ROOT/TDFInterface.hxx ROOT/TDFInterfaceUtils.hxx ROOT/TDFNodes.hxx ROOT/TDFNodesUtils.hxx ROOT/TDFUtils.hxx ROOT/TDataFrame.hxx ROOT/TDataSource.hxx ROOT/TLazyDS.hxx ROOT/TResultProxy.hxx ROOT/TRootDS.hxx ROOT/TSnapshotOptions.hxx ROOT/TTreeProcessorMP.hxx ROOT/TTreeProcessorMT.hxx ROOT/TTrivialDS.hxx ROOT/TVec.hxx /mnt/build/jenkins/workspace/root-pullrequests-build/root/tree/treeplayer/inc/LinkDef.h. 21:28:33 In file included from input_line_12:37:. 21:28:33 /mnt/build/jenkins/workspace/root-pullrequests-build/build/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. 21:28:33 #include <arrow/table.h>. 21:28:33 ^~~~~~~~~~~~~~~. 21:28:33 Error: /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling: compilation failure (/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer721ceb24c2_dictUmbrella.h). ```,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:3176,reliability,fail,failure,3176,rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h TTreeReaderValue.h TTreeTableInterface.h ROOT/TAdoptAllocator.hxx ROOT/TArrowDS.hxx ROOT/TCsvDS.hxx ROOT/TCutFlowReport.hxx ROOT/TDFActionHelpers.hxx ROOT/TDFHelpers.hxx ROOT/TDFHistoModels.hxx ROOT/TDFInterface.hxx ROOT/TDFInterfaceUtils.hxx ROOT/TDFNodes.hxx ROOT/TDFNodesUtils.hxx ROOT/TDFUtils.hxx ROOT/TDataFrame.hxx ROOT/TDataSource.hxx ROOT/TLazyDS.hxx ROOT/TResultProxy.hxx ROOT/TRootDS.hxx ROOT/TSnapshotOptions.hxx ROOT/TTreeProcessorMP.hxx ROOT/TTreeProcessorMT.hxx ROOT/TTrivialDS.hxx ROOT/TVec.hxx /mnt/build/jenkins/workspace/root-pullrequests-build/root/tree/treeplayer/inc/LinkDef.h. 21:28:33 In file included from input_line_12:37:. 21:28:33 /mnt/build/jenkins/workspace/root-pullrequests-build/build/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. 21:28:33 #include <arrow/table.h>. 21:28:33 ^~~~~~~~~~~~~~~. 21:28:33 Error: /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling: compilation failure (/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer721ceb24c2_dictUmbrella.h). ```,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:4,safety,error,error,4,the error seems to be related to rootcling not finding the Arrow header files. ```. 21:28:33 cd /mnt/build/jenkins/workspace/root-pullrequests-build/build/tree/treeplayer && /cvmfs/sft.cern.ch/lcg/releases/CMake/3.7.0-a8e5d/x86_64-slc6-gcc49-opt/bin/cmake -E env LD_LIBRARY_PATH=/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/bin/../lib:/cvmfs/sft.cern.ch/lcg/releases/java/8u91-ae32f/x86_64-slc6-gcc49-opt/jre/lib/amd64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib:/cvmfs/sft.cern.ch/lcg/contrib/gcc/4.9/x86_64-slc6/lib64 ROOTIGNOREPREFIX=1 /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling -rootbuild -v2 -f G__TreePlayer.cxx -s /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.so -m libTree_rdict.pcm -m libGraf3d_rdict.pcm -m libGraf_rdict.pcm -m libHist_rdict.pcm -m libGpad_rdict.pcm -m libRIO_rdict.pcm -m libMathCore_rdict.pcm -m libMultiProc_rdict.pcm -m libImt_rdict.pcm -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/root -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/build -rml libTreePlayer.so -rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTr,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:2974,safety,error,error,2974,rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h TTreeReaderValue.h TTreeTableInterface.h ROOT/TAdoptAllocator.hxx ROOT/TArrowDS.hxx ROOT/TCsvDS.hxx ROOT/TCutFlowReport.hxx ROOT/TDFActionHelpers.hxx ROOT/TDFHelpers.hxx ROOT/TDFHistoModels.hxx ROOT/TDFInterface.hxx ROOT/TDFInterfaceUtils.hxx ROOT/TDFNodes.hxx ROOT/TDFNodesUtils.hxx ROOT/TDFUtils.hxx ROOT/TDataFrame.hxx ROOT/TDataSource.hxx ROOT/TLazyDS.hxx ROOT/TResultProxy.hxx ROOT/TRootDS.hxx ROOT/TSnapshotOptions.hxx ROOT/TTreeProcessorMP.hxx ROOT/TTreeProcessorMT.hxx ROOT/TTrivialDS.hxx ROOT/TVec.hxx /mnt/build/jenkins/workspace/root-pullrequests-build/root/tree/treeplayer/inc/LinkDef.h. 21:28:33 In file included from input_line_12:37:. 21:28:33 /mnt/build/jenkins/workspace/root-pullrequests-build/build/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. 21:28:33 #include <arrow/table.h>. 21:28:33 ^~~~~~~~~~~~~~~. 21:28:33 Error: /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling: compilation failure (/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer721ceb24c2_dictUmbrella.h). ```,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:3083,safety,Error,Error,3083,rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h TTreeReaderValue.h TTreeTableInterface.h ROOT/TAdoptAllocator.hxx ROOT/TArrowDS.hxx ROOT/TCsvDS.hxx ROOT/TCutFlowReport.hxx ROOT/TDFActionHelpers.hxx ROOT/TDFHelpers.hxx ROOT/TDFHistoModels.hxx ROOT/TDFInterface.hxx ROOT/TDFInterfaceUtils.hxx ROOT/TDFNodes.hxx ROOT/TDFNodesUtils.hxx ROOT/TDFUtils.hxx ROOT/TDataFrame.hxx ROOT/TDataSource.hxx ROOT/TLazyDS.hxx ROOT/TResultProxy.hxx ROOT/TRootDS.hxx ROOT/TSnapshotOptions.hxx ROOT/TTreeProcessorMP.hxx ROOT/TTreeProcessorMT.hxx ROOT/TTrivialDS.hxx ROOT/TVec.hxx /mnt/build/jenkins/workspace/root-pullrequests-build/root/tree/treeplayer/inc/LinkDef.h. 21:28:33 In file included from input_line_12:37:. 21:28:33 /mnt/build/jenkins/workspace/root-pullrequests-build/build/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. 21:28:33 #include <arrow/table.h>. 21:28:33 ^~~~~~~~~~~~~~~. 21:28:33 Error: /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling: compilation failure (/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer721ceb24c2_dictUmbrella.h). ```,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:4,usability,error,error,4,the error seems to be related to rootcling not finding the Arrow header files. ```. 21:28:33 cd /mnt/build/jenkins/workspace/root-pullrequests-build/build/tree/treeplayer && /cvmfs/sft.cern.ch/lcg/releases/CMake/3.7.0-a8e5d/x86_64-slc6-gcc49-opt/bin/cmake -E env LD_LIBRARY_PATH=/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/bin/../lib:/cvmfs/sft.cern.ch/lcg/releases/java/8u91-ae32f/x86_64-slc6-gcc49-opt/jre/lib/amd64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib64:/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/lib:/cvmfs/sft.cern.ch/lcg/contrib/gcc/4.9/x86_64-slc6/lib64 ROOTIGNOREPREFIX=1 /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling -rootbuild -v2 -f G__TreePlayer.cxx -s /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.so -m libTree_rdict.pcm -m libGraf3d_rdict.pcm -m libGraf_rdict.pcm -m libHist_rdict.pcm -m libGpad_rdict.pcm -m libRIO_rdict.pcm -m libMathCore_rdict.pcm -m libMultiProc_rdict.pcm -m libImt_rdict.pcm -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/root -excludePath /mnt/build/jenkins/workspace/root-pullrequests-build/build -rml libTreePlayer.so -rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTr,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:2974,usability,error,error,2974,rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h TTreeReaderValue.h TTreeTableInterface.h ROOT/TAdoptAllocator.hxx ROOT/TArrowDS.hxx ROOT/TCsvDS.hxx ROOT/TCutFlowReport.hxx ROOT/TDFActionHelpers.hxx ROOT/TDFHelpers.hxx ROOT/TDFHistoModels.hxx ROOT/TDFInterface.hxx ROOT/TDFInterfaceUtils.hxx ROOT/TDFNodes.hxx ROOT/TDFNodesUtils.hxx ROOT/TDFUtils.hxx ROOT/TDataFrame.hxx ROOT/TDataSource.hxx ROOT/TLazyDS.hxx ROOT/TResultProxy.hxx ROOT/TRootDS.hxx ROOT/TSnapshotOptions.hxx ROOT/TTreeProcessorMP.hxx ROOT/TTreeProcessorMT.hxx ROOT/TTrivialDS.hxx ROOT/TVec.hxx /mnt/build/jenkins/workspace/root-pullrequests-build/root/tree/treeplayer/inc/LinkDef.h. 21:28:33 In file included from input_line_12:37:. 21:28:33 /mnt/build/jenkins/workspace/root-pullrequests-build/build/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. 21:28:33 #include <arrow/table.h>. 21:28:33 ^~~~~~~~~~~~~~~. 21:28:33 Error: /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling: compilation failure (/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer721ceb24c2_dictUmbrella.h). ```,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:3083,usability,Error,Error,3083,rmf /mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer.rootmap -writeEmptyRootPCM -I/mnt/build/jenkins/workspace/root-pullrequests-build/root -I/mnt/build/jenkins/workspace/root-pullrequests-build/root/interpreter/cling/include -I/mnt/build/jenkins/workspace/root-pullrequests-build/build/include -I/cvmfs/sft.cern.ch/lcg/views/LCG_rootext20171122/x86_64-slc6-gcc49-opt/include TBranchProxy.h TBranchProxyClassDescriptor.h TBranchProxyDescriptor.h TBranchProxyDirector.h TChainIndex.h TFileDrawMap.h TFormLeafInfo.h TFormLeafInfoReference.h TFriendProxy.h TFriendProxyDescriptor.h TMPWorkerTree.h TRefArrayProxy.h TRefProxy.h TSelectorDraw.h TSelectorEntries.h TSimpleAnalysis.h TTreeDrawArgsParser.h TTreeFormula.h TTreeFormulaManager.h TTreeGeneratorBase.h TTreeIndex.h TTreePerfStats.h TTreePlayer.h TTreeProxyGenerator.h TTreeReader.h TTreeReaderArray.h TTreeReaderGenerator.h TTreeReaderUtils.h TTreeReaderValue.h TTreeTableInterface.h ROOT/TAdoptAllocator.hxx ROOT/TArrowDS.hxx ROOT/TCsvDS.hxx ROOT/TCutFlowReport.hxx ROOT/TDFActionHelpers.hxx ROOT/TDFHelpers.hxx ROOT/TDFHistoModels.hxx ROOT/TDFInterface.hxx ROOT/TDFInterfaceUtils.hxx ROOT/TDFNodes.hxx ROOT/TDFNodesUtils.hxx ROOT/TDFUtils.hxx ROOT/TDataFrame.hxx ROOT/TDataSource.hxx ROOT/TLazyDS.hxx ROOT/TResultProxy.hxx ROOT/TRootDS.hxx ROOT/TSnapshotOptions.hxx ROOT/TTreeProcessorMP.hxx ROOT/TTreeProcessorMT.hxx ROOT/TTrivialDS.hxx ROOT/TVec.hxx /mnt/build/jenkins/workspace/root-pullrequests-build/root/tree/treeplayer/inc/LinkDef.h. 21:28:33 In file included from input_line_12:37:. 21:28:33 /mnt/build/jenkins/workspace/root-pullrequests-build/build/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. 21:28:33 #include <arrow/table.h>. 21:28:33 ^~~~~~~~~~~~~~~. 21:28:33 Error: /mnt/build/jenkins/workspace/root-pullrequests-build/build/bin/rootcling: compilation failure (/mnt/build/jenkins/workspace/root-pullrequests-build/build/lib/libTreePlayer721ceb24c2_dictUmbrella.h). ```,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:97,deployability,version,version,97,"@pcanal, regarding your requirements:. * I've already run `clang-format` on my laptop. If the CI version behaves differently, I am of course happy to fix further stuff. * The documentation is on par with `TCsvDS`, given I copied most of it from there. I am happy to improve it further in a subsequent PR. * The tests are on par with `datasource_csv`, given I simply adapted it to my case. I will of course add more as I experiment more with it myself.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:366,energy efficiency,adapt,adapted,366,"@pcanal, regarding your requirements:. * I've already run `clang-format` on my laptop. If the CI version behaves differently, I am of course happy to fix further stuff. * The documentation is on par with `TCsvDS`, given I copied most of it from there. I am happy to improve it further in a subsequent PR. * The tests are on par with `datasource_csv`, given I simply adapted it to my case. I will of course add more as I experiment more with it myself.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:97,integrability,version,version,97,"@pcanal, regarding your requirements:. * I've already run `clang-format` on my laptop. If the CI version behaves differently, I am of course happy to fix further stuff. * The documentation is on par with `TCsvDS`, given I copied most of it from there. I am happy to improve it further in a subsequent PR. * The tests are on par with `datasource_csv`, given I simply adapted it to my case. I will of course add more as I experiment more with it myself.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:290,integrability,sub,subsequent,290,"@pcanal, regarding your requirements:. * I've already run `clang-format` on my laptop. If the CI version behaves differently, I am of course happy to fix further stuff. * The documentation is on par with `TCsvDS`, given I copied most of it from there. I am happy to improve it further in a subsequent PR. * The tests are on par with `datasource_csv`, given I simply adapted it to my case. I will of course add more as I experiment more with it myself.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:366,integrability,adapt,adapted,366,"@pcanal, regarding your requirements:. * I've already run `clang-format` on my laptop. If the CI version behaves differently, I am of course happy to fix further stuff. * The documentation is on par with `TCsvDS`, given I copied most of it from there. I am happy to improve it further in a subsequent PR. * The tests are on par with `datasource_csv`, given I simply adapted it to my case. I will of course add more as I experiment more with it myself.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:65,interoperability,format,format,65,"@pcanal, regarding your requirements:. * I've already run `clang-format` on my laptop. If the CI version behaves differently, I am of course happy to fix further stuff. * The documentation is on par with `TCsvDS`, given I copied most of it from there. I am happy to improve it further in a subsequent PR. * The tests are on par with `datasource_csv`, given I simply adapted it to my case. I will of course add more as I experiment more with it myself.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:366,interoperability,adapt,adapted,366,"@pcanal, regarding your requirements:. * I've already run `clang-format` on my laptop. If the CI version behaves differently, I am of course happy to fix further stuff. * The documentation is on par with `TCsvDS`, given I copied most of it from there. I am happy to improve it further in a subsequent PR. * The tests are on par with `datasource_csv`, given I simply adapted it to my case. I will of course add more as I experiment more with it myself.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:97,modifiability,version,version,97,"@pcanal, regarding your requirements:. * I've already run `clang-format` on my laptop. If the CI version behaves differently, I am of course happy to fix further stuff. * The documentation is on par with `TCsvDS`, given I copied most of it from there. I am happy to improve it further in a subsequent PR. * The tests are on par with `datasource_csv`, given I simply adapted it to my case. I will of course add more as I experiment more with it myself.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:366,modifiability,adapt,adapted,366,"@pcanal, regarding your requirements:. * I've already run `clang-format` on my laptop. If the CI version behaves differently, I am of course happy to fix further stuff. * The documentation is on par with `TCsvDS`, given I copied most of it from there. I am happy to improve it further in a subsequent PR. * The tests are on par with `datasource_csv`, given I simply adapted it to my case. I will of course add more as I experiment more with it myself.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:311,safety,test,tests,311,"@pcanal, regarding your requirements:. * I've already run `clang-format` on my laptop. If the CI version behaves differently, I am of course happy to fix further stuff. * The documentation is on par with `TCsvDS`, given I copied most of it from there. I am happy to improve it further in a subsequent PR. * The tests are on par with `datasource_csv`, given I simply adapted it to my case. I will of course add more as I experiment more with it myself.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:311,testability,test,tests,311,"@pcanal, regarding your requirements:. * I've already run `clang-format` on my laptop. If the CI version behaves differently, I am of course happy to fix further stuff. * The documentation is on par with `TCsvDS`, given I copied most of it from there. I am happy to improve it further in a subsequent PR. * The tests are on par with `datasource_csv`, given I simply adapted it to my case. I will of course add more as I experiment more with it myself.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:359,testability,simpl,simply,359,"@pcanal, regarding your requirements:. * I've already run `clang-format` on my laptop. If the CI version behaves differently, I am of course happy to fix further stuff. * The documentation is on par with `TCsvDS`, given I copied most of it from there. I am happy to improve it further in a subsequent PR. * The tests are on par with `datasource_csv`, given I simply adapted it to my case. I will of course add more as I experiment more with it myself.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:175,usability,document,documentation,175,"@pcanal, regarding your requirements:. * I've already run `clang-format` on my laptop. If the CI version behaves differently, I am of course happy to fix further stuff. * The documentation is on par with `TCsvDS`, given I copied most of it from there. I am happy to improve it further in a subsequent PR. * The tests are on par with `datasource_csv`, given I simply adapted it to my case. I will of course add more as I experiment more with it myself.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:359,usability,simpl,simply,359,"@pcanal, regarding your requirements:. * I've already run `clang-format` on my laptop. If the CI version behaves differently, I am of course happy to fix further stuff. * The documentation is on par with `TCsvDS`, given I copied most of it from there. I am happy to improve it further in a subsequent PR. * The tests are on par with `datasource_csv`, given I simply adapted it to my case. I will of course add more as I experiment more with it myself.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:103,safety,test,tested,103,"I've hopefully fixed it. Of course this means that unless you include arrow in the CI, nothing will be tested for real.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:103,testability,test,tested,103,"I've hopefully fixed it. Of course this means that unless you include arrow in the CI, nothing will be tested for real.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:20,deployability,build,build,20,Some hack I have to build the test unoptimised was mistakenly added to the commit. I removed it.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:30,safety,test,test,30,Some hack I have to build the test unoptimised was mistakenly added to the commit. I removed it.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:5,security,hack,hack,5,Some hack I have to build the test unoptimised was mistakenly added to the commit. I removed it.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:30,testability,test,test,30,Some hack I have to build the test unoptimised was mistakenly added to the commit. I removed it.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:26,deployability,integr,integration,26,"I strongly favour a quick integration of this PR but, @pcanal before integrating I think there are other steps besides the suggested doc + tutorials + tests. For example a double check by @amadio about the CMake code to find arrow and arrow itself in our externals and/or inclusion of arrow in the built-ins (needs discussion). . @ktf, the tutorials for this TDS should go in https://github.com/root-project/root/tree/master/tutorials/dataframe . You can punch in the C++ and Python version of the example you'd like to propose: ROOT will pick them up as tests for the CI and the doc machinery will put them on the web https://root.cern/doc/master/group__tutorial__tdataframe.html accessible also as rendered notebooks and notebooks runable in [SWAN](https://swan.cern.ch).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:69,deployability,integr,integrating,69,"I strongly favour a quick integration of this PR but, @pcanal before integrating I think there are other steps besides the suggested doc + tutorials + tests. For example a double check by @amadio about the CMake code to find arrow and arrow itself in our externals and/or inclusion of arrow in the built-ins (needs discussion). . @ktf, the tutorials for this TDS should go in https://github.com/root-project/root/tree/master/tutorials/dataframe . You can punch in the C++ and Python version of the example you'd like to propose: ROOT will pick them up as tests for the CI and the doc machinery will put them on the web https://root.cern/doc/master/group__tutorial__tdataframe.html accessible also as rendered notebooks and notebooks runable in [SWAN](https://swan.cern.ch).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:483,deployability,version,version,483,"I strongly favour a quick integration of this PR but, @pcanal before integrating I think there are other steps besides the suggested doc + tutorials + tests. For example a double check by @amadio about the CMake code to find arrow and arrow itself in our externals and/or inclusion of arrow in the built-ins (needs discussion). . @ktf, the tutorials for this TDS should go in https://github.com/root-project/root/tree/master/tutorials/dataframe . You can punch in the C++ and Python version of the example you'd like to propose: ROOT will pick them up as tests for the CI and the doc machinery will put them on the web https://root.cern/doc/master/group__tutorial__tdataframe.html accessible also as rendered notebooks and notebooks runable in [SWAN](https://swan.cern.ch).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:26,integrability,integr,integration,26,"I strongly favour a quick integration of this PR but, @pcanal before integrating I think there are other steps besides the suggested doc + tutorials + tests. For example a double check by @amadio about the CMake code to find arrow and arrow itself in our externals and/or inclusion of arrow in the built-ins (needs discussion). . @ktf, the tutorials for this TDS should go in https://github.com/root-project/root/tree/master/tutorials/dataframe . You can punch in the C++ and Python version of the example you'd like to propose: ROOT will pick them up as tests for the CI and the doc machinery will put them on the web https://root.cern/doc/master/group__tutorial__tdataframe.html accessible also as rendered notebooks and notebooks runable in [SWAN](https://swan.cern.ch).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:69,integrability,integr,integrating,69,"I strongly favour a quick integration of this PR but, @pcanal before integrating I think there are other steps besides the suggested doc + tutorials + tests. For example a double check by @amadio about the CMake code to find arrow and arrow itself in our externals and/or inclusion of arrow in the built-ins (needs discussion). . @ktf, the tutorials for this TDS should go in https://github.com/root-project/root/tree/master/tutorials/dataframe . You can punch in the C++ and Python version of the example you'd like to propose: ROOT will pick them up as tests for the CI and the doc machinery will put them on the web https://root.cern/doc/master/group__tutorial__tdataframe.html accessible also as rendered notebooks and notebooks runable in [SWAN](https://swan.cern.ch).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:483,integrability,version,version,483,"I strongly favour a quick integration of this PR but, @pcanal before integrating I think there are other steps besides the suggested doc + tutorials + tests. For example a double check by @amadio about the CMake code to find arrow and arrow itself in our externals and/or inclusion of arrow in the built-ins (needs discussion). . @ktf, the tutorials for this TDS should go in https://github.com/root-project/root/tree/master/tutorials/dataframe . You can punch in the C++ and Python version of the example you'd like to propose: ROOT will pick them up as tests for the CI and the doc machinery will put them on the web https://root.cern/doc/master/group__tutorial__tdataframe.html accessible also as rendered notebooks and notebooks runable in [SWAN](https://swan.cern.ch).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:26,interoperability,integr,integration,26,"I strongly favour a quick integration of this PR but, @pcanal before integrating I think there are other steps besides the suggested doc + tutorials + tests. For example a double check by @amadio about the CMake code to find arrow and arrow itself in our externals and/or inclusion of arrow in the built-ins (needs discussion). . @ktf, the tutorials for this TDS should go in https://github.com/root-project/root/tree/master/tutorials/dataframe . You can punch in the C++ and Python version of the example you'd like to propose: ROOT will pick them up as tests for the CI and the doc machinery will put them on the web https://root.cern/doc/master/group__tutorial__tdataframe.html accessible also as rendered notebooks and notebooks runable in [SWAN](https://swan.cern.ch).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:69,interoperability,integr,integrating,69,"I strongly favour a quick integration of this PR but, @pcanal before integrating I think there are other steps besides the suggested doc + tutorials + tests. For example a double check by @amadio about the CMake code to find arrow and arrow itself in our externals and/or inclusion of arrow in the built-ins (needs discussion). . @ktf, the tutorials for this TDS should go in https://github.com/root-project/root/tree/master/tutorials/dataframe . You can punch in the C++ and Python version of the example you'd like to propose: ROOT will pick them up as tests for the CI and the doc machinery will put them on the web https://root.cern/doc/master/group__tutorial__tdataframe.html accessible also as rendered notebooks and notebooks runable in [SWAN](https://swan.cern.ch).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:26,modifiability,integr,integration,26,"I strongly favour a quick integration of this PR but, @pcanal before integrating I think there are other steps besides the suggested doc + tutorials + tests. For example a double check by @amadio about the CMake code to find arrow and arrow itself in our externals and/or inclusion of arrow in the built-ins (needs discussion). . @ktf, the tutorials for this TDS should go in https://github.com/root-project/root/tree/master/tutorials/dataframe . You can punch in the C++ and Python version of the example you'd like to propose: ROOT will pick them up as tests for the CI and the doc machinery will put them on the web https://root.cern/doc/master/group__tutorial__tdataframe.html accessible also as rendered notebooks and notebooks runable in [SWAN](https://swan.cern.ch).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:69,modifiability,integr,integrating,69,"I strongly favour a quick integration of this PR but, @pcanal before integrating I think there are other steps besides the suggested doc + tutorials + tests. For example a double check by @amadio about the CMake code to find arrow and arrow itself in our externals and/or inclusion of arrow in the built-ins (needs discussion). . @ktf, the tutorials for this TDS should go in https://github.com/root-project/root/tree/master/tutorials/dataframe . You can punch in the C++ and Python version of the example you'd like to propose: ROOT will pick them up as tests for the CI and the doc machinery will put them on the web https://root.cern/doc/master/group__tutorial__tdataframe.html accessible also as rendered notebooks and notebooks runable in [SWAN](https://swan.cern.ch).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:483,modifiability,version,version,483,"I strongly favour a quick integration of this PR but, @pcanal before integrating I think there are other steps besides the suggested doc + tutorials + tests. For example a double check by @amadio about the CMake code to find arrow and arrow itself in our externals and/or inclusion of arrow in the built-ins (needs discussion). . @ktf, the tutorials for this TDS should go in https://github.com/root-project/root/tree/master/tutorials/dataframe . You can punch in the C++ and Python version of the example you'd like to propose: ROOT will pick them up as tests for the CI and the doc machinery will put them on the web https://root.cern/doc/master/group__tutorial__tdataframe.html accessible also as rendered notebooks and notebooks runable in [SWAN](https://swan.cern.ch).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:26,reliability,integr,integration,26,"I strongly favour a quick integration of this PR but, @pcanal before integrating I think there are other steps besides the suggested doc + tutorials + tests. For example a double check by @amadio about the CMake code to find arrow and arrow itself in our externals and/or inclusion of arrow in the built-ins (needs discussion). . @ktf, the tutorials for this TDS should go in https://github.com/root-project/root/tree/master/tutorials/dataframe . You can punch in the C++ and Python version of the example you'd like to propose: ROOT will pick them up as tests for the CI and the doc machinery will put them on the web https://root.cern/doc/master/group__tutorial__tdataframe.html accessible also as rendered notebooks and notebooks runable in [SWAN](https://swan.cern.ch).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:69,reliability,integr,integrating,69,"I strongly favour a quick integration of this PR but, @pcanal before integrating I think there are other steps besides the suggested doc + tutorials + tests. For example a double check by @amadio about the CMake code to find arrow and arrow itself in our externals and/or inclusion of arrow in the built-ins (needs discussion). . @ktf, the tutorials for this TDS should go in https://github.com/root-project/root/tree/master/tutorials/dataframe . You can punch in the C++ and Python version of the example you'd like to propose: ROOT will pick them up as tests for the CI and the doc machinery will put them on the web https://root.cern/doc/master/group__tutorial__tdataframe.html accessible also as rendered notebooks and notebooks runable in [SWAN](https://swan.cern.ch).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:151,safety,test,tests,151,"I strongly favour a quick integration of this PR but, @pcanal before integrating I think there are other steps besides the suggested doc + tutorials + tests. For example a double check by @amadio about the CMake code to find arrow and arrow itself in our externals and/or inclusion of arrow in the built-ins (needs discussion). . @ktf, the tutorials for this TDS should go in https://github.com/root-project/root/tree/master/tutorials/dataframe . You can punch in the C++ and Python version of the example you'd like to propose: ROOT will pick them up as tests for the CI and the doc machinery will put them on the web https://root.cern/doc/master/group__tutorial__tdataframe.html accessible also as rendered notebooks and notebooks runable in [SWAN](https://swan.cern.ch).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:555,safety,test,tests,555,"I strongly favour a quick integration of this PR but, @pcanal before integrating I think there are other steps besides the suggested doc + tutorials + tests. For example a double check by @amadio about the CMake code to find arrow and arrow itself in our externals and/or inclusion of arrow in the built-ins (needs discussion). . @ktf, the tutorials for this TDS should go in https://github.com/root-project/root/tree/master/tutorials/dataframe . You can punch in the C++ and Python version of the example you'd like to propose: ROOT will pick them up as tests for the CI and the doc machinery will put them on the web https://root.cern/doc/master/group__tutorial__tdataframe.html accessible also as rendered notebooks and notebooks runable in [SWAN](https://swan.cern.ch).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:26,security,integr,integration,26,"I strongly favour a quick integration of this PR but, @pcanal before integrating I think there are other steps besides the suggested doc + tutorials + tests. For example a double check by @amadio about the CMake code to find arrow and arrow itself in our externals and/or inclusion of arrow in the built-ins (needs discussion). . @ktf, the tutorials for this TDS should go in https://github.com/root-project/root/tree/master/tutorials/dataframe . You can punch in the C++ and Python version of the example you'd like to propose: ROOT will pick them up as tests for the CI and the doc machinery will put them on the web https://root.cern/doc/master/group__tutorial__tdataframe.html accessible also as rendered notebooks and notebooks runable in [SWAN](https://swan.cern.ch).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:69,security,integr,integrating,69,"I strongly favour a quick integration of this PR but, @pcanal before integrating I think there are other steps besides the suggested doc + tutorials + tests. For example a double check by @amadio about the CMake code to find arrow and arrow itself in our externals and/or inclusion of arrow in the built-ins (needs discussion). . @ktf, the tutorials for this TDS should go in https://github.com/root-project/root/tree/master/tutorials/dataframe . You can punch in the C++ and Python version of the example you'd like to propose: ROOT will pick them up as tests for the CI and the doc machinery will put them on the web https://root.cern/doc/master/group__tutorial__tdataframe.html accessible also as rendered notebooks and notebooks runable in [SWAN](https://swan.cern.ch).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:681,security,access,accessible,681,"I strongly favour a quick integration of this PR but, @pcanal before integrating I think there are other steps besides the suggested doc + tutorials + tests. For example a double check by @amadio about the CMake code to find arrow and arrow itself in our externals and/or inclusion of arrow in the built-ins (needs discussion). . @ktf, the tutorials for this TDS should go in https://github.com/root-project/root/tree/master/tutorials/dataframe . You can punch in the C++ and Python version of the example you'd like to propose: ROOT will pick them up as tests for the CI and the doc machinery will put them on the web https://root.cern/doc/master/group__tutorial__tdataframe.html accessible also as rendered notebooks and notebooks runable in [SWAN](https://swan.cern.ch).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:26,testability,integr,integration,26,"I strongly favour a quick integration of this PR but, @pcanal before integrating I think there are other steps besides the suggested doc + tutorials + tests. For example a double check by @amadio about the CMake code to find arrow and arrow itself in our externals and/or inclusion of arrow in the built-ins (needs discussion). . @ktf, the tutorials for this TDS should go in https://github.com/root-project/root/tree/master/tutorials/dataframe . You can punch in the C++ and Python version of the example you'd like to propose: ROOT will pick them up as tests for the CI and the doc machinery will put them on the web https://root.cern/doc/master/group__tutorial__tdataframe.html accessible also as rendered notebooks and notebooks runable in [SWAN](https://swan.cern.ch).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:69,testability,integr,integrating,69,"I strongly favour a quick integration of this PR but, @pcanal before integrating I think there are other steps besides the suggested doc + tutorials + tests. For example a double check by @amadio about the CMake code to find arrow and arrow itself in our externals and/or inclusion of arrow in the built-ins (needs discussion). . @ktf, the tutorials for this TDS should go in https://github.com/root-project/root/tree/master/tutorials/dataframe . You can punch in the C++ and Python version of the example you'd like to propose: ROOT will pick them up as tests for the CI and the doc machinery will put them on the web https://root.cern/doc/master/group__tutorial__tdataframe.html accessible also as rendered notebooks and notebooks runable in [SWAN](https://swan.cern.ch).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:151,testability,test,tests,151,"I strongly favour a quick integration of this PR but, @pcanal before integrating I think there are other steps besides the suggested doc + tutorials + tests. For example a double check by @amadio about the CMake code to find arrow and arrow itself in our externals and/or inclusion of arrow in the built-ins (needs discussion). . @ktf, the tutorials for this TDS should go in https://github.com/root-project/root/tree/master/tutorials/dataframe . You can punch in the C++ and Python version of the example you'd like to propose: ROOT will pick them up as tests for the CI and the doc machinery will put them on the web https://root.cern/doc/master/group__tutorial__tdataframe.html accessible also as rendered notebooks and notebooks runable in [SWAN](https://swan.cern.ch).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:555,testability,test,tests,555,"I strongly favour a quick integration of this PR but, @pcanal before integrating I think there are other steps besides the suggested doc + tutorials + tests. For example a double check by @amadio about the CMake code to find arrow and arrow itself in our externals and/or inclusion of arrow in the built-ins (needs discussion). . @ktf, the tutorials for this TDS should go in https://github.com/root-project/root/tree/master/tutorials/dataframe . You can punch in the C++ and Python version of the example you'd like to propose: ROOT will pick them up as tests for the CI and the doc machinery will put them on the web https://root.cern/doc/master/group__tutorial__tdataframe.html accessible also as rendered notebooks and notebooks runable in [SWAN](https://swan.cern.ch).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:32,interoperability,format,format,32,How am I supposed to run `clang-format` so that it behaves like the PR checker? ```bash. clang-format -i src/TArrowDS.cxx inc/ROOT/TArrowDS.hxx test/dataframe/datasource_arrow.cxx. ```. gives me no changes.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:95,interoperability,format,format,95,How am I supposed to run `clang-format` so that it behaves like the PR checker? ```bash. clang-format -i src/TArrowDS.cxx inc/ROOT/TArrowDS.hxx test/dataframe/datasource_arrow.cxx. ```. gives me no changes.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:144,safety,test,test,144,How am I supposed to run `clang-format` so that it behaves like the PR checker? ```bash. clang-format -i src/TArrowDS.cxx inc/ROOT/TArrowDS.hxx test/dataframe/datasource_arrow.cxx. ```. gives me no changes.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:144,testability,test,test,144,How am I supposed to run `clang-format` so that it behaves like the PR checker? ```bash. clang-format -i src/TArrowDS.cxx inc/ROOT/TArrowDS.hxx test/dataframe/datasource_arrow.cxx. ```. gives me no changes.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:72,deployability,configurat,configuration,72,"@ktf, try to run it from the very root directory. It should pick up our configuration :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:72,integrability,configur,configuration,72,"@ktf, try to run it from the very root directory. It should pick up our configuration :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:72,modifiability,configur,configuration,72,"@ktf, try to run it from the very root directory. It should pick up our configuration :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:72,security,configur,configuration,72,"@ktf, try to run it from the very root directory. It should pick up our configuration :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:97,interoperability,format,format,97,"It actually looks up in parents directory as well, like git does. In any case I did:. ```. clang-format -i tree/treeplayer/src/TArrowDS.cxx tree/treeplayer/inc/ROOT/TArrowDS.hxx tree/treeplayer/test/dataframe/datasource_arrow.cxx. ```. and I still have the same results.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:60,reliability,doe,does,60,"It actually looks up in parents directory as well, like git does. In any case I did:. ```. clang-format -i tree/treeplayer/src/TArrowDS.cxx tree/treeplayer/inc/ROOT/TArrowDS.hxx tree/treeplayer/test/dataframe/datasource_arrow.cxx. ```. and I still have the same results.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:194,safety,test,test,194,"It actually looks up in parents directory as well, like git does. In any case I did:. ```. clang-format -i tree/treeplayer/src/TArrowDS.cxx tree/treeplayer/inc/ROOT/TArrowDS.hxx tree/treeplayer/test/dataframe/datasource_arrow.cxx. ```. and I still have the same results.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:194,testability,test,test,194,"It actually looks up in parents directory as well, like git does. In any case I did:. ```. clang-format -i tree/treeplayer/src/TArrowDS.cxx tree/treeplayer/inc/ROOT/TArrowDS.hxx tree/treeplayer/test/dataframe/datasource_arrow.cxx. ```. and I still have the same results.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:21,deployability,log,log,21,"Hi @ktf , the travis log could be clearer, but it indicates how to run the same command it does:. ```. Running clang-format-3.9 against branch master, with hash 7554be95715898fa2a93528254ce3646764ab3d2. clang-format failed. To reproduce it locally please run. 	git checkout master. 	git-clang-format --commit 7554be95715898fa2a93528254ce3646764ab3d2 --diff --binary /usr/local/clang-5.0.0/bin/clang-format. ```. This system is not perfect and you might have to adapt hashes/paths to your case, but this is it. If you do not get any corrections you might somehow be overriding ROOT's clang-format configuration.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:216,deployability,fail,failed,216,"Hi @ktf , the travis log could be clearer, but it indicates how to run the same command it does:. ```. Running clang-format-3.9 against branch master, with hash 7554be95715898fa2a93528254ce3646764ab3d2. clang-format failed. To reproduce it locally please run. 	git checkout master. 	git-clang-format --commit 7554be95715898fa2a93528254ce3646764ab3d2 --diff --binary /usr/local/clang-5.0.0/bin/clang-format. ```. This system is not perfect and you might have to adapt hashes/paths to your case, but this is it. If you do not get any corrections you might somehow be overriding ROOT's clang-format configuration.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:596,deployability,configurat,configuration,596,"Hi @ktf , the travis log could be clearer, but it indicates how to run the same command it does:. ```. Running clang-format-3.9 against branch master, with hash 7554be95715898fa2a93528254ce3646764ab3d2. clang-format failed. To reproduce it locally please run. 	git checkout master. 	git-clang-format --commit 7554be95715898fa2a93528254ce3646764ab3d2 --diff --binary /usr/local/clang-5.0.0/bin/clang-format. ```. This system is not perfect and you might have to adapt hashes/paths to your case, but this is it. If you do not get any corrections you might somehow be overriding ROOT's clang-format configuration.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:461,energy efficiency,adapt,adapt,461,"Hi @ktf , the travis log could be clearer, but it indicates how to run the same command it does:. ```. Running clang-format-3.9 against branch master, with hash 7554be95715898fa2a93528254ce3646764ab3d2. clang-format failed. To reproduce it locally please run. 	git checkout master. 	git-clang-format --commit 7554be95715898fa2a93528254ce3646764ab3d2 --diff --binary /usr/local/clang-5.0.0/bin/clang-format. ```. This system is not perfect and you might have to adapt hashes/paths to your case, but this is it. If you do not get any corrections you might somehow be overriding ROOT's clang-format configuration.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:461,integrability,adapt,adapt,461,"Hi @ktf , the travis log could be clearer, but it indicates how to run the same command it does:. ```. Running clang-format-3.9 against branch master, with hash 7554be95715898fa2a93528254ce3646764ab3d2. clang-format failed. To reproduce it locally please run. 	git checkout master. 	git-clang-format --commit 7554be95715898fa2a93528254ce3646764ab3d2 --diff --binary /usr/local/clang-5.0.0/bin/clang-format. ```. This system is not perfect and you might have to adapt hashes/paths to your case, but this is it. If you do not get any corrections you might somehow be overriding ROOT's clang-format configuration.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:596,integrability,configur,configuration,596,"Hi @ktf , the travis log could be clearer, but it indicates how to run the same command it does:. ```. Running clang-format-3.9 against branch master, with hash 7554be95715898fa2a93528254ce3646764ab3d2. clang-format failed. To reproduce it locally please run. 	git checkout master. 	git-clang-format --commit 7554be95715898fa2a93528254ce3646764ab3d2 --diff --binary /usr/local/clang-5.0.0/bin/clang-format. ```. This system is not perfect and you might have to adapt hashes/paths to your case, but this is it. If you do not get any corrections you might somehow be overriding ROOT's clang-format configuration.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:117,interoperability,format,format-,117,"Hi @ktf , the travis log could be clearer, but it indicates how to run the same command it does:. ```. Running clang-format-3.9 against branch master, with hash 7554be95715898fa2a93528254ce3646764ab3d2. clang-format failed. To reproduce it locally please run. 	git checkout master. 	git-clang-format --commit 7554be95715898fa2a93528254ce3646764ab3d2 --diff --binary /usr/local/clang-5.0.0/bin/clang-format. ```. This system is not perfect and you might have to adapt hashes/paths to your case, but this is it. If you do not get any corrections you might somehow be overriding ROOT's clang-format configuration.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:209,interoperability,format,format,209,"Hi @ktf , the travis log could be clearer, but it indicates how to run the same command it does:. ```. Running clang-format-3.9 against branch master, with hash 7554be95715898fa2a93528254ce3646764ab3d2. clang-format failed. To reproduce it locally please run. 	git checkout master. 	git-clang-format --commit 7554be95715898fa2a93528254ce3646764ab3d2 --diff --binary /usr/local/clang-5.0.0/bin/clang-format. ```. This system is not perfect and you might have to adapt hashes/paths to your case, but this is it. If you do not get any corrections you might somehow be overriding ROOT's clang-format configuration.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:293,interoperability,format,format,293,"Hi @ktf , the travis log could be clearer, but it indicates how to run the same command it does:. ```. Running clang-format-3.9 against branch master, with hash 7554be95715898fa2a93528254ce3646764ab3d2. clang-format failed. To reproduce it locally please run. 	git checkout master. 	git-clang-format --commit 7554be95715898fa2a93528254ce3646764ab3d2 --diff --binary /usr/local/clang-5.0.0/bin/clang-format. ```. This system is not perfect and you might have to adapt hashes/paths to your case, but this is it. If you do not get any corrections you might somehow be overriding ROOT's clang-format configuration.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:399,interoperability,format,format,399,"Hi @ktf , the travis log could be clearer, but it indicates how to run the same command it does:. ```. Running clang-format-3.9 against branch master, with hash 7554be95715898fa2a93528254ce3646764ab3d2. clang-format failed. To reproduce it locally please run. 	git checkout master. 	git-clang-format --commit 7554be95715898fa2a93528254ce3646764ab3d2 --diff --binary /usr/local/clang-5.0.0/bin/clang-format. ```. This system is not perfect and you might have to adapt hashes/paths to your case, but this is it. If you do not get any corrections you might somehow be overriding ROOT's clang-format configuration.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:461,interoperability,adapt,adapt,461,"Hi @ktf , the travis log could be clearer, but it indicates how to run the same command it does:. ```. Running clang-format-3.9 against branch master, with hash 7554be95715898fa2a93528254ce3646764ab3d2. clang-format failed. To reproduce it locally please run. 	git checkout master. 	git-clang-format --commit 7554be95715898fa2a93528254ce3646764ab3d2 --diff --binary /usr/local/clang-5.0.0/bin/clang-format. ```. This system is not perfect and you might have to adapt hashes/paths to your case, but this is it. If you do not get any corrections you might somehow be overriding ROOT's clang-format configuration.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:589,interoperability,format,format,589,"Hi @ktf , the travis log could be clearer, but it indicates how to run the same command it does:. ```. Running clang-format-3.9 against branch master, with hash 7554be95715898fa2a93528254ce3646764ab3d2. clang-format failed. To reproduce it locally please run. 	git checkout master. 	git-clang-format --commit 7554be95715898fa2a93528254ce3646764ab3d2 --diff --binary /usr/local/clang-5.0.0/bin/clang-format. ```. This system is not perfect and you might have to adapt hashes/paths to your case, but this is it. If you do not get any corrections you might somehow be overriding ROOT's clang-format configuration.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:461,modifiability,adapt,adapt,461,"Hi @ktf , the travis log could be clearer, but it indicates how to run the same command it does:. ```. Running clang-format-3.9 against branch master, with hash 7554be95715898fa2a93528254ce3646764ab3d2. clang-format failed. To reproduce it locally please run. 	git checkout master. 	git-clang-format --commit 7554be95715898fa2a93528254ce3646764ab3d2 --diff --binary /usr/local/clang-5.0.0/bin/clang-format. ```. This system is not perfect and you might have to adapt hashes/paths to your case, but this is it. If you do not get any corrections you might somehow be overriding ROOT's clang-format configuration.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:596,modifiability,configur,configuration,596,"Hi @ktf , the travis log could be clearer, but it indicates how to run the same command it does:. ```. Running clang-format-3.9 against branch master, with hash 7554be95715898fa2a93528254ce3646764ab3d2. clang-format failed. To reproduce it locally please run. 	git checkout master. 	git-clang-format --commit 7554be95715898fa2a93528254ce3646764ab3d2 --diff --binary /usr/local/clang-5.0.0/bin/clang-format. ```. This system is not perfect and you might have to adapt hashes/paths to your case, but this is it. If you do not get any corrections you might somehow be overriding ROOT's clang-format configuration.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:91,reliability,doe,does,91,"Hi @ktf , the travis log could be clearer, but it indicates how to run the same command it does:. ```. Running clang-format-3.9 against branch master, with hash 7554be95715898fa2a93528254ce3646764ab3d2. clang-format failed. To reproduce it locally please run. 	git checkout master. 	git-clang-format --commit 7554be95715898fa2a93528254ce3646764ab3d2 --diff --binary /usr/local/clang-5.0.0/bin/clang-format. ```. This system is not perfect and you might have to adapt hashes/paths to your case, but this is it. If you do not get any corrections you might somehow be overriding ROOT's clang-format configuration.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:216,reliability,fail,failed,216,"Hi @ktf , the travis log could be clearer, but it indicates how to run the same command it does:. ```. Running clang-format-3.9 against branch master, with hash 7554be95715898fa2a93528254ce3646764ab3d2. clang-format failed. To reproduce it locally please run. 	git checkout master. 	git-clang-format --commit 7554be95715898fa2a93528254ce3646764ab3d2 --diff --binary /usr/local/clang-5.0.0/bin/clang-format. ```. This system is not perfect and you might have to adapt hashes/paths to your case, but this is it. If you do not get any corrections you might somehow be overriding ROOT's clang-format configuration.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:21,safety,log,log,21,"Hi @ktf , the travis log could be clearer, but it indicates how to run the same command it does:. ```. Running clang-format-3.9 against branch master, with hash 7554be95715898fa2a93528254ce3646764ab3d2. clang-format failed. To reproduce it locally please run. 	git checkout master. 	git-clang-format --commit 7554be95715898fa2a93528254ce3646764ab3d2 --diff --binary /usr/local/clang-5.0.0/bin/clang-format. ```. This system is not perfect and you might have to adapt hashes/paths to your case, but this is it. If you do not get any corrections you might somehow be overriding ROOT's clang-format configuration.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:21,security,log,log,21,"Hi @ktf , the travis log could be clearer, but it indicates how to run the same command it does:. ```. Running clang-format-3.9 against branch master, with hash 7554be95715898fa2a93528254ce3646764ab3d2. clang-format failed. To reproduce it locally please run. 	git checkout master. 	git-clang-format --commit 7554be95715898fa2a93528254ce3646764ab3d2 --diff --binary /usr/local/clang-5.0.0/bin/clang-format. ```. This system is not perfect and you might have to adapt hashes/paths to your case, but this is it. If you do not get any corrections you might somehow be overriding ROOT's clang-format configuration.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:156,security,hash,hash,156,"Hi @ktf , the travis log could be clearer, but it indicates how to run the same command it does:. ```. Running clang-format-3.9 against branch master, with hash 7554be95715898fa2a93528254ce3646764ab3d2. clang-format failed. To reproduce it locally please run. 	git checkout master. 	git-clang-format --commit 7554be95715898fa2a93528254ce3646764ab3d2 --diff --binary /usr/local/clang-5.0.0/bin/clang-format. ```. This system is not perfect and you might have to adapt hashes/paths to your case, but this is it. If you do not get any corrections you might somehow be overriding ROOT's clang-format configuration.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:467,security,hash,hashes,467,"Hi @ktf , the travis log could be clearer, but it indicates how to run the same command it does:. ```. Running clang-format-3.9 against branch master, with hash 7554be95715898fa2a93528254ce3646764ab3d2. clang-format failed. To reproduce it locally please run. 	git checkout master. 	git-clang-format --commit 7554be95715898fa2a93528254ce3646764ab3d2 --diff --binary /usr/local/clang-5.0.0/bin/clang-format. ```. This system is not perfect and you might have to adapt hashes/paths to your case, but this is it. If you do not get any corrections you might somehow be overriding ROOT's clang-format configuration.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:596,security,configur,configuration,596,"Hi @ktf , the travis log could be clearer, but it indicates how to run the same command it does:. ```. Running clang-format-3.9 against branch master, with hash 7554be95715898fa2a93528254ce3646764ab3d2. clang-format failed. To reproduce it locally please run. 	git checkout master. 	git-clang-format --commit 7554be95715898fa2a93528254ce3646764ab3d2 --diff --binary /usr/local/clang-5.0.0/bin/clang-format. ```. This system is not perfect and you might have to adapt hashes/paths to your case, but this is it. If you do not get any corrections you might somehow be overriding ROOT's clang-format configuration.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:21,testability,log,log,21,"Hi @ktf , the travis log could be clearer, but it indicates how to run the same command it does:. ```. Running clang-format-3.9 against branch master, with hash 7554be95715898fa2a93528254ce3646764ab3d2. clang-format failed. To reproduce it locally please run. 	git checkout master. 	git-clang-format --commit 7554be95715898fa2a93528254ce3646764ab3d2 --diff --binary /usr/local/clang-5.0.0/bin/clang-format. ```. This system is not perfect and you might have to adapt hashes/paths to your case, but this is it. If you do not get any corrections you might somehow be overriding ROOT's clang-format configuration.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:34,usability,clear,clearer,34,"Hi @ktf , the travis log could be clearer, but it indicates how to run the same command it does:. ```. Running clang-format-3.9 against branch master, with hash 7554be95715898fa2a93528254ce3646764ab3d2. clang-format failed. To reproduce it locally please run. 	git checkout master. 	git-clang-format --commit 7554be95715898fa2a93528254ce3646764ab3d2 --diff --binary /usr/local/clang-5.0.0/bin/clang-format. ```. This system is not perfect and you might have to adapt hashes/paths to your case, but this is it. If you do not get any corrections you might somehow be overriding ROOT's clang-format configuration.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:50,usability,indicat,indicates,50,"Hi @ktf , the travis log could be clearer, but it indicates how to run the same command it does:. ```. Running clang-format-3.9 against branch master, with hash 7554be95715898fa2a93528254ce3646764ab3d2. clang-format failed. To reproduce it locally please run. 	git checkout master. 	git-clang-format --commit 7554be95715898fa2a93528254ce3646764ab3d2 --diff --binary /usr/local/clang-5.0.0/bin/clang-format. ```. This system is not perfect and you might have to adapt hashes/paths to your case, but this is it. If you do not get any corrections you might somehow be overriding ROOT's clang-format configuration.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:80,usability,command,command,80,"Hi @ktf , the travis log could be clearer, but it indicates how to run the same command it does:. ```. Running clang-format-3.9 against branch master, with hash 7554be95715898fa2a93528254ce3646764ab3d2. clang-format failed. To reproduce it locally please run. 	git checkout master. 	git-clang-format --commit 7554be95715898fa2a93528254ce3646764ab3d2 --diff --binary /usr/local/clang-5.0.0/bin/clang-format. ```. This system is not perfect and you might have to adapt hashes/paths to your case, but this is it. If you do not get any corrections you might somehow be overriding ROOT's clang-format configuration.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:278,availability,error,error,278,"I am pretty sure I am running `clang-format` correctly, and I did try with `git-clang-format` with the same result. I suspect the problem is the fact I am using a newer version of `clang-format`. I will fix things by hand. Since I updated to the tip of the branch I also get an error when compiling the test:. ```. In file included from /Users/ktf/work/active/sw/SOURCES/ROOT/master/0/tree/treeplayer/test/dataframe/datasource_arrow.cxx:2:. /Users/ktf/work/active/sw/BUILD/3b4c53a9fa7efde0667fff1580b37f11a3842da8/ROOT/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. #include <arrow/table.h>. ^~~~~~~~~~~~~~~. ```. however the TreePlayer compiles fine. Am I missing something trivial? This used to work on the previous commit I was using.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:557,availability,error,error,557,"I am pretty sure I am running `clang-format` correctly, and I did try with `git-clang-format` with the same result. I suspect the problem is the fact I am using a newer version of `clang-format`. I will fix things by hand. Since I updated to the tip of the branch I also get an error when compiling the test:. ```. In file included from /Users/ktf/work/active/sw/SOURCES/ROOT/master/0/tree/treeplayer/test/dataframe/datasource_arrow.cxx:2:. /Users/ktf/work/active/sw/BUILD/3b4c53a9fa7efde0667fff1580b37f11a3842da8/ROOT/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. #include <arrow/table.h>. ^~~~~~~~~~~~~~~. ```. however the TreePlayer compiles fine. Am I missing something trivial? This used to work on the previous commit I was using.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:169,deployability,version,version,169,"I am pretty sure I am running `clang-format` correctly, and I did try with `git-clang-format` with the same result. I suspect the problem is the fact I am using a newer version of `clang-format`. I will fix things by hand. Since I updated to the tip of the branch I also get an error when compiling the test:. ```. In file included from /Users/ktf/work/active/sw/SOURCES/ROOT/master/0/tree/treeplayer/test/dataframe/datasource_arrow.cxx:2:. /Users/ktf/work/active/sw/BUILD/3b4c53a9fa7efde0667fff1580b37f11a3842da8/ROOT/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. #include <arrow/table.h>. ^~~~~~~~~~~~~~~. ```. however the TreePlayer compiles fine. Am I missing something trivial? This used to work on the previous commit I was using.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:231,deployability,updat,updated,231,"I am pretty sure I am running `clang-format` correctly, and I did try with `git-clang-format` with the same result. I suspect the problem is the fact I am using a newer version of `clang-format`. I will fix things by hand. Since I updated to the tip of the branch I also get an error when compiling the test:. ```. In file included from /Users/ktf/work/active/sw/SOURCES/ROOT/master/0/tree/treeplayer/test/dataframe/datasource_arrow.cxx:2:. /Users/ktf/work/active/sw/BUILD/3b4c53a9fa7efde0667fff1580b37f11a3842da8/ROOT/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. #include <arrow/table.h>. ^~~~~~~~~~~~~~~. ```. however the TreePlayer compiles fine. Am I missing something trivial? This used to work on the previous commit I was using.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:467,deployability,BUILD,BUILD,467,"I am pretty sure I am running `clang-format` correctly, and I did try with `git-clang-format` with the same result. I suspect the problem is the fact I am using a newer version of `clang-format`. I will fix things by hand. Since I updated to the tip of the branch I also get an error when compiling the test:. ```. In file included from /Users/ktf/work/active/sw/SOURCES/ROOT/master/0/tree/treeplayer/test/dataframe/datasource_arrow.cxx:2:. /Users/ktf/work/active/sw/BUILD/3b4c53a9fa7efde0667fff1580b37f11a3842da8/ROOT/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. #include <arrow/table.h>. ^~~~~~~~~~~~~~~. ```. however the TreePlayer compiles fine. Am I missing something trivial? This used to work on the previous commit I was using.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:169,integrability,version,version,169,"I am pretty sure I am running `clang-format` correctly, and I did try with `git-clang-format` with the same result. I suspect the problem is the fact I am using a newer version of `clang-format`. I will fix things by hand. Since I updated to the tip of the branch I also get an error when compiling the test:. ```. In file included from /Users/ktf/work/active/sw/SOURCES/ROOT/master/0/tree/treeplayer/test/dataframe/datasource_arrow.cxx:2:. /Users/ktf/work/active/sw/BUILD/3b4c53a9fa7efde0667fff1580b37f11a3842da8/ROOT/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. #include <arrow/table.h>. ^~~~~~~~~~~~~~~. ```. however the TreePlayer compiles fine. Am I missing something trivial? This used to work on the previous commit I was using.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:37,interoperability,format,format,37,"I am pretty sure I am running `clang-format` correctly, and I did try with `git-clang-format` with the same result. I suspect the problem is the fact I am using a newer version of `clang-format`. I will fix things by hand. Since I updated to the tip of the branch I also get an error when compiling the test:. ```. In file included from /Users/ktf/work/active/sw/SOURCES/ROOT/master/0/tree/treeplayer/test/dataframe/datasource_arrow.cxx:2:. /Users/ktf/work/active/sw/BUILD/3b4c53a9fa7efde0667fff1580b37f11a3842da8/ROOT/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. #include <arrow/table.h>. ^~~~~~~~~~~~~~~. ```. however the TreePlayer compiles fine. Am I missing something trivial? This used to work on the previous commit I was using.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:86,interoperability,format,format,86,"I am pretty sure I am running `clang-format` correctly, and I did try with `git-clang-format` with the same result. I suspect the problem is the fact I am using a newer version of `clang-format`. I will fix things by hand. Since I updated to the tip of the branch I also get an error when compiling the test:. ```. In file included from /Users/ktf/work/active/sw/SOURCES/ROOT/master/0/tree/treeplayer/test/dataframe/datasource_arrow.cxx:2:. /Users/ktf/work/active/sw/BUILD/3b4c53a9fa7efde0667fff1580b37f11a3842da8/ROOT/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. #include <arrow/table.h>. ^~~~~~~~~~~~~~~. ```. however the TreePlayer compiles fine. Am I missing something trivial? This used to work on the previous commit I was using.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:187,interoperability,format,format,187,"I am pretty sure I am running `clang-format` correctly, and I did try with `git-clang-format` with the same result. I suspect the problem is the fact I am using a newer version of `clang-format`. I will fix things by hand. Since I updated to the tip of the branch I also get an error when compiling the test:. ```. In file included from /Users/ktf/work/active/sw/SOURCES/ROOT/master/0/tree/treeplayer/test/dataframe/datasource_arrow.cxx:2:. /Users/ktf/work/active/sw/BUILD/3b4c53a9fa7efde0667fff1580b37f11a3842da8/ROOT/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. #include <arrow/table.h>. ^~~~~~~~~~~~~~~. ```. however the TreePlayer compiles fine. Am I missing something trivial? This used to work on the previous commit I was using.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:169,modifiability,version,version,169,"I am pretty sure I am running `clang-format` correctly, and I did try with `git-clang-format` with the same result. I suspect the problem is the fact I am using a newer version of `clang-format`. I will fix things by hand. Since I updated to the tip of the branch I also get an error when compiling the test:. ```. In file included from /Users/ktf/work/active/sw/SOURCES/ROOT/master/0/tree/treeplayer/test/dataframe/datasource_arrow.cxx:2:. /Users/ktf/work/active/sw/BUILD/3b4c53a9fa7efde0667fff1580b37f11a3842da8/ROOT/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. #include <arrow/table.h>. ^~~~~~~~~~~~~~~. ```. however the TreePlayer compiles fine. Am I missing something trivial? This used to work on the previous commit I was using.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:278,performance,error,error,278,"I am pretty sure I am running `clang-format` correctly, and I did try with `git-clang-format` with the same result. I suspect the problem is the fact I am using a newer version of `clang-format`. I will fix things by hand. Since I updated to the tip of the branch I also get an error when compiling the test:. ```. In file included from /Users/ktf/work/active/sw/SOURCES/ROOT/master/0/tree/treeplayer/test/dataframe/datasource_arrow.cxx:2:. /Users/ktf/work/active/sw/BUILD/3b4c53a9fa7efde0667fff1580b37f11a3842da8/ROOT/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. #include <arrow/table.h>. ^~~~~~~~~~~~~~~. ```. however the TreePlayer compiles fine. Am I missing something trivial? This used to work on the previous commit I was using.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:557,performance,error,error,557,"I am pretty sure I am running `clang-format` correctly, and I did try with `git-clang-format` with the same result. I suspect the problem is the fact I am using a newer version of `clang-format`. I will fix things by hand. Since I updated to the tip of the branch I also get an error when compiling the test:. ```. In file included from /Users/ktf/work/active/sw/SOURCES/ROOT/master/0/tree/treeplayer/test/dataframe/datasource_arrow.cxx:2:. /Users/ktf/work/active/sw/BUILD/3b4c53a9fa7efde0667fff1580b37f11a3842da8/ROOT/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. #include <arrow/table.h>. ^~~~~~~~~~~~~~~. ```. however the TreePlayer compiles fine. Am I missing something trivial? This used to work on the previous commit I was using.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:231,safety,updat,updated,231,"I am pretty sure I am running `clang-format` correctly, and I did try with `git-clang-format` with the same result. I suspect the problem is the fact I am using a newer version of `clang-format`. I will fix things by hand. Since I updated to the tip of the branch I also get an error when compiling the test:. ```. In file included from /Users/ktf/work/active/sw/SOURCES/ROOT/master/0/tree/treeplayer/test/dataframe/datasource_arrow.cxx:2:. /Users/ktf/work/active/sw/BUILD/3b4c53a9fa7efde0667fff1580b37f11a3842da8/ROOT/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. #include <arrow/table.h>. ^~~~~~~~~~~~~~~. ```. however the TreePlayer compiles fine. Am I missing something trivial? This used to work on the previous commit I was using.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:278,safety,error,error,278,"I am pretty sure I am running `clang-format` correctly, and I did try with `git-clang-format` with the same result. I suspect the problem is the fact I am using a newer version of `clang-format`. I will fix things by hand. Since I updated to the tip of the branch I also get an error when compiling the test:. ```. In file included from /Users/ktf/work/active/sw/SOURCES/ROOT/master/0/tree/treeplayer/test/dataframe/datasource_arrow.cxx:2:. /Users/ktf/work/active/sw/BUILD/3b4c53a9fa7efde0667fff1580b37f11a3842da8/ROOT/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. #include <arrow/table.h>. ^~~~~~~~~~~~~~~. ```. however the TreePlayer compiles fine. Am I missing something trivial? This used to work on the previous commit I was using.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:303,safety,test,test,303,"I am pretty sure I am running `clang-format` correctly, and I did try with `git-clang-format` with the same result. I suspect the problem is the fact I am using a newer version of `clang-format`. I will fix things by hand. Since I updated to the tip of the branch I also get an error when compiling the test:. ```. In file included from /Users/ktf/work/active/sw/SOURCES/ROOT/master/0/tree/treeplayer/test/dataframe/datasource_arrow.cxx:2:. /Users/ktf/work/active/sw/BUILD/3b4c53a9fa7efde0667fff1580b37f11a3842da8/ROOT/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. #include <arrow/table.h>. ^~~~~~~~~~~~~~~. ```. however the TreePlayer compiles fine. Am I missing something trivial? This used to work on the previous commit I was using.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:401,safety,test,test,401,"I am pretty sure I am running `clang-format` correctly, and I did try with `git-clang-format` with the same result. I suspect the problem is the fact I am using a newer version of `clang-format`. I will fix things by hand. Since I updated to the tip of the branch I also get an error when compiling the test:. ```. In file included from /Users/ktf/work/active/sw/SOURCES/ROOT/master/0/tree/treeplayer/test/dataframe/datasource_arrow.cxx:2:. /Users/ktf/work/active/sw/BUILD/3b4c53a9fa7efde0667fff1580b37f11a3842da8/ROOT/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. #include <arrow/table.h>. ^~~~~~~~~~~~~~~. ```. however the TreePlayer compiles fine. Am I missing something trivial? This used to work on the previous commit I was using.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:557,safety,error,error,557,"I am pretty sure I am running `clang-format` correctly, and I did try with `git-clang-format` with the same result. I suspect the problem is the fact I am using a newer version of `clang-format`. I will fix things by hand. Since I updated to the tip of the branch I also get an error when compiling the test:. ```. In file included from /Users/ktf/work/active/sw/SOURCES/ROOT/master/0/tree/treeplayer/test/dataframe/datasource_arrow.cxx:2:. /Users/ktf/work/active/sw/BUILD/3b4c53a9fa7efde0667fff1580b37f11a3842da8/ROOT/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. #include <arrow/table.h>. ^~~~~~~~~~~~~~~. ```. however the TreePlayer compiles fine. Am I missing something trivial? This used to work on the previous commit I was using.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:231,security,updat,updated,231,"I am pretty sure I am running `clang-format` correctly, and I did try with `git-clang-format` with the same result. I suspect the problem is the fact I am using a newer version of `clang-format`. I will fix things by hand. Since I updated to the tip of the branch I also get an error when compiling the test:. ```. In file included from /Users/ktf/work/active/sw/SOURCES/ROOT/master/0/tree/treeplayer/test/dataframe/datasource_arrow.cxx:2:. /Users/ktf/work/active/sw/BUILD/3b4c53a9fa7efde0667fff1580b37f11a3842da8/ROOT/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. #include <arrow/table.h>. ^~~~~~~~~~~~~~~. ```. however the TreePlayer compiles fine. Am I missing something trivial? This used to work on the previous commit I was using.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:303,testability,test,test,303,"I am pretty sure I am running `clang-format` correctly, and I did try with `git-clang-format` with the same result. I suspect the problem is the fact I am using a newer version of `clang-format`. I will fix things by hand. Since I updated to the tip of the branch I also get an error when compiling the test:. ```. In file included from /Users/ktf/work/active/sw/SOURCES/ROOT/master/0/tree/treeplayer/test/dataframe/datasource_arrow.cxx:2:. /Users/ktf/work/active/sw/BUILD/3b4c53a9fa7efde0667fff1580b37f11a3842da8/ROOT/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. #include <arrow/table.h>. ^~~~~~~~~~~~~~~. ```. however the TreePlayer compiles fine. Am I missing something trivial? This used to work on the previous commit I was using.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:401,testability,test,test,401,"I am pretty sure I am running `clang-format` correctly, and I did try with `git-clang-format` with the same result. I suspect the problem is the fact I am using a newer version of `clang-format`. I will fix things by hand. Since I updated to the tip of the branch I also get an error when compiling the test:. ```. In file included from /Users/ktf/work/active/sw/SOURCES/ROOT/master/0/tree/treeplayer/test/dataframe/datasource_arrow.cxx:2:. /Users/ktf/work/active/sw/BUILD/3b4c53a9fa7efde0667fff1580b37f11a3842da8/ROOT/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. #include <arrow/table.h>. ^~~~~~~~~~~~~~~. ```. however the TreePlayer compiles fine. Am I missing something trivial? This used to work on the previous commit I was using.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:246,usability,tip,tip,246,"I am pretty sure I am running `clang-format` correctly, and I did try with `git-clang-format` with the same result. I suspect the problem is the fact I am using a newer version of `clang-format`. I will fix things by hand. Since I updated to the tip of the branch I also get an error when compiling the test:. ```. In file included from /Users/ktf/work/active/sw/SOURCES/ROOT/master/0/tree/treeplayer/test/dataframe/datasource_arrow.cxx:2:. /Users/ktf/work/active/sw/BUILD/3b4c53a9fa7efde0667fff1580b37f11a3842da8/ROOT/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. #include <arrow/table.h>. ^~~~~~~~~~~~~~~. ```. however the TreePlayer compiles fine. Am I missing something trivial? This used to work on the previous commit I was using.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:278,usability,error,error,278,"I am pretty sure I am running `clang-format` correctly, and I did try with `git-clang-format` with the same result. I suspect the problem is the fact I am using a newer version of `clang-format`. I will fix things by hand. Since I updated to the tip of the branch I also get an error when compiling the test:. ```. In file included from /Users/ktf/work/active/sw/SOURCES/ROOT/master/0/tree/treeplayer/test/dataframe/datasource_arrow.cxx:2:. /Users/ktf/work/active/sw/BUILD/3b4c53a9fa7efde0667fff1580b37f11a3842da8/ROOT/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. #include <arrow/table.h>. ^~~~~~~~~~~~~~~. ```. however the TreePlayer compiles fine. Am I missing something trivial? This used to work on the previous commit I was using.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:338,usability,User,Users,338,"I am pretty sure I am running `clang-format` correctly, and I did try with `git-clang-format` with the same result. I suspect the problem is the fact I am using a newer version of `clang-format`. I will fix things by hand. Since I updated to the tip of the branch I also get an error when compiling the test:. ```. In file included from /Users/ktf/work/active/sw/SOURCES/ROOT/master/0/tree/treeplayer/test/dataframe/datasource_arrow.cxx:2:. /Users/ktf/work/active/sw/BUILD/3b4c53a9fa7efde0667fff1580b37f11a3842da8/ROOT/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. #include <arrow/table.h>. ^~~~~~~~~~~~~~~. ```. however the TreePlayer compiles fine. Am I missing something trivial? This used to work on the previous commit I was using.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:442,usability,User,Users,442,"I am pretty sure I am running `clang-format` correctly, and I did try with `git-clang-format` with the same result. I suspect the problem is the fact I am using a newer version of `clang-format`. I will fix things by hand. Since I updated to the tip of the branch I also get an error when compiling the test:. ```. In file included from /Users/ktf/work/active/sw/SOURCES/ROOT/master/0/tree/treeplayer/test/dataframe/datasource_arrow.cxx:2:. /Users/ktf/work/active/sw/BUILD/3b4c53a9fa7efde0667fff1580b37f11a3842da8/ROOT/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. #include <arrow/table.h>. ^~~~~~~~~~~~~~~. ```. however the TreePlayer compiles fine. Am I missing something trivial? This used to work on the previous commit I was using.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:557,usability,error,error,557,"I am pretty sure I am running `clang-format` correctly, and I did try with `git-clang-format` with the same result. I suspect the problem is the fact I am using a newer version of `clang-format`. I will fix things by hand. Since I updated to the tip of the branch I also get an error when compiling the test:. ```. In file included from /Users/ktf/work/active/sw/SOURCES/ROOT/master/0/tree/treeplayer/test/dataframe/datasource_arrow.cxx:2:. /Users/ktf/work/active/sw/BUILD/3b4c53a9fa7efde0667fff1580b37f11a3842da8/ROOT/include/ROOT/TArrowDS.hxx:4:10: fatal error: 'arrow/table.h' file not found. #include <arrow/table.h>. ^~~~~~~~~~~~~~~. ```. however the TreePlayer compiles fine. Am I missing something trivial? This used to work on the previous commit I was using.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:14,deployability,patch,patch,14,"I applied the patch of proposed style changes and fixed the missing include in the test. Please let me know if you expect anything else from my side before merging this. I am happy to improve the tutorial, but I'd rather do this is a separate PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:14,safety,patch,patch,14,"I applied the patch of proposed style changes and fixed the missing include in the test. Please let me know if you expect anything else from my side before merging this. I am happy to improve the tutorial, but I'd rather do this is a separate PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:83,safety,test,test,83,"I applied the patch of proposed style changes and fixed the missing include in the test. Please let me know if you expect anything else from my side before merging this. I am happy to improve the tutorial, but I'd rather do this is a separate PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:14,security,patch,patch,14,"I applied the patch of proposed style changes and fixed the missing include in the test. Please let me know if you expect anything else from my side before merging this. I am happy to improve the tutorial, but I'd rather do this is a separate PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:83,testability,test,test,83,"I applied the patch of proposed style changes and fixed the missing include in the test. Please let me know if you expect anything else from my side before merging this. I am happy to improve the tutorial, but I'd rather do this is a separate PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:259,deployability,releas,release,259,"@amadio I pushed a new commit where I fixed the things I considered real issues from your comments. I did not fix the ones which are more about code development taste as I'd rather avoid risking introducing bugs and delay further the inclusion of this in the release. We can of course debate on better implementations, but I'd rather do it in a separate PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:181,safety,avoid,avoid,181,"@amadio I pushed a new commit where I fixed the things I considered real issues from your comments. I did not fix the ones which are more about code development taste as I'd rather avoid risking introducing bugs and delay further the inclusion of this in the release. We can of course debate on better implementations, but I'd rather do it in a separate PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:187,safety,risk,risking,187,"@amadio I pushed a new commit where I fixed the things I considered real issues from your comments. I did not fix the ones which are more about code development taste as I'd rather avoid risking introducing bugs and delay further the inclusion of this in the release. We can of course debate on better implementations, but I'd rather do it in a separate PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:187,security,risk,risking,187,"@amadio I pushed a new commit where I fixed the things I considered real issues from your comments. I did not fix the ones which are more about code development taste as I'd rather avoid risking introducing bugs and delay further the inclusion of this in the release. We can of course debate on better implementations, but I'd rather do it in a separate PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:143,safety,test,test,143,"@ktf That's fine. As I said, my comments were to be taken only as suggestions. Hopefully we will get Arrow in the externals soon to be able to test and merge. Cheers,",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:143,testability,test,test,143,"@ktf That's fine. As I said, my comments were to be taken only as suggestions. Hopefully we will get Arrow in the externals soon to be able to test and merge. Cheers,",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:11,deployability,build,build,11,@phsft-bot build please.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:19,availability,error,error,19,Is this a spurious error?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:19,performance,error,error,19,Is this a spurious error?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:19,safety,error,error,19,Is this a spurious error?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:19,usability,error,error,19,Is this a spurious error?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:30,availability,error,error,30,"Hi @ktf, yes. It's a checkout error. Let me do one thing...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:30,performance,error,error,30,"Hi @ktf, yes. It's a checkout error. Let me do one thing...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:30,safety,error,error,30,"Hi @ktf, yes. It's a checkout error. Let me do one thing...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:30,usability,error,error,30,"Hi @ktf, yes. It's a checkout error. Let me do one thing...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:11,deployability,build,build,11,@phsft-bot build please!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:11,deployability,build,build,11,@phsft-bot build with flags -Darrow=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:188,availability,error,error,188,"I am not able to reproduce and the code looks correct to me. The only thing I see as potential issue is the fact line 137 is an assert, but I do not understand how that could result in an error, especially because a few lines above the compiler seems to be happy when using the same variable. Am I missing something trivial here? I am using the same arrow version, BTW.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:356,deployability,version,version,356,"I am not able to reproduce and the code looks correct to me. The only thing I see as potential issue is the fact line 137 is an assert, but I do not understand how that could result in an error, especially because a few lines above the compiler seems to be happy when using the same variable. Am I missing something trivial here? I am using the same arrow version, BTW.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:356,integrability,version,version,356,"I am not able to reproduce and the code looks correct to me. The only thing I see as potential issue is the fact line 137 is an assert, but I do not understand how that could result in an error, especially because a few lines above the compiler seems to be happy when using the same variable. Am I missing something trivial here? I am using the same arrow version, BTW.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:283,modifiability,variab,variable,283,"I am not able to reproduce and the code looks correct to me. The only thing I see as potential issue is the fact line 137 is an assert, but I do not understand how that could result in an error, especially because a few lines above the compiler seems to be happy when using the same variable. Am I missing something trivial here? I am using the same arrow version, BTW.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:356,modifiability,version,version,356,"I am not able to reproduce and the code looks correct to me. The only thing I see as potential issue is the fact line 137 is an assert, but I do not understand how that could result in an error, especially because a few lines above the compiler seems to be happy when using the same variable. Am I missing something trivial here? I am using the same arrow version, BTW.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:188,performance,error,error,188,"I am not able to reproduce and the code looks correct to me. The only thing I see as potential issue is the fact line 137 is an assert, but I do not understand how that could result in an error, especially because a few lines above the compiler seems to be happy when using the same variable. Am I missing something trivial here? I am using the same arrow version, BTW.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:188,safety,error,error,188,"I am not able to reproduce and the code looks correct to me. The only thing I see as potential issue is the fact line 137 is an assert, but I do not understand how that could result in an error, especially because a few lines above the compiler seems to be happy when using the same variable. Am I missing something trivial here? I am using the same arrow version, BTW.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:128,testability,assert,assert,128,"I am not able to reproduce and the code looks correct to me. The only thing I see as potential issue is the fact line 137 is an assert, but I do not understand how that could result in an error, especially because a few lines above the compiler seems to be happy when using the same variable. Am I missing something trivial here? I am using the same arrow version, BTW.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:149,testability,understand,understand,149,"I am not able to reproduce and the code looks correct to me. The only thing I see as potential issue is the fact line 137 is an assert, but I do not understand how that could result in an error, especially because a few lines above the compiler seems to be happy when using the same variable. Am I missing something trivial here? I am using the same arrow version, BTW.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:188,usability,error,error,188,"I am not able to reproduce and the code looks correct to me. The only thing I see as potential issue is the fact line 137 is an assert, but I do not understand how that could result in an error, especially because a few lines above the compiler seems to be happy when using the same variable. Am I missing something trivial here? I am using the same arrow version, BTW.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:11,deployability,build,build,11,@phsft-bot build when you have a minute,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:11,deployability,build,build,11,@phsft-bot build with flags -Darrow=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:11,deployability,build,build,11,@phsft-bot build with flags -Darrow=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:11,deployability,build,build,11,@phsft-bot build with flags -Darrow=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:122,deployability,Build,Build,122,"I forgot there are two visitors... will fix. On Tue, 27 Mar 2018 at 15:19, phsft-bot <notifications@github.com> wrote:. > Build failed on slc6/gcc62. > See console output. > <https://epsft-jenkins.cern.ch/job/root-pullrequests-build/20469/console>. > Warnings:. >. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:90:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::DictionaryType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:89:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::UnionType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:88:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::StructType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:87:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::ListType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:86:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::Decimal128Type&) was hidd",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:128,deployability,fail,failed,128,"I forgot there are two visitors... will fix. On Tue, 27 Mar 2018 at 15:19, phsft-bot <notifications@github.com> wrote:. > Build failed on slc6/gcc62. > See console output. > <https://epsft-jenkins.cern.ch/job/root-pullrequests-build/20469/console>. > Warnings:. >. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:90:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::DictionaryType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:89:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::UnionType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:88:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::StructType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:87:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::ListType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:86:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::Decimal128Type&) was hidd",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:227,deployability,build,build,227,"I forgot there are two visitors... will fix. On Tue, 27 Mar 2018 at 15:19, phsft-bot <notifications@github.com> wrote:. > Build failed on slc6/gcc62. > See console output. > <https://epsft-jenkins.cern.ch/job/root-pullrequests-build/20469/console>. > Warnings:. >. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:90:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::DictionaryType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:89:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::UnionType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:88:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::StructType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:87:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::ListType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:86:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::Decimal128Type&) was hidd",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:296,deployability,releas,releases,296,"I forgot there are two visitors... will fix. On Tue, 27 Mar 2018 at 15:19, phsft-bot <notifications@github.com> wrote:. > Build failed on slc6/gcc62. > See console output. > <https://epsft-jenkins.cern.ch/job/root-pullrequests-build/20469/console>. > Warnings:. >. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:90:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::DictionaryType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:89:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::UnionType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:88:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::StructType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:87:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::ListType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:86:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::Decimal128Type&) was hidd",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:680,deployability,releas,releases,680,"I forgot there are two visitors... will fix. On Tue, 27 Mar 2018 at 15:19, phsft-bot <notifications@github.com> wrote:. > Build failed on slc6/gcc62. > See console output. > <https://epsft-jenkins.cern.ch/job/root-pullrequests-build/20469/console>. > Warnings:. >. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:90:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::DictionaryType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:89:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::UnionType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:88:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::StructType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:87:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::ListType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:86:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::Decimal128Type&) was hidd",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:1059,deployability,releas,releases,1059,"8 at 15:19, phsft-bot <notifications@github.com> wrote:. > Build failed on slc6/gcc62. > See console output. > <https://epsft-jenkins.cern.ch/job/root-pullrequests-build/20469/console>. > Warnings:. >. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:90:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::DictionaryType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:89:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::UnionType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:88:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::StructType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:87:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::ListType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:86:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::Decimal128Type&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArr",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:1439,deployability,releas,releases,1439, > arrow::DictionaryType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:89:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::UnionType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:88:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::StructType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:87:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::ListType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:86:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::Decimal128Type&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. >. > And 84 more. > Failing tests:. >. > -. > projectroot.tree.treeplayer.test.gtest_tree_treeplayer_test_datasource_arrow. > <https://epsft-jenkins.cern.ch/job/root-pullrequests-build/20469/testReport/projectroot.tree.treeplayer/test/gtest_tree_treeplayer_test_datasource_,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:1817,deployability,releas,releases,1817,"tual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::UnionType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:88:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::StructType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:87:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::ListType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:86:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::Decimal128Type&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. >. > And 84 more. > Failing tests:. >. > -. > projectroot.tree.treeplayer.test.gtest_tree_treeplayer_test_datasource_arrow. > <https://epsft-jenkins.cern.ch/job/root-pullrequests-build/20469/testReport/projectroot.tree.treeplayer/test/gtest_tree_treeplayer_test_datasource_arrow/>. >. > . > You are receiving this because you were mentioned. > Reply to this email directly, view it on GitHub. > <https://github.com/root-project/root/pull/1712#issuecomment-376521563>,. > or mute the thread. > <https://github.com/notifications/unsubscribe-auth/AAApMNXWkIzMpGRjU2YzWZW95tWceJ5Oks5tijw2gaJpZM4Siqq9>. > . >.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:2190,deployability,Fail,Failing,2190,"tual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::UnionType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:88:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::StructType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:87:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::ListType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:86:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::Decimal128Type&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. >. > And 84 more. > Failing tests:. >. > -. > projectroot.tree.treeplayer.test.gtest_tree_treeplayer_test_datasource_arrow. > <https://epsft-jenkins.cern.ch/job/root-pullrequests-build/20469/testReport/projectroot.tree.treeplayer/test/gtest_tree_treeplayer_test_datasource_arrow/>. >. > . > You are receiving this because you were mentioned. > Reply to this email directly, view it on GitHub. > <https://github.com/root-project/root/pull/1712#issuecomment-376521563>,. > or mute the thread. > <https://github.com/notifications/unsubscribe-auth/AAApMNXWkIzMpGRjU2YzWZW95tWceJ5Oks5tijw2gaJpZM4Siqq9>. > . >.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:2349,deployability,build,build,2349,"tual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::UnionType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:88:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::StructType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:87:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::ListType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:86:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::Decimal128Type&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. >. > And 84 more. > Failing tests:. >. > -. > projectroot.tree.treeplayer.test.gtest_tree_treeplayer_test_datasource_arrow. > <https://epsft-jenkins.cern.ch/job/root-pullrequests-build/20469/testReport/projectroot.tree.treeplayer/test/gtest_tree_treeplayer_test_datasource_arrow/>. >. > . > You are receiving this because you were mentioned. > Reply to this email directly, view it on GitHub. > <https://github.com/root-project/root/pull/1712#issuecomment-376521563>,. > or mute the thread. > <https://github.com/notifications/unsubscribe-auth/AAApMNXWkIzMpGRjU2YzWZW95tWceJ5Oks5tijw2gaJpZM4Siqq9>. > . >.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:128,reliability,fail,failed,128,"I forgot there are two visitors... will fix. On Tue, 27 Mar 2018 at 15:19, phsft-bot <notifications@github.com> wrote:. > Build failed on slc6/gcc62. > See console output. > <https://epsft-jenkins.cern.ch/job/root-pullrequests-build/20469/console>. > Warnings:. >. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:90:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::DictionaryType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:89:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::UnionType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:88:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::StructType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:87:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::ListType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:86:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::Decimal128Type&) was hidd",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:2190,reliability,Fail,Failing,2190,"tual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::UnionType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:88:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::StructType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:87:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::ListType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:86:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::Decimal128Type&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. >. > And 84 more. > Failing tests:. >. > -. > projectroot.tree.treeplayer.test.gtest_tree_treeplayer_test_datasource_arrow. > <https://epsft-jenkins.cern.ch/job/root-pullrequests-build/20469/testReport/projectroot.tree.treeplayer/test/gtest_tree_treeplayer_test_datasource_arrow/>. >. > . > You are receiving this because you were mentioned. > Reply to this email directly, view it on GitHub. > <https://github.com/root-project/root/pull/1712#issuecomment-376521563>,. > or mute the thread. > <https://github.com/notifications/unsubscribe-auth/AAApMNXWkIzMpGRjU2YzWZW95tWceJ5Oks5tijw2gaJpZM4Siqq9>. > . >.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:2198,safety,test,tests,2198,"tual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::UnionType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:88:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::StructType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:87:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::ListType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:86:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::Decimal128Type&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. >. > And 84 more. > Failing tests:. >. > -. > projectroot.tree.treeplayer.test.gtest_tree_treeplayer_test_datasource_arrow. > <https://epsft-jenkins.cern.ch/job/root-pullrequests-build/20469/testReport/projectroot.tree.treeplayer/test/gtest_tree_treeplayer_test_datasource_arrow/>. >. > . > You are receiving this because you were mentioned. > Reply to this email directly, view it on GitHub. > <https://github.com/root-project/root/pull/1712#issuecomment-376521563>,. > or mute the thread. > <https://github.com/notifications/unsubscribe-auth/AAApMNXWkIzMpGRjU2YzWZW95tWceJ5Oks5tijw2gaJpZM4Siqq9>. > . >.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:2244,safety,test,test,2244,"tual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::UnionType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:88:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::StructType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:87:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::ListType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:86:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::Decimal128Type&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. >. > And 84 more. > Failing tests:. >. > -. > projectroot.tree.treeplayer.test.gtest_tree_treeplayer_test_datasource_arrow. > <https://epsft-jenkins.cern.ch/job/root-pullrequests-build/20469/testReport/projectroot.tree.treeplayer/test/gtest_tree_treeplayer_test_datasource_arrow/>. >. > . > You are receiving this because you were mentioned. > Reply to this email directly, view it on GitHub. > <https://github.com/root-project/root/pull/1712#issuecomment-376521563>,. > or mute the thread. > <https://github.com/notifications/unsubscribe-auth/AAApMNXWkIzMpGRjU2YzWZW95tWceJ5Oks5tijw2gaJpZM4Siqq9>. > . >.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:2361,safety,test,testReport,2361,"tual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::UnionType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:88:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::StructType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:87:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::ListType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:86:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::Decimal128Type&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. >. > And 84 more. > Failing tests:. >. > -. > projectroot.tree.treeplayer.test.gtest_tree_treeplayer_test_datasource_arrow. > <https://epsft-jenkins.cern.ch/job/root-pullrequests-build/20469/testReport/projectroot.tree.treeplayer/test/gtest_tree_treeplayer_test_datasource_arrow/>. >. > . > You are receiving this because you were mentioned. > Reply to this email directly, view it on GitHub. > <https://github.com/root-project/root/pull/1712#issuecomment-376521563>,. > or mute the thread. > <https://github.com/notifications/unsubscribe-auth/AAApMNXWkIzMpGRjU2YzWZW95tWceJ5Oks5tijw2gaJpZM4Siqq9>. > . >.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:2400,safety,test,test,2400,"tual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::UnionType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:88:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::StructType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:87:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::ListType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:86:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::Decimal128Type&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. >. > And 84 more. > Failing tests:. >. > -. > projectroot.tree.treeplayer.test.gtest_tree_treeplayer_test_datasource_arrow. > <https://epsft-jenkins.cern.ch/job/root-pullrequests-build/20469/testReport/projectroot.tree.treeplayer/test/gtest_tree_treeplayer_test_datasource_arrow/>. >. > . > You are receiving this because you were mentioned. > Reply to this email directly, view it on GitHub. > <https://github.com/root-project/root/pull/1712#issuecomment-376521563>,. > or mute the thread. > <https://github.com/notifications/unsubscribe-auth/AAApMNXWkIzMpGRjU2YzWZW95tWceJ5Oks5tijw2gaJpZM4Siqq9>. > . >.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:2710,security,auth,auth,2710,"tual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::UnionType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:88:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::StructType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:87:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::ListType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:86:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::Decimal128Type&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. >. > And 84 more. > Failing tests:. >. > -. > projectroot.tree.treeplayer.test.gtest_tree_treeplayer_test_datasource_arrow. > <https://epsft-jenkins.cern.ch/job/root-pullrequests-build/20469/testReport/projectroot.tree.treeplayer/test/gtest_tree_treeplayer_test_datasource_arrow/>. >. > . > You are receiving this because you were mentioned. > Reply to this email directly, view it on GitHub. > <https://github.com/root-project/root/pull/1712#issuecomment-376521563>,. > or mute the thread. > <https://github.com/notifications/unsubscribe-auth/AAApMNXWkIzMpGRjU2YzWZW95tWceJ5Oks5tijw2gaJpZM4Siqq9>. > . >.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:2198,testability,test,tests,2198,"tual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::UnionType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:88:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::StructType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:87:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::ListType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:86:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::Decimal128Type&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. >. > And 84 more. > Failing tests:. >. > -. > projectroot.tree.treeplayer.test.gtest_tree_treeplayer_test_datasource_arrow. > <https://epsft-jenkins.cern.ch/job/root-pullrequests-build/20469/testReport/projectroot.tree.treeplayer/test/gtest_tree_treeplayer_test_datasource_arrow/>. >. > . > You are receiving this because you were mentioned. > Reply to this email directly, view it on GitHub. > <https://github.com/root-project/root/pull/1712#issuecomment-376521563>,. > or mute the thread. > <https://github.com/notifications/unsubscribe-auth/AAApMNXWkIzMpGRjU2YzWZW95tWceJ5Oks5tijw2gaJpZM4Siqq9>. > . >.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:2244,testability,test,test,2244,"tual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::UnionType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:88:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::StructType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:87:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::ListType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:86:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::Decimal128Type&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. >. > And 84 more. > Failing tests:. >. > -. > projectroot.tree.treeplayer.test.gtest_tree_treeplayer_test_datasource_arrow. > <https://epsft-jenkins.cern.ch/job/root-pullrequests-build/20469/testReport/projectroot.tree.treeplayer/test/gtest_tree_treeplayer_test_datasource_arrow/>. >. > . > You are receiving this because you were mentioned. > Reply to this email directly, view it on GitHub. > <https://github.com/root-project/root/pull/1712#issuecomment-376521563>,. > or mute the thread. > <https://github.com/notifications/unsubscribe-auth/AAApMNXWkIzMpGRjU2YzWZW95tWceJ5Oks5tijw2gaJpZM4Siqq9>. > . >.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:2361,testability,test,testReport,2361,"tual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::UnionType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:88:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::StructType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:87:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::ListType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:86:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::Decimal128Type&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. >. > And 84 more. > Failing tests:. >. > -. > projectroot.tree.treeplayer.test.gtest_tree_treeplayer_test_datasource_arrow. > <https://epsft-jenkins.cern.ch/job/root-pullrequests-build/20469/testReport/projectroot.tree.treeplayer/test/gtest_tree_treeplayer_test_datasource_arrow/>. >. > . > You are receiving this because you were mentioned. > Reply to this email directly, view it on GitHub. > <https://github.com/root-project/root/pull/1712#issuecomment-376521563>,. > or mute the thread. > <https://github.com/notifications/unsubscribe-auth/AAApMNXWkIzMpGRjU2YzWZW95tWceJ5Oks5tijw2gaJpZM4Siqq9>. > . >.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:2400,testability,test,test,2400,"tual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::UnionType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:88:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::StructType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:87:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::ListType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:86:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::Decimal128Type&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. >. > And 84 more. > Failing tests:. >. > -. > projectroot.tree.treeplayer.test.gtest_tree_treeplayer_test_datasource_arrow. > <https://epsft-jenkins.cern.ch/job/root-pullrequests-build/20469/testReport/projectroot.tree.treeplayer/test/gtest_tree_treeplayer_test_datasource_arrow/>. >. > . > You are receiving this because you were mentioned. > Reply to this email directly, view it on GitHub. > <https://github.com/root-project/root/pull/1712#issuecomment-376521563>,. > or mute the thread. > <https://github.com/notifications/unsubscribe-auth/AAApMNXWkIzMpGRjU2YzWZW95tWceJ5Oks5tijw2gaJpZM4Siqq9>. > . >.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:404,usability,Statu,Status,404,"I forgot there are two visitors... will fix. On Tue, 27 Mar 2018 at 15:19, phsft-bot <notifications@github.com> wrote:. > Build failed on slc6/gcc62. > See console output. > <https://epsft-jenkins.cern.ch/job/root-pullrequests-build/20469/console>. > Warnings:. >. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:90:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::DictionaryType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:89:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::UnionType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:88:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::StructType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:87:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::ListType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:86:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::Decimal128Type&) was hidd",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:788,usability,Statu,Status,788,"I forgot there are two visitors... will fix. On Tue, 27 Mar 2018 at 15:19, phsft-bot <notifications@github.com> wrote:. > Build failed on slc6/gcc62. > See console output. > <https://epsft-jenkins.cern.ch/job/root-pullrequests-build/20469/console>. > Warnings:. >. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:90:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::DictionaryType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:89:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::UnionType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:88:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::StructType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:87:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::ListType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:86:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::Decimal128Type&) was hidd",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:1167,usability,Statu,Status,1167,. > <https://epsft-jenkins.cern.ch/job/root-pullrequests-build/20469/console>. > Warnings:. >. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:90:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::DictionaryType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:89:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::UnionType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:88:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::StructType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:87:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::ListType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:86:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::Decimal128Type&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. ,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:1547,usability,Statu,Status,1547,":95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:89:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::UnionType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:88:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::StructType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:87:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::ListType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:86:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::Decimal128Type&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. >. > And 84 more. > Failing tests:. >. > -. > projectroot.tree.treeplayer.test.gtest_tree_treeplayer_test_datasource_arrow. > <https://epsft-jenkins.cern.ch/job/root-pullrequests-build/20469/testReport/projectroot.tree.treeplayer/test/gtest_tree_treeplayer_test_datasource_arrow/>. >. > . > You are receiving this because you were mentioned. > Reply to this email directly, view ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:1925,usability,Statu,Status,1925,"tual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::UnionType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:88:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::StructType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:87:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::ListType&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. > - /cvmfs/. > sft.cern.ch/lcg/releases/arrow/0.8.0-352ba/x86_64-slc6-gcc62-opt/include/arrow/visitor.h:86:18:. > warning: virtual arrow::Status arrow::TypeVisitor::Visit(const. > arrow::Decimal128Type&) was hidden [-Woverloaded-virtual]. > - ../root/tree/treeplayer/src/TArrowDS.cxx:95:18: warning: by. > ROOT::Experimental::TDF::TDFTypeNameGetter::Visit [-Woverloaded-virtual]. >. > And 84 more. > Failing tests:. >. > -. > projectroot.tree.treeplayer.test.gtest_tree_treeplayer_test_datasource_arrow. > <https://epsft-jenkins.cern.ch/job/root-pullrequests-build/20469/testReport/projectroot.tree.treeplayer/test/gtest_tree_treeplayer_test_datasource_arrow/>. >. > . > You are receiving this because you were mentioned. > Reply to this email directly, view it on GitHub. > <https://github.com/root-project/root/pull/1712#issuecomment-376521563>,. > or mute the thread. > <https://github.com/notifications/unsubscribe-auth/AAApMNXWkIzMpGRjU2YzWZW95tWceJ5Oks5tijw2gaJpZM4Siqq9>. > . >.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:11,deployability,build,build,11,@phsft-bot build with flags -Darrow=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1712:11,deployability,build,build,11,@phsft-bot build with flags -Darrow=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1712
https://github.com/root-project/root/pull/1714:46,availability,redund,redundant,46,"Remotely related to this PR, could remove the redundant `#include ""RooCintUtils.h""`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1714
https://github.com/root-project/root/pull/1714:46,deployability,redundan,redundant,46,"Remotely related to this PR, could remove the redundant `#include ""RooCintUtils.h""`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1714
https://github.com/root-project/root/pull/1714:46,reliability,redundan,redundant,46,"Remotely related to this PR, could remove the redundant `#include ""RooCintUtils.h""`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1714
https://github.com/root-project/root/pull/1714:46,safety,redund,redundant,46,"Remotely related to this PR, could remove the redundant `#include ""RooCintUtils.h""`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1714
https://github.com/root-project/root/pull/1714:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1714
https://github.com/root-project/root/pull/1715:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1715
https://github.com/root-project/root/pull/1715:126,availability,avail,available,126,"Hi @yamaguchi1024 @vgvassilev , I have a last comment. We provide in the ROOT type system an endpoint to check if the enum is available, `TEnum::GetEnum(const char*)`. It can be used as. ```. TEnum::GetEnum(""ROOT::Detail::VecOps::TAdoptAllocator<double>::EAllocType""). ```. I don't know if it can be used inside these utils but it would have an advantage wrt to the current solution, namely the ability to avoid lookups in case the enum is present in the type-system (selected by the user). This would avoid memory consumption in case of autoparsing being triggered. The PR is a nice improvement, I am discussiong a *possible* performance improvement on top of it!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1715
https://github.com/root-project/root/pull/1715:366,energy efficiency,current,current,366,"Hi @yamaguchi1024 @vgvassilev , I have a last comment. We provide in the ROOT type system an endpoint to check if the enum is available, `TEnum::GetEnum(const char*)`. It can be used as. ```. TEnum::GetEnum(""ROOT::Detail::VecOps::TAdoptAllocator<double>::EAllocType""). ```. I don't know if it can be used inside these utils but it would have an advantage wrt to the current solution, namely the ability to avoid lookups in case the enum is present in the type-system (selected by the user). This would avoid memory consumption in case of autoparsing being triggered. The PR is a nice improvement, I am discussiong a *possible* performance improvement on top of it!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1715
https://github.com/root-project/root/pull/1715:93,integrability,endpoint,endpoint,93,"Hi @yamaguchi1024 @vgvassilev , I have a last comment. We provide in the ROOT type system an endpoint to check if the enum is available, `TEnum::GetEnum(const char*)`. It can be used as. ```. TEnum::GetEnum(""ROOT::Detail::VecOps::TAdoptAllocator<double>::EAllocType""). ```. I don't know if it can be used inside these utils but it would have an advantage wrt to the current solution, namely the ability to avoid lookups in case the enum is present in the type-system (selected by the user). This would avoid memory consumption in case of autoparsing being triggered. The PR is a nice improvement, I am discussiong a *possible* performance improvement on top of it!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1715
https://github.com/root-project/root/pull/1715:508,performance,memor,memory,508,"Hi @yamaguchi1024 @vgvassilev , I have a last comment. We provide in the ROOT type system an endpoint to check if the enum is available, `TEnum::GetEnum(const char*)`. It can be used as. ```. TEnum::GetEnum(""ROOT::Detail::VecOps::TAdoptAllocator<double>::EAllocType""). ```. I don't know if it can be used inside these utils but it would have an advantage wrt to the current solution, namely the ability to avoid lookups in case the enum is present in the type-system (selected by the user). This would avoid memory consumption in case of autoparsing being triggered. The PR is a nice improvement, I am discussiong a *possible* performance improvement on top of it!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1715
https://github.com/root-project/root/pull/1715:627,performance,perform,performance,627,"Hi @yamaguchi1024 @vgvassilev , I have a last comment. We provide in the ROOT type system an endpoint to check if the enum is available, `TEnum::GetEnum(const char*)`. It can be used as. ```. TEnum::GetEnum(""ROOT::Detail::VecOps::TAdoptAllocator<double>::EAllocType""). ```. I don't know if it can be used inside these utils but it would have an advantage wrt to the current solution, namely the ability to avoid lookups in case the enum is present in the type-system (selected by the user). This would avoid memory consumption in case of autoparsing being triggered. The PR is a nice improvement, I am discussiong a *possible* performance improvement on top of it!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1715
https://github.com/root-project/root/pull/1715:126,reliability,availab,available,126,"Hi @yamaguchi1024 @vgvassilev , I have a last comment. We provide in the ROOT type system an endpoint to check if the enum is available, `TEnum::GetEnum(const char*)`. It can be used as. ```. TEnum::GetEnum(""ROOT::Detail::VecOps::TAdoptAllocator<double>::EAllocType""). ```. I don't know if it can be used inside these utils but it would have an advantage wrt to the current solution, namely the ability to avoid lookups in case the enum is present in the type-system (selected by the user). This would avoid memory consumption in case of autoparsing being triggered. The PR is a nice improvement, I am discussiong a *possible* performance improvement on top of it!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1715
https://github.com/root-project/root/pull/1715:126,safety,avail,available,126,"Hi @yamaguchi1024 @vgvassilev , I have a last comment. We provide in the ROOT type system an endpoint to check if the enum is available, `TEnum::GetEnum(const char*)`. It can be used as. ```. TEnum::GetEnum(""ROOT::Detail::VecOps::TAdoptAllocator<double>::EAllocType""). ```. I don't know if it can be used inside these utils but it would have an advantage wrt to the current solution, namely the ability to avoid lookups in case the enum is present in the type-system (selected by the user). This would avoid memory consumption in case of autoparsing being triggered. The PR is a nice improvement, I am discussiong a *possible* performance improvement on top of it!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1715
https://github.com/root-project/root/pull/1715:406,safety,avoid,avoid,406,"Hi @yamaguchi1024 @vgvassilev , I have a last comment. We provide in the ROOT type system an endpoint to check if the enum is available, `TEnum::GetEnum(const char*)`. It can be used as. ```. TEnum::GetEnum(""ROOT::Detail::VecOps::TAdoptAllocator<double>::EAllocType""). ```. I don't know if it can be used inside these utils but it would have an advantage wrt to the current solution, namely the ability to avoid lookups in case the enum is present in the type-system (selected by the user). This would avoid memory consumption in case of autoparsing being triggered. The PR is a nice improvement, I am discussiong a *possible* performance improvement on top of it!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1715
https://github.com/root-project/root/pull/1715:502,safety,avoid,avoid,502,"Hi @yamaguchi1024 @vgvassilev , I have a last comment. We provide in the ROOT type system an endpoint to check if the enum is available, `TEnum::GetEnum(const char*)`. It can be used as. ```. TEnum::GetEnum(""ROOT::Detail::VecOps::TAdoptAllocator<double>::EAllocType""). ```. I don't know if it can be used inside these utils but it would have an advantage wrt to the current solution, namely the ability to avoid lookups in case the enum is present in the type-system (selected by the user). This would avoid memory consumption in case of autoparsing being triggered. The PR is a nice improvement, I am discussiong a *possible* performance improvement on top of it!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1715
https://github.com/root-project/root/pull/1715:126,security,availab,available,126,"Hi @yamaguchi1024 @vgvassilev , I have a last comment. We provide in the ROOT type system an endpoint to check if the enum is available, `TEnum::GetEnum(const char*)`. It can be used as. ```. TEnum::GetEnum(""ROOT::Detail::VecOps::TAdoptAllocator<double>::EAllocType""). ```. I don't know if it can be used inside these utils but it would have an advantage wrt to the current solution, namely the ability to avoid lookups in case the enum is present in the type-system (selected by the user). This would avoid memory consumption in case of autoparsing being triggered. The PR is a nice improvement, I am discussiong a *possible* performance improvement on top of it!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1715
https://github.com/root-project/root/pull/1715:484,usability,user,user,484,"Hi @yamaguchi1024 @vgvassilev , I have a last comment. We provide in the ROOT type system an endpoint to check if the enum is available, `TEnum::GetEnum(const char*)`. It can be used as. ```. TEnum::GetEnum(""ROOT::Detail::VecOps::TAdoptAllocator<double>::EAllocType""). ```. I don't know if it can be used inside these utils but it would have an advantage wrt to the current solution, namely the ability to avoid lookups in case the enum is present in the type-system (selected by the user). This would avoid memory consumption in case of autoparsing being triggered. The PR is a nice improvement, I am discussiong a *possible* performance improvement on top of it!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1715
https://github.com/root-project/root/pull/1715:508,usability,memor,memory,508,"Hi @yamaguchi1024 @vgvassilev , I have a last comment. We provide in the ROOT type system an endpoint to check if the enum is available, `TEnum::GetEnum(const char*)`. It can be used as. ```. TEnum::GetEnum(""ROOT::Detail::VecOps::TAdoptAllocator<double>::EAllocType""). ```. I don't know if it can be used inside these utils but it would have an advantage wrt to the current solution, namely the ability to avoid lookups in case the enum is present in the type-system (selected by the user). This would avoid memory consumption in case of autoparsing being triggered. The PR is a nice improvement, I am discussiong a *possible* performance improvement on top of it!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1715
https://github.com/root-project/root/pull/1715:627,usability,perform,performance,627,"Hi @yamaguchi1024 @vgvassilev , I have a last comment. We provide in the ROOT type system an endpoint to check if the enum is available, `TEnum::GetEnum(const char*)`. It can be used as. ```. TEnum::GetEnum(""ROOT::Detail::VecOps::TAdoptAllocator<double>::EAllocType""). ```. I don't know if it can be used inside these utils but it would have an advantage wrt to the current solution, namely the ability to avoid lookups in case the enum is present in the type-system (selected by the user). This would avoid memory consumption in case of autoparsing being triggered. The PR is a nice improvement, I am discussiong a *possible* performance improvement on top of it!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1715
https://github.com/root-project/root/pull/1716:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1716
https://github.com/root-project/root/pull/1720:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1720
https://github.com/root-project/root/pull/1720:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1720
https://github.com/root-project/root/pull/1720:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1720
https://github.com/root-project/root/pull/1721:119,safety,safe,safety,119,"Just a reminder that when writing (new) function that break const-ness, one need to consider the consequence on thread-safety (i.e. in first approximation the user might expect that if they do only const calls to an another it is safe to make them from multiple threads). .. humm actually this is odder ... the return type of genData is a const pointer. Do we know even know why?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:230,safety,safe,safe,230,"Just a reminder that when writing (new) function that break const-ness, one need to consider the consequence on thread-safety (i.e. in first approximation the user might expect that if they do only const calls to an another it is safe to make them from multiple threads). .. humm actually this is odder ... the return type of genData is a const pointer. Do we know even know why?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:159,usability,user,user,159,"Just a reminder that when writing (new) function that break const-ness, one need to consider the consequence on thread-safety (i.e. in first approximation the user might expect that if they do only const calls to an another it is safe to make them from multiple threads). .. humm actually this is odder ... the return type of genData is a const pointer. Do we know even know why?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:13,reliability,doe,does,13,"@pcanal, how does that function break constness? It is adding an overload which is chosen by the user.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:97,usability,user,user,97,"@pcanal, how does that function break constness? It is adding an overload which is chosen by the user.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:999,deployability,version,version,999,"I mis-read the directory of the part. ```. const_cast<const RooMCStudy *>(this). ```. which indeed 'add' const rather than removing (hence my first sentence which is not as apropos as I though ti was). However it still does:. ```. return const_cast<RooAbsData*>(....);. ```. So *unless* gendata is return a const pointer for the fun of it (it might be), this is transforming a pointer to const into a pointer to non-const. The orginal 'gendata' was explicitly disallowing changes to the object it returns, this new overload is not. So the question I was asking in conclusion was essentially:. 1. is gendata return a const pointer because it hold the data as a member and this function is const, so the result should be const . 2. is gendata return a const pointer because the result *must* not be changed for some reason beyond the const-ness of its generator. 3. is gendata not even retaining a pointer/reference/something to the object returns and thus the 'constness of the pointer' of the const version of gendata is superflous (and thus we only need one version). I agree that it is likely (1) but without looking somewhat at the code I can not exclude (2) or (3)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:1059,deployability,version,version,1059,"I mis-read the directory of the part. ```. const_cast<const RooMCStudy *>(this). ```. which indeed 'add' const rather than removing (hence my first sentence which is not as apropos as I though ti was). However it still does:. ```. return const_cast<RooAbsData*>(....);. ```. So *unless* gendata is return a const pointer for the fun of it (it might be), this is transforming a pointer to const into a pointer to non-const. The orginal 'gendata' was explicitly disallowing changes to the object it returns, this new overload is not. So the question I was asking in conclusion was essentially:. 1. is gendata return a const pointer because it hold the data as a member and this function is const, so the result should be const . 2. is gendata return a const pointer because the result *must* not be changed for some reason beyond the const-ness of its generator. 3. is gendata not even retaining a pointer/reference/something to the object returns and thus the 'constness of the pointer' of the const version of gendata is superflous (and thus we only need one version). I agree that it is likely (1) but without looking somewhat at the code I can not exclude (2) or (3)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:362,integrability,transform,transforming,362,"I mis-read the directory of the part. ```. const_cast<const RooMCStudy *>(this). ```. which indeed 'add' const rather than removing (hence my first sentence which is not as apropos as I though ti was). However it still does:. ```. return const_cast<RooAbsData*>(....);. ```. So *unless* gendata is return a const pointer for the fun of it (it might be), this is transforming a pointer to const into a pointer to non-const. The orginal 'gendata' was explicitly disallowing changes to the object it returns, this new overload is not. So the question I was asking in conclusion was essentially:. 1. is gendata return a const pointer because it hold the data as a member and this function is const, so the result should be const . 2. is gendata return a const pointer because the result *must* not be changed for some reason beyond the const-ness of its generator. 3. is gendata not even retaining a pointer/reference/something to the object returns and thus the 'constness of the pointer' of the const version of gendata is superflous (and thus we only need one version). I agree that it is likely (1) but without looking somewhat at the code I can not exclude (2) or (3)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:999,integrability,version,version,999,"I mis-read the directory of the part. ```. const_cast<const RooMCStudy *>(this). ```. which indeed 'add' const rather than removing (hence my first sentence which is not as apropos as I though ti was). However it still does:. ```. return const_cast<RooAbsData*>(....);. ```. So *unless* gendata is return a const pointer for the fun of it (it might be), this is transforming a pointer to const into a pointer to non-const. The orginal 'gendata' was explicitly disallowing changes to the object it returns, this new overload is not. So the question I was asking in conclusion was essentially:. 1. is gendata return a const pointer because it hold the data as a member and this function is const, so the result should be const . 2. is gendata return a const pointer because the result *must* not be changed for some reason beyond the const-ness of its generator. 3. is gendata not even retaining a pointer/reference/something to the object returns and thus the 'constness of the pointer' of the const version of gendata is superflous (and thus we only need one version). I agree that it is likely (1) but without looking somewhat at the code I can not exclude (2) or (3)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:1059,integrability,version,version,1059,"I mis-read the directory of the part. ```. const_cast<const RooMCStudy *>(this). ```. which indeed 'add' const rather than removing (hence my first sentence which is not as apropos as I though ti was). However it still does:. ```. return const_cast<RooAbsData*>(....);. ```. So *unless* gendata is return a const pointer for the fun of it (it might be), this is transforming a pointer to const into a pointer to non-const. The orginal 'gendata' was explicitly disallowing changes to the object it returns, this new overload is not. So the question I was asking in conclusion was essentially:. 1. is gendata return a const pointer because it hold the data as a member and this function is const, so the result should be const . 2. is gendata return a const pointer because the result *must* not be changed for some reason beyond the const-ness of its generator. 3. is gendata not even retaining a pointer/reference/something to the object returns and thus the 'constness of the pointer' of the const version of gendata is superflous (and thus we only need one version). I agree that it is likely (1) but without looking somewhat at the code I can not exclude (2) or (3)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:362,interoperability,transform,transforming,362,"I mis-read the directory of the part. ```. const_cast<const RooMCStudy *>(this). ```. which indeed 'add' const rather than removing (hence my first sentence which is not as apropos as I though ti was). However it still does:. ```. return const_cast<RooAbsData*>(....);. ```. So *unless* gendata is return a const pointer for the fun of it (it might be), this is transforming a pointer to const into a pointer to non-const. The orginal 'gendata' was explicitly disallowing changes to the object it returns, this new overload is not. So the question I was asking in conclusion was essentially:. 1. is gendata return a const pointer because it hold the data as a member and this function is const, so the result should be const . 2. is gendata return a const pointer because the result *must* not be changed for some reason beyond the const-ness of its generator. 3. is gendata not even retaining a pointer/reference/something to the object returns and thus the 'constness of the pointer' of the const version of gendata is superflous (and thus we only need one version). I agree that it is likely (1) but without looking somewhat at the code I can not exclude (2) or (3)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:999,modifiability,version,version,999,"I mis-read the directory of the part. ```. const_cast<const RooMCStudy *>(this). ```. which indeed 'add' const rather than removing (hence my first sentence which is not as apropos as I though ti was). However it still does:. ```. return const_cast<RooAbsData*>(....);. ```. So *unless* gendata is return a const pointer for the fun of it (it might be), this is transforming a pointer to const into a pointer to non-const. The orginal 'gendata' was explicitly disallowing changes to the object it returns, this new overload is not. So the question I was asking in conclusion was essentially:. 1. is gendata return a const pointer because it hold the data as a member and this function is const, so the result should be const . 2. is gendata return a const pointer because the result *must* not be changed for some reason beyond the const-ness of its generator. 3. is gendata not even retaining a pointer/reference/something to the object returns and thus the 'constness of the pointer' of the const version of gendata is superflous (and thus we only need one version). I agree that it is likely (1) but without looking somewhat at the code I can not exclude (2) or (3)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:1059,modifiability,version,version,1059,"I mis-read the directory of the part. ```. const_cast<const RooMCStudy *>(this). ```. which indeed 'add' const rather than removing (hence my first sentence which is not as apropos as I though ti was). However it still does:. ```. return const_cast<RooAbsData*>(....);. ```. So *unless* gendata is return a const pointer for the fun of it (it might be), this is transforming a pointer to const into a pointer to non-const. The orginal 'gendata' was explicitly disallowing changes to the object it returns, this new overload is not. So the question I was asking in conclusion was essentially:. 1. is gendata return a const pointer because it hold the data as a member and this function is const, so the result should be const . 2. is gendata return a const pointer because the result *must* not be changed for some reason beyond the const-ness of its generator. 3. is gendata not even retaining a pointer/reference/something to the object returns and thus the 'constness of the pointer' of the const version of gendata is superflous (and thus we only need one version). I agree that it is likely (1) but without looking somewhat at the code I can not exclude (2) or (3)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:219,reliability,doe,does,219,"I mis-read the directory of the part. ```. const_cast<const RooMCStudy *>(this). ```. which indeed 'add' const rather than removing (hence my first sentence which is not as apropos as I though ti was). However it still does:. ```. return const_cast<RooAbsData*>(....);. ```. So *unless* gendata is return a const pointer for the fun of it (it might be), this is transforming a pointer to const into a pointer to non-const. The orginal 'gendata' was explicitly disallowing changes to the object it returns, this new overload is not. So the question I was asking in conclusion was essentially:. 1. is gendata return a const pointer because it hold the data as a member and this function is const, so the result should be const . 2. is gendata return a const pointer because the result *must* not be changed for some reason beyond the const-ness of its generator. 3. is gendata not even retaining a pointer/reference/something to the object returns and thus the 'constness of the pointer' of the const version of gendata is superflous (and thus we only need one version). I agree that it is likely (1) but without looking somewhat at the code I can not exclude (2) or (3)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:98,integrability,interfac,interfaces,98,Arguing about threading and roofit is an oxymoron :). I am still not getting the point. There are interfaces which are expected to change that output (namely [here](https://root-forum.cern.ch/t/accessing-gendata-in-roofit/28237)). I am far from expert in roofit but if we close this PR that would mean the const_casts are going to end up in users code which is arguably worse because it is out of our control. I'd prefer to land this and lift that burden from the users when interacting with roostats. EDIT: @lmoneta should be able to say...,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:98,interoperability,interfac,interfaces,98,Arguing about threading and roofit is an oxymoron :). I am still not getting the point. There are interfaces which are expected to change that output (namely [here](https://root-forum.cern.ch/t/accessing-gendata-in-roofit/28237)). I am far from expert in roofit but if we close this PR that would mean the const_casts are going to end up in users code which is arguably worse because it is out of our control. I'd prefer to land this and lift that burden from the users when interacting with roostats. EDIT: @lmoneta should be able to say...,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:98,modifiability,interfac,interfaces,98,Arguing about threading and roofit is an oxymoron :). I am still not getting the point. There are interfaces which are expected to change that output (namely [here](https://root-forum.cern.ch/t/accessing-gendata-in-roofit/28237)). I am far from expert in roofit but if we close this PR that would mean the const_casts are going to end up in users code which is arguably worse because it is out of our control. I'd prefer to land this and lift that burden from the users when interacting with roostats. EDIT: @lmoneta should be able to say...,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:194,security,access,accessing-gendata-in-roofit,194,Arguing about threading and roofit is an oxymoron :). I am still not getting the point. There are interfaces which are expected to change that output (namely [here](https://root-forum.cern.ch/t/accessing-gendata-in-roofit/28237)). I am far from expert in roofit but if we close this PR that would mean the const_casts are going to end up in users code which is arguably worse because it is out of our control. I'd prefer to land this and lift that burden from the users when interacting with roostats. EDIT: @lmoneta should be able to say...,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:401,security,control,control,401,Arguing about threading and roofit is an oxymoron :). I am still not getting the point. There are interfaces which are expected to change that output (namely [here](https://root-forum.cern.ch/t/accessing-gendata-in-roofit/28237)). I am far from expert in roofit but if we close this PR that would mean the const_casts are going to end up in users code which is arguably worse because it is out of our control. I'd prefer to land this and lift that burden from the users when interacting with roostats. EDIT: @lmoneta should be able to say...,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:401,testability,control,control,401,Arguing about threading and roofit is an oxymoron :). I am still not getting the point. There are interfaces which are expected to change that output (namely [here](https://root-forum.cern.ch/t/accessing-gendata-in-roofit/28237)). I am far from expert in roofit but if we close this PR that would mean the const_casts are going to end up in users code which is arguably worse because it is out of our control. I'd prefer to land this and lift that burden from the users when interacting with roostats. EDIT: @lmoneta should be able to say...,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:272,usability,close,close,272,Arguing about threading and roofit is an oxymoron :). I am still not getting the point. There are interfaces which are expected to change that output (namely [here](https://root-forum.cern.ch/t/accessing-gendata-in-roofit/28237)). I am far from expert in roofit but if we close this PR that would mean the const_casts are going to end up in users code which is arguably worse because it is out of our control. I'd prefer to land this and lift that burden from the users when interacting with roostats. EDIT: @lmoneta should be able to say...,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:341,usability,user,users,341,Arguing about threading and roofit is an oxymoron :). I am still not getting the point. There are interfaces which are expected to change that output (namely [here](https://root-forum.cern.ch/t/accessing-gendata-in-roofit/28237)). I am far from expert in roofit but if we close this PR that would mean the const_casts are going to end up in users code which is arguably worse because it is out of our control. I'd prefer to land this and lift that burden from the users when interacting with roostats. EDIT: @lmoneta should be able to say...,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:414,usability,prefer,prefer,414,Arguing about threading and roofit is an oxymoron :). I am still not getting the point. There are interfaces which are expected to change that output (namely [here](https://root-forum.cern.ch/t/accessing-gendata-in-roofit/28237)). I am far from expert in roofit but if we close this PR that would mean the const_casts are going to end up in users code which is arguably worse because it is out of our control. I'd prefer to land this and lift that burden from the users when interacting with roostats. EDIT: @lmoneta should be able to say...,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:464,usability,user,users,464,Arguing about threading and roofit is an oxymoron :). I am still not getting the point. There are interfaces which are expected to change that output (namely [here](https://root-forum.cern.ch/t/accessing-gendata-in-roofit/28237)). I am far from expert in roofit but if we close this PR that would mean the const_casts are going to end up in users code which is arguably worse because it is out of our control. I'd prefer to land this and lift that burden from the users when interacting with roostats. EDIT: @lmoneta should be able to say...,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:475,usability,interact,interacting,475,Arguing about threading and roofit is an oxymoron :). I am still not getting the point. There are interfaces which are expected to change that output (namely [here](https://root-forum.cern.ch/t/accessing-gendata-in-roofit/28237)). I am far from expert in roofit but if we close this PR that would mean the const_casts are going to end up in users code which is arguably worse because it is out of our control. I'd prefer to land this and lift that burden from the users when interacting with roostats. EDIT: @lmoneta should be able to say...,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:117,deployability,patch,patch,117,"> Arguing about threading and roofit is an oxymoron :). Forget about that part (that was based on mis-reading of the patch and desire not to make code any worse) :). So let focus on const-correctnest and semantic. The salient question is **why** is the return type of gendata a const pointer? It could be:. 1. is gendata return a const pointer because it hold the data as a member and this function is const, so the result should be const. 2. is gendata return a const pointer because the result must not be changed for some reason beyond the const-ness of its generator. 3. is gendata not even retaining a pointer/reference/something to the object returns and thus the 'constness of the pointer' of the const version of gendata is superflous (and thus we only need one version). if it is (3) the a single function is enough. ```. RooAbsData* genData(Int_t sampleNum) const ;. ```. if it is (2) then the user-code/pattern you pointed is a disaster. If it is (1) then the proposed addition break const-correctness and one need to review whether this is a real issue or not. Cheers,. Philippe",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:710,deployability,version,version,710,"> Arguing about threading and roofit is an oxymoron :). Forget about that part (that was based on mis-reading of the patch and desire not to make code any worse) :). So let focus on const-correctnest and semantic. The salient question is **why** is the return type of gendata a const pointer? It could be:. 1. is gendata return a const pointer because it hold the data as a member and this function is const, so the result should be const. 2. is gendata return a const pointer because the result must not be changed for some reason beyond the const-ness of its generator. 3. is gendata not even retaining a pointer/reference/something to the object returns and thus the 'constness of the pointer' of the const version of gendata is superflous (and thus we only need one version). if it is (3) the a single function is enough. ```. RooAbsData* genData(Int_t sampleNum) const ;. ```. if it is (2) then the user-code/pattern you pointed is a disaster. If it is (1) then the proposed addition break const-correctness and one need to review whether this is a real issue or not. Cheers,. Philippe",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:770,deployability,version,version,770,"> Arguing about threading and roofit is an oxymoron :). Forget about that part (that was based on mis-reading of the patch and desire not to make code any worse) :). So let focus on const-correctnest and semantic. The salient question is **why** is the return type of gendata a const pointer? It could be:. 1. is gendata return a const pointer because it hold the data as a member and this function is const, so the result should be const. 2. is gendata return a const pointer because the result must not be changed for some reason beyond the const-ness of its generator. 3. is gendata not even retaining a pointer/reference/something to the object returns and thus the 'constness of the pointer' of the const version of gendata is superflous (and thus we only need one version). if it is (3) the a single function is enough. ```. RooAbsData* genData(Int_t sampleNum) const ;. ```. if it is (2) then the user-code/pattern you pointed is a disaster. If it is (1) then the proposed addition break const-correctness and one need to review whether this is a real issue or not. Cheers,. Philippe",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:710,integrability,version,version,710,"> Arguing about threading and roofit is an oxymoron :). Forget about that part (that was based on mis-reading of the patch and desire not to make code any worse) :). So let focus on const-correctnest and semantic. The salient question is **why** is the return type of gendata a const pointer? It could be:. 1. is gendata return a const pointer because it hold the data as a member and this function is const, so the result should be const. 2. is gendata return a const pointer because the result must not be changed for some reason beyond the const-ness of its generator. 3. is gendata not even retaining a pointer/reference/something to the object returns and thus the 'constness of the pointer' of the const version of gendata is superflous (and thus we only need one version). if it is (3) the a single function is enough. ```. RooAbsData* genData(Int_t sampleNum) const ;. ```. if it is (2) then the user-code/pattern you pointed is a disaster. If it is (1) then the proposed addition break const-correctness and one need to review whether this is a real issue or not. Cheers,. Philippe",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:770,integrability,version,version,770,"> Arguing about threading and roofit is an oxymoron :). Forget about that part (that was based on mis-reading of the patch and desire not to make code any worse) :). So let focus on const-correctnest and semantic. The salient question is **why** is the return type of gendata a const pointer? It could be:. 1. is gendata return a const pointer because it hold the data as a member and this function is const, so the result should be const. 2. is gendata return a const pointer because the result must not be changed for some reason beyond the const-ness of its generator. 3. is gendata not even retaining a pointer/reference/something to the object returns and thus the 'constness of the pointer' of the const version of gendata is superflous (and thus we only need one version). if it is (3) the a single function is enough. ```. RooAbsData* genData(Int_t sampleNum) const ;. ```. if it is (2) then the user-code/pattern you pointed is a disaster. If it is (1) then the proposed addition break const-correctness and one need to review whether this is a real issue or not. Cheers,. Philippe",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:204,interoperability,semant,semantic,204,"> Arguing about threading and roofit is an oxymoron :). Forget about that part (that was based on mis-reading of the patch and desire not to make code any worse) :). So let focus on const-correctnest and semantic. The salient question is **why** is the return type of gendata a const pointer? It could be:. 1. is gendata return a const pointer because it hold the data as a member and this function is const, so the result should be const. 2. is gendata return a const pointer because the result must not be changed for some reason beyond the const-ness of its generator. 3. is gendata not even retaining a pointer/reference/something to the object returns and thus the 'constness of the pointer' of the const version of gendata is superflous (and thus we only need one version). if it is (3) the a single function is enough. ```. RooAbsData* genData(Int_t sampleNum) const ;. ```. if it is (2) then the user-code/pattern you pointed is a disaster. If it is (1) then the proposed addition break const-correctness and one need to review whether this is a real issue or not. Cheers,. Philippe",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:710,modifiability,version,version,710,"> Arguing about threading and roofit is an oxymoron :). Forget about that part (that was based on mis-reading of the patch and desire not to make code any worse) :). So let focus on const-correctnest and semantic. The salient question is **why** is the return type of gendata a const pointer? It could be:. 1. is gendata return a const pointer because it hold the data as a member and this function is const, so the result should be const. 2. is gendata return a const pointer because the result must not be changed for some reason beyond the const-ness of its generator. 3. is gendata not even retaining a pointer/reference/something to the object returns and thus the 'constness of the pointer' of the const version of gendata is superflous (and thus we only need one version). if it is (3) the a single function is enough. ```. RooAbsData* genData(Int_t sampleNum) const ;. ```. if it is (2) then the user-code/pattern you pointed is a disaster. If it is (1) then the proposed addition break const-correctness and one need to review whether this is a real issue or not. Cheers,. Philippe",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:770,modifiability,version,version,770,"> Arguing about threading and roofit is an oxymoron :). Forget about that part (that was based on mis-reading of the patch and desire not to make code any worse) :). So let focus on const-correctnest and semantic. The salient question is **why** is the return type of gendata a const pointer? It could be:. 1. is gendata return a const pointer because it hold the data as a member and this function is const, so the result should be const. 2. is gendata return a const pointer because the result must not be changed for some reason beyond the const-ness of its generator. 3. is gendata not even retaining a pointer/reference/something to the object returns and thus the 'constness of the pointer' of the const version of gendata is superflous (and thus we only need one version). if it is (3) the a single function is enough. ```. RooAbsData* genData(Int_t sampleNum) const ;. ```. if it is (2) then the user-code/pattern you pointed is a disaster. If it is (1) then the proposed addition break const-correctness and one need to review whether this is a real issue or not. Cheers,. Philippe",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:117,safety,patch,patch,117,"> Arguing about threading and roofit is an oxymoron :). Forget about that part (that was based on mis-reading of the patch and desire not to make code any worse) :). So let focus on const-correctnest and semantic. The salient question is **why** is the return type of gendata a const pointer? It could be:. 1. is gendata return a const pointer because it hold the data as a member and this function is const, so the result should be const. 2. is gendata return a const pointer because the result must not be changed for some reason beyond the const-ness of its generator. 3. is gendata not even retaining a pointer/reference/something to the object returns and thus the 'constness of the pointer' of the const version of gendata is superflous (and thus we only need one version). if it is (3) the a single function is enough. ```. RooAbsData* genData(Int_t sampleNum) const ;. ```. if it is (2) then the user-code/pattern you pointed is a disaster. If it is (1) then the proposed addition break const-correctness and one need to review whether this is a real issue or not. Cheers,. Philippe",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:1029,safety,review,review,1029,"> Arguing about threading and roofit is an oxymoron :). Forget about that part (that was based on mis-reading of the patch and desire not to make code any worse) :). So let focus on const-correctnest and semantic. The salient question is **why** is the return type of gendata a const pointer? It could be:. 1. is gendata return a const pointer because it hold the data as a member and this function is const, so the result should be const. 2. is gendata return a const pointer because the result must not be changed for some reason beyond the const-ness of its generator. 3. is gendata not even retaining a pointer/reference/something to the object returns and thus the 'constness of the pointer' of the const version of gendata is superflous (and thus we only need one version). if it is (3) the a single function is enough. ```. RooAbsData* genData(Int_t sampleNum) const ;. ```. if it is (2) then the user-code/pattern you pointed is a disaster. If it is (1) then the proposed addition break const-correctness and one need to review whether this is a real issue or not. Cheers,. Philippe",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:117,security,patch,patch,117,"> Arguing about threading and roofit is an oxymoron :). Forget about that part (that was based on mis-reading of the patch and desire not to make code any worse) :). So let focus on const-correctnest and semantic. The salient question is **why** is the return type of gendata a const pointer? It could be:. 1. is gendata return a const pointer because it hold the data as a member and this function is const, so the result should be const. 2. is gendata return a const pointer because the result must not be changed for some reason beyond the const-ness of its generator. 3. is gendata not even retaining a pointer/reference/something to the object returns and thus the 'constness of the pointer' of the const version of gendata is superflous (and thus we only need one version). if it is (3) the a single function is enough. ```. RooAbsData* genData(Int_t sampleNum) const ;. ```. if it is (2) then the user-code/pattern you pointed is a disaster. If it is (1) then the proposed addition break const-correctness and one need to review whether this is a real issue or not. Cheers,. Philippe",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:1029,testability,review,review,1029,"> Arguing about threading and roofit is an oxymoron :). Forget about that part (that was based on mis-reading of the patch and desire not to make code any worse) :). So let focus on const-correctnest and semantic. The salient question is **why** is the return type of gendata a const pointer? It could be:. 1. is gendata return a const pointer because it hold the data as a member and this function is const, so the result should be const. 2. is gendata return a const pointer because the result must not be changed for some reason beyond the const-ness of its generator. 3. is gendata not even retaining a pointer/reference/something to the object returns and thus the 'constness of the pointer' of the const version of gendata is superflous (and thus we only need one version). if it is (3) the a single function is enough. ```. RooAbsData* genData(Int_t sampleNum) const ;. ```. if it is (2) then the user-code/pattern you pointed is a disaster. If it is (1) then the proposed addition break const-correctness and one need to review whether this is a real issue or not. Cheers,. Philippe",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:904,usability,user,user-code,904,"> Arguing about threading and roofit is an oxymoron :). Forget about that part (that was based on mis-reading of the patch and desire not to make code any worse) :). So let focus on const-correctnest and semantic. The salient question is **why** is the return type of gendata a const pointer? It could be:. 1. is gendata return a const pointer because it hold the data as a member and this function is const, so the result should be const. 2. is gendata return a const pointer because the result must not be changed for some reason beyond the const-ness of its generator. 3. is gendata not even retaining a pointer/reference/something to the object returns and thus the 'constness of the pointer' of the const version of gendata is superflous (and thus we only need one version). if it is (3) the a single function is enough. ```. RooAbsData* genData(Int_t sampleNum) const ;. ```. if it is (2) then the user-code/pattern you pointed is a disaster. If it is (1) then the proposed addition break const-correctness and one need to review whether this is a real issue or not. Cheers,. Philippe",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:106,deployability,contain,contains,106,"As suggested by Philippe, there is no reason to have genData returning a const pointer, since the class . contains non-const pointer to RooAbsData. . I would go for the simplest solution and change the function to be . RooAbsData * RooMCStudy::genData	(Int_t 	sampleNum	)	const. Lorenzo.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:169,testability,simpl,simplest,169,"As suggested by Philippe, there is no reason to have genData returning a const pointer, since the class . contains non-const pointer to RooAbsData. . I would go for the simplest solution and change the function to be . RooAbsData * RooMCStudy::genData	(Int_t 	sampleNum	)	const. Lorenzo.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:169,usability,simpl,simplest,169,"As suggested by Philippe, there is no reason to have genData returning a const pointer, since the class . contains non-const pointer to RooAbsData. . I would go for the simplest solution and change the function to be . RooAbsData * RooMCStudy::genData	(Int_t 	sampleNum	)	const. Lorenzo.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:8,testability,understand,understand,8,"I don't understand why was closed. I think only there was just no need to add a new method, we just need to change the existing one",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1721:27,usability,close,closed,27,"I don't understand why was closed. I think only there was just no need to add a new method, we just need to change the existing one",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1721
https://github.com/root-project/root/pull/1722:33,safety,review,reviewers,33,@yamaguchi1024 : nice. I let the reviewers comment but I support this change.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1722
https://github.com/root-project/root/pull/1722:33,testability,review,reviewers,33,@yamaguchi1024 : nice. I let the reviewers comment but I support this change.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1722
https://github.com/root-project/root/pull/1722:57,usability,support,support,57,@yamaguchi1024 : nice. I let the reviewers comment but I support this change.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1722
https://github.com/root-project/root/pull/1722:288,performance,time,time,288,"Great work, thanks, @yamaguchi1024 ! This seems to be ok (but needs to be reviewed by @lmoneta ). For future PRs I'd appreciate keeping functional changes (enum iteration) and non-functional changes (moving functions into a different source file) in separate commits. As is I have a hard time seeing where the functional changes are taking place. So much so that I trust Vassil to have reviewed the functional part, such that I don't need to sign off on it. Thanks!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1722
https://github.com/root-project/root/pull/1722:74,safety,review,reviewed,74,"Great work, thanks, @yamaguchi1024 ! This seems to be ok (but needs to be reviewed by @lmoneta ). For future PRs I'd appreciate keeping functional changes (enum iteration) and non-functional changes (moving functions into a different source file) in separate commits. As is I have a hard time seeing where the functional changes are taking place. So much so that I trust Vassil to have reviewed the functional part, such that I don't need to sign off on it. Thanks!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1722
https://github.com/root-project/root/pull/1722:386,safety,review,reviewed,386,"Great work, thanks, @yamaguchi1024 ! This seems to be ok (but needs to be reviewed by @lmoneta ). For future PRs I'd appreciate keeping functional changes (enum iteration) and non-functional changes (moving functions into a different source file) in separate commits. As is I have a hard time seeing where the functional changes are taking place. So much so that I trust Vassil to have reviewed the functional part, such that I don't need to sign off on it. Thanks!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1722
https://github.com/root-project/root/pull/1722:365,security,trust,trust,365,"Great work, thanks, @yamaguchi1024 ! This seems to be ok (but needs to be reviewed by @lmoneta ). For future PRs I'd appreciate keeping functional changes (enum iteration) and non-functional changes (moving functions into a different source file) in separate commits. As is I have a hard time seeing where the functional changes are taking place. So much so that I trust Vassil to have reviewed the functional part, such that I don't need to sign off on it. Thanks!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1722
https://github.com/root-project/root/pull/1722:442,security,sign,sign,442,"Great work, thanks, @yamaguchi1024 ! This seems to be ok (but needs to be reviewed by @lmoneta ). For future PRs I'd appreciate keeping functional changes (enum iteration) and non-functional changes (moving functions into a different source file) in separate commits. As is I have a hard time seeing where the functional changes are taking place. So much so that I trust Vassil to have reviewed the functional part, such that I don't need to sign off on it. Thanks!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1722
https://github.com/root-project/root/pull/1722:74,testability,review,reviewed,74,"Great work, thanks, @yamaguchi1024 ! This seems to be ok (but needs to be reviewed by @lmoneta ). For future PRs I'd appreciate keeping functional changes (enum iteration) and non-functional changes (moving functions into a different source file) in separate commits. As is I have a hard time seeing where the functional changes are taking place. So much so that I trust Vassil to have reviewed the functional part, such that I don't need to sign off on it. Thanks!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1722
https://github.com/root-project/root/pull/1722:386,testability,review,reviewed,386,"Great work, thanks, @yamaguchi1024 ! This seems to be ok (but needs to be reviewed by @lmoneta ). For future PRs I'd appreciate keeping functional changes (enum iteration) and non-functional changes (moving functions into a different source file) in separate commits. As is I have a hard time seeing where the functional changes are taking place. So much so that I trust Vassil to have reviewed the functional part, such that I don't need to sign off on it. Thanks!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1722
https://github.com/root-project/root/pull/1722:49,deployability,depend,depending,49,"Thanks for comments! @phsft-bot This is actually depending on #1720, I have to fix this first",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1722
https://github.com/root-project/root/pull/1722:49,integrability,depend,depending,49,"Thanks for comments! @phsft-bot This is actually depending on #1720, I have to fix this first",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1722
https://github.com/root-project/root/pull/1722:49,modifiability,depend,depending,49,"Thanks for comments! @phsft-bot This is actually depending on #1720, I have to fix this first",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1722
https://github.com/root-project/root/pull/1722:49,safety,depend,depending,49,"Thanks for comments! @phsft-bot This is actually depending on #1720, I have to fix this first",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1722
https://github.com/root-project/root/pull/1722:49,testability,depend,depending,49,"Thanks for comments! @phsft-bot This is actually depending on #1720, I have to fix this first",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1722
https://github.com/root-project/root/pull/1724:56,availability,Error,Error,56,"Thanks for noting this problem. Note that the first new Error message is inaccurate. For example,. ```. gInterpreter->GenerateDictionary(""std::vector<TNamed*>"","""");. ```. works perfectly. And in my opinion the 2nd error message might be too noisy for this kind of error. Either way, my understanding of the problem is simply a missing nullptr checking which was apply to 'just' TCint.cxx at a time we had both TCint and TCintWithCling.cxx:. ```. commit 40ff05f286d494f930c00d81942b845f240a74f9. Author: Axel Naumann <Axel.Naumann@cern.ch>. Date: Thu Jan 19 09:46:31 2012 +0000. Fix Coverity 39060 (deref of 0 ptr). . . git-svn-id: http://root.cern.ch/svn/root/trunk@42716 27541ba8-7e3a-0410-8455-c3a389f83636. diff --git a/core/meta/src/TCint.cxx b/core/meta/src/TCint.cxx. index 311e2f2d99..b9babb70e6 100644. --- a/core/meta/src/TCint.cxx. +++ b/core/meta/src/TCint.cxx. @@ -1165,6 +1165,7 @@ Int_t TCint::GenerateDictionary(const char *classes, const char *includes /* = 0. // gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");. . if (classes == 0 || classes[0] == 0) return 0;. + if (!includes) includes = """";. . // Split the input list. std::vector<std::string> listClasses;. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1724
https://github.com/root-project/root/pull/1724:214,availability,error,error,214,"Thanks for noting this problem. Note that the first new Error message is inaccurate. For example,. ```. gInterpreter->GenerateDictionary(""std::vector<TNamed*>"","""");. ```. works perfectly. And in my opinion the 2nd error message might be too noisy for this kind of error. Either way, my understanding of the problem is simply a missing nullptr checking which was apply to 'just' TCint.cxx at a time we had both TCint and TCintWithCling.cxx:. ```. commit 40ff05f286d494f930c00d81942b845f240a74f9. Author: Axel Naumann <Axel.Naumann@cern.ch>. Date: Thu Jan 19 09:46:31 2012 +0000. Fix Coverity 39060 (deref of 0 ptr). . . git-svn-id: http://root.cern.ch/svn/root/trunk@42716 27541ba8-7e3a-0410-8455-c3a389f83636. diff --git a/core/meta/src/TCint.cxx b/core/meta/src/TCint.cxx. index 311e2f2d99..b9babb70e6 100644. --- a/core/meta/src/TCint.cxx. +++ b/core/meta/src/TCint.cxx. @@ -1165,6 +1165,7 @@ Int_t TCint::GenerateDictionary(const char *classes, const char *includes /* = 0. // gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");. . if (classes == 0 || classes[0] == 0) return 0;. + if (!includes) includes = """";. . // Split the input list. std::vector<std::string> listClasses;. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1724
https://github.com/root-project/root/pull/1724:264,availability,error,error,264,"Thanks for noting this problem. Note that the first new Error message is inaccurate. For example,. ```. gInterpreter->GenerateDictionary(""std::vector<TNamed*>"","""");. ```. works perfectly. And in my opinion the 2nd error message might be too noisy for this kind of error. Either way, my understanding of the problem is simply a missing nullptr checking which was apply to 'just' TCint.cxx at a time we had both TCint and TCintWithCling.cxx:. ```. commit 40ff05f286d494f930c00d81942b845f240a74f9. Author: Axel Naumann <Axel.Naumann@cern.ch>. Date: Thu Jan 19 09:46:31 2012 +0000. Fix Coverity 39060 (deref of 0 ptr). . . git-svn-id: http://root.cern.ch/svn/root/trunk@42716 27541ba8-7e3a-0410-8455-c3a389f83636. diff --git a/core/meta/src/TCint.cxx b/core/meta/src/TCint.cxx. index 311e2f2d99..b9babb70e6 100644. --- a/core/meta/src/TCint.cxx. +++ b/core/meta/src/TCint.cxx. @@ -1165,6 +1165,7 @@ Int_t TCint::GenerateDictionary(const char *classes, const char *includes /* = 0. // gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");. . if (classes == 0 || classes[0] == 0) return 0;. + if (!includes) includes = """";. . // Split the input list. std::vector<std::string> listClasses;. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1724
https://github.com/root-project/root/pull/1724:723,energy efficiency,core,core,723,"Thanks for noting this problem. Note that the first new Error message is inaccurate. For example,. ```. gInterpreter->GenerateDictionary(""std::vector<TNamed*>"","""");. ```. works perfectly. And in my opinion the 2nd error message might be too noisy for this kind of error. Either way, my understanding of the problem is simply a missing nullptr checking which was apply to 'just' TCint.cxx at a time we had both TCint and TCintWithCling.cxx:. ```. commit 40ff05f286d494f930c00d81942b845f240a74f9. Author: Axel Naumann <Axel.Naumann@cern.ch>. Date: Thu Jan 19 09:46:31 2012 +0000. Fix Coverity 39060 (deref of 0 ptr). . . git-svn-id: http://root.cern.ch/svn/root/trunk@42716 27541ba8-7e3a-0410-8455-c3a389f83636. diff --git a/core/meta/src/TCint.cxx b/core/meta/src/TCint.cxx. index 311e2f2d99..b9babb70e6 100644. --- a/core/meta/src/TCint.cxx. +++ b/core/meta/src/TCint.cxx. @@ -1165,6 +1165,7 @@ Int_t TCint::GenerateDictionary(const char *classes, const char *includes /* = 0. // gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");. . if (classes == 0 || classes[0] == 0) return 0;. + if (!includes) includes = """";. . // Split the input list. std::vector<std::string> listClasses;. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1724
https://github.com/root-project/root/pull/1724:749,energy efficiency,core,core,749,"Thanks for noting this problem. Note that the first new Error message is inaccurate. For example,. ```. gInterpreter->GenerateDictionary(""std::vector<TNamed*>"","""");. ```. works perfectly. And in my opinion the 2nd error message might be too noisy for this kind of error. Either way, my understanding of the problem is simply a missing nullptr checking which was apply to 'just' TCint.cxx at a time we had both TCint and TCintWithCling.cxx:. ```. commit 40ff05f286d494f930c00d81942b845f240a74f9. Author: Axel Naumann <Axel.Naumann@cern.ch>. Date: Thu Jan 19 09:46:31 2012 +0000. Fix Coverity 39060 (deref of 0 ptr). . . git-svn-id: http://root.cern.ch/svn/root/trunk@42716 27541ba8-7e3a-0410-8455-c3a389f83636. diff --git a/core/meta/src/TCint.cxx b/core/meta/src/TCint.cxx. index 311e2f2d99..b9babb70e6 100644. --- a/core/meta/src/TCint.cxx. +++ b/core/meta/src/TCint.cxx. @@ -1165,6 +1165,7 @@ Int_t TCint::GenerateDictionary(const char *classes, const char *includes /* = 0. // gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");. . if (classes == 0 || classes[0] == 0) return 0;. + if (!includes) includes = """";. . // Split the input list. std::vector<std::string> listClasses;. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1724
https://github.com/root-project/root/pull/1724:817,energy efficiency,core,core,817,"Thanks for noting this problem. Note that the first new Error message is inaccurate. For example,. ```. gInterpreter->GenerateDictionary(""std::vector<TNamed*>"","""");. ```. works perfectly. And in my opinion the 2nd error message might be too noisy for this kind of error. Either way, my understanding of the problem is simply a missing nullptr checking which was apply to 'just' TCint.cxx at a time we had both TCint and TCintWithCling.cxx:. ```. commit 40ff05f286d494f930c00d81942b845f240a74f9. Author: Axel Naumann <Axel.Naumann@cern.ch>. Date: Thu Jan 19 09:46:31 2012 +0000. Fix Coverity 39060 (deref of 0 ptr). . . git-svn-id: http://root.cern.ch/svn/root/trunk@42716 27541ba8-7e3a-0410-8455-c3a389f83636. diff --git a/core/meta/src/TCint.cxx b/core/meta/src/TCint.cxx. index 311e2f2d99..b9babb70e6 100644. --- a/core/meta/src/TCint.cxx. +++ b/core/meta/src/TCint.cxx. @@ -1165,6 +1165,7 @@ Int_t TCint::GenerateDictionary(const char *classes, const char *includes /* = 0. // gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");. . if (classes == 0 || classes[0] == 0) return 0;. + if (!includes) includes = """";. . // Split the input list. std::vector<std::string> listClasses;. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1724
https://github.com/root-project/root/pull/1724:848,energy efficiency,core,core,848,"Thanks for noting this problem. Note that the first new Error message is inaccurate. For example,. ```. gInterpreter->GenerateDictionary(""std::vector<TNamed*>"","""");. ```. works perfectly. And in my opinion the 2nd error message might be too noisy for this kind of error. Either way, my understanding of the problem is simply a missing nullptr checking which was apply to 'just' TCint.cxx at a time we had both TCint and TCintWithCling.cxx:. ```. commit 40ff05f286d494f930c00d81942b845f240a74f9. Author: Axel Naumann <Axel.Naumann@cern.ch>. Date: Thu Jan 19 09:46:31 2012 +0000. Fix Coverity 39060 (deref of 0 ptr). . . git-svn-id: http://root.cern.ch/svn/root/trunk@42716 27541ba8-7e3a-0410-8455-c3a389f83636. diff --git a/core/meta/src/TCint.cxx b/core/meta/src/TCint.cxx. index 311e2f2d99..b9babb70e6 100644. --- a/core/meta/src/TCint.cxx. +++ b/core/meta/src/TCint.cxx. @@ -1165,6 +1165,7 @@ Int_t TCint::GenerateDictionary(const char *classes, const char *includes /* = 0. // gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");. . if (classes == 0 || classes[0] == 0) return 0;. + if (!includes) includes = """";. . // Split the input list. std::vector<std::string> listClasses;. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1724
https://github.com/root-project/root/pull/1724:62,integrability,messag,message,62,"Thanks for noting this problem. Note that the first new Error message is inaccurate. For example,. ```. gInterpreter->GenerateDictionary(""std::vector<TNamed*>"","""");. ```. works perfectly. And in my opinion the 2nd error message might be too noisy for this kind of error. Either way, my understanding of the problem is simply a missing nullptr checking which was apply to 'just' TCint.cxx at a time we had both TCint and TCintWithCling.cxx:. ```. commit 40ff05f286d494f930c00d81942b845f240a74f9. Author: Axel Naumann <Axel.Naumann@cern.ch>. Date: Thu Jan 19 09:46:31 2012 +0000. Fix Coverity 39060 (deref of 0 ptr). . . git-svn-id: http://root.cern.ch/svn/root/trunk@42716 27541ba8-7e3a-0410-8455-c3a389f83636. diff --git a/core/meta/src/TCint.cxx b/core/meta/src/TCint.cxx. index 311e2f2d99..b9babb70e6 100644. --- a/core/meta/src/TCint.cxx. +++ b/core/meta/src/TCint.cxx. @@ -1165,6 +1165,7 @@ Int_t TCint::GenerateDictionary(const char *classes, const char *includes /* = 0. // gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");. . if (classes == 0 || classes[0] == 0) return 0;. + if (!includes) includes = """";. . // Split the input list. std::vector<std::string> listClasses;. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1724
https://github.com/root-project/root/pull/1724:220,integrability,messag,message,220,"Thanks for noting this problem. Note that the first new Error message is inaccurate. For example,. ```. gInterpreter->GenerateDictionary(""std::vector<TNamed*>"","""");. ```. works perfectly. And in my opinion the 2nd error message might be too noisy for this kind of error. Either way, my understanding of the problem is simply a missing nullptr checking which was apply to 'just' TCint.cxx at a time we had both TCint and TCintWithCling.cxx:. ```. commit 40ff05f286d494f930c00d81942b845f240a74f9. Author: Axel Naumann <Axel.Naumann@cern.ch>. Date: Thu Jan 19 09:46:31 2012 +0000. Fix Coverity 39060 (deref of 0 ptr). . . git-svn-id: http://root.cern.ch/svn/root/trunk@42716 27541ba8-7e3a-0410-8455-c3a389f83636. diff --git a/core/meta/src/TCint.cxx b/core/meta/src/TCint.cxx. index 311e2f2d99..b9babb70e6 100644. --- a/core/meta/src/TCint.cxx. +++ b/core/meta/src/TCint.cxx. @@ -1165,6 +1165,7 @@ Int_t TCint::GenerateDictionary(const char *classes, const char *includes /* = 0. // gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");. . if (classes == 0 || classes[0] == 0) return 0;. + if (!includes) includes = """";. . // Split the input list. std::vector<std::string> listClasses;. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1724
https://github.com/root-project/root/pull/1724:62,interoperability,messag,message,62,"Thanks for noting this problem. Note that the first new Error message is inaccurate. For example,. ```. gInterpreter->GenerateDictionary(""std::vector<TNamed*>"","""");. ```. works perfectly. And in my opinion the 2nd error message might be too noisy for this kind of error. Either way, my understanding of the problem is simply a missing nullptr checking which was apply to 'just' TCint.cxx at a time we had both TCint and TCintWithCling.cxx:. ```. commit 40ff05f286d494f930c00d81942b845f240a74f9. Author: Axel Naumann <Axel.Naumann@cern.ch>. Date: Thu Jan 19 09:46:31 2012 +0000. Fix Coverity 39060 (deref of 0 ptr). . . git-svn-id: http://root.cern.ch/svn/root/trunk@42716 27541ba8-7e3a-0410-8455-c3a389f83636. diff --git a/core/meta/src/TCint.cxx b/core/meta/src/TCint.cxx. index 311e2f2d99..b9babb70e6 100644. --- a/core/meta/src/TCint.cxx. +++ b/core/meta/src/TCint.cxx. @@ -1165,6 +1165,7 @@ Int_t TCint::GenerateDictionary(const char *classes, const char *includes /* = 0. // gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");. . if (classes == 0 || classes[0] == 0) return 0;. + if (!includes) includes = """";. . // Split the input list. std::vector<std::string> listClasses;. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1724
https://github.com/root-project/root/pull/1724:220,interoperability,messag,message,220,"Thanks for noting this problem. Note that the first new Error message is inaccurate. For example,. ```. gInterpreter->GenerateDictionary(""std::vector<TNamed*>"","""");. ```. works perfectly. And in my opinion the 2nd error message might be too noisy for this kind of error. Either way, my understanding of the problem is simply a missing nullptr checking which was apply to 'just' TCint.cxx at a time we had both TCint and TCintWithCling.cxx:. ```. commit 40ff05f286d494f930c00d81942b845f240a74f9. Author: Axel Naumann <Axel.Naumann@cern.ch>. Date: Thu Jan 19 09:46:31 2012 +0000. Fix Coverity 39060 (deref of 0 ptr). . . git-svn-id: http://root.cern.ch/svn/root/trunk@42716 27541ba8-7e3a-0410-8455-c3a389f83636. diff --git a/core/meta/src/TCint.cxx b/core/meta/src/TCint.cxx. index 311e2f2d99..b9babb70e6 100644. --- a/core/meta/src/TCint.cxx. +++ b/core/meta/src/TCint.cxx. @@ -1165,6 +1165,7 @@ Int_t TCint::GenerateDictionary(const char *classes, const char *includes /* = 0. // gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");. . if (classes == 0 || classes[0] == 0) return 0;. + if (!includes) includes = """";. . // Split the input list. std::vector<std::string> listClasses;. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1724
https://github.com/root-project/root/pull/1724:56,performance,Error,Error,56,"Thanks for noting this problem. Note that the first new Error message is inaccurate. For example,. ```. gInterpreter->GenerateDictionary(""std::vector<TNamed*>"","""");. ```. works perfectly. And in my opinion the 2nd error message might be too noisy for this kind of error. Either way, my understanding of the problem is simply a missing nullptr checking which was apply to 'just' TCint.cxx at a time we had both TCint and TCintWithCling.cxx:. ```. commit 40ff05f286d494f930c00d81942b845f240a74f9. Author: Axel Naumann <Axel.Naumann@cern.ch>. Date: Thu Jan 19 09:46:31 2012 +0000. Fix Coverity 39060 (deref of 0 ptr). . . git-svn-id: http://root.cern.ch/svn/root/trunk@42716 27541ba8-7e3a-0410-8455-c3a389f83636. diff --git a/core/meta/src/TCint.cxx b/core/meta/src/TCint.cxx. index 311e2f2d99..b9babb70e6 100644. --- a/core/meta/src/TCint.cxx. +++ b/core/meta/src/TCint.cxx. @@ -1165,6 +1165,7 @@ Int_t TCint::GenerateDictionary(const char *classes, const char *includes /* = 0. // gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");. . if (classes == 0 || classes[0] == 0) return 0;. + if (!includes) includes = """";. . // Split the input list. std::vector<std::string> listClasses;. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1724
https://github.com/root-project/root/pull/1724:214,performance,error,error,214,"Thanks for noting this problem. Note that the first new Error message is inaccurate. For example,. ```. gInterpreter->GenerateDictionary(""std::vector<TNamed*>"","""");. ```. works perfectly. And in my opinion the 2nd error message might be too noisy for this kind of error. Either way, my understanding of the problem is simply a missing nullptr checking which was apply to 'just' TCint.cxx at a time we had both TCint and TCintWithCling.cxx:. ```. commit 40ff05f286d494f930c00d81942b845f240a74f9. Author: Axel Naumann <Axel.Naumann@cern.ch>. Date: Thu Jan 19 09:46:31 2012 +0000. Fix Coverity 39060 (deref of 0 ptr). . . git-svn-id: http://root.cern.ch/svn/root/trunk@42716 27541ba8-7e3a-0410-8455-c3a389f83636. diff --git a/core/meta/src/TCint.cxx b/core/meta/src/TCint.cxx. index 311e2f2d99..b9babb70e6 100644. --- a/core/meta/src/TCint.cxx. +++ b/core/meta/src/TCint.cxx. @@ -1165,6 +1165,7 @@ Int_t TCint::GenerateDictionary(const char *classes, const char *includes /* = 0. // gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");. . if (classes == 0 || classes[0] == 0) return 0;. + if (!includes) includes = """";. . // Split the input list. std::vector<std::string> listClasses;. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1724
https://github.com/root-project/root/pull/1724:264,performance,error,error,264,"Thanks for noting this problem. Note that the first new Error message is inaccurate. For example,. ```. gInterpreter->GenerateDictionary(""std::vector<TNamed*>"","""");. ```. works perfectly. And in my opinion the 2nd error message might be too noisy for this kind of error. Either way, my understanding of the problem is simply a missing nullptr checking which was apply to 'just' TCint.cxx at a time we had both TCint and TCintWithCling.cxx:. ```. commit 40ff05f286d494f930c00d81942b845f240a74f9. Author: Axel Naumann <Axel.Naumann@cern.ch>. Date: Thu Jan 19 09:46:31 2012 +0000. Fix Coverity 39060 (deref of 0 ptr). . . git-svn-id: http://root.cern.ch/svn/root/trunk@42716 27541ba8-7e3a-0410-8455-c3a389f83636. diff --git a/core/meta/src/TCint.cxx b/core/meta/src/TCint.cxx. index 311e2f2d99..b9babb70e6 100644. --- a/core/meta/src/TCint.cxx. +++ b/core/meta/src/TCint.cxx. @@ -1165,6 +1165,7 @@ Int_t TCint::GenerateDictionary(const char *classes, const char *includes /* = 0. // gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");. . if (classes == 0 || classes[0] == 0) return 0;. + if (!includes) includes = """";. . // Split the input list. std::vector<std::string> listClasses;. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1724
https://github.com/root-project/root/pull/1724:393,performance,time,time,393,"Thanks for noting this problem. Note that the first new Error message is inaccurate. For example,. ```. gInterpreter->GenerateDictionary(""std::vector<TNamed*>"","""");. ```. works perfectly. And in my opinion the 2nd error message might be too noisy for this kind of error. Either way, my understanding of the problem is simply a missing nullptr checking which was apply to 'just' TCint.cxx at a time we had both TCint and TCintWithCling.cxx:. ```. commit 40ff05f286d494f930c00d81942b845f240a74f9. Author: Axel Naumann <Axel.Naumann@cern.ch>. Date: Thu Jan 19 09:46:31 2012 +0000. Fix Coverity 39060 (deref of 0 ptr). . . git-svn-id: http://root.cern.ch/svn/root/trunk@42716 27541ba8-7e3a-0410-8455-c3a389f83636. diff --git a/core/meta/src/TCint.cxx b/core/meta/src/TCint.cxx. index 311e2f2d99..b9babb70e6 100644. --- a/core/meta/src/TCint.cxx. +++ b/core/meta/src/TCint.cxx. @@ -1165,6 +1165,7 @@ Int_t TCint::GenerateDictionary(const char *classes, const char *includes /* = 0. // gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");. . if (classes == 0 || classes[0] == 0) return 0;. + if (!includes) includes = """";. . // Split the input list. std::vector<std::string> listClasses;. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1724
https://github.com/root-project/root/pull/1724:56,safety,Error,Error,56,"Thanks for noting this problem. Note that the first new Error message is inaccurate. For example,. ```. gInterpreter->GenerateDictionary(""std::vector<TNamed*>"","""");. ```. works perfectly. And in my opinion the 2nd error message might be too noisy for this kind of error. Either way, my understanding of the problem is simply a missing nullptr checking which was apply to 'just' TCint.cxx at a time we had both TCint and TCintWithCling.cxx:. ```. commit 40ff05f286d494f930c00d81942b845f240a74f9. Author: Axel Naumann <Axel.Naumann@cern.ch>. Date: Thu Jan 19 09:46:31 2012 +0000. Fix Coverity 39060 (deref of 0 ptr). . . git-svn-id: http://root.cern.ch/svn/root/trunk@42716 27541ba8-7e3a-0410-8455-c3a389f83636. diff --git a/core/meta/src/TCint.cxx b/core/meta/src/TCint.cxx. index 311e2f2d99..b9babb70e6 100644. --- a/core/meta/src/TCint.cxx. +++ b/core/meta/src/TCint.cxx. @@ -1165,6 +1165,7 @@ Int_t TCint::GenerateDictionary(const char *classes, const char *includes /* = 0. // gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");. . if (classes == 0 || classes[0] == 0) return 0;. + if (!includes) includes = """";. . // Split the input list. std::vector<std::string> listClasses;. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1724
https://github.com/root-project/root/pull/1724:214,safety,error,error,214,"Thanks for noting this problem. Note that the first new Error message is inaccurate. For example,. ```. gInterpreter->GenerateDictionary(""std::vector<TNamed*>"","""");. ```. works perfectly. And in my opinion the 2nd error message might be too noisy for this kind of error. Either way, my understanding of the problem is simply a missing nullptr checking which was apply to 'just' TCint.cxx at a time we had both TCint and TCintWithCling.cxx:. ```. commit 40ff05f286d494f930c00d81942b845f240a74f9. Author: Axel Naumann <Axel.Naumann@cern.ch>. Date: Thu Jan 19 09:46:31 2012 +0000. Fix Coverity 39060 (deref of 0 ptr). . . git-svn-id: http://root.cern.ch/svn/root/trunk@42716 27541ba8-7e3a-0410-8455-c3a389f83636. diff --git a/core/meta/src/TCint.cxx b/core/meta/src/TCint.cxx. index 311e2f2d99..b9babb70e6 100644. --- a/core/meta/src/TCint.cxx. +++ b/core/meta/src/TCint.cxx. @@ -1165,6 +1165,7 @@ Int_t TCint::GenerateDictionary(const char *classes, const char *includes /* = 0. // gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");. . if (classes == 0 || classes[0] == 0) return 0;. + if (!includes) includes = """";. . // Split the input list. std::vector<std::string> listClasses;. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1724
https://github.com/root-project/root/pull/1724:264,safety,error,error,264,"Thanks for noting this problem. Note that the first new Error message is inaccurate. For example,. ```. gInterpreter->GenerateDictionary(""std::vector<TNamed*>"","""");. ```. works perfectly. And in my opinion the 2nd error message might be too noisy for this kind of error. Either way, my understanding of the problem is simply a missing nullptr checking which was apply to 'just' TCint.cxx at a time we had both TCint and TCintWithCling.cxx:. ```. commit 40ff05f286d494f930c00d81942b845f240a74f9. Author: Axel Naumann <Axel.Naumann@cern.ch>. Date: Thu Jan 19 09:46:31 2012 +0000. Fix Coverity 39060 (deref of 0 ptr). . . git-svn-id: http://root.cern.ch/svn/root/trunk@42716 27541ba8-7e3a-0410-8455-c3a389f83636. diff --git a/core/meta/src/TCint.cxx b/core/meta/src/TCint.cxx. index 311e2f2d99..b9babb70e6 100644. --- a/core/meta/src/TCint.cxx. +++ b/core/meta/src/TCint.cxx. @@ -1165,6 +1165,7 @@ Int_t TCint::GenerateDictionary(const char *classes, const char *includes /* = 0. // gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");. . if (classes == 0 || classes[0] == 0) return 0;. + if (!includes) includes = """";. . // Split the input list. std::vector<std::string> listClasses;. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1724
https://github.com/root-project/root/pull/1724:1147,safety,input,input,1147,"Thanks for noting this problem. Note that the first new Error message is inaccurate. For example,. ```. gInterpreter->GenerateDictionary(""std::vector<TNamed*>"","""");. ```. works perfectly. And in my opinion the 2nd error message might be too noisy for this kind of error. Either way, my understanding of the problem is simply a missing nullptr checking which was apply to 'just' TCint.cxx at a time we had both TCint and TCintWithCling.cxx:. ```. commit 40ff05f286d494f930c00d81942b845f240a74f9. Author: Axel Naumann <Axel.Naumann@cern.ch>. Date: Thu Jan 19 09:46:31 2012 +0000. Fix Coverity 39060 (deref of 0 ptr). . . git-svn-id: http://root.cern.ch/svn/root/trunk@42716 27541ba8-7e3a-0410-8455-c3a389f83636. diff --git a/core/meta/src/TCint.cxx b/core/meta/src/TCint.cxx. index 311e2f2d99..b9babb70e6 100644. --- a/core/meta/src/TCint.cxx. +++ b/core/meta/src/TCint.cxx. @@ -1165,6 +1165,7 @@ Int_t TCint::GenerateDictionary(const char *classes, const char *includes /* = 0. // gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");. . if (classes == 0 || classes[0] == 0) return 0;. + if (!includes) includes = """";. . // Split the input list. std::vector<std::string> listClasses;. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1724
https://github.com/root-project/root/pull/1724:495,security,Auth,Author,495,"Thanks for noting this problem. Note that the first new Error message is inaccurate. For example,. ```. gInterpreter->GenerateDictionary(""std::vector<TNamed*>"","""");. ```. works perfectly. And in my opinion the 2nd error message might be too noisy for this kind of error. Either way, my understanding of the problem is simply a missing nullptr checking which was apply to 'just' TCint.cxx at a time we had both TCint and TCintWithCling.cxx:. ```. commit 40ff05f286d494f930c00d81942b845f240a74f9. Author: Axel Naumann <Axel.Naumann@cern.ch>. Date: Thu Jan 19 09:46:31 2012 +0000. Fix Coverity 39060 (deref of 0 ptr). . . git-svn-id: http://root.cern.ch/svn/root/trunk@42716 27541ba8-7e3a-0410-8455-c3a389f83636. diff --git a/core/meta/src/TCint.cxx b/core/meta/src/TCint.cxx. index 311e2f2d99..b9babb70e6 100644. --- a/core/meta/src/TCint.cxx. +++ b/core/meta/src/TCint.cxx. @@ -1165,6 +1165,7 @@ Int_t TCint::GenerateDictionary(const char *classes, const char *includes /* = 0. // gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");. . if (classes == 0 || classes[0] == 0) return 0;. + if (!includes) includes = """";. . // Split the input list. std::vector<std::string> listClasses;. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1724
https://github.com/root-project/root/pull/1724:286,testability,understand,understanding,286,"Thanks for noting this problem. Note that the first new Error message is inaccurate. For example,. ```. gInterpreter->GenerateDictionary(""std::vector<TNamed*>"","""");. ```. works perfectly. And in my opinion the 2nd error message might be too noisy for this kind of error. Either way, my understanding of the problem is simply a missing nullptr checking which was apply to 'just' TCint.cxx at a time we had both TCint and TCintWithCling.cxx:. ```. commit 40ff05f286d494f930c00d81942b845f240a74f9. Author: Axel Naumann <Axel.Naumann@cern.ch>. Date: Thu Jan 19 09:46:31 2012 +0000. Fix Coverity 39060 (deref of 0 ptr). . . git-svn-id: http://root.cern.ch/svn/root/trunk@42716 27541ba8-7e3a-0410-8455-c3a389f83636. diff --git a/core/meta/src/TCint.cxx b/core/meta/src/TCint.cxx. index 311e2f2d99..b9babb70e6 100644. --- a/core/meta/src/TCint.cxx. +++ b/core/meta/src/TCint.cxx. @@ -1165,6 +1165,7 @@ Int_t TCint::GenerateDictionary(const char *classes, const char *includes /* = 0. // gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");. . if (classes == 0 || classes[0] == 0) return 0;. + if (!includes) includes = """";. . // Split the input list. std::vector<std::string> listClasses;. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1724
https://github.com/root-project/root/pull/1724:318,testability,simpl,simply,318,"Thanks for noting this problem. Note that the first new Error message is inaccurate. For example,. ```. gInterpreter->GenerateDictionary(""std::vector<TNamed*>"","""");. ```. works perfectly. And in my opinion the 2nd error message might be too noisy for this kind of error. Either way, my understanding of the problem is simply a missing nullptr checking which was apply to 'just' TCint.cxx at a time we had both TCint and TCintWithCling.cxx:. ```. commit 40ff05f286d494f930c00d81942b845f240a74f9. Author: Axel Naumann <Axel.Naumann@cern.ch>. Date: Thu Jan 19 09:46:31 2012 +0000. Fix Coverity 39060 (deref of 0 ptr). . . git-svn-id: http://root.cern.ch/svn/root/trunk@42716 27541ba8-7e3a-0410-8455-c3a389f83636. diff --git a/core/meta/src/TCint.cxx b/core/meta/src/TCint.cxx. index 311e2f2d99..b9babb70e6 100644. --- a/core/meta/src/TCint.cxx. +++ b/core/meta/src/TCint.cxx. @@ -1165,6 +1165,7 @@ Int_t TCint::GenerateDictionary(const char *classes, const char *includes /* = 0. // gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");. . if (classes == 0 || classes[0] == 0) return 0;. + if (!includes) includes = """";. . // Split the input list. std::vector<std::string> listClasses;. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1724
https://github.com/root-project/root/pull/1724:56,usability,Error,Error,56,"Thanks for noting this problem. Note that the first new Error message is inaccurate. For example,. ```. gInterpreter->GenerateDictionary(""std::vector<TNamed*>"","""");. ```. works perfectly. And in my opinion the 2nd error message might be too noisy for this kind of error. Either way, my understanding of the problem is simply a missing nullptr checking which was apply to 'just' TCint.cxx at a time we had both TCint and TCintWithCling.cxx:. ```. commit 40ff05f286d494f930c00d81942b845f240a74f9. Author: Axel Naumann <Axel.Naumann@cern.ch>. Date: Thu Jan 19 09:46:31 2012 +0000. Fix Coverity 39060 (deref of 0 ptr). . . git-svn-id: http://root.cern.ch/svn/root/trunk@42716 27541ba8-7e3a-0410-8455-c3a389f83636. diff --git a/core/meta/src/TCint.cxx b/core/meta/src/TCint.cxx. index 311e2f2d99..b9babb70e6 100644. --- a/core/meta/src/TCint.cxx. +++ b/core/meta/src/TCint.cxx. @@ -1165,6 +1165,7 @@ Int_t TCint::GenerateDictionary(const char *classes, const char *includes /* = 0. // gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");. . if (classes == 0 || classes[0] == 0) return 0;. + if (!includes) includes = """";. . // Split the input list. std::vector<std::string> listClasses;. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1724
https://github.com/root-project/root/pull/1724:214,usability,error,error,214,"Thanks for noting this problem. Note that the first new Error message is inaccurate. For example,. ```. gInterpreter->GenerateDictionary(""std::vector<TNamed*>"","""");. ```. works perfectly. And in my opinion the 2nd error message might be too noisy for this kind of error. Either way, my understanding of the problem is simply a missing nullptr checking which was apply to 'just' TCint.cxx at a time we had both TCint and TCintWithCling.cxx:. ```. commit 40ff05f286d494f930c00d81942b845f240a74f9. Author: Axel Naumann <Axel.Naumann@cern.ch>. Date: Thu Jan 19 09:46:31 2012 +0000. Fix Coverity 39060 (deref of 0 ptr). . . git-svn-id: http://root.cern.ch/svn/root/trunk@42716 27541ba8-7e3a-0410-8455-c3a389f83636. diff --git a/core/meta/src/TCint.cxx b/core/meta/src/TCint.cxx. index 311e2f2d99..b9babb70e6 100644. --- a/core/meta/src/TCint.cxx. +++ b/core/meta/src/TCint.cxx. @@ -1165,6 +1165,7 @@ Int_t TCint::GenerateDictionary(const char *classes, const char *includes /* = 0. // gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");. . if (classes == 0 || classes[0] == 0) return 0;. + if (!includes) includes = """";. . // Split the input list. std::vector<std::string> listClasses;. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1724
https://github.com/root-project/root/pull/1724:264,usability,error,error,264,"Thanks for noting this problem. Note that the first new Error message is inaccurate. For example,. ```. gInterpreter->GenerateDictionary(""std::vector<TNamed*>"","""");. ```. works perfectly. And in my opinion the 2nd error message might be too noisy for this kind of error. Either way, my understanding of the problem is simply a missing nullptr checking which was apply to 'just' TCint.cxx at a time we had both TCint and TCintWithCling.cxx:. ```. commit 40ff05f286d494f930c00d81942b845f240a74f9. Author: Axel Naumann <Axel.Naumann@cern.ch>. Date: Thu Jan 19 09:46:31 2012 +0000. Fix Coverity 39060 (deref of 0 ptr). . . git-svn-id: http://root.cern.ch/svn/root/trunk@42716 27541ba8-7e3a-0410-8455-c3a389f83636. diff --git a/core/meta/src/TCint.cxx b/core/meta/src/TCint.cxx. index 311e2f2d99..b9babb70e6 100644. --- a/core/meta/src/TCint.cxx. +++ b/core/meta/src/TCint.cxx. @@ -1165,6 +1165,7 @@ Int_t TCint::GenerateDictionary(const char *classes, const char *includes /* = 0. // gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");. . if (classes == 0 || classes[0] == 0) return 0;. + if (!includes) includes = """";. . // Split the input list. std::vector<std::string> listClasses;. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1724
https://github.com/root-project/root/pull/1724:318,usability,simpl,simply,318,"Thanks for noting this problem. Note that the first new Error message is inaccurate. For example,. ```. gInterpreter->GenerateDictionary(""std::vector<TNamed*>"","""");. ```. works perfectly. And in my opinion the 2nd error message might be too noisy for this kind of error. Either way, my understanding of the problem is simply a missing nullptr checking which was apply to 'just' TCint.cxx at a time we had both TCint and TCintWithCling.cxx:. ```. commit 40ff05f286d494f930c00d81942b845f240a74f9. Author: Axel Naumann <Axel.Naumann@cern.ch>. Date: Thu Jan 19 09:46:31 2012 +0000. Fix Coverity 39060 (deref of 0 ptr). . . git-svn-id: http://root.cern.ch/svn/root/trunk@42716 27541ba8-7e3a-0410-8455-c3a389f83636. diff --git a/core/meta/src/TCint.cxx b/core/meta/src/TCint.cxx. index 311e2f2d99..b9babb70e6 100644. --- a/core/meta/src/TCint.cxx. +++ b/core/meta/src/TCint.cxx. @@ -1165,6 +1165,7 @@ Int_t TCint::GenerateDictionary(const char *classes, const char *includes /* = 0. // gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");. . if (classes == 0 || classes[0] == 0) return 0;. + if (!includes) includes = """";. . // Split the input list. std::vector<std::string> listClasses;. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1724
https://github.com/root-project/root/pull/1724:1147,usability,input,input,1147,"Thanks for noting this problem. Note that the first new Error message is inaccurate. For example,. ```. gInterpreter->GenerateDictionary(""std::vector<TNamed*>"","""");. ```. works perfectly. And in my opinion the 2nd error message might be too noisy for this kind of error. Either way, my understanding of the problem is simply a missing nullptr checking which was apply to 'just' TCint.cxx at a time we had both TCint and TCintWithCling.cxx:. ```. commit 40ff05f286d494f930c00d81942b845f240a74f9. Author: Axel Naumann <Axel.Naumann@cern.ch>. Date: Thu Jan 19 09:46:31 2012 +0000. Fix Coverity 39060 (deref of 0 ptr). . . git-svn-id: http://root.cern.ch/svn/root/trunk@42716 27541ba8-7e3a-0410-8455-c3a389f83636. diff --git a/core/meta/src/TCint.cxx b/core/meta/src/TCint.cxx. index 311e2f2d99..b9babb70e6 100644. --- a/core/meta/src/TCint.cxx. +++ b/core/meta/src/TCint.cxx. @@ -1165,6 +1165,7 @@ Int_t TCint::GenerateDictionary(const char *classes, const char *includes /* = 0. // gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");. . if (classes == 0 || classes[0] == 0) return 0;. + if (!includes) includes = """";. . // Split the input list. std::vector<std::string> listClasses;. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1724
https://github.com/root-project/root/pull/1724:92,deployability,infrastructur,infrastructure,92,"Well it passes a few headers by default (the one needed for compilation the dictionary code infrastructure .. which include <vector>). > leads to an infinite loop. Interestingly, it is not GenerateDictionary that is going into an infinite loop but rootcling that is failing on processing the 'incomplete' header. i.e. ```gInterpreter->GenerateDictionary(""std::vector<std::array<int, 5>>"", ""TNamed.h"")``` avoid the proposed test **and still** get rootcling into a infinite loop. You see this yourself, suspending the root.exe process and attaching (or re-running) the rootcling process running the time. (The linkdef parser seems to have problem with the 'unknown' type vector<array....>). Cheers,. Philippe.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1724
https://github.com/root-project/root/pull/1724:266,deployability,fail,failing,266,"Well it passes a few headers by default (the one needed for compilation the dictionary code infrastructure .. which include <vector>). > leads to an infinite loop. Interestingly, it is not GenerateDictionary that is going into an infinite loop but rootcling that is failing on processing the 'incomplete' header. i.e. ```gInterpreter->GenerateDictionary(""std::vector<std::array<int, 5>>"", ""TNamed.h"")``` avoid the proposed test **and still** get rootcling into a infinite loop. You see this yourself, suspending the root.exe process and attaching (or re-running) the rootcling process running the time. (The linkdef parser seems to have problem with the 'unknown' type vector<array....>). Cheers,. Philippe.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1724
https://github.com/root-project/root/pull/1724:597,performance,time,time,597,"Well it passes a few headers by default (the one needed for compilation the dictionary code infrastructure .. which include <vector>). > leads to an infinite loop. Interestingly, it is not GenerateDictionary that is going into an infinite loop but rootcling that is failing on processing the 'incomplete' header. i.e. ```gInterpreter->GenerateDictionary(""std::vector<std::array<int, 5>>"", ""TNamed.h"")``` avoid the proposed test **and still** get rootcling into a infinite loop. You see this yourself, suspending the root.exe process and attaching (or re-running) the rootcling process running the time. (The linkdef parser seems to have problem with the 'unknown' type vector<array....>). Cheers,. Philippe.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1724
https://github.com/root-project/root/pull/1724:266,reliability,fail,failing,266,"Well it passes a few headers by default (the one needed for compilation the dictionary code infrastructure .. which include <vector>). > leads to an infinite loop. Interestingly, it is not GenerateDictionary that is going into an infinite loop but rootcling that is failing on processing the 'incomplete' header. i.e. ```gInterpreter->GenerateDictionary(""std::vector<std::array<int, 5>>"", ""TNamed.h"")``` avoid the proposed test **and still** get rootcling into a infinite loop. You see this yourself, suspending the root.exe process and attaching (or re-running) the rootcling process running the time. (The linkdef parser seems to have problem with the 'unknown' type vector<array....>). Cheers,. Philippe.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1724
https://github.com/root-project/root/pull/1724:404,safety,avoid,avoid,404,"Well it passes a few headers by default (the one needed for compilation the dictionary code infrastructure .. which include <vector>). > leads to an infinite loop. Interestingly, it is not GenerateDictionary that is going into an infinite loop but rootcling that is failing on processing the 'incomplete' header. i.e. ```gInterpreter->GenerateDictionary(""std::vector<std::array<int, 5>>"", ""TNamed.h"")``` avoid the proposed test **and still** get rootcling into a infinite loop. You see this yourself, suspending the root.exe process and attaching (or re-running) the rootcling process running the time. (The linkdef parser seems to have problem with the 'unknown' type vector<array....>). Cheers,. Philippe.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1724
https://github.com/root-project/root/pull/1724:423,safety,test,test,423,"Well it passes a few headers by default (the one needed for compilation the dictionary code infrastructure .. which include <vector>). > leads to an infinite loop. Interestingly, it is not GenerateDictionary that is going into an infinite loop but rootcling that is failing on processing the 'incomplete' header. i.e. ```gInterpreter->GenerateDictionary(""std::vector<std::array<int, 5>>"", ""TNamed.h"")``` avoid the proposed test **and still** get rootcling into a infinite loop. You see this yourself, suspending the root.exe process and attaching (or re-running) the rootcling process running the time. (The linkdef parser seems to have problem with the 'unknown' type vector<array....>). Cheers,. Philippe.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1724
https://github.com/root-project/root/pull/1724:423,testability,test,test,423,"Well it passes a few headers by default (the one needed for compilation the dictionary code infrastructure .. which include <vector>). > leads to an infinite loop. Interestingly, it is not GenerateDictionary that is going into an infinite loop but rootcling that is failing on processing the 'incomplete' header. i.e. ```gInterpreter->GenerateDictionary(""std::vector<std::array<int, 5>>"", ""TNamed.h"")``` avoid the proposed test **and still** get rootcling into a infinite loop. You see this yourself, suspending the root.exe process and attaching (or re-running) the rootcling process running the time. (The linkdef parser seems to have problem with the 'unknown' type vector<array....>). Cheers,. Philippe.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1724
https://github.com/root-project/root/pull/1726:63,deployability,fail,failed,63,@yamaguchi1024 On the previous attempt what test/functionality failed?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1726
https://github.com/root-project/root/pull/1726:63,reliability,fail,failed,63,@yamaguchi1024 On the previous attempt what test/functionality failed?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1726
https://github.com/root-project/root/pull/1726:44,safety,test,test,44,@yamaguchi1024 On the previous attempt what test/functionality failed?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1726
https://github.com/root-project/root/pull/1726:44,testability,test,test,44,@yamaguchi1024 On the previous attempt what test/functionality failed?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1726
https://github.com/root-project/root/pull/1726:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1726
https://github.com/root-project/root/pull/1726:124,deployability,stack,stack,124,roottest_root_multicore_tp_process_imt crashes within Davix. root_multicore_processExecutorH1Test crashes without showing a stack trace (in the web output). So I assume both are network related. merging.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1726
https://github.com/root-project/root/pull/1726:178,performance,network,network,178,roottest_root_multicore_tp_process_imt crashes within Davix. root_multicore_processExecutorH1Test crashes without showing a stack trace (in the web output). So I assume both are network related. merging.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1726
https://github.com/root-project/root/pull/1726:178,security,network,network,178,roottest_root_multicore_tp_process_imt crashes within Davix. root_multicore_processExecutorH1Test crashes without showing a stack trace (in the web output). So I assume both are network related. merging.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1726
https://github.com/root-project/root/pull/1726:130,testability,trace,trace,130,roottest_root_multicore_tp_process_imt crashes within Davix. root_multicore_processExecutorH1Test crashes without showing a stack trace (in the web output). So I assume both are network related. merging.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1726
https://github.com/root-project/root/pull/1728:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1728
https://github.com/root-project/root/pull/1728:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1728
https://github.com/root-project/root/pull/1728:169,deployability,fail,failing,169,"Nice catch. Thanks. The commit message could be made even better by explaining what was wrong with the previous implementation; for example by mentioning which test was failing and how. This would allow to make sure that future attempt to make a similar change do not suffer the same problems. Cheers,. Philippe.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1728
https://github.com/root-project/root/pull/1728:31,integrability,messag,message,31,"Nice catch. Thanks. The commit message could be made even better by explaining what was wrong with the previous implementation; for example by mentioning which test was failing and how. This would allow to make sure that future attempt to make a similar change do not suffer the same problems. Cheers,. Philippe.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1728
https://github.com/root-project/root/pull/1728:31,interoperability,messag,message,31,"Nice catch. Thanks. The commit message could be made even better by explaining what was wrong with the previous implementation; for example by mentioning which test was failing and how. This would allow to make sure that future attempt to make a similar change do not suffer the same problems. Cheers,. Philippe.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1728
https://github.com/root-project/root/pull/1728:169,reliability,fail,failing,169,"Nice catch. Thanks. The commit message could be made even better by explaining what was wrong with the previous implementation; for example by mentioning which test was failing and how. This would allow to make sure that future attempt to make a similar change do not suffer the same problems. Cheers,. Philippe.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1728
https://github.com/root-project/root/pull/1728:160,safety,test,test,160,"Nice catch. Thanks. The commit message could be made even better by explaining what was wrong with the previous implementation; for example by mentioning which test was failing and how. This would allow to make sure that future attempt to make a similar change do not suffer the same problems. Cheers,. Philippe.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1728
https://github.com/root-project/root/pull/1728:160,testability,test,test,160,"Nice catch. Thanks. The commit message could be made even better by explaining what was wrong with the previous implementation; for example by mentioning which test was failing and how. This would allow to make sure that future attempt to make a similar change do not suffer the same problems. Cheers,. Philippe.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1728
https://github.com/root-project/root/pull/1729:11,deployability,build,build,11,@phsft-bot build with flags -Dclingtest=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1729
https://github.com/root-project/root/pull/1730:11,deployability,build,build,11,@phsft-bot build just on slc6/gcc62 with flags -Druntime_cxxmodules=On -Dctest_test_exclude_none=on,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1730
https://github.com/root-project/root/pull/1730:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1730
https://github.com/root-project/root/pull/1730:11,deployability,build,build,11,@phsft-bot build just on slc6/gcc62 with flags -Druntime_cxxmodules=On -Dctest_test_exclude_none=on,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1730
https://github.com/root-project/root/pull/1731:109,energy efficiency,core,core,109,It'd be a good idea to add a test covering this case [here](https://github.com/root-project/root/blob/master/core/metacling/test/TClingCallFuncTests.cxx).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1731
https://github.com/root-project/root/pull/1731:29,safety,test,test,29,It'd be a good idea to add a test covering this case [here](https://github.com/root-project/root/blob/master/core/metacling/test/TClingCallFuncTests.cxx).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1731
https://github.com/root-project/root/pull/1731:124,safety,test,test,124,It'd be a good idea to add a test covering this case [here](https://github.com/root-project/root/blob/master/core/metacling/test/TClingCallFuncTests.cxx).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1731
https://github.com/root-project/root/pull/1731:29,testability,test,test,29,It'd be a good idea to add a test covering this case [here](https://github.com/root-project/root/blob/master/core/metacling/test/TClingCallFuncTests.cxx).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1731
https://github.com/root-project/root/pull/1731:124,testability,test,test,124,It'd be a good idea to add a test covering this case [here](https://github.com/root-project/root/blob/master/core/metacling/test/TClingCallFuncTests.cxx).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1731
https://github.com/root-project/root/pull/1731:51,modifiability,paramet,parameter,51,"Hi @vgvassilev, I added a test for the r-value ref parameter case, and @Axel-Naumann I changed the name for the enum value according to your comment.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1731
https://github.com/root-project/root/pull/1731:26,safety,test,test,26,"Hi @vgvassilev, I added a test for the r-value ref parameter case, and @Axel-Naumann I changed the name for the enum value according to your comment.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1731
https://github.com/root-project/root/pull/1731:26,testability,test,test,26,"Hi @vgvassilev, I added a test for the r-value ref parameter case, and @Axel-Naumann I changed the name for the enum value according to your comment.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1731
https://github.com/root-project/root/pull/1734:11,deployability,build,build,11,@phsft-bot build please,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1734
https://github.com/root-project/root/pull/1735:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1735
https://github.com/root-project/root/pull/1737:14,interoperability,format,format,14,Applied clang-format to each commit in last push...,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:469,availability,operat,operation,469,"With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. (In addition to the CPU cost of merging, this submit the calling thread to the latency in writing to a (potential remote) disk for example ; this would become even more apparent if we reduce further the CPU cost of the merging operation). Is that correct? Is there a way to re-add it? If not, shouldn't we provide an example?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:10,deployability,patch,patch,10,"With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. (In addition to the CPU cost of merging, this submit the calling thread to the latency in writing to a (potential remote) disk for example ; this would become even more apparent if we reduce further the CPU cost of the merging operation). Is that correct? Is there a way to re-add it? If not, shouldn't we provide an example?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:222,deployability,continu,continuing,222,"With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. (In addition to the CPU cost of merging, this submit the calling thread to the latency in writing to a (potential remote) disk for example ; this would become even more apparent if we reduce further the CPU cost of the merging operation). Is that correct? Is there a way to re-add it? If not, shouldn't we provide an example?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:262,energy efficiency,CPU,CPU,262,"With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. (In addition to the CPU cost of merging, this submit the calling thread to the latency in writing to a (potential remote) disk for example ; this would become even more apparent if we reduce further the CPU cost of the merging operation). Is that correct? Is there a way to re-add it? If not, shouldn't we provide an example?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:426,energy efficiency,reduc,reduce,426,"With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. (In addition to the CPU cost of merging, this submit the calling thread to the latency in writing to a (potential remote) disk for example ; this would become even more apparent if we reduce further the CPU cost of the merging operation). Is that correct? Is there a way to re-add it? If not, shouldn't we provide an example?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:445,energy efficiency,CPU,CPU,445,"With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. (In addition to the CPU cost of merging, this submit the calling thread to the latency in writing to a (potential remote) disk for example ; this would become even more apparent if we reduce further the CPU cost of the merging operation). Is that correct? Is there a way to re-add it? If not, shouldn't we provide an example?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:57,integrability,asynchron,asynchronous,57,"With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. (In addition to the CPU cost of merging, this submit the calling thread to the latency in writing to a (potential remote) disk for example ; this would become even more apparent if we reduce further the CPU cost of the merging operation). Is that correct? Is there a way to re-add it? If not, shouldn't we provide an example?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:288,integrability,sub,submit,288,"With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. (In addition to the CPU cost of merging, this submit the calling thread to the latency in writing to a (potential remote) disk for example ; this would become even more apparent if we reduce further the CPU cost of the merging operation). Is that correct? Is there a way to re-add it? If not, shouldn't we provide an example?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:57,performance,asynch,asynchronous,57,"With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. (In addition to the CPU cost of merging, this submit the calling thread to the latency in writing to a (potential remote) disk for example ; this would become even more apparent if we reduce further the CPU cost of the merging operation). Is that correct? Is there a way to re-add it? If not, shouldn't we provide an example?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:191,performance,parallel,parallel,191,"With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. (In addition to the CPU cost of merging, this submit the calling thread to the latency in writing to a (potential remote) disk for example ; this would become even more apparent if we reduce further the CPU cost of the merging operation). Is that correct? Is there a way to re-add it? If not, shouldn't we provide an example?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:262,performance,CPU,CPU,262,"With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. (In addition to the CPU cost of merging, this submit the calling thread to the latency in writing to a (potential remote) disk for example ; this would become even more apparent if we reduce further the CPU cost of the merging operation). Is that correct? Is there a way to re-add it? If not, shouldn't we provide an example?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:321,performance,latenc,latency,321,"With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. (In addition to the CPU cost of merging, this submit the calling thread to the latency in writing to a (potential remote) disk for example ; this would become even more apparent if we reduce further the CPU cost of the merging operation). Is that correct? Is there a way to re-add it? If not, shouldn't we provide an example?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:364,performance,disk,disk,364,"With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. (In addition to the CPU cost of merging, this submit the calling thread to the latency in writing to a (potential remote) disk for example ; this would become even more apparent if we reduce further the CPU cost of the merging operation). Is that correct? Is there a way to re-add it? If not, shouldn't we provide an example?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:445,performance,CPU,CPU,445,"With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. (In addition to the CPU cost of merging, this submit the calling thread to the latency in writing to a (potential remote) disk for example ; this would become even more apparent if we reduce further the CPU cost of the merging operation). Is that correct? Is there a way to re-add it? If not, shouldn't we provide an example?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:10,safety,patch,patch,10,"With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. (In addition to the CPU cost of merging, this submit the calling thread to the latency in writing to a (potential remote) disk for example ; this would become even more apparent if we reduce further the CPU cost of the merging operation). Is that correct? Is there a way to re-add it? If not, shouldn't we provide an example?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:10,security,patch,patch,10,"With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. (In addition to the CPU cost of merging, this submit the calling thread to the latency in writing to a (potential remote) disk for example ; this would become even more apparent if we reduce further the CPU cost of the merging operation). Is that correct? Is there a way to re-add it? If not, shouldn't we provide an example?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:46,usability,support,support,46,"With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. (In addition to the CPU cost of merging, this submit the calling thread to the latency in writing to a (potential remote) disk for example ; this would become even more apparent if we reduce further the CPU cost of the merging operation). Is that correct? Is there a way to re-add it? If not, shouldn't we provide an example?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:91,usability,user,user,91,"With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. (In addition to the CPU cost of merging, this submit the calling thread to the latency in writing to a (potential remote) disk for example ; this would become even more apparent if we reduce further the CPU cost of the merging operation). Is that correct? Is there a way to re-add it? If not, shouldn't we provide an example?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:321,usability,latenc,latency,321,"With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. (In addition to the CPU cost of merging, this submit the calling thread to the latency in writing to a (potential remote) disk for example ; this would become even more apparent if we reduce further the CPU cost of the merging operation). Is that correct? Is there a way to re-add it? If not, shouldn't we provide an example?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:592,availability,down,down,592,"> With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. Yes, now the merging is done by the worker threads/tasks themselves. This is necessary to avoid oversubscription, which happens if we launch the extra thread for merging. Only one worker will be ""blocked"" at a time, unless data production is faster than what the disk can take, in which case blocking the workers is good to keep memory consumption down instead of letting it growing it indefinitely. As is, this actually has improved slightly the performance for the same number of workers. I think that this is the best way to satisfy the requirement by CMS. I will measure performance again in several setups as a follow up to these changes.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:678,availability,sli,slightly,678,"> With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. Yes, now the merging is done by the worker threads/tasks themselves. This is necessary to avoid oversubscription, which happens if we launch the extra thread for merging. Only one worker will be ""blocked"" at a time, unless data production is faster than what the disk can take, in which case blocking the workers is good to keep memory consumption down instead of letting it growing it indefinitely. As is, this actually has improved slightly the performance for the same number of workers. I think that this is the best way to satisfy the requirement by CMS. I will measure performance again in several setups as a follow up to these changes.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:12,deployability,patch,patch,12,"> With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. Yes, now the merging is done by the worker threads/tasks themselves. This is necessary to avoid oversubscription, which happens if we launch the extra thread for merging. Only one worker will be ""blocked"" at a time, unless data production is faster than what the disk can take, in which case blocking the workers is good to keep memory consumption down instead of letting it growing it indefinitely. As is, this actually has improved slightly the performance for the same number of workers. I think that this is the best way to satisfy the requirement by CMS. I will measure performance again in several setups as a follow up to these changes.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:224,deployability,continu,continuing,224,"> With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. Yes, now the merging is done by the worker threads/tasks themselves. This is necessary to avoid oversubscription, which happens if we launch the extra thread for merging. Only one worker will be ""blocked"" at a time, unless data production is faster than what the disk can take, in which case blocking the workers is good to keep memory consumption down instead of letting it growing it indefinitely. As is, this actually has improved slightly the performance for the same number of workers. I think that this is the best way to satisfy the requirement by CMS. I will measure performance again in several setups as a follow up to these changes.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:811,energy efficiency,measur,measure,811,"> With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. Yes, now the merging is done by the worker threads/tasks themselves. This is necessary to avoid oversubscription, which happens if we launch the extra thread for merging. Only one worker will be ""blocked"" at a time, unless data production is faster than what the disk can take, in which case blocking the workers is good to keep memory consumption down instead of letting it growing it indefinitely. As is, this actually has improved slightly the performance for the same number of workers. I think that this is the best way to satisfy the requirement by CMS. I will measure performance again in several setups as a follow up to these changes.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:59,integrability,asynchron,asynchronous,59,"> With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. Yes, now the merging is done by the worker threads/tasks themselves. This is necessary to avoid oversubscription, which happens if we launch the extra thread for merging. Only one worker will be ""blocked"" at a time, unless data production is faster than what the disk can take, in which case blocking the workers is good to keep memory consumption down instead of letting it growing it indefinitely. As is, this actually has improved slightly the performance for the same number of workers. I think that this is the best way to satisfy the requirement by CMS. I will measure performance again in several setups as a follow up to these changes.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:59,performance,asynch,asynchronous,59,"> With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. Yes, now the merging is done by the worker threads/tasks themselves. This is necessary to avoid oversubscription, which happens if we launch the extra thread for merging. Only one worker will be ""blocked"" at a time, unless data production is faster than what the disk can take, in which case blocking the workers is good to keep memory consumption down instead of letting it growing it indefinitely. As is, this actually has improved slightly the performance for the same number of workers. I think that this is the best way to satisfy the requirement by CMS. I will measure performance again in several setups as a follow up to these changes.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:193,performance,parallel,parallel,193,"> With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. Yes, now the merging is done by the worker threads/tasks themselves. This is necessary to avoid oversubscription, which happens if we launch the extra thread for merging. Only one worker will be ""blocked"" at a time, unless data production is faster than what the disk can take, in which case blocking the workers is good to keep memory consumption down instead of letting it growing it indefinitely. As is, this actually has improved slightly the performance for the same number of workers. I think that this is the best way to satisfy the requirement by CMS. I will measure performance again in several setups as a follow up to these changes.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:454,performance,time,time,454,"> With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. Yes, now the merging is done by the worker threads/tasks themselves. This is necessary to avoid oversubscription, which happens if we launch the extra thread for merging. Only one worker will be ""blocked"" at a time, unless data production is faster than what the disk can take, in which case blocking the workers is good to keep memory consumption down instead of letting it growing it indefinitely. As is, this actually has improved slightly the performance for the same number of workers. I think that this is the best way to satisfy the requirement by CMS. I will measure performance again in several setups as a follow up to these changes.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:507,performance,disk,disk,507,"> With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. Yes, now the merging is done by the worker threads/tasks themselves. This is necessary to avoid oversubscription, which happens if we launch the extra thread for merging. Only one worker will be ""blocked"" at a time, unless data production is faster than what the disk can take, in which case blocking the workers is good to keep memory consumption down instead of letting it growing it indefinitely. As is, this actually has improved slightly the performance for the same number of workers. I think that this is the best way to satisfy the requirement by CMS. I will measure performance again in several setups as a follow up to these changes.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:573,performance,memor,memory,573,"> With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. Yes, now the merging is done by the worker threads/tasks themselves. This is necessary to avoid oversubscription, which happens if we launch the extra thread for merging. Only one worker will be ""blocked"" at a time, unless data production is faster than what the disk can take, in which case blocking the workers is good to keep memory consumption down instead of letting it growing it indefinitely. As is, this actually has improved slightly the performance for the same number of workers. I think that this is the best way to satisfy the requirement by CMS. I will measure performance again in several setups as a follow up to these changes.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:691,performance,perform,performance,691,"> With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. Yes, now the merging is done by the worker threads/tasks themselves. This is necessary to avoid oversubscription, which happens if we launch the extra thread for merging. Only one worker will be ""blocked"" at a time, unless data production is faster than what the disk can take, in which case blocking the workers is good to keep memory consumption down instead of letting it growing it indefinitely. As is, this actually has improved slightly the performance for the same number of workers. I think that this is the best way to satisfy the requirement by CMS. I will measure performance again in several setups as a follow up to these changes.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:819,performance,perform,performance,819,"> With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. Yes, now the merging is done by the worker threads/tasks themselves. This is necessary to avoid oversubscription, which happens if we launch the extra thread for merging. Only one worker will be ""blocked"" at a time, unless data production is faster than what the disk can take, in which case blocking the workers is good to keep memory consumption down instead of letting it growing it indefinitely. As is, this actually has improved slightly the performance for the same number of workers. I think that this is the best way to satisfy the requirement by CMS. I will measure performance again in several setups as a follow up to these changes.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:678,reliability,sli,slightly,678,"> With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. Yes, now the merging is done by the worker threads/tasks themselves. This is necessary to avoid oversubscription, which happens if we launch the extra thread for merging. Only one worker will be ""blocked"" at a time, unless data production is faster than what the disk can take, in which case blocking the workers is good to keep memory consumption down instead of letting it growing it indefinitely. As is, this actually has improved slightly the performance for the same number of workers. I think that this is the best way to satisfy the requirement by CMS. I will measure performance again in several setups as a follow up to these changes.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:12,safety,patch,patch,12,"> With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. Yes, now the merging is done by the worker threads/tasks themselves. This is necessary to avoid oversubscription, which happens if we launch the extra thread for merging. Only one worker will be ""blocked"" at a time, unless data production is faster than what the disk can take, in which case blocking the workers is good to keep memory consumption down instead of letting it growing it indefinitely. As is, this actually has improved slightly the performance for the same number of workers. I think that this is the best way to satisfy the requirement by CMS. I will measure performance again in several setups as a follow up to these changes.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:334,safety,avoid,avoid,334,"> With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. Yes, now the merging is done by the worker threads/tasks themselves. This is necessary to avoid oversubscription, which happens if we launch the extra thread for merging. Only one worker will be ""blocked"" at a time, unless data production is faster than what the disk can take, in which case blocking the workers is good to keep memory consumption down instead of letting it growing it indefinitely. As is, this actually has improved slightly the performance for the same number of workers. I think that this is the best way to satisfy the requirement by CMS. I will measure performance again in several setups as a follow up to these changes.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:12,security,patch,patch,12,"> With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. Yes, now the merging is done by the worker threads/tasks themselves. This is necessary to avoid oversubscription, which happens if we launch the extra thread for merging. Only one worker will be ""blocked"" at a time, unless data production is faster than what the disk can take, in which case blocking the workers is good to keep memory consumption down instead of letting it growing it indefinitely. As is, this actually has improved slightly the performance for the same number of workers. I think that this is the best way to satisfy the requirement by CMS. I will measure performance again in several setups as a follow up to these changes.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:48,usability,support,support,48,"> With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. Yes, now the merging is done by the worker threads/tasks themselves. This is necessary to avoid oversubscription, which happens if we launch the extra thread for merging. Only one worker will be ""blocked"" at a time, unless data production is faster than what the disk can take, in which case blocking the workers is good to keep memory consumption down instead of letting it growing it indefinitely. As is, this actually has improved slightly the performance for the same number of workers. I think that this is the best way to satisfy the requirement by CMS. I will measure performance again in several setups as a follow up to these changes.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:93,usability,user,user,93,"> With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. Yes, now the merging is done by the worker threads/tasks themselves. This is necessary to avoid oversubscription, which happens if we launch the extra thread for merging. Only one worker will be ""blocked"" at a time, unless data production is faster than what the disk can take, in which case blocking the workers is good to keep memory consumption down instead of letting it growing it indefinitely. As is, this actually has improved slightly the performance for the same number of workers. I think that this is the best way to satisfy the requirement by CMS. I will measure performance again in several setups as a follow up to these changes.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:573,usability,memor,memory,573,"> With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. Yes, now the merging is done by the worker threads/tasks themselves. This is necessary to avoid oversubscription, which happens if we launch the extra thread for merging. Only one worker will be ""blocked"" at a time, unless data production is faster than what the disk can take, in which case blocking the workers is good to keep memory consumption down instead of letting it growing it indefinitely. As is, this actually has improved slightly the performance for the same number of workers. I think that this is the best way to satisfy the requirement by CMS. I will measure performance again in several setups as a follow up to these changes.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:691,usability,perform,performance,691,"> With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. Yes, now the merging is done by the worker threads/tasks themselves. This is necessary to avoid oversubscription, which happens if we launch the extra thread for merging. Only one worker will be ""blocked"" at a time, unless data production is faster than what the disk can take, in which case blocking the workers is good to keep memory consumption down instead of letting it growing it indefinitely. As is, this actually has improved slightly the performance for the same number of workers. I think that this is the best way to satisfy the requirement by CMS. I will measure performance again in several setups as a follow up to these changes.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:819,usability,perform,performance,819,"> With this patch (as is), we seem to no longer support an asynchronous merging. I.e. if the user would like to have TBufferMerger::Push (always) return 'immediately' and have the work done in parallel of the pushing thread continuing to work. Yes, now the merging is done by the worker threads/tasks themselves. This is necessary to avoid oversubscription, which happens if we launch the extra thread for merging. Only one worker will be ""blocked"" at a time, unless data production is faster than what the disk can take, in which case blocking the workers is good to keep memory consumption down instead of letting it growing it indefinitely. As is, this actually has improved slightly the performance for the same number of workers. I think that this is the best way to satisfy the requirement by CMS. I will measure performance again in several setups as a follow up to these changes.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:98,availability,failur,failure,98,"Build went fine, just failed to fetch on the first try... It's a bug in the PR scripts to mark as failure when this happens. I will merge this.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:0,deployability,Build,Build,0,"Build went fine, just failed to fetch on the first try... It's a bug in the PR scripts to mark as failure when this happens. I will merge this.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:22,deployability,fail,failed,22,"Build went fine, just failed to fetch on the first try... It's a bug in the PR scripts to mark as failure when this happens. I will merge this.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:98,deployability,fail,failure,98,"Build went fine, just failed to fetch on the first try... It's a bug in the PR scripts to mark as failure when this happens. I will merge this.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:98,performance,failur,failure,98,"Build went fine, just failed to fetch on the first try... It's a bug in the PR scripts to mark as failure when this happens. I will merge this.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:22,reliability,fail,failed,22,"Build went fine, just failed to fetch on the first try... It's a bug in the PR scripts to mark as failure when this happens. I will merge this.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1737:98,reliability,fail,failure,98,"Build went fine, just failed to fetch on the first try... It's a bug in the PR scripts to mark as failure when this happens. I will merge this.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1737
https://github.com/root-project/root/pull/1738:80,interoperability,skeleton,skeleton,80,"Hi Sergey. I see you ""adjusted the new TLine"" class but not TText class ? TLine skeleton is inspired from TText. So I would have guessed that if you adjust TLine, TText should be adjusted too ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1738
https://github.com/root-project/root/pull/1741:26,deployability,build,build,26,The `gitcommit` target is build before `BaseTROOT` [here](https://github.com/root-project/root/pull/1741/files#diff-5f4a237561b8048385b3ba09ef74fc96L97).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1741
https://github.com/root-project/root/pull/1743:13,energy efficiency,load,loading,13,Removing the loading the list of function changes the semantic of the return value and indeed as Danilo points we need to understand *how* this routine (Cppyy::GetNumMethods) is used before knowing whether this is the best improvement.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:144,integrability,rout,routine,144,Removing the loading the list of function changes the semantic of the return value and indeed as Danilo points we need to understand *how* this routine (Cppyy::GetNumMethods) is used before knowing whether this is the best improvement.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:54,interoperability,semant,semantic,54,Removing the loading the list of function changes the semantic of the return value and indeed as Danilo points we need to understand *how* this routine (Cppyy::GetNumMethods) is used before knowing whether this is the best improvement.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:13,performance,load,loading,13,Removing the loading the list of function changes the semantic of the return value and indeed as Danilo points we need to understand *how* this routine (Cppyy::GetNumMethods) is used before knowing whether this is the best improvement.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:122,testability,understand,understand,122,Removing the loading the list of function changes the semantic of the return value and indeed as Danilo points we need to understand *how* this routine (Cppyy::GetNumMethods) is used before knowing whether this is the best improvement.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:111,energy efficiency,load,loads,111,"humm .. actually since GetNmethods calls GetListOfMethods with the default value for the parameter (kTRUE), it loads of the functions anyway. So I was wrong there is no semantic change :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:169,interoperability,semant,semantic,169,"humm .. actually since GetNmethods calls GetListOfMethods with the default value for the parameter (kTRUE), it loads of the functions anyway. So I was wrong there is no semantic change :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:89,modifiability,paramet,parameter,89,"humm .. actually since GetNmethods calls GetListOfMethods with the default value for the parameter (kTRUE), it loads of the functions anyway. So I was wrong there is no semantic change :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:111,performance,load,loads,111,"humm .. actually since GetNmethods calls GetListOfMethods with the default value for the parameter (kTRUE), it loads of the functions anyway. So I was wrong there is no semantic change :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:15,safety,avoid,avoid,15,I think we can avoid requiring the method count. I will discuss with Yuka offline and we will let you know.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:191,integrability,rout,routine,191,"> Yeah GetNmethods calls GetListOfMethods :) It would be nice if we don't have to make a list of methods just because we want to get the number.. Strictly speaking this is not the case. This routine is used twice in the code and both time it is used as the barrier in a for loop over the method. So indeed, those two loop might be better off being rewritten to use iterators instead of index, however lifting the need for the iteration through the method is another thing entirely.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:234,performance,time,time,234,"> Yeah GetNmethods calls GetListOfMethods :) It would be nice if we don't have to make a list of methods just because we want to get the number.. Strictly speaking this is not the case. This routine is used twice in the code and both time it is used as the barrier in a for loop over the method. So indeed, those two loop might be better off being rewritten to use iterators instead of index, however lifting the need for the iteration through the method is another thing entirely.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:257,security,barrier,barrier,257,"> Yeah GetNmethods calls GetListOfMethods :) It would be nice if we don't have to make a list of methods just because we want to get the number.. Strictly speaking this is not the case. This routine is used twice in the code and both time it is used as the barrier in a for loop over the method. So indeed, those two loop might be better off being rewritten to use iterators instead of index, however lifting the need for the iteration through the method is another thing entirely.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:97,energy efficiency,Current,Currently,97,"So what we want to do is *Remove using GetListOfMethods(kTRUE), because it involves iterations*. Currently GetNmethods is calling GetListOfMethods internally, but we would like to change the implementation of GetNmethods not to use GetListOfMethods soonish.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:97,energy efficiency,Current,Currently,97,"> So what we want to do is Remove using GetListOfMethods(kTRUE), because it involves iterations. Currently GetNmethods is calling GetListOfMethods internally, but we would like to change the implementation of GetNmethods not to use GetListOfMethods soonish. But given that GetNmethod is (almost) always use by code that iterate through the list, I do not see the gain (i.e. shouldn't we first look if the iteration (that uses GetNmethods) can (semantically) be removed?).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:444,interoperability,semant,semantically,444,"> So what we want to do is Remove using GetListOfMethods(kTRUE), because it involves iterations. Currently GetNmethods is calling GetListOfMethods internally, but we would like to change the implementation of GetNmethods not to use GetListOfMethods soonish. But given that GetNmethod is (almost) always use by code that iterate through the list, I do not see the gain (i.e. shouldn't we first look if the iteration (that uses GetNmethods) can (semantically) be removed?).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:5,energy efficiency,core,core,5,```. core/meta/inc/TClass.h. std::atomic<TListOfFunctions*> fMethod; //linked list for methods . TViewPubDataMembers*fAllPubData; //all public data members (including from base classes). TViewPubFunctions *fAllPubMethod; //all public methods (including from base classes). mutable TList *fClassMenuList; //list of class menu items. ... ```. I guessed it means fMethod already has list for methods,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:136,integrability,pub,public,136,```. core/meta/inc/TClass.h. std::atomic<TListOfFunctions*> fMethod; //linked list for methods . TViewPubDataMembers*fAllPubData; //all public data members (including from base classes). TViewPubFunctions *fAllPubMethod; //all public methods (including from base classes). mutable TList *fClassMenuList; //list of class menu items. ... ```. I guessed it means fMethod already has list for methods,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:227,integrability,pub,public,227,```. core/meta/inc/TClass.h. std::atomic<TListOfFunctions*> fMethod; //linked list for methods . TViewPubDataMembers*fAllPubData; //all public data members (including from base classes). TViewPubFunctions *fAllPubMethod; //all public methods (including from base classes). mutable TList *fClassMenuList; //list of class menu items. ... ```. I guessed it means fMethod already has list for methods,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:320,usability,menu,menu,320,```. core/meta/inc/TClass.h. std::atomic<TListOfFunctions*> fMethod; //linked list for methods . TViewPubDataMembers*fAllPubData; //all public data members (including from base classes). TViewPubFunctions *fAllPubMethod; //all public methods (including from base classes). mutable TList *fClassMenuList; //list of class menu items. ... ```. I guessed it means fMethod already has list for methods,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:165,energy efficiency,load,loaded,165,> I guessed it means fMethod already has list for methods. That is its purpose but the content is brought it only on demand (i.e. if the user ask for the list to be loaded).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:87,performance,content,content,87,> I guessed it means fMethod already has list for methods. That is its purpose but the content is brought it only on demand (i.e. if the user ask for the list to be loaded).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:165,performance,load,loaded,165,> I guessed it means fMethod already has list for methods. That is its purpose but the content is brought it only on demand (i.e. if the user ask for the list to be loaded).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:137,usability,user,user,137,> I guessed it means fMethod already has list for methods. That is its purpose but the content is brought it only on demand (i.e. if the user ask for the list to be loaded).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:147,reliability,doe,doesn,147,"https://gist.github.com/yamaguchi1024/cab4db2ec5f479837ddde54943ea0ec3. We can do something like this and try not to invoke this with true, but it doesn't solve any problems. Ideally we want to remove all methods like this (GetNmethods, GetListOfMethods, GetListOf... ) so we don't have to worry about iterations. However there are many codes in ROOT which are relying onto these methods, so I'm looking for somewhere middle...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:433,availability,operat,operations,433,"> We can do something like this and try not to invoke this with true, but it doesn't solve any problems. . I agree that it does not solve the problem as the user that invokes this function is likely to want to be informed about **all** methods and so would call it always with ""load==true"". > Ideally we want to remove all methods like this (GetNmethods, GetListOfMethods, GetListOf... ) . I disagree that we should. Those are valid operations that are have no possible replacement; for example when wanting to print to the screen the list of all methods. What we need to do is to look at their **usage** and see if they can be replaced by something else (for example when an iteration through the methods can be replaced by a lookup). Note that in the case of the code in binding/pyroot, you would first discuss with @etejedor as this code may soon be replaced by a new version/implementation that has different characteristics.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:871,deployability,version,version,871,"> We can do something like this and try not to invoke this with true, but it doesn't solve any problems. . I agree that it does not solve the problem as the user that invokes this function is likely to want to be informed about **all** methods and so would call it always with ""load==true"". > Ideally we want to remove all methods like this (GetNmethods, GetListOfMethods, GetListOf... ) . I disagree that we should. Those are valid operations that are have no possible replacement; for example when wanting to print to the screen the list of all methods. What we need to do is to look at their **usage** and see if they can be replaced by something else (for example when an iteration through the methods can be replaced by a lookup). Note that in the case of the code in binding/pyroot, you would first discuss with @etejedor as this code may soon be replaced by a new version/implementation that has different characteristics.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:278,energy efficiency,load,load,278,"> We can do something like this and try not to invoke this with true, but it doesn't solve any problems. . I agree that it does not solve the problem as the user that invokes this function is likely to want to be informed about **all** methods and so would call it always with ""load==true"". > Ideally we want to remove all methods like this (GetNmethods, GetListOfMethods, GetListOf... ) . I disagree that we should. Those are valid operations that are have no possible replacement; for example when wanting to print to the screen the list of all methods. What we need to do is to look at their **usage** and see if they can be replaced by something else (for example when an iteration through the methods can be replaced by a lookup). Note that in the case of the code in binding/pyroot, you would first discuss with @etejedor as this code may soon be replaced by a new version/implementation that has different characteristics.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:871,integrability,version,version,871,"> We can do something like this and try not to invoke this with true, but it doesn't solve any problems. . I agree that it does not solve the problem as the user that invokes this function is likely to want to be informed about **all** methods and so would call it always with ""load==true"". > Ideally we want to remove all methods like this (GetNmethods, GetListOfMethods, GetListOf... ) . I disagree that we should. Those are valid operations that are have no possible replacement; for example when wanting to print to the screen the list of all methods. What we need to do is to look at their **usage** and see if they can be replaced by something else (for example when an iteration through the methods can be replaced by a lookup). Note that in the case of the code in binding/pyroot, you would first discuss with @etejedor as this code may soon be replaced by a new version/implementation that has different characteristics.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:773,interoperability,bind,binding,773,"> We can do something like this and try not to invoke this with true, but it doesn't solve any problems. . I agree that it does not solve the problem as the user that invokes this function is likely to want to be informed about **all** methods and so would call it always with ""load==true"". > Ideally we want to remove all methods like this (GetNmethods, GetListOfMethods, GetListOf... ) . I disagree that we should. Those are valid operations that are have no possible replacement; for example when wanting to print to the screen the list of all methods. What we need to do is to look at their **usage** and see if they can be replaced by something else (for example when an iteration through the methods can be replaced by a lookup). Note that in the case of the code in binding/pyroot, you would first discuss with @etejedor as this code may soon be replaced by a new version/implementation that has different characteristics.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:773,modifiability,bind,binding,773,"> We can do something like this and try not to invoke this with true, but it doesn't solve any problems. . I agree that it does not solve the problem as the user that invokes this function is likely to want to be informed about **all** methods and so would call it always with ""load==true"". > Ideally we want to remove all methods like this (GetNmethods, GetListOfMethods, GetListOf... ) . I disagree that we should. Those are valid operations that are have no possible replacement; for example when wanting to print to the screen the list of all methods. What we need to do is to look at their **usage** and see if they can be replaced by something else (for example when an iteration through the methods can be replaced by a lookup). Note that in the case of the code in binding/pyroot, you would first discuss with @etejedor as this code may soon be replaced by a new version/implementation that has different characteristics.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:871,modifiability,version,version,871,"> We can do something like this and try not to invoke this with true, but it doesn't solve any problems. . I agree that it does not solve the problem as the user that invokes this function is likely to want to be informed about **all** methods and so would call it always with ""load==true"". > Ideally we want to remove all methods like this (GetNmethods, GetListOfMethods, GetListOf... ) . I disagree that we should. Those are valid operations that are have no possible replacement; for example when wanting to print to the screen the list of all methods. What we need to do is to look at their **usage** and see if they can be replaced by something else (for example when an iteration through the methods can be replaced by a lookup). Note that in the case of the code in binding/pyroot, you would first discuss with @etejedor as this code may soon be replaced by a new version/implementation that has different characteristics.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:278,performance,load,load,278,"> We can do something like this and try not to invoke this with true, but it doesn't solve any problems. . I agree that it does not solve the problem as the user that invokes this function is likely to want to be informed about **all** methods and so would call it always with ""load==true"". > Ideally we want to remove all methods like this (GetNmethods, GetListOfMethods, GetListOf... ) . I disagree that we should. Those are valid operations that are have no possible replacement; for example when wanting to print to the screen the list of all methods. What we need to do is to look at their **usage** and see if they can be replaced by something else (for example when an iteration through the methods can be replaced by a lookup). Note that in the case of the code in binding/pyroot, you would first discuss with @etejedor as this code may soon be replaced by a new version/implementation that has different characteristics.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:77,reliability,doe,doesn,77,"> We can do something like this and try not to invoke this with true, but it doesn't solve any problems. . I agree that it does not solve the problem as the user that invokes this function is likely to want to be informed about **all** methods and so would call it always with ""load==true"". > Ideally we want to remove all methods like this (GetNmethods, GetListOfMethods, GetListOf... ) . I disagree that we should. Those are valid operations that are have no possible replacement; for example when wanting to print to the screen the list of all methods. What we need to do is to look at their **usage** and see if they can be replaced by something else (for example when an iteration through the methods can be replaced by a lookup). Note that in the case of the code in binding/pyroot, you would first discuss with @etejedor as this code may soon be replaced by a new version/implementation that has different characteristics.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:123,reliability,doe,does,123,"> We can do something like this and try not to invoke this with true, but it doesn't solve any problems. . I agree that it does not solve the problem as the user that invokes this function is likely to want to be informed about **all** methods and so would call it always with ""load==true"". > Ideally we want to remove all methods like this (GetNmethods, GetListOfMethods, GetListOf... ) . I disagree that we should. Those are valid operations that are have no possible replacement; for example when wanting to print to the screen the list of all methods. What we need to do is to look at their **usage** and see if they can be replaced by something else (for example when an iteration through the methods can be replaced by a lookup). Note that in the case of the code in binding/pyroot, you would first discuss with @etejedor as this code may soon be replaced by a new version/implementation that has different characteristics.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:427,safety,valid,valid,427,"> We can do something like this and try not to invoke this with true, but it doesn't solve any problems. . I agree that it does not solve the problem as the user that invokes this function is likely to want to be informed about **all** methods and so would call it always with ""load==true"". > Ideally we want to remove all methods like this (GetNmethods, GetListOfMethods, GetListOf... ) . I disagree that we should. Those are valid operations that are have no possible replacement; for example when wanting to print to the screen the list of all methods. What we need to do is to look at their **usage** and see if they can be replaced by something else (for example when an iteration through the methods can be replaced by a lookup). Note that in the case of the code in binding/pyroot, you would first discuss with @etejedor as this code may soon be replaced by a new version/implementation that has different characteristics.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:157,usability,user,user,157,"> We can do something like this and try not to invoke this with true, but it doesn't solve any problems. . I agree that it does not solve the problem as the user that invokes this function is likely to want to be informed about **all** methods and so would call it always with ""load==true"". > Ideally we want to remove all methods like this (GetNmethods, GetListOfMethods, GetListOf... ) . I disagree that we should. Those are valid operations that are have no possible replacement; for example when wanting to print to the screen the list of all methods. What we need to do is to look at their **usage** and see if they can be replaced by something else (for example when an iteration through the methods can be replaced by a lookup). Note that in the case of the code in binding/pyroot, you would first discuss with @etejedor as this code may soon be replaced by a new version/implementation that has different characteristics.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:243,energy efficiency,optim,optimization,243,"I've checked the code of `Cppyy::GetNumMethods` in Wim's Cppyy and it is equivalent to what we have now in PyROOT. Although it is true that we might merge with Cppyy in the end, it seems that both Cppyy and PyROOT can benefit from the kind of optimization that is proposed in this PR. Ideally, Wim should be aware of these optimizations and incorporate them also in Cppyy, so that we don't lose them if the merge happens.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:323,energy efficiency,optim,optimizations,323,"I've checked the code of `Cppyy::GetNumMethods` in Wim's Cppyy and it is equivalent to what we have now in PyROOT. Although it is true that we might merge with Cppyy in the end, it seems that both Cppyy and PyROOT can benefit from the kind of optimization that is proposed in this PR. Ideally, Wim should be aware of these optimizations and incorporate them also in Cppyy, so that we don't lose them if the merge happens.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:243,performance,optimiz,optimization,243,"I've checked the code of `Cppyy::GetNumMethods` in Wim's Cppyy and it is equivalent to what we have now in PyROOT. Although it is true that we might merge with Cppyy in the end, it seems that both Cppyy and PyROOT can benefit from the kind of optimization that is proposed in this PR. Ideally, Wim should be aware of these optimizations and incorporate them also in Cppyy, so that we don't lose them if the merge happens.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:323,performance,optimiz,optimizations,323,"I've checked the code of `Cppyy::GetNumMethods` in Wim's Cppyy and it is equivalent to what we have now in PyROOT. Although it is true that we might merge with Cppyy in the end, it seems that both Cppyy and PyROOT can benefit from the kind of optimization that is proposed in this PR. Ideally, Wim should be aware of these optimizations and incorporate them also in Cppyy, so that we don't lose them if the merge happens.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:166,performance,perform,performance,166,https://gist.github.com/yamaguchi1024/95f332222e74f2168df0d452cb2b463f. How about remembering the number of methods in TClassRef? I don't know if this will solve the performance problem but at least we don't have to iterate on same classes.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:82,safety,reme,remembering,82,https://gist.github.com/yamaguchi1024/95f332222e74f2168df0d452cb2b463f. How about remembering the number of methods in TClassRef? I don't know if this will solve the performance problem but at least we don't have to iterate on same classes.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:166,usability,perform,performance,166,https://gist.github.com/yamaguchi1024/95f332222e74f2168df0d452cb2b463f. How about remembering the number of methods in TClassRef? I don't know if this will solve the performance problem but at least we don't have to iterate on same classes.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:432,energy efficiency,optim,optimizing,432,> How about remembering the number of methods in TClassRef? I don't know if this will solve the performance problem but at least we don't have to iterate on same classes. I am a bit lost .... What performance problem are we addressing here? [i.e. as far as I can tell most time the number of methods is accessed this is followed by an iteration over all methods]. Can you be more specific on which (part of which) benchmark you are optimizing and how much this change would improve the run-time of this benchmark?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:380,interoperability,specif,specific,380,> How about remembering the number of methods in TClassRef? I don't know if this will solve the performance problem but at least we don't have to iterate on same classes. I am a bit lost .... What performance problem are we addressing here? [i.e. as far as I can tell most time the number of methods is accessed this is followed by an iteration over all methods]. Can you be more specific on which (part of which) benchmark you are optimizing and how much this change would improve the run-time of this benchmark?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:96,performance,perform,performance,96,> How about remembering the number of methods in TClassRef? I don't know if this will solve the performance problem but at least we don't have to iterate on same classes. I am a bit lost .... What performance problem are we addressing here? [i.e. as far as I can tell most time the number of methods is accessed this is followed by an iteration over all methods]. Can you be more specific on which (part of which) benchmark you are optimizing and how much this change would improve the run-time of this benchmark?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:197,performance,perform,performance,197,> How about remembering the number of methods in TClassRef? I don't know if this will solve the performance problem but at least we don't have to iterate on same classes. I am a bit lost .... What performance problem are we addressing here? [i.e. as far as I can tell most time the number of methods is accessed this is followed by an iteration over all methods]. Can you be more specific on which (part of which) benchmark you are optimizing and how much this change would improve the run-time of this benchmark?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:273,performance,time,time,273,> How about remembering the number of methods in TClassRef? I don't know if this will solve the performance problem but at least we don't have to iterate on same classes. I am a bit lost .... What performance problem are we addressing here? [i.e. as far as I can tell most time the number of methods is accessed this is followed by an iteration over all methods]. Can you be more specific on which (part of which) benchmark you are optimizing and how much this change would improve the run-time of this benchmark?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:432,performance,optimiz,optimizing,432,> How about remembering the number of methods in TClassRef? I don't know if this will solve the performance problem but at least we don't have to iterate on same classes. I am a bit lost .... What performance problem are we addressing here? [i.e. as far as I can tell most time the number of methods is accessed this is followed by an iteration over all methods]. Can you be more specific on which (part of which) benchmark you are optimizing and how much this change would improve the run-time of this benchmark?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:490,performance,time,time,490,> How about remembering the number of methods in TClassRef? I don't know if this will solve the performance problem but at least we don't have to iterate on same classes. I am a bit lost .... What performance problem are we addressing here? [i.e. as far as I can tell most time the number of methods is accessed this is followed by an iteration over all methods]. Can you be more specific on which (part of which) benchmark you are optimizing and how much this change would improve the run-time of this benchmark?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:12,safety,reme,remembering,12,> How about remembering the number of methods in TClassRef? I don't know if this will solve the performance problem but at least we don't have to iterate on same classes. I am a bit lost .... What performance problem are we addressing here? [i.e. as far as I can tell most time the number of methods is accessed this is followed by an iteration over all methods]. Can you be more specific on which (part of which) benchmark you are optimizing and how much this change would improve the run-time of this benchmark?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:303,security,access,accessed,303,> How about remembering the number of methods in TClassRef? I don't know if this will solve the performance problem but at least we don't have to iterate on same classes. I am a bit lost .... What performance problem are we addressing here? [i.e. as far as I can tell most time the number of methods is accessed this is followed by an iteration over all methods]. Can you be more specific on which (part of which) benchmark you are optimizing and how much this change would improve the run-time of this benchmark?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:96,usability,perform,performance,96,> How about remembering the number of methods in TClassRef? I don't know if this will solve the performance problem but at least we don't have to iterate on same classes. I am a bit lost .... What performance problem are we addressing here? [i.e. as far as I can tell most time the number of methods is accessed this is followed by an iteration over all methods]. Can you be more specific on which (part of which) benchmark you are optimizing and how much this change would improve the run-time of this benchmark?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:197,usability,perform,performance,197,> How about remembering the number of methods in TClassRef? I don't know if this will solve the performance problem but at least we don't have to iterate on same classes. I am a bit lost .... What performance problem are we addressing here? [i.e. as far as I can tell most time the number of methods is accessed this is followed by an iteration over all methods]. Can you be more specific on which (part of which) benchmark you are optimizing and how much this change would improve the run-time of this benchmark?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:152,energy efficiency,optim,optimize,152,"I thought it's unavoidable to iterate over methods at first, so it might be a little help to remember the number of methods in TClassRef. I'm trying to optimize memory (and also cpu time) by removing iterations as possible, and I thought remembering the method number help reduce calling GetListOfMethods(true)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:178,energy efficiency,cpu,cpu,178,"I thought it's unavoidable to iterate over methods at first, so it might be a little help to remember the number of methods in TClassRef. I'm trying to optimize memory (and also cpu time) by removing iterations as possible, and I thought remembering the method number help reduce calling GetListOfMethods(true)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:273,energy efficiency,reduc,reduce,273,"I thought it's unavoidable to iterate over methods at first, so it might be a little help to remember the number of methods in TClassRef. I'm trying to optimize memory (and also cpu time) by removing iterations as possible, and I thought remembering the method number help reduce calling GetListOfMethods(true)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:152,performance,optimiz,optimize,152,"I thought it's unavoidable to iterate over methods at first, so it might be a little help to remember the number of methods in TClassRef. I'm trying to optimize memory (and also cpu time) by removing iterations as possible, and I thought remembering the method number help reduce calling GetListOfMethods(true)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:161,performance,memor,memory,161,"I thought it's unavoidable to iterate over methods at first, so it might be a little help to remember the number of methods in TClassRef. I'm trying to optimize memory (and also cpu time) by removing iterations as possible, and I thought remembering the method number help reduce calling GetListOfMethods(true)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:178,performance,cpu,cpu,178,"I thought it's unavoidable to iterate over methods at first, so it might be a little help to remember the number of methods in TClassRef. I'm trying to optimize memory (and also cpu time) by removing iterations as possible, and I thought remembering the method number help reduce calling GetListOfMethods(true)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:182,performance,time,time,182,"I thought it's unavoidable to iterate over methods at first, so it might be a little help to remember the number of methods in TClassRef. I'm trying to optimize memory (and also cpu time) by removing iterations as possible, and I thought remembering the method number help reduce calling GetListOfMethods(true)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:93,safety,reme,remember,93,"I thought it's unavoidable to iterate over methods at first, so it might be a little help to remember the number of methods in TClassRef. I'm trying to optimize memory (and also cpu time) by removing iterations as possible, and I thought remembering the method number help reduce calling GetListOfMethods(true)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:238,safety,reme,remembering,238,"I thought it's unavoidable to iterate over methods at first, so it might be a little help to remember the number of methods in TClassRef. I'm trying to optimize memory (and also cpu time) by removing iterations as possible, and I thought remembering the method number help reduce calling GetListOfMethods(true)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:85,usability,help,help,85,"I thought it's unavoidable to iterate over methods at first, so it might be a little help to remember the number of methods in TClassRef. I'm trying to optimize memory (and also cpu time) by removing iterations as possible, and I thought remembering the method number help reduce calling GetListOfMethods(true)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:161,usability,memor,memory,161,"I thought it's unavoidable to iterate over methods at first, so it might be a little help to remember the number of methods in TClassRef. I'm trying to optimize memory (and also cpu time) by removing iterations as possible, and I thought remembering the method number help reduce calling GetListOfMethods(true)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:268,usability,help,help,268,"I thought it's unavoidable to iterate over methods at first, so it might be a little help to remember the number of methods in TClassRef. I'm trying to optimize memory (and also cpu time) by removing iterations as possible, and I thought remembering the method number help reduce calling GetListOfMethods(true)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:64,energy efficiency,optim,optimize,64,> to remember the number of methods in TClassRef. I'm trying to optimize memory . TClassRef is supposed to be a light weight object (a smart pointer) which might be duplicated many times. Increasing the size of this object would unnecessarily increased the memory consumption by a little bit in many places. I also do not see the point of caching the value there since it is *already* cached in the list itself (i.e. doing GetListOfMethods(kFALSE)->GetEntries() would cost 'only' the cost of the two functions calls to retrieve whatever was the 'previous' value of the number of methods).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:64,performance,optimiz,optimize,64,> to remember the number of methods in TClassRef. I'm trying to optimize memory . TClassRef is supposed to be a light weight object (a smart pointer) which might be duplicated many times. Increasing the size of this object would unnecessarily increased the memory consumption by a little bit in many places. I also do not see the point of caching the value there since it is *already* cached in the list itself (i.e. doing GetListOfMethods(kFALSE)->GetEntries() would cost 'only' the cost of the two functions calls to retrieve whatever was the 'previous' value of the number of methods).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:73,performance,memor,memory,73,> to remember the number of methods in TClassRef. I'm trying to optimize memory . TClassRef is supposed to be a light weight object (a smart pointer) which might be duplicated many times. Increasing the size of this object would unnecessarily increased the memory consumption by a little bit in many places. I also do not see the point of caching the value there since it is *already* cached in the list itself (i.e. doing GetListOfMethods(kFALSE)->GetEntries() would cost 'only' the cost of the two functions calls to retrieve whatever was the 'previous' value of the number of methods).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:181,performance,time,times,181,> to remember the number of methods in TClassRef. I'm trying to optimize memory . TClassRef is supposed to be a light weight object (a smart pointer) which might be duplicated many times. Increasing the size of this object would unnecessarily increased the memory consumption by a little bit in many places. I also do not see the point of caching the value there since it is *already* cached in the list itself (i.e. doing GetListOfMethods(kFALSE)->GetEntries() would cost 'only' the cost of the two functions calls to retrieve whatever was the 'previous' value of the number of methods).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:257,performance,memor,memory,257,> to remember the number of methods in TClassRef. I'm trying to optimize memory . TClassRef is supposed to be a light weight object (a smart pointer) which might be duplicated many times. Increasing the size of this object would unnecessarily increased the memory consumption by a little bit in many places. I also do not see the point of caching the value there since it is *already* cached in the list itself (i.e. doing GetListOfMethods(kFALSE)->GetEntries() would cost 'only' the cost of the two functions calls to retrieve whatever was the 'previous' value of the number of methods).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:339,performance,cach,caching,339,> to remember the number of methods in TClassRef. I'm trying to optimize memory . TClassRef is supposed to be a light weight object (a smart pointer) which might be duplicated many times. Increasing the size of this object would unnecessarily increased the memory consumption by a little bit in many places. I also do not see the point of caching the value there since it is *already* cached in the list itself (i.e. doing GetListOfMethods(kFALSE)->GetEntries() would cost 'only' the cost of the two functions calls to retrieve whatever was the 'previous' value of the number of methods).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:385,performance,cach,cached,385,> to remember the number of methods in TClassRef. I'm trying to optimize memory . TClassRef is supposed to be a light weight object (a smart pointer) which might be duplicated many times. Increasing the size of this object would unnecessarily increased the memory consumption by a little bit in many places. I also do not see the point of caching the value there since it is *already* cached in the list itself (i.e. doing GetListOfMethods(kFALSE)->GetEntries() would cost 'only' the cost of the two functions calls to retrieve whatever was the 'previous' value of the number of methods).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:5,safety,reme,remember,5,> to remember the number of methods in TClassRef. I'm trying to optimize memory . TClassRef is supposed to be a light weight object (a smart pointer) which might be duplicated many times. Increasing the size of this object would unnecessarily increased the memory consumption by a little bit in many places. I also do not see the point of caching the value there since it is *already* cached in the list itself (i.e. doing GetListOfMethods(kFALSE)->GetEntries() would cost 'only' the cost of the two functions calls to retrieve whatever was the 'previous' value of the number of methods).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:73,usability,memor,memory,73,> to remember the number of methods in TClassRef. I'm trying to optimize memory . TClassRef is supposed to be a light weight object (a smart pointer) which might be duplicated many times. Increasing the size of this object would unnecessarily increased the memory consumption by a little bit in many places. I also do not see the point of caching the value there since it is *already* cached in the list itself (i.e. doing GetListOfMethods(kFALSE)->GetEntries() would cost 'only' the cost of the two functions calls to retrieve whatever was the 'previous' value of the number of methods).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:257,usability,memor,memory,257,> to remember the number of methods in TClassRef. I'm trying to optimize memory . TClassRef is supposed to be a light weight object (a smart pointer) which might be duplicated many times. Increasing the size of this object would unnecessarily increased the memory consumption by a little bit in many places. I also do not see the point of caching the value there since it is *already* cached in the list itself (i.e. doing GetListOfMethods(kFALSE)->GetEntries() would cost 'only' the cost of the two functions calls to retrieve whatever was the 'previous' value of the number of methods).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:65,energy efficiency,profil,profiled,65,"(I always post a comment before I see your latest comment...). I profiled pyroot few days ago and found `LookupCppEntity` is a hot function, and this is calling `CreateScopeProxy`, which is calling `Cppyy::GetNumMethods`. So I thought optimizing this part of code really make sense. . > also do not see the point of caching the value there since it is already cached in the list itself . Hmm but GetNumMethods is calling TClass::GetNmethods, which is invoking GetListOfMethods like this:. ```. 4385 Int_t TClass::GetNmethods() . 4386 {. 4387 if (!HasInterpreterInfo()) return 0;. 4388 . 4389 TList *lm = GetListOfMethods();. 4390 if (lm). 4391 return lm->GetSize();. 4392 else. 4393 return 0;. 4394 }. ```. Looks to me it's invoking GetListOfMethods(true) (because default is true) but are we using the cache you mentioned to make GetNumMethods?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:235,energy efficiency,optim,optimizing,235,"(I always post a comment before I see your latest comment...). I profiled pyroot few days ago and found `LookupCppEntity` is a hot function, and this is calling `CreateScopeProxy`, which is calling `Cppyy::GetNumMethods`. So I thought optimizing this part of code really make sense. . > also do not see the point of caching the value there since it is already cached in the list itself . Hmm but GetNumMethods is calling TClass::GetNmethods, which is invoking GetListOfMethods like this:. ```. 4385 Int_t TClass::GetNmethods() . 4386 {. 4387 if (!HasInterpreterInfo()) return 0;. 4388 . 4389 TList *lm = GetListOfMethods();. 4390 if (lm). 4391 return lm->GetSize();. 4392 else. 4393 return 0;. 4394 }. ```. Looks to me it's invoking GetListOfMethods(true) (because default is true) but are we using the cache you mentioned to make GetNumMethods?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:65,performance,profil,profiled,65,"(I always post a comment before I see your latest comment...). I profiled pyroot few days ago and found `LookupCppEntity` is a hot function, and this is calling `CreateScopeProxy`, which is calling `Cppyy::GetNumMethods`. So I thought optimizing this part of code really make sense. . > also do not see the point of caching the value there since it is already cached in the list itself . Hmm but GetNumMethods is calling TClass::GetNmethods, which is invoking GetListOfMethods like this:. ```. 4385 Int_t TClass::GetNmethods() . 4386 {. 4387 if (!HasInterpreterInfo()) return 0;. 4388 . 4389 TList *lm = GetListOfMethods();. 4390 if (lm). 4391 return lm->GetSize();. 4392 else. 4393 return 0;. 4394 }. ```. Looks to me it's invoking GetListOfMethods(true) (because default is true) but are we using the cache you mentioned to make GetNumMethods?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:235,performance,optimiz,optimizing,235,"(I always post a comment before I see your latest comment...). I profiled pyroot few days ago and found `LookupCppEntity` is a hot function, and this is calling `CreateScopeProxy`, which is calling `Cppyy::GetNumMethods`. So I thought optimizing this part of code really make sense. . > also do not see the point of caching the value there since it is already cached in the list itself . Hmm but GetNumMethods is calling TClass::GetNmethods, which is invoking GetListOfMethods like this:. ```. 4385 Int_t TClass::GetNmethods() . 4386 {. 4387 if (!HasInterpreterInfo()) return 0;. 4388 . 4389 TList *lm = GetListOfMethods();. 4390 if (lm). 4391 return lm->GetSize();. 4392 else. 4393 return 0;. 4394 }. ```. Looks to me it's invoking GetListOfMethods(true) (because default is true) but are we using the cache you mentioned to make GetNumMethods?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:316,performance,cach,caching,316,"(I always post a comment before I see your latest comment...). I profiled pyroot few days ago and found `LookupCppEntity` is a hot function, and this is calling `CreateScopeProxy`, which is calling `Cppyy::GetNumMethods`. So I thought optimizing this part of code really make sense. . > also do not see the point of caching the value there since it is already cached in the list itself . Hmm but GetNumMethods is calling TClass::GetNmethods, which is invoking GetListOfMethods like this:. ```. 4385 Int_t TClass::GetNmethods() . 4386 {. 4387 if (!HasInterpreterInfo()) return 0;. 4388 . 4389 TList *lm = GetListOfMethods();. 4390 if (lm). 4391 return lm->GetSize();. 4392 else. 4393 return 0;. 4394 }. ```. Looks to me it's invoking GetListOfMethods(true) (because default is true) but are we using the cache you mentioned to make GetNumMethods?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:360,performance,cach,cached,360,"(I always post a comment before I see your latest comment...). I profiled pyroot few days ago and found `LookupCppEntity` is a hot function, and this is calling `CreateScopeProxy`, which is calling `Cppyy::GetNumMethods`. So I thought optimizing this part of code really make sense. . > also do not see the point of caching the value there since it is already cached in the list itself . Hmm but GetNumMethods is calling TClass::GetNmethods, which is invoking GetListOfMethods like this:. ```. 4385 Int_t TClass::GetNmethods() . 4386 {. 4387 if (!HasInterpreterInfo()) return 0;. 4388 . 4389 TList *lm = GetListOfMethods();. 4390 if (lm). 4391 return lm->GetSize();. 4392 else. 4393 return 0;. 4394 }. ```. Looks to me it's invoking GetListOfMethods(true) (because default is true) but are we using the cache you mentioned to make GetNumMethods?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:803,performance,cach,cache,803,"(I always post a comment before I see your latest comment...). I profiled pyroot few days ago and found `LookupCppEntity` is a hot function, and this is calling `CreateScopeProxy`, which is calling `Cppyy::GetNumMethods`. So I thought optimizing this part of code really make sense. . > also do not see the point of caching the value there since it is already cached in the list itself . Hmm but GetNumMethods is calling TClass::GetNmethods, which is invoking GetListOfMethods like this:. ```. 4385 Int_t TClass::GetNmethods() . 4386 {. 4387 if (!HasInterpreterInfo()) return 0;. 4388 . 4389 TList *lm = GetListOfMethods();. 4390 if (lm). 4391 return lm->GetSize();. 4392 else. 4393 return 0;. 4394 }. ```. Looks to me it's invoking GetListOfMethods(true) (because default is true) but are we using the cache you mentioned to make GetNumMethods?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:127,safety,hot,hot,127,"(I always post a comment before I see your latest comment...). I profiled pyroot few days ago and found `LookupCppEntity` is a hot function, and this is calling `CreateScopeProxy`, which is calling `Cppyy::GetNumMethods`. So I thought optimizing this part of code really make sense. . > also do not see the point of caching the value there since it is already cached in the list itself . Hmm but GetNumMethods is calling TClass::GetNmethods, which is invoking GetListOfMethods like this:. ```. 4385 Int_t TClass::GetNmethods() . 4386 {. 4387 if (!HasInterpreterInfo()) return 0;. 4388 . 4389 TList *lm = GetListOfMethods();. 4390 if (lm). 4391 return lm->GetSize();. 4392 else. 4393 return 0;. 4394 }. ```. Looks to me it's invoking GetListOfMethods(true) (because default is true) but are we using the cache you mentioned to make GetNumMethods?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:344,energy efficiency,profil,profile,344,"This conversation makes no sense to me :-) You're discussing. ```. auto GetAllMethods() {. vector<...> ret;. for (method: methods()). ret.emplace_back(method);. return ret;. }. ```. That's because PyROOT and cppyy do ""overload resolution"" by choosing the best out of a pre-existing collection of functions. If we want to have any effect in the profile we need to change the way that PyROOT and cppyy find the function to call. This cannot happen by changing either the loop style nor the loop itself, it needs to be fixed by changing the way PyROOT and cppyy do ""overload resolution"". If this makes to you no sense then please:. - do not post a reply here. - wait until I'm back at CERN. - I invite everyone to a coffee and we chat. I recommend we either close this or wait until this chat has happened.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:5,interoperability,convers,conversation,5,"This conversation makes no sense to me :-) You're discussing. ```. auto GetAllMethods() {. vector<...> ret;. for (method: methods()). ret.emplace_back(method);. return ret;. }. ```. That's because PyROOT and cppyy do ""overload resolution"" by choosing the best out of a pre-existing collection of functions. If we want to have any effect in the profile we need to change the way that PyROOT and cppyy find the function to call. This cannot happen by changing either the loop style nor the loop itself, it needs to be fixed by changing the way PyROOT and cppyy do ""overload resolution"". If this makes to you no sense then please:. - do not post a reply here. - wait until I'm back at CERN. - I invite everyone to a coffee and we chat. I recommend we either close this or wait until this chat has happened.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:344,performance,profil,profile,344,"This conversation makes no sense to me :-) You're discussing. ```. auto GetAllMethods() {. vector<...> ret;. for (method: methods()). ret.emplace_back(method);. return ret;. }. ```. That's because PyROOT and cppyy do ""overload resolution"" by choosing the best out of a pre-existing collection of functions. If we want to have any effect in the profile we need to change the way that PyROOT and cppyy find the function to call. This cannot happen by changing either the loop style nor the loop itself, it needs to be fixed by changing the way PyROOT and cppyy do ""overload resolution"". If this makes to you no sense then please:. - do not post a reply here. - wait until I'm back at CERN. - I invite everyone to a coffee and we chat. I recommend we either close this or wait until this chat has happened.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1743:755,usability,close,close,755,"This conversation makes no sense to me :-) You're discussing. ```. auto GetAllMethods() {. vector<...> ret;. for (method: methods()). ret.emplace_back(method);. return ret;. }. ```. That's because PyROOT and cppyy do ""overload resolution"" by choosing the best out of a pre-existing collection of functions. If we want to have any effect in the profile we need to change the way that PyROOT and cppyy find the function to call. This cannot happen by changing either the loop style nor the loop itself, it needs to be fixed by changing the way PyROOT and cppyy do ""overload resolution"". If this makes to you no sense then please:. - do not post a reply here. - wait until I'm back at CERN. - I invite everyone to a coffee and we chat. I recommend we either close this or wait until this chat has happened.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1743
https://github.com/root-project/root/pull/1744:11,deployability,build,build,11,@phsft-bot build only on mac1013/native with flags -Dvc=OFF -Dimt=ON -Dccache=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1744
https://github.com/root-project/root/pull/1744:11,deployability,build,build,11,@phsft-bot build just on mac1013/native with flags -Dvc=OFF -Dimt=ON -Dccache=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1744
https://github.com/root-project/root/pull/1746:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1746
https://github.com/root-project/root/pull/1747:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1747
https://github.com/root-project/root/pull/1748:173,deployability,fail,fail,173,"Hi, Vassil, Yuka, please make sure to recompile locally with relevant options enabled before pushing/merging. This PR removed some includes in RooFit which made compilation fail for me. I'm adding them back in #1751.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1748
https://github.com/root-project/root/pull/1748:173,reliability,fail,fail,173,"Hi, Vassil, Yuka, please make sure to recompile locally with relevant options enabled before pushing/merging. This PR removed some includes in RooFit which made compilation fail for me. I'm adding them back in #1751.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1748
https://github.com/root-project/root/pull/1749:38,integrability,coupl,couple,38,Can we replace all those numbers by a couple of global constexpr?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1749
https://github.com/root-project/root/pull/1749:38,modifiability,coupl,couple,38,Can we replace all those numbers by a couple of global constexpr?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1749
https://github.com/root-project/root/pull/1749:38,testability,coupl,couple,38,Can we replace all those numbers by a couple of global constexpr?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1749
https://github.com/root-project/root/pull/1749:15,deployability,updat,update,15,@pcanal I will update a code with your remark in the next iteration,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1749
https://github.com/root-project/root/pull/1749:15,safety,updat,update,15,@pcanal I will update a code with your remark in the next iteration,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1749
https://github.com/root-project/root/pull/1749:15,security,updat,update,15,@pcanal I will update a code with your remark in the next iteration,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1749
https://github.com/root-project/root/pull/1750:153,usability,command,command,153,"Thanks for your comment! https://github.com/root-project/root/pull/1748. Your question is related to this commit. I'm just invoking include-what-you-use command for each file, and only using part of its output. IWYU only looks at one file to determine if included header is needed or not.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1750
https://github.com/root-project/root/pull/1750:140,testability,understand,understand,140,"> I'm just invoking include-what-you-use command for each file,. Fair-enough, that is a good way to go about it. . However, I would like to understand why it recommends removing '#include <string>' when it is obviously use. I.e. is it a deficiency in IWYU or is it a feature (in which case I am not quite sure what rules/heuristic it follows and would appreciate a clarification) or am I missing something?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1750
https://github.com/root-project/root/pull/1750:41,usability,command,command,41,"> I'm just invoking include-what-you-use command for each file,. Fair-enough, that is a good way to go about it. . However, I would like to understand why it recommends removing '#include <string>' when it is obviously use. I.e. is it a deficiency in IWYU or is it a feature (in which case I am not quite sure what rules/heuristic it follows and would appreciate a clarification) or am I missing something?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1750
https://github.com/root-project/root/pull/1750:70,energy efficiency,reduc,reducing,70,"Hmm, now I understood what you meant. Actually I'm not sure what IWYU reducing policy is, so I'm trying to read this: https://github.com/include-what-you-use/include-what-you-use/blob/master/docs/WhatIsAUse.md.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1750
https://github.com/root-project/root/pull/1750:79,security,polic,policy,79,"Hmm, now I understood what you meant. Actually I'm not sure what IWYU reducing policy is, so I'm trying to read this: https://github.com/include-what-you-use/include-what-you-use/blob/master/docs/WhatIsAUse.md.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1750
https://github.com/root-project/root/pull/1751:66,deployability,fail,fails,66,> Comments have been addressed. I still need to understand why it fails on Jenkins. I tested myself on Mac High Sierra and it worked. I might be mis-reading the new code but it seems comment https://github.com/root-project/root/pull/1751/files#r175929733 might still be valid (i.e. needing to be addressed). Thanks.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1751
https://github.com/root-project/root/pull/1751:66,reliability,fail,fails,66,> Comments have been addressed. I still need to understand why it fails on Jenkins. I tested myself on Mac High Sierra and it worked. I might be mis-reading the new code but it seems comment https://github.com/root-project/root/pull/1751/files#r175929733 might still be valid (i.e. needing to be addressed). Thanks.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1751
https://github.com/root-project/root/pull/1751:86,safety,test,tested,86,> Comments have been addressed. I still need to understand why it fails on Jenkins. I tested myself on Mac High Sierra and it worked. I might be mis-reading the new code but it seems comment https://github.com/root-project/root/pull/1751/files#r175929733 might still be valid (i.e. needing to be addressed). Thanks.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1751
https://github.com/root-project/root/pull/1751:270,safety,valid,valid,270,> Comments have been addressed. I still need to understand why it fails on Jenkins. I tested myself on Mac High Sierra and it worked. I might be mis-reading the new code but it seems comment https://github.com/root-project/root/pull/1751/files#r175929733 might still be valid (i.e. needing to be addressed). Thanks.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1751
https://github.com/root-project/root/pull/1751:48,testability,understand,understand,48,> Comments have been addressed. I still need to understand why it fails on Jenkins. I tested myself on Mac High Sierra and it worked. I might be mis-reading the new code but it seems comment https://github.com/root-project/root/pull/1751/files#r175929733 might still be valid (i.e. needing to be addressed). Thanks.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1751
https://github.com/root-project/root/pull/1751:86,testability,test,tested,86,> Comments have been addressed. I still need to understand why it fails on Jenkins. I tested myself on Mac High Sierra and it worked. I might be mis-reading the new code but it seems comment https://github.com/root-project/root/pull/1751/files#r175929733 might still be valid (i.e. needing to be addressed). Thanks.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1751
https://github.com/root-project/root/pull/1751:37,usability,close,close,37,"I want to reorder changes, so I will close this PR and start a new one with the new commits.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1751
https://github.com/root-project/root/pull/1752:11,deployability,build,build,11,@phsft-bot build with flags -Dctest_test_exclude_none=on,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1752
https://github.com/root-project/root/pull/1752:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1752
https://github.com/root-project/root/pull/1753:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1753
https://github.com/root-project/root/pull/1753:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1753
https://github.com/root-project/root/pull/1753:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1753
https://github.com/root-project/root/pull/1753:73,deployability,build,builds,73,FYI: This unfortunately had to be reverted because it broke the Python 3 builds.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1753
https://github.com/root-project/root/pull/1753:29,deployability,build,builds,29,The CI does not have python3 builds?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1753
https://github.com/root-project/root/pull/1753:7,reliability,doe,does,7,The CI does not have python3 builds?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1753
https://github.com/root-project/root/pull/1753:59,availability,error,error,59,"```. /.../root/bindings/pyroot/src/Pythonize.cxx:2284:104: error: PyString_FromString was not declared in this scope. PyString_FromString(TString::Format(""%c%c%i"", endianess, type, bytes).Data()));. ```. In python3 it's sth like `PyUnicode...`",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1753
https://github.com/root-project/root/pull/1753:15,interoperability,bind,bindings,15,"```. /.../root/bindings/pyroot/src/Pythonize.cxx:2284:104: error: PyString_FromString was not declared in this scope. PyString_FromString(TString::Format(""%c%c%i"", endianess, type, bytes).Data()));. ```. In python3 it's sth like `PyUnicode...`",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1753
https://github.com/root-project/root/pull/1753:149,interoperability,Format,Format,149,"```. /.../root/bindings/pyroot/src/Pythonize.cxx:2284:104: error: PyString_FromString was not declared in this scope. PyString_FromString(TString::Format(""%c%c%i"", endianess, type, bytes).Data()));. ```. In python3 it's sth like `PyUnicode...`",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1753
https://github.com/root-project/root/pull/1753:15,modifiability,bind,bindings,15,"```. /.../root/bindings/pyroot/src/Pythonize.cxx:2284:104: error: PyString_FromString was not declared in this scope. PyString_FromString(TString::Format(""%c%c%i"", endianess, type, bytes).Data()));. ```. In python3 it's sth like `PyUnicode...`",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1753
https://github.com/root-project/root/pull/1753:59,performance,error,error,59,"```. /.../root/bindings/pyroot/src/Pythonize.cxx:2284:104: error: PyString_FromString was not declared in this scope. PyString_FromString(TString::Format(""%c%c%i"", endianess, type, bytes).Data()));. ```. In python3 it's sth like `PyUnicode...`",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1753
https://github.com/root-project/root/pull/1753:59,safety,error,error,59,"```. /.../root/bindings/pyroot/src/Pythonize.cxx:2284:104: error: PyString_FromString was not declared in this scope. PyString_FromString(TString::Format(""%c%c%i"", endianess, type, bytes).Data()));. ```. In python3 it's sth like `PyUnicode...`",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1753
https://github.com/root-project/root/pull/1753:59,usability,error,error,59,"```. /.../root/bindings/pyroot/src/Pythonize.cxx:2284:104: error: PyString_FromString was not declared in this scope. PyString_FromString(TString::Format(""%c%c%i"", endianess, type, bytes).Data()));. ```. In python3 it's sth like `PyUnicode...`",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1753
https://github.com/root-project/root/pull/1758:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1758
https://github.com/root-project/root/pull/1760:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1760
https://github.com/root-project/root/pull/1760:32,interoperability,conflict,conflicts,32,@Axel-Naumann should we fix the conflicts and merge this one ? . I am not sure this is really needed,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1760
https://github.com/root-project/root/pull/1761:11,deployability,build,build,11,@phsft-bot build just on slc6/gcc62 with flags -Druntime_cxxmodules=On -Dctest_test_exclude_none=on,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:11,deployability,build,build,11,@phsft-bot build just on slc6/gcc62 with flags -Druntime_cxxmodules=On -Dctest_test_exclude_none=on,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:11,deployability,build,build,11,@phsft-bot build just on slc6/gcc62 with flags -Druntime_cxxmodules=On -Droofit=Off -Dctest_test_exclude_none=on,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:72,deployability,modul,modules,72,Looks like the system goes out of memory due to the multiple concurrent modules built by rootcling.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:72,modifiability,modul,modules,72,Looks like the system goes out of memory due to the multiple concurrent modules built by rootcling.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:34,performance,memor,memory,34,Looks like the system goes out of memory due to the multiple concurrent modules built by rootcling.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:61,performance,concurren,concurrent,61,Looks like the system goes out of memory due to the multiple concurrent modules built by rootcling.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:72,safety,modul,modules,72,Looks like the system goes out of memory due to the multiple concurrent modules built by rootcling.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:34,usability,memor,memory,34,Looks like the system goes out of memory due to the multiple concurrent modules built by rootcling.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:11,deployability,build,build,11,@phsft-bot build just on slc6/gcc62 with flags -DCMAKE_BUILD_TYPE=Debug -DLLVM_BUILD_TYPE=Debug -Druntime_cxxmodules=On -Droofit=Off -Dctest_test_exclude_none=on,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:125,availability,error,error,125,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:737,availability,error,error,737,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:900,availability,Error,Error,900,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:959,availability,Error,Error,959,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1013,availability,Error,Error,1013,"oot.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading mo",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1085,availability,Error,Error,1085,"TH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is u",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1152,availability,Error,Error,1152,"odule-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1218,availability,Error,Error,1218,"urce bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, wi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1279,availability,Error,Error,1279,"ot.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1363,availability,Error,Error,1363,"-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future share",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1547,availability,error,error,1547,"ache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db en",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:4569,availability,operat,operator,4569,"riter.cpp:4470. #1 0x00007ffff1fd2e6a in clang::PCHGenerator::HandleTranslationUnit (this=0x7fffdc023ba0, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/GeneratePCH.cpp:61. #2 0x00007ffff1d96a58 in clang::MultiplexConsumer::HandleTranslationUnit (this=<optimized out>, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/MultiplexConsumer.cpp:305. #3 0x00007ffff37bc16a in clang::ParseAST (S=..., PrintStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::callback_fn<compileModuleImpl(clang::CompilerInstance&, clang::SourceLocation, llvm::StringRef, clang::FrontendInputFile, llvm::StringRef, llvm::StringRef, llvm::function_ref<void(clang::CompilerInstance&)>, llvm::function_ref<void(clang::CompilerInstance&)>)::<lambda()> >(intptr_t) (callable=140737152777648) at /usr/include/llvm/ADT/STLExtras.h:98. #8 0x00007ffff43bffb3 in llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) () from /home/yuka/module-relwithdeb/lib/libCling.so. #9 0x00007ffff43c00a5 in RunSafelyOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #10 0x00007ffff44360ad in ExecuteOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #11 0x00007ffff6e3d08c in start_thread () from /usr/lib/libpthread.so.0. #12 0x00007ffff6b74e7f in clone () from /usr/li",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:5993,availability,error,error,5993,"ntStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::callback_fn<compileModuleImpl(clang::CompilerInstance&, clang::SourceLocation, llvm::StringRef, clang::FrontendInputFile, llvm::StringRef, llvm::StringRef, llvm::function_ref<void(clang::CompilerInstance&)>, llvm::function_ref<void(clang::CompilerInstance&)>)::<lambda()> >(intptr_t) (callable=140737152777648) at /usr/include/llvm/ADT/STLExtras.h:98. #8 0x00007ffff43bffb3 in llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) () from /home/yuka/module-relwithdeb/lib/libCling.so. #9 0x00007ffff43c00a5 in RunSafelyOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #10 0x00007ffff44360ad in ExecuteOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #11 0x00007ffff6e3d08c in start_thread () from /usr/lib/libpthread.so.0. #12 0x00007ffff6b74e7f in clone () from /usr/lib/libc.so.6. ```. My point is. 1. In user's machine, I think it is unlikely that LD_LIBRARY_PATH and DYLD_LIBRARY_PATH is unset because if ROOT is successfully installed in the machine, they should be set. Thus I'm not 100% sure that we should add DynamicPath to search because it causes overhead in the lookup. 2. Instead, I think we can change Clang code to abort when it generates implicit modules on-demand and emit error messages. What do you think?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:41,deployability,patch,patch,41,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:50,deployability,releas,release,50,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:58,deployability,build,build,58,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:154,deployability,modul,module-release,154,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:202,deployability,modul,module-release,202,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:259,deployability,modul,module-release,259,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:314,deployability,modul,module-release,314,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:372,deployability,modul,module-release,372,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:428,deployability,modul,module-release,428,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:492,deployability,build,building,492,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:501,deployability,modul,module,501,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:543,deployability,Modul,ModuleCache,543,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:574,deployability,build,build,574,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:637,deployability,build,building,637,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:646,deployability,modul,module,646,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:669,deployability,build,build,669,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:688,deployability,modul,module-release,688,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:716,deployability,modul,modulemap,716,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:744,deployability,modul,module,744,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:803,deployability,Modul,ModuleCache,803,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:841,deployability,modul,module-release,841,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:871,deployability,modul,module,871,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:931,deployability,Modul,Module,931,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:943,deployability,fail,failed,943,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:990,deployability,Modul,Module,990,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1044,deployability,Modul,Module,1044,"in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-rel",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1069,deployability,fail,failed,1069,"ng LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_L",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1116,deployability,Modul,Module,1116," this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't wo",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1183,deployability,Modul,Module,1183,"[yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1202,deployability,fail,failed,1202,"ule-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of Writ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1249,deployability,Modul,Module,1249,"a-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIB",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1310,deployability,Modul,Module,1310," module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST""",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1347,deployability,fail,failed,1347,"PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1394,deployability,Modul,Module,1394,"_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. B",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1660,deployability,modul,modules,1660,"dule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module '",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1697,deployability,Modul,ModuleCache,1697,"include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/Modul",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1717,deployability,patch,patch,1717,"lemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1745,deployability,modul,module-release,1745,"libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1777,deployability,modul,module-release,1777,"rg.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:2014,deployability,modul,modules,2014," in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffd",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:2037,deployability,modul,module-release,2037,"Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., Outp",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:2177,deployability,modul,modules,2177,": Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yu",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:2186,deployability,Stack,Stack,2186," ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yuka/root/",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:2473,deployability,modul,module-relwithdeb,2473,"nce of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. 4470 bool hasErrors) {. (gdb) bt. #0 clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, isysroot=..., h",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:2647,deployability,build,building,2647,"implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. 4470 bool hasErrors) {. (gdb) bt. #0 clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, isysroot=..., hasErrors=false). at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. #1 0x00007ffff1fd2e6a in clang::PCHGenerator::HandleTranslatio",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:2656,deployability,modul,module,2656," modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. 4470 bool hasErrors) {. (gdb) bt. #0 clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, isysroot=..., hasErrors=false). at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. #1 0x00007ffff1fd2e6a in clang::PCHGenerator::HandleTranslationUnit (t",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:2698,deployability,Modul,ModuleCache,2698,"ache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. 4470 bool hasErrors) {. (gdb) bt. #0 clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, isysroot=..., hasErrors=false). at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. #1 0x00007ffff1fd2e6a in clang::PCHGenerator::HandleTranslationUnit (this=0x7fffdc023ba0, Ctx=...) at /home/yuka/ro",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:2729,deployability,build,build,2729," `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. 4470 bool hasErrors) {. (gdb) bt. #0 clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, isysroot=..., hasErrors=false). at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. #1 0x00007ffff1fd2e6a in clang::PCHGenerator::HandleTranslationUnit (this=0x7fffdc023ba0, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tool",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:3077,deployability,Modul,ModuleCache,3077," is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. 4470 bool hasErrors) {. (gdb) bt. #0 clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, isysroot=..., hasErrors=false). at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. #1 0x00007ffff1fd2e6a in clang::PCHGenerator::HandleTranslationUnit (this=0x7fffdc023ba0, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/GeneratePCH.cpp:61. #2 0x00007ffff1d96a58 in clang::MultiplexConsumer::HandleTranslationUnit (this=<optimized out>, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/MultiplexConsumer.cpp:305. #3 0x00007ffff37bc16a in clang::ParseAST (S=..., PrintStats=<optimized out>, SkipFunctionBodies=<optimized o",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:3407,deployability,Modul,ModuleCache,3407,"teAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. 4470 bool hasErrors) {. (gdb) bt. #0 clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, isysroot=..., hasErrors=false). at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. #1 0x00007ffff1fd2e6a in clang::PCHGenerator::HandleTranslationUnit (this=0x7fffdc023ba0, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/GeneratePCH.cpp:61. #2 0x00007ffff1d96a58 in clang::MultiplexConsumer::HandleTranslationUnit (this=<optimized out>, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/MultiplexConsumer.cpp:305. #3 0x00007ffff37bc16a in clang::ParseAST (S=..., PrintStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (th",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:5193,deployability,modul,module-relwithdeb,5193,"ntStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::callback_fn<compileModuleImpl(clang::CompilerInstance&, clang::SourceLocation, llvm::StringRef, clang::FrontendInputFile, llvm::StringRef, llvm::StringRef, llvm::function_ref<void(clang::CompilerInstance&)>, llvm::function_ref<void(clang::CompilerInstance&)>)::<lambda()> >(intptr_t) (callable=140737152777648) at /usr/include/llvm/ADT/STLExtras.h:98. #8 0x00007ffff43bffb3 in llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) () from /home/yuka/module-relwithdeb/lib/libCling.so. #9 0x00007ffff43c00a5 in RunSafelyOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #10 0x00007ffff44360ad in ExecuteOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #11 0x00007ffff6e3d08c in start_thread () from /usr/lib/libpthread.so.0. #12 0x00007ffff6b74e7f in clone () from /usr/lib/libc.so.6. ```. My point is. 1. In user's machine, I think it is unlikely that LD_LIBRARY_PATH and DYLD_LIBRARY_PATH is unset because if ROOT is successfully installed in the machine, they should be set. Thus I'm not 100% sure that we should add DynamicPath to search because it causes overhead in the lookup. 2. Instead, I think we can change Clang code to abort when it generates implicit modules on-demand and emit error messages. What do you think?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:5306,deployability,modul,module-relwithdeb,5306,"ntStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::callback_fn<compileModuleImpl(clang::CompilerInstance&, clang::SourceLocation, llvm::StringRef, clang::FrontendInputFile, llvm::StringRef, llvm::StringRef, llvm::function_ref<void(clang::CompilerInstance&)>, llvm::function_ref<void(clang::CompilerInstance&)>)::<lambda()> >(intptr_t) (callable=140737152777648) at /usr/include/llvm/ADT/STLExtras.h:98. #8 0x00007ffff43bffb3 in llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) () from /home/yuka/module-relwithdeb/lib/libCling.so. #9 0x00007ffff43c00a5 in RunSafelyOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #10 0x00007ffff44360ad in ExecuteOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #11 0x00007ffff6e3d08c in start_thread () from /usr/lib/libpthread.so.0. #12 0x00007ffff6b74e7f in clone () from /usr/lib/libc.so.6. ```. My point is. 1. In user's machine, I think it is unlikely that LD_LIBRARY_PATH and DYLD_LIBRARY_PATH is unset because if ROOT is successfully installed in the machine, they should be set. Thus I'm not 100% sure that we should add DynamicPath to search because it causes overhead in the lookup. 2. Instead, I think we can change Clang code to abort when it generates implicit modules on-demand and emit error messages. What do you think?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:5418,deployability,modul,module-relwithdeb,5418,"ntStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::callback_fn<compileModuleImpl(clang::CompilerInstance&, clang::SourceLocation, llvm::StringRef, clang::FrontendInputFile, llvm::StringRef, llvm::StringRef, llvm::function_ref<void(clang::CompilerInstance&)>, llvm::function_ref<void(clang::CompilerInstance&)>)::<lambda()> >(intptr_t) (callable=140737152777648) at /usr/include/llvm/ADT/STLExtras.h:98. #8 0x00007ffff43bffb3 in llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) () from /home/yuka/module-relwithdeb/lib/libCling.so. #9 0x00007ffff43c00a5 in RunSafelyOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #10 0x00007ffff44360ad in ExecuteOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #11 0x00007ffff6e3d08c in start_thread () from /usr/lib/libpthread.so.0. #12 0x00007ffff6b74e7f in clone () from /usr/lib/libc.so.6. ```. My point is. 1. In user's machine, I think it is unlikely that LD_LIBRARY_PATH and DYLD_LIBRARY_PATH is unset because if ROOT is successfully installed in the machine, they should be set. Thus I'm not 100% sure that we should add DynamicPath to search because it causes overhead in the lookup. 2. Instead, I think we can change Clang code to abort when it generates implicit modules on-demand and emit error messages. What do you think?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:5733,deployability,instal,installed,5733,"ntStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::callback_fn<compileModuleImpl(clang::CompilerInstance&, clang::SourceLocation, llvm::StringRef, clang::FrontendInputFile, llvm::StringRef, llvm::StringRef, llvm::function_ref<void(clang::CompilerInstance&)>, llvm::function_ref<void(clang::CompilerInstance&)>)::<lambda()> >(intptr_t) (callable=140737152777648) at /usr/include/llvm/ADT/STLExtras.h:98. #8 0x00007ffff43bffb3 in llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) () from /home/yuka/module-relwithdeb/lib/libCling.so. #9 0x00007ffff43c00a5 in RunSafelyOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #10 0x00007ffff44360ad in ExecuteOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #11 0x00007ffff6e3d08c in start_thread () from /usr/lib/libpthread.so.0. #12 0x00007ffff6b74e7f in clone () from /usr/lib/libc.so.6. ```. My point is. 1. In user's machine, I think it is unlikely that LD_LIBRARY_PATH and DYLD_LIBRARY_PATH is unset because if ROOT is successfully installed in the machine, they should be set. Thus I'm not 100% sure that we should add DynamicPath to search because it causes overhead in the lookup. 2. Instead, I think we can change Clang code to abort when it generates implicit modules on-demand and emit error messages. What do you think?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:5966,deployability,modul,modules,5966,"ntStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::callback_fn<compileModuleImpl(clang::CompilerInstance&, clang::SourceLocation, llvm::StringRef, clang::FrontendInputFile, llvm::StringRef, llvm::StringRef, llvm::function_ref<void(clang::CompilerInstance&)>, llvm::function_ref<void(clang::CompilerInstance&)>)::<lambda()> >(intptr_t) (callable=140737152777648) at /usr/include/llvm/ADT/STLExtras.h:98. #8 0x00007ffff43bffb3 in llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) () from /home/yuka/module-relwithdeb/lib/libCling.so. #9 0x00007ffff43c00a5 in RunSafelyOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #10 0x00007ffff44360ad in ExecuteOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #11 0x00007ffff6e3d08c in start_thread () from /usr/lib/libpthread.so.0. #12 0x00007ffff6b74e7f in clone () from /usr/lib/libc.so.6. ```. My point is. 1. In user's machine, I think it is unlikely that LD_LIBRARY_PATH and DYLD_LIBRARY_PATH is unset because if ROOT is successfully installed in the machine, they should be set. Thus I'm not 100% sure that we should add DynamicPath to search because it causes overhead in the lookup. 2. Instead, I think we can change Clang code to abort when it generates implicit modules on-demand and emit error messages. What do you think?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:918,energy efficiency,Load,LoadModule,918,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:953,energy efficiency,load,load,953,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:977,energy efficiency,Load,LoadModule,977,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1031,energy efficiency,Load,LoadModule,1031,"this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1079,energy efficiency,load,load,1079,"RARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PA",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1103,energy efficiency,Load,LoadModule,1103,"PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1170,energy efficiency,Load,LoadModule,1170,"rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implici",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1212,energy efficiency,load,load,1212,"se]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runt",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1236,energy efficiency,Load,LoadModule,1236,". [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH a",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1297,energy efficiency,Load,LoadModule,1297,"a@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1357,energy efficiency,load,load,1357,"ka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on futur",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1381,energy efficiency,Load,LoadModule,1381,"]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y o",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1588,energy efficiency,core,core,1588," <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:2006,energy efficiency,load,loading,2006,"d! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:2130,energy efficiency,current,currently,2130,"ion_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:2376,energy efficiency,load,load,2376,"g::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. 4470 bool hasErrors) {. (gdb) bt. #0 clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:3858,energy efficiency,optim,optimized,3858,"0 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. 4470 bool hasErrors) {. (gdb) bt. #0 clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, isysroot=..., hasErrors=false). at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. #1 0x00007ffff1fd2e6a in clang::PCHGenerator::HandleTranslationUnit (this=0x7fffdc023ba0, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/GeneratePCH.cpp:61. #2 0x00007ffff1d96a58 in clang::MultiplexConsumer::HandleTranslationUnit (this=<optimized out>, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/MultiplexConsumer.cpp:305. #3 0x00007ffff37bc16a in clang::ParseAST (S=..., PrintStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::callback_fn<compileModuleImpl(clang::CompilerInstance&, clang::SourceLocation, llvm::StringRef, clang::FrontendInputFile, llvm::Strin",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:4036,energy efficiency,optim,optimized,4036,"utputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. 4470 bool hasErrors) {. (gdb) bt. #0 clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, isysroot=..., hasErrors=false). at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. #1 0x00007ffff1fd2e6a in clang::PCHGenerator::HandleTranslationUnit (this=0x7fffdc023ba0, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/GeneratePCH.cpp:61. #2 0x00007ffff1d96a58 in clang::MultiplexConsumer::HandleTranslationUnit (this=<optimized out>, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/MultiplexConsumer.cpp:305. #3 0x00007ffff37bc16a in clang::ParseAST (S=..., PrintStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::callback_fn<compileModuleImpl(clang::CompilerInstance&, clang::SourceLocation, llvm::StringRef, clang::FrontendInputFile, llvm::StringRef, llvm::StringRef, llvm::function_ref<void(clang::CompilerInstance&)>, llvm::function_ref<void(clang::CompilerInstance&)>)::<lambda()> >(intptr_t) (callable=140737152777648) ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:4072,energy efficiency,optim,optimized,4072,"ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. 4470 bool hasErrors) {. (gdb) bt. #0 clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, isysroot=..., hasErrors=false). at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. #1 0x00007ffff1fd2e6a in clang::PCHGenerator::HandleTranslationUnit (this=0x7fffdc023ba0, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/GeneratePCH.cpp:61. #2 0x00007ffff1d96a58 in clang::MultiplexConsumer::HandleTranslationUnit (this=<optimized out>, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/MultiplexConsumer.cpp:305. #3 0x00007ffff37bc16a in clang::ParseAST (S=..., PrintStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::callback_fn<compileModuleImpl(clang::CompilerInstance&, clang::SourceLocation, llvm::StringRef, clang::FrontendInputFile, llvm::StringRef, llvm::StringRef, llvm::function_ref<void(clang::CompilerInstance&)>, llvm::function_ref<void(clang::CompilerInstance&)>)::<lambda()> >(intptr_t) (callable=140737152777648) at /usr/include/llvm/ADT/STLExtras.h",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:5999,integrability,messag,messages,5999,"ntStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::callback_fn<compileModuleImpl(clang::CompilerInstance&, clang::SourceLocation, llvm::StringRef, clang::FrontendInputFile, llvm::StringRef, llvm::StringRef, llvm::function_ref<void(clang::CompilerInstance&)>, llvm::function_ref<void(clang::CompilerInstance&)>)::<lambda()> >(intptr_t) (callable=140737152777648) at /usr/include/llvm/ADT/STLExtras.h:98. #8 0x00007ffff43bffb3 in llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) () from /home/yuka/module-relwithdeb/lib/libCling.so. #9 0x00007ffff43c00a5 in RunSafelyOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #10 0x00007ffff44360ad in ExecuteOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #11 0x00007ffff6e3d08c in start_thread () from /usr/lib/libpthread.so.0. #12 0x00007ffff6b74e7f in clone () from /usr/lib/libc.so.6. ```. My point is. 1. In user's machine, I think it is unlikely that LD_LIBRARY_PATH and DYLD_LIBRARY_PATH is unset because if ROOT is successfully installed in the machine, they should be set. Thus I'm not 100% sure that we should add DynamicPath to search because it causes overhead in the lookup. 2. Instead, I think we can change Clang code to abort when it generates implicit modules on-demand and emit error messages. What do you think?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:2361,interoperability,share,shared,2361,"rror in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. 4470 bool hasErrors) {. (gdb) bt. #0 clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:5999,interoperability,messag,messages,5999,"ntStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::callback_fn<compileModuleImpl(clang::CompilerInstance&, clang::SourceLocation, llvm::StringRef, clang::FrontendInputFile, llvm::StringRef, llvm::StringRef, llvm::function_ref<void(clang::CompilerInstance&)>, llvm::function_ref<void(clang::CompilerInstance&)>)::<lambda()> >(intptr_t) (callable=140737152777648) at /usr/include/llvm/ADT/STLExtras.h:98. #8 0x00007ffff43bffb3 in llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) () from /home/yuka/module-relwithdeb/lib/libCling.so. #9 0x00007ffff43c00a5 in RunSafelyOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #10 0x00007ffff44360ad in ExecuteOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #11 0x00007ffff6e3d08c in start_thread () from /usr/lib/libpthread.so.0. #12 0x00007ffff6b74e7f in clone () from /usr/lib/libc.so.6. ```. My point is. 1. In user's machine, I think it is unlikely that LD_LIBRARY_PATH and DYLD_LIBRARY_PATH is unset because if ROOT is successfully installed in the machine, they should be set. Thus I'm not 100% sure that we should add DynamicPath to search because it causes overhead in the lookup. 2. Instead, I think we can change Clang code to abort when it generates implicit modules on-demand and emit error messages. What do you think?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:154,modifiability,modul,module-release,154,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:202,modifiability,modul,module-release,202,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:259,modifiability,modul,module-release,259,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:314,modifiability,modul,module-release,314,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:372,modifiability,modul,module-release,372,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:428,modifiability,modul,module-release,428,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:501,modifiability,modul,module,501,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:543,modifiability,Modul,ModuleCache,543,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:646,modifiability,modul,module,646,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:688,modifiability,modul,module-release,688,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:716,modifiability,modul,modulemap,716,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:744,modifiability,modul,module,744,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:803,modifiability,Modul,ModuleCache,803,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:841,modifiability,modul,module-release,841,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:871,modifiability,modul,module,871,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:931,modifiability,Modul,Module,931,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:990,modifiability,Modul,Module,990,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1044,modifiability,Modul,Module,1044,"in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-rel",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1116,modifiability,Modul,Module,1116," this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't wo",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1183,modifiability,Modul,Module,1183,"[yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1249,modifiability,Modul,Module,1249,"a-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIB",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1310,modifiability,Modul,Module,1310," module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST""",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1394,modifiability,Modul,Module,1394,"_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. B",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1660,modifiability,modul,modules,1660,"dule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module '",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1697,modifiability,Modul,ModuleCache,1697,"include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/Modul",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1745,modifiability,modul,module-release,1745,"libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1777,modifiability,modul,module-release,1777,"rg.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:2014,modifiability,modul,modules,2014," in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffd",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:2037,modifiability,modul,module-release,2037,"Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., Outp",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:2177,modifiability,modul,modules,2177,": Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yu",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:2473,modifiability,modul,module-relwithdeb,2473,"nce of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. 4470 bool hasErrors) {. (gdb) bt. #0 clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, isysroot=..., h",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:2656,modifiability,modul,module,2656," modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. 4470 bool hasErrors) {. (gdb) bt. #0 clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, isysroot=..., hasErrors=false). at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. #1 0x00007ffff1fd2e6a in clang::PCHGenerator::HandleTranslationUnit (t",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:2698,modifiability,Modul,ModuleCache,2698,"ache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. 4470 bool hasErrors) {. (gdb) bt. #0 clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, isysroot=..., hasErrors=false). at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. #1 0x00007ffff1fd2e6a in clang::PCHGenerator::HandleTranslationUnit (this=0x7fffdc023ba0, Ctx=...) at /home/yuka/ro",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:3077,modifiability,Modul,ModuleCache,3077," is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. 4470 bool hasErrors) {. (gdb) bt. #0 clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, isysroot=..., hasErrors=false). at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. #1 0x00007ffff1fd2e6a in clang::PCHGenerator::HandleTranslationUnit (this=0x7fffdc023ba0, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/GeneratePCH.cpp:61. #2 0x00007ffff1d96a58 in clang::MultiplexConsumer::HandleTranslationUnit (this=<optimized out>, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/MultiplexConsumer.cpp:305. #3 0x00007ffff37bc16a in clang::ParseAST (S=..., PrintStats=<optimized out>, SkipFunctionBodies=<optimized o",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:3407,modifiability,Modul,ModuleCache,3407,"teAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. 4470 bool hasErrors) {. (gdb) bt. #0 clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, isysroot=..., hasErrors=false). at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. #1 0x00007ffff1fd2e6a in clang::PCHGenerator::HandleTranslationUnit (this=0x7fffdc023ba0, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/GeneratePCH.cpp:61. #2 0x00007ffff1d96a58 in clang::MultiplexConsumer::HandleTranslationUnit (this=<optimized out>, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/MultiplexConsumer.cpp:305. #3 0x00007ffff37bc16a in clang::ParseAST (S=..., PrintStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (th",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:5193,modifiability,modul,module-relwithdeb,5193,"ntStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::callback_fn<compileModuleImpl(clang::CompilerInstance&, clang::SourceLocation, llvm::StringRef, clang::FrontendInputFile, llvm::StringRef, llvm::StringRef, llvm::function_ref<void(clang::CompilerInstance&)>, llvm::function_ref<void(clang::CompilerInstance&)>)::<lambda()> >(intptr_t) (callable=140737152777648) at /usr/include/llvm/ADT/STLExtras.h:98. #8 0x00007ffff43bffb3 in llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) () from /home/yuka/module-relwithdeb/lib/libCling.so. #9 0x00007ffff43c00a5 in RunSafelyOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #10 0x00007ffff44360ad in ExecuteOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #11 0x00007ffff6e3d08c in start_thread () from /usr/lib/libpthread.so.0. #12 0x00007ffff6b74e7f in clone () from /usr/lib/libc.so.6. ```. My point is. 1. In user's machine, I think it is unlikely that LD_LIBRARY_PATH and DYLD_LIBRARY_PATH is unset because if ROOT is successfully installed in the machine, they should be set. Thus I'm not 100% sure that we should add DynamicPath to search because it causes overhead in the lookup. 2. Instead, I think we can change Clang code to abort when it generates implicit modules on-demand and emit error messages. What do you think?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:5306,modifiability,modul,module-relwithdeb,5306,"ntStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::callback_fn<compileModuleImpl(clang::CompilerInstance&, clang::SourceLocation, llvm::StringRef, clang::FrontendInputFile, llvm::StringRef, llvm::StringRef, llvm::function_ref<void(clang::CompilerInstance&)>, llvm::function_ref<void(clang::CompilerInstance&)>)::<lambda()> >(intptr_t) (callable=140737152777648) at /usr/include/llvm/ADT/STLExtras.h:98. #8 0x00007ffff43bffb3 in llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) () from /home/yuka/module-relwithdeb/lib/libCling.so. #9 0x00007ffff43c00a5 in RunSafelyOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #10 0x00007ffff44360ad in ExecuteOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #11 0x00007ffff6e3d08c in start_thread () from /usr/lib/libpthread.so.0. #12 0x00007ffff6b74e7f in clone () from /usr/lib/libc.so.6. ```. My point is. 1. In user's machine, I think it is unlikely that LD_LIBRARY_PATH and DYLD_LIBRARY_PATH is unset because if ROOT is successfully installed in the machine, they should be set. Thus I'm not 100% sure that we should add DynamicPath to search because it causes overhead in the lookup. 2. Instead, I think we can change Clang code to abort when it generates implicit modules on-demand and emit error messages. What do you think?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:5418,modifiability,modul,module-relwithdeb,5418,"ntStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::callback_fn<compileModuleImpl(clang::CompilerInstance&, clang::SourceLocation, llvm::StringRef, clang::FrontendInputFile, llvm::StringRef, llvm::StringRef, llvm::function_ref<void(clang::CompilerInstance&)>, llvm::function_ref<void(clang::CompilerInstance&)>)::<lambda()> >(intptr_t) (callable=140737152777648) at /usr/include/llvm/ADT/STLExtras.h:98. #8 0x00007ffff43bffb3 in llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) () from /home/yuka/module-relwithdeb/lib/libCling.so. #9 0x00007ffff43c00a5 in RunSafelyOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #10 0x00007ffff44360ad in ExecuteOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #11 0x00007ffff6e3d08c in start_thread () from /usr/lib/libpthread.so.0. #12 0x00007ffff6b74e7f in clone () from /usr/lib/libc.so.6. ```. My point is. 1. In user's machine, I think it is unlikely that LD_LIBRARY_PATH and DYLD_LIBRARY_PATH is unset because if ROOT is successfully installed in the machine, they should be set. Thus I'm not 100% sure that we should add DynamicPath to search because it causes overhead in the lookup. 2. Instead, I think we can change Clang code to abort when it generates implicit modules on-demand and emit error messages. What do you think?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:5966,modifiability,modul,modules,5966,"ntStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::callback_fn<compileModuleImpl(clang::CompilerInstance&, clang::SourceLocation, llvm::StringRef, clang::FrontendInputFile, llvm::StringRef, llvm::StringRef, llvm::function_ref<void(clang::CompilerInstance&)>, llvm::function_ref<void(clang::CompilerInstance&)>)::<lambda()> >(intptr_t) (callable=140737152777648) at /usr/include/llvm/ADT/STLExtras.h:98. #8 0x00007ffff43bffb3 in llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) () from /home/yuka/module-relwithdeb/lib/libCling.so. #9 0x00007ffff43c00a5 in RunSafelyOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #10 0x00007ffff44360ad in ExecuteOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #11 0x00007ffff6e3d08c in start_thread () from /usr/lib/libpthread.so.0. #12 0x00007ffff6b74e7f in clone () from /usr/lib/libc.so.6. ```. My point is. 1. In user's machine, I think it is unlikely that LD_LIBRARY_PATH and DYLD_LIBRARY_PATH is unset because if ROOT is successfully installed in the machine, they should be set. Thus I'm not 100% sure that we should add DynamicPath to search because it causes overhead in the lookup. 2. Instead, I think we can change Clang code to abort when it generates implicit modules on-demand and emit error messages. What do you think?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:125,performance,error,error,125,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:737,performance,error,error,737,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:900,performance,Error,Error,900,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:918,performance,Load,LoadModule,918,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:953,performance,load,load,953,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:959,performance,Error,Error,959,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:977,performance,Load,LoadModule,977,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1013,performance,Error,Error,1013,"oot.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading mo",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1031,performance,Load,LoadModule,1031,"this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1079,performance,load,load,1079,"RARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PA",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1085,performance,Error,Error,1085,"TH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is u",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1103,performance,Load,LoadModule,1103,"PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1152,performance,Error,Error,1152,"odule-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1170,performance,Load,LoadModule,1170,"rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implici",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1212,performance,load,load,1212,"se]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runt",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1218,performance,Error,Error,1218,"urce bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, wi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1236,performance,Load,LoadModule,1236,". [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH a",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1279,performance,Error,Error,1279,"ot.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1297,performance,Load,LoadModule,1297,"a@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1357,performance,load,load,1357,"ka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on futur",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1363,performance,Error,Error,1363,"-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future share",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1381,performance,Load,LoadModule,1381,"]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y o",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1547,performance,error,error,1547,"ache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db en",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:2006,performance,load,loading,2006,"d! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:2376,performance,load,load,2376,"g::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. 4470 bool hasErrors) {. (gdb) bt. #0 clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:3810,performance,Multiplex,MultiplexConsumer,3810,"f700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. 4470 bool hasErrors) {. (gdb) bt. #0 clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, isysroot=..., hasErrors=false). at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. #1 0x00007ffff1fd2e6a in clang::PCHGenerator::HandleTranslationUnit (this=0x7fffdc023ba0, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/GeneratePCH.cpp:61. #2 0x00007ffff1d96a58 in clang::MultiplexConsumer::HandleTranslationUnit (this=<optimized out>, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/MultiplexConsumer.cpp:305. #3 0x00007ffff37bc16a in clang::ParseAST (S=..., PrintStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::callback_fn<compileModuleImpl(clang::CompilerInstance&, clang::SourceLocation, llvm::Stri",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:3858,performance,optimiz,optimized,3858,"0 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. 4470 bool hasErrors) {. (gdb) bt. #0 clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, isysroot=..., hasErrors=false). at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. #1 0x00007ffff1fd2e6a in clang::PCHGenerator::HandleTranslationUnit (this=0x7fffdc023ba0, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/GeneratePCH.cpp:61. #2 0x00007ffff1d96a58 in clang::MultiplexConsumer::HandleTranslationUnit (this=<optimized out>, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/MultiplexConsumer.cpp:305. #3 0x00007ffff37bc16a in clang::ParseAST (S=..., PrintStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::callback_fn<compileModuleImpl(clang::CompilerInstance&, clang::SourceLocation, llvm::StringRef, clang::FrontendInputFile, llvm::Strin",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:3948,performance,Multiplex,MultiplexConsumer,3948,"kpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. 4470 bool hasErrors) {. (gdb) bt. #0 clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, isysroot=..., hasErrors=false). at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. #1 0x00007ffff1fd2e6a in clang::PCHGenerator::HandleTranslationUnit (this=0x7fffdc023ba0, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/GeneratePCH.cpp:61. #2 0x00007ffff1d96a58 in clang::MultiplexConsumer::HandleTranslationUnit (this=<optimized out>, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/MultiplexConsumer.cpp:305. #3 0x00007ffff37bc16a in clang::ParseAST (S=..., PrintStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::callback_fn<compileModuleImpl(clang::CompilerInstance&, clang::SourceLocation, llvm::StringRef, clang::FrontendInputFile, llvm::StringRef, llvm::StringRef, llvm::function_ref<void(clang::CompilerInstance&)>, llvm::function_ref<",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:4036,performance,optimiz,optimized,4036,"utputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. 4470 bool hasErrors) {. (gdb) bt. #0 clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, isysroot=..., hasErrors=false). at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. #1 0x00007ffff1fd2e6a in clang::PCHGenerator::HandleTranslationUnit (this=0x7fffdc023ba0, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/GeneratePCH.cpp:61. #2 0x00007ffff1d96a58 in clang::MultiplexConsumer::HandleTranslationUnit (this=<optimized out>, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/MultiplexConsumer.cpp:305. #3 0x00007ffff37bc16a in clang::ParseAST (S=..., PrintStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::callback_fn<compileModuleImpl(clang::CompilerInstance&, clang::SourceLocation, llvm::StringRef, clang::FrontendInputFile, llvm::StringRef, llvm::StringRef, llvm::function_ref<void(clang::CompilerInstance&)>, llvm::function_ref<void(clang::CompilerInstance&)>)::<lambda()> >(intptr_t) (callable=140737152777648) ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:4072,performance,optimiz,optimized,4072,"ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. 4470 bool hasErrors) {. (gdb) bt. #0 clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, isysroot=..., hasErrors=false). at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. #1 0x00007ffff1fd2e6a in clang::PCHGenerator::HandleTranslationUnit (this=0x7fffdc023ba0, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/GeneratePCH.cpp:61. #2 0x00007ffff1d96a58 in clang::MultiplexConsumer::HandleTranslationUnit (this=<optimized out>, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/MultiplexConsumer.cpp:305. #3 0x00007ffff37bc16a in clang::ParseAST (S=..., PrintStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::callback_fn<compileModuleImpl(clang::CompilerInstance&, clang::SourceLocation, llvm::StringRef, clang::FrontendInputFile, llvm::StringRef, llvm::StringRef, llvm::function_ref<void(clang::CompilerInstance&)>, llvm::function_ref<void(clang::CompilerInstance&)>)::<lambda()> >(intptr_t) (callable=140737152777648) at /usr/include/llvm/ADT/STLExtras.h",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:5861,performance,overhead,overhead,5861,"ntStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::callback_fn<compileModuleImpl(clang::CompilerInstance&, clang::SourceLocation, llvm::StringRef, clang::FrontendInputFile, llvm::StringRef, llvm::StringRef, llvm::function_ref<void(clang::CompilerInstance&)>, llvm::function_ref<void(clang::CompilerInstance&)>)::<lambda()> >(intptr_t) (callable=140737152777648) at /usr/include/llvm/ADT/STLExtras.h:98. #8 0x00007ffff43bffb3 in llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) () from /home/yuka/module-relwithdeb/lib/libCling.so. #9 0x00007ffff43c00a5 in RunSafelyOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #10 0x00007ffff44360ad in ExecuteOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #11 0x00007ffff6e3d08c in start_thread () from /usr/lib/libpthread.so.0. #12 0x00007ffff6b74e7f in clone () from /usr/lib/libc.so.6. ```. My point is. 1. In user's machine, I think it is unlikely that LD_LIBRARY_PATH and DYLD_LIBRARY_PATH is unset because if ROOT is successfully installed in the machine, they should be set. Thus I'm not 100% sure that we should add DynamicPath to search because it causes overhead in the lookup. 2. Instead, I think we can change Clang code to abort when it generates implicit modules on-demand and emit error messages. What do you think?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:5993,performance,error,error,5993,"ntStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::callback_fn<compileModuleImpl(clang::CompilerInstance&, clang::SourceLocation, llvm::StringRef, clang::FrontendInputFile, llvm::StringRef, llvm::StringRef, llvm::function_ref<void(clang::CompilerInstance&)>, llvm::function_ref<void(clang::CompilerInstance&)>)::<lambda()> >(intptr_t) (callable=140737152777648) at /usr/include/llvm/ADT/STLExtras.h:98. #8 0x00007ffff43bffb3 in llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) () from /home/yuka/module-relwithdeb/lib/libCling.so. #9 0x00007ffff43c00a5 in RunSafelyOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #10 0x00007ffff44360ad in ExecuteOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #11 0x00007ffff6e3d08c in start_thread () from /usr/lib/libpthread.so.0. #12 0x00007ffff6b74e7f in clone () from /usr/lib/libc.so.6. ```. My point is. 1. In user's machine, I think it is unlikely that LD_LIBRARY_PATH and DYLD_LIBRARY_PATH is unset because if ROOT is successfully installed in the machine, they should be set. Thus I'm not 100% sure that we should add DynamicPath to search because it causes overhead in the lookup. 2. Instead, I think we can change Clang code to abort when it generates implicit modules on-demand and emit error messages. What do you think?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:943,reliability,fail,failed,943,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1069,reliability,fail,failed,1069,"ng LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_L",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1202,reliability,fail,failed,1202,"ule-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of Writ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1347,reliability,fail,failed,1347,"PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:2109,reliability,doe,doesn,2109,"e>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", Writi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:41,safety,patch,patch,41,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:125,safety,error,error,125,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:154,safety,modul,module-release,154,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:202,safety,modul,module-release,202,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:259,safety,modul,module-release,259,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:314,safety,modul,module-release,314,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:372,safety,modul,module-release,372,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:428,safety,modul,module-release,428,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:501,safety,modul,module,501,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:543,safety,Modul,ModuleCache,543,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:646,safety,modul,module,646,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:688,safety,modul,module-release,688,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:716,safety,modul,modulemap,716,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:737,safety,error,error,737,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:744,safety,modul,module,744,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:803,safety,Modul,ModuleCache,803,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:841,safety,modul,module-release,841,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:871,safety,modul,module,871,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:900,safety,Error,Error,900,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:931,safety,Modul,Module,931,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:959,safety,Error,Error,959,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:990,safety,Modul,Module,990,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1013,safety,Error,Error,1013,"oot.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading mo",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1044,safety,Modul,Module,1044,"in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-rel",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1085,safety,Error,Error,1085,"TH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is u",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1116,safety,Modul,Module,1116," this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't wo",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1152,safety,Error,Error,1152,"odule-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1183,safety,Modul,Module,1183,"[yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1218,safety,Error,Error,1218,"urce bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, wi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1249,safety,Modul,Module,1249,"a-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIB",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1279,safety,Error,Error,1279,"ot.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1310,safety,Modul,Module,1310," module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST""",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1363,safety,Error,Error,1363,"-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future share",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1394,safety,Modul,Module,1394,"_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. B",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1547,safety,error,error,1547,"ache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db en",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1660,safety,modul,modules,1660,"dule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module '",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1697,safety,Modul,ModuleCache,1697,"include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/Modul",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1717,safety,patch,patch,1717,"lemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1745,safety,modul,module-release,1745,"libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1777,safety,modul,module-release,1777,"rg.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:2014,safety,modul,modules,2014," in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffd",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:2037,safety,modul,module-release,2037,"Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., Outp",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:2177,safety,modul,modules,2177,": Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yu",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:2473,safety,modul,module-relwithdeb,2473,"nce of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. 4470 bool hasErrors) {. (gdb) bt. #0 clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, isysroot=..., h",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:2656,safety,modul,module,2656," modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. 4470 bool hasErrors) {. (gdb) bt. #0 clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, isysroot=..., hasErrors=false). at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. #1 0x00007ffff1fd2e6a in clang::PCHGenerator::HandleTranslationUnit (t",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:2698,safety,Modul,ModuleCache,2698,"ache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. 4470 bool hasErrors) {. (gdb) bt. #0 clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, isysroot=..., hasErrors=false). at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. #1 0x00007ffff1fd2e6a in clang::PCHGenerator::HandleTranslationUnit (this=0x7fffdc023ba0, Ctx=...) at /home/yuka/ro",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:3077,safety,Modul,ModuleCache,3077," is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. 4470 bool hasErrors) {. (gdb) bt. #0 clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, isysroot=..., hasErrors=false). at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. #1 0x00007ffff1fd2e6a in clang::PCHGenerator::HandleTranslationUnit (this=0x7fffdc023ba0, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/GeneratePCH.cpp:61. #2 0x00007ffff1d96a58 in clang::MultiplexConsumer::HandleTranslationUnit (this=<optimized out>, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/MultiplexConsumer.cpp:305. #3 0x00007ffff37bc16a in clang::ParseAST (S=..., PrintStats=<optimized out>, SkipFunctionBodies=<optimized o",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:3407,safety,Modul,ModuleCache,3407,"teAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. 4470 bool hasErrors) {. (gdb) bt. #0 clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, isysroot=..., hasErrors=false). at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. #1 0x00007ffff1fd2e6a in clang::PCHGenerator::HandleTranslationUnit (this=0x7fffdc023ba0, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/GeneratePCH.cpp:61. #2 0x00007ffff1d96a58 in clang::MultiplexConsumer::HandleTranslationUnit (this=<optimized out>, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/MultiplexConsumer.cpp:305. #3 0x00007ffff37bc16a in clang::ParseAST (S=..., PrintStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (th",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:5193,safety,modul,module-relwithdeb,5193,"ntStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::callback_fn<compileModuleImpl(clang::CompilerInstance&, clang::SourceLocation, llvm::StringRef, clang::FrontendInputFile, llvm::StringRef, llvm::StringRef, llvm::function_ref<void(clang::CompilerInstance&)>, llvm::function_ref<void(clang::CompilerInstance&)>)::<lambda()> >(intptr_t) (callable=140737152777648) at /usr/include/llvm/ADT/STLExtras.h:98. #8 0x00007ffff43bffb3 in llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) () from /home/yuka/module-relwithdeb/lib/libCling.so. #9 0x00007ffff43c00a5 in RunSafelyOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #10 0x00007ffff44360ad in ExecuteOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #11 0x00007ffff6e3d08c in start_thread () from /usr/lib/libpthread.so.0. #12 0x00007ffff6b74e7f in clone () from /usr/lib/libc.so.6. ```. My point is. 1. In user's machine, I think it is unlikely that LD_LIBRARY_PATH and DYLD_LIBRARY_PATH is unset because if ROOT is successfully installed in the machine, they should be set. Thus I'm not 100% sure that we should add DynamicPath to search because it causes overhead in the lookup. 2. Instead, I think we can change Clang code to abort when it generates implicit modules on-demand and emit error messages. What do you think?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:5306,safety,modul,module-relwithdeb,5306,"ntStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::callback_fn<compileModuleImpl(clang::CompilerInstance&, clang::SourceLocation, llvm::StringRef, clang::FrontendInputFile, llvm::StringRef, llvm::StringRef, llvm::function_ref<void(clang::CompilerInstance&)>, llvm::function_ref<void(clang::CompilerInstance&)>)::<lambda()> >(intptr_t) (callable=140737152777648) at /usr/include/llvm/ADT/STLExtras.h:98. #8 0x00007ffff43bffb3 in llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) () from /home/yuka/module-relwithdeb/lib/libCling.so. #9 0x00007ffff43c00a5 in RunSafelyOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #10 0x00007ffff44360ad in ExecuteOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #11 0x00007ffff6e3d08c in start_thread () from /usr/lib/libpthread.so.0. #12 0x00007ffff6b74e7f in clone () from /usr/lib/libc.so.6. ```. My point is. 1. In user's machine, I think it is unlikely that LD_LIBRARY_PATH and DYLD_LIBRARY_PATH is unset because if ROOT is successfully installed in the machine, they should be set. Thus I'm not 100% sure that we should add DynamicPath to search because it causes overhead in the lookup. 2. Instead, I think we can change Clang code to abort when it generates implicit modules on-demand and emit error messages. What do you think?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:5418,safety,modul,module-relwithdeb,5418,"ntStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::callback_fn<compileModuleImpl(clang::CompilerInstance&, clang::SourceLocation, llvm::StringRef, clang::FrontendInputFile, llvm::StringRef, llvm::StringRef, llvm::function_ref<void(clang::CompilerInstance&)>, llvm::function_ref<void(clang::CompilerInstance&)>)::<lambda()> >(intptr_t) (callable=140737152777648) at /usr/include/llvm/ADT/STLExtras.h:98. #8 0x00007ffff43bffb3 in llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) () from /home/yuka/module-relwithdeb/lib/libCling.so. #9 0x00007ffff43c00a5 in RunSafelyOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #10 0x00007ffff44360ad in ExecuteOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #11 0x00007ffff6e3d08c in start_thread () from /usr/lib/libpthread.so.0. #12 0x00007ffff6b74e7f in clone () from /usr/lib/libc.so.6. ```. My point is. 1. In user's machine, I think it is unlikely that LD_LIBRARY_PATH and DYLD_LIBRARY_PATH is unset because if ROOT is successfully installed in the machine, they should be set. Thus I'm not 100% sure that we should add DynamicPath to search because it causes overhead in the lookup. 2. Instead, I think we can change Clang code to abort when it generates implicit modules on-demand and emit error messages. What do you think?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:5966,safety,modul,modules,5966,"ntStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::callback_fn<compileModuleImpl(clang::CompilerInstance&, clang::SourceLocation, llvm::StringRef, clang::FrontendInputFile, llvm::StringRef, llvm::StringRef, llvm::function_ref<void(clang::CompilerInstance&)>, llvm::function_ref<void(clang::CompilerInstance&)>)::<lambda()> >(intptr_t) (callable=140737152777648) at /usr/include/llvm/ADT/STLExtras.h:98. #8 0x00007ffff43bffb3 in llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) () from /home/yuka/module-relwithdeb/lib/libCling.so. #9 0x00007ffff43c00a5 in RunSafelyOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #10 0x00007ffff44360ad in ExecuteOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #11 0x00007ffff6e3d08c in start_thread () from /usr/lib/libpthread.so.0. #12 0x00007ffff6b74e7f in clone () from /usr/lib/libc.so.6. ```. My point is. 1. In user's machine, I think it is unlikely that LD_LIBRARY_PATH and DYLD_LIBRARY_PATH is unset because if ROOT is successfully installed in the machine, they should be set. Thus I'm not 100% sure that we should add DynamicPath to search because it causes overhead in the lookup. 2. Instead, I think we can change Clang code to abort when it generates implicit modules on-demand and emit error messages. What do you think?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:5993,safety,error,error,5993,"ntStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::callback_fn<compileModuleImpl(clang::CompilerInstance&, clang::SourceLocation, llvm::StringRef, clang::FrontendInputFile, llvm::StringRef, llvm::StringRef, llvm::function_ref<void(clang::CompilerInstance&)>, llvm::function_ref<void(clang::CompilerInstance&)>)::<lambda()> >(intptr_t) (callable=140737152777648) at /usr/include/llvm/ADT/STLExtras.h:98. #8 0x00007ffff43bffb3 in llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) () from /home/yuka/module-relwithdeb/lib/libCling.so. #9 0x00007ffff43c00a5 in RunSafelyOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #10 0x00007ffff44360ad in ExecuteOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #11 0x00007ffff6e3d08c in start_thread () from /usr/lib/libpthread.so.0. #12 0x00007ffff6b74e7f in clone () from /usr/lib/libc.so.6. ```. My point is. 1. In user's machine, I think it is unlikely that LD_LIBRARY_PATH and DYLD_LIBRARY_PATH is unset because if ROOT is successfully installed in the machine, they should be set. Thus I'm not 100% sure that we should add DynamicPath to search because it causes overhead in the lookup. 2. Instead, I think we can change Clang code to abort when it generates implicit modules on-demand and emit error messages. What do you think?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:41,security,patch,patch,41,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1717,security,patch,patch,1717,"lemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:2192,testability,trace,trace,2192,"Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yuka/root/interp",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:125,usability,error,error,125,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:737,usability,error,error,737,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:900,usability,Error,Error,900,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:959,usability,Error,Error,959,"When I do `bin/root.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is impli",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1013,usability,Error,Error,1013,"oot.exe -q -l` with this patch in release build, unsetting LD_LIBRARY_PATH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading mo",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1085,usability,Error,Error,1085,"TH and DYLD_LIBRARY_PATH, I get this error:. ```. [yuka@yuka-arch module-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is u",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1152,usability,Error,Error,1152,"odule-release]$ rm -rf /tmp/*. [yuka@yuka-arch module-release]$ source bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1218,usability,Error,Error,1218,"urce bin/thisroot.sh. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, wi",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1279,usability,Error,Error,1279,"ot.exe -q -l. . [yuka@yuka-arch module-release]$ unset DYLD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1363,usability,Error,Error,1363,"-arch module-release]$ unset LD_LIBRARY_PATH. [yuka@yuka-arch module-release]$ bin/root.exe -q -l. input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future share",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:1547,usability,error,error,1547,"ache/stl.pcm' [-Rmodule-build]. #include <new>. ^. input_line_1:1:10: remark: finished building module 'stl' [-Rmodule-build]. /home/yuka/module-release/include/libc.modulemap:1:8: fatal error: module 'libc' is defined in both '/tmp/org.llvm.clang.yuka/ModuleCache/libc.pcm' and '/home/yuka/module-release/lib/libc.pcm'. module ""libc"" [system] {. ^. Error in <TCling::LoadModule>: Module libc failed to load. Error in <TCling::LoadModule>: Module libc not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_C failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_C not found! Error in <TCling::LoadModule>: Module ROOT_Config failed to load. Error in <TCling::LoadModule>: Module ROOT_Config not found! Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI failed to load. Error in <TCling::LoadModule>: Module ROOT_Foundation_Stage1_NoRTTI not found! terminate called after throwing an instance of 'std::runtime_error'. what(): >>> Interpreter compilation error:. Unexpected end of file. Aborted (core dumped). ```. As shown, Clang is still trying to generate implicit modules in `/tmp/org.llvm.clang.yuka/ModuleCache/`. This patch is adding `/home/yuka/module-release/lib:.:/home/yuka/module-release/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib` to TCling path, so I guess the expected result is implicitly loading modules in `/home/yuka/module-release/lib` (even when LD_LIBRARY_PATH is unset) but somehow it doesn't work because currently Clang is trying to generate implicit modules. Stack trace of WriteAST(Runtime, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db en",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:3210,usability,tool,tools,3210,"time, with LD_LIBRARY_PATH and DYLD_LIBRAYR_PATH unset):. ```. (gdb) b WriteAST. Function ""WriteAST"" not defined. Make breakpoint pending on future shared library load? (y or [n]) y. Breakpoint 1 (WriteAST) pending. (gdb) r -q -l. Starting program: /home/yuka/module-relwithdeb/bin/root.exe -q -l. [Thread debugging using libthread_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. 4470 bool hasErrors) {. (gdb) bt. #0 clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, isysroot=..., hasErrors=false). at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. #1 0x00007ffff1fd2e6a in clang::PCHGenerator::HandleTranslationUnit (this=0x7fffdc023ba0, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/GeneratePCH.cpp:61. #2 0x00007ffff1d96a58 in clang::MultiplexConsumer::HandleTranslationUnit (this=<optimized out>, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/MultiplexConsumer.cpp:305. #3 0x00007ffff37bc16a in clang::ParseAST (S=..., PrintStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendActio",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:3539,usability,tool,tools,3539,"ad_db enabled]. Using host libthread_db library ""/usr/lib/libthread_db.so.1"". input_line_1:1:10: remark: building module 'stl' as '/tmp/org.llvm.clang.yuka/ModuleCache/stl.pcm' [-Rmodule-build]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. 4470 bool hasErrors) {. (gdb) bt. #0 clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, isysroot=..., hasErrors=false). at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. #1 0x00007ffff1fd2e6a in clang::PCHGenerator::HandleTranslationUnit (this=0x7fffdc023ba0, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/GeneratePCH.cpp:61. #2 0x00007ffff1d96a58 in clang::MultiplexConsumer::HandleTranslationUnit (this=<optimized out>, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/MultiplexConsumer.cpp:305. #3 0x00007ffff37bc16a in clang::ParseAST (S=..., PrintStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:3728,usability,tool,tools,3728,"ild]. #include <new>. ^. [New Thread 0x7ffff0b8c700 (LWP 21631)]. [New Thread 0x7fffebfff700 (LWP 21632)]. [New Thread 0x7fffeb7fe700 (LWP 21633)]. [Switching to Thread 0x7fffeb7fe700 (LWP 21633)]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. 4470 bool hasErrors) {. (gdb) bt. #0 clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, isysroot=..., hasErrors=false). at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. #1 0x00007ffff1fd2e6a in clang::PCHGenerator::HandleTranslationUnit (this=0x7fffdc023ba0, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/GeneratePCH.cpp:61. #2 0x00007ffff1d96a58 in clang::MultiplexConsumer::HandleTranslationUnit (this=<optimized out>, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/MultiplexConsumer.cpp:305. #3 0x00007ffff37bc16a in clang::ParseAST (S=..., PrintStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::c",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:3923,usability,tool,tools,3923,"]. Thread 4 ""root.exe"" hit Breakpoint 1, clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, . isysroot=..., hasErrors=false) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. 4470 bool hasErrors) {. (gdb) bt. #0 clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, isysroot=..., hasErrors=false). at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. #1 0x00007ffff1fd2e6a in clang::PCHGenerator::HandleTranslationUnit (this=0x7fffdc023ba0, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/GeneratePCH.cpp:61. #2 0x00007ffff1d96a58 in clang::MultiplexConsumer::HandleTranslationUnit (this=<optimized out>, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/MultiplexConsumer.cpp:305. #3 0x00007ffff37bc16a in clang::ParseAST (S=..., PrintStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::callback_fn<compileModuleImpl(clang::CompilerInstance&, clang::SourceLocation, llvm::StringRef, clang::FrontendInputFile, llvm::StringRef, llvm::StringRef, llvm::function_ref<void(clang::CompilerI",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:4128,usability,tool,tools,4128,"8480, . isysroot=..., hasErrors=false) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. 4470 bool hasErrors) {. (gdb) bt. #0 clang::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, isysroot=..., hasErrors=false). at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. #1 0x00007ffff1fd2e6a in clang::PCHGenerator::HandleTranslationUnit (this=0x7fffdc023ba0, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/GeneratePCH.cpp:61. #2 0x00007ffff1d96a58 in clang::MultiplexConsumer::HandleTranslationUnit (this=<optimized out>, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/MultiplexConsumer.cpp:305. #3 0x00007ffff37bc16a in clang::ParseAST (S=..., PrintStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::callback_fn<compileModuleImpl(clang::CompilerInstance&, clang::SourceLocation, llvm::StringRef, clang::FrontendInputFile, llvm::StringRef, llvm::StringRef, llvm::function_ref<void(clang::CompilerInstance&)>, llvm::function_ref<void(clang::CompilerInstance&)>)::<lambda()> >(intptr_t) (callable=140737152777648) at /usr/include/llvm/ADT/STLExtras.h:98. #8 0x00007ffff43bffb3 in llvm::CrashRecoveryConte",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:4297,usability,tool,tools,4297,"ng::ASTWriter::WriteAST (this=this@entry=0x7fffdc023c70, SemaRef=..., OutputFile=""/tmp/org.llvm.clang.yuka/ModuleCache/sys_types.h.pcm"", WritingModule=0x7fffdc018480, isysroot=..., hasErrors=false). at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. #1 0x00007ffff1fd2e6a in clang::PCHGenerator::HandleTranslationUnit (this=0x7fffdc023ba0, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/GeneratePCH.cpp:61. #2 0x00007ffff1d96a58 in clang::MultiplexConsumer::HandleTranslationUnit (this=<optimized out>, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/MultiplexConsumer.cpp:305. #3 0x00007ffff37bc16a in clang::ParseAST (S=..., PrintStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::callback_fn<compileModuleImpl(clang::CompilerInstance&, clang::SourceLocation, llvm::StringRef, clang::FrontendInputFile, llvm::StringRef, llvm::StringRef, llvm::function_ref<void(clang::CompilerInstance&)>, llvm::function_ref<void(clang::CompilerInstance&)>)::<lambda()> >(intptr_t) (callable=140737152777648) at /usr/include/llvm/ADT/STLExtras.h:98. #8 0x00007ffff43bffb3 in llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) () from /home/yuka/module-relwithdeb/lib/libCling.so. #9 0x00007ffff43c00a5 in RunSafelyOnThread_Dispatch(void*) () from /home",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:4481,usability,tool,tools,4481,"Errors=false). at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/ASTWriter.cpp:4470. #1 0x00007ffff1fd2e6a in clang::PCHGenerator::HandleTranslationUnit (this=0x7fffdc023ba0, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/GeneratePCH.cpp:61. #2 0x00007ffff1d96a58 in clang::MultiplexConsumer::HandleTranslationUnit (this=<optimized out>, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/MultiplexConsumer.cpp:305. #3 0x00007ffff37bc16a in clang::ParseAST (S=..., PrintStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::callback_fn<compileModuleImpl(clang::CompilerInstance&, clang::SourceLocation, llvm::StringRef, clang::FrontendInputFile, llvm::StringRef, llvm::StringRef, llvm::function_ref<void(clang::CompilerInstance&)>, llvm::function_ref<void(clang::CompilerInstance&)>)::<lambda()> >(intptr_t) (callable=140737152777648) at /usr/include/llvm/ADT/STLExtras.h:98. #8 0x00007ffff43bffb3 in llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) () from /home/yuka/module-relwithdeb/lib/libCling.so. #9 0x00007ffff43c00a5 in RunSafelyOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #10 0x00007ffff44360ad in ExecuteOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #11 0x00007ffff6e3d08c in start",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:4647,usability,tool,tools,4647,"onUnit (this=0x7fffdc023ba0, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Serialization/GeneratePCH.cpp:61. #2 0x00007ffff1d96a58 in clang::MultiplexConsumer::HandleTranslationUnit (this=<optimized out>, Ctx=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/MultiplexConsumer.cpp:305. #3 0x00007ffff37bc16a in clang::ParseAST (S=..., PrintStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::callback_fn<compileModuleImpl(clang::CompilerInstance&, clang::SourceLocation, llvm::StringRef, clang::FrontendInputFile, llvm::StringRef, llvm::StringRef, llvm::function_ref<void(clang::CompilerInstance&)>, llvm::function_ref<void(clang::CompilerInstance&)>)::<lambda()> >(intptr_t) (callable=140737152777648) at /usr/include/llvm/ADT/STLExtras.h:98. #8 0x00007ffff43bffb3 in llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) () from /home/yuka/module-relwithdeb/lib/libCling.so. #9 0x00007ffff43c00a5 in RunSafelyOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #10 0x00007ffff44360ad in ExecuteOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #11 0x00007ffff6e3d08c in start_thread () from /usr/lib/libpthread.so.0. #12 0x00007ffff6b74e7f in clone () from /usr/lib/libc.so.6. ```. My point is. 1. In user's machine, I think it is unlikely t",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:5610,usability,user,user,5610,"ntStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::callback_fn<compileModuleImpl(clang::CompilerInstance&, clang::SourceLocation, llvm::StringRef, clang::FrontendInputFile, llvm::StringRef, llvm::StringRef, llvm::function_ref<void(clang::CompilerInstance&)>, llvm::function_ref<void(clang::CompilerInstance&)>)::<lambda()> >(intptr_t) (callable=140737152777648) at /usr/include/llvm/ADT/STLExtras.h:98. #8 0x00007ffff43bffb3 in llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) () from /home/yuka/module-relwithdeb/lib/libCling.so. #9 0x00007ffff43c00a5 in RunSafelyOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #10 0x00007ffff44360ad in ExecuteOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #11 0x00007ffff6e3d08c in start_thread () from /usr/lib/libpthread.so.0. #12 0x00007ffff6b74e7f in clone () from /usr/lib/libc.so.6. ```. My point is. 1. In user's machine, I think it is unlikely that LD_LIBRARY_PATH and DYLD_LIBRARY_PATH is unset because if ROOT is successfully installed in the machine, they should be set. Thus I'm not 100% sure that we should add DynamicPath to search because it causes overhead in the lookup. 2. Instead, I think we can change Clang code to abort when it generates implicit modules on-demand and emit error messages. What do you think?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:5993,usability,error,error,5993,"ntStats=<optimized out>, SkipFunctionBodies=<optimized out>) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Parse/ParseAST.cpp:159. #4 0x00007ffff1d67996 in clang::FrontendAction::Execute (this=this@entry=0x7fffeb7f9c00) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/FrontendAction.cpp:896. #5 0x00007ffff1d302f4 in clang::CompilerInstance::ExecuteAction (this=0x7fffebff7ed0, Act=...) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:984. #6 0x00007ffff1d309af in <lambda()>::operator() (__closure=0x7fffebff7db0) at /home/yuka/root/interpreter/llvm/src/tools/clang/lib/Frontend/CompilerInstance.cpp:1154. #7 llvm::function_ref<void()>::callback_fn<compileModuleImpl(clang::CompilerInstance&, clang::SourceLocation, llvm::StringRef, clang::FrontendInputFile, llvm::StringRef, llvm::StringRef, llvm::function_ref<void(clang::CompilerInstance&)>, llvm::function_ref<void(clang::CompilerInstance&)>)::<lambda()> >(intptr_t) (callable=140737152777648) at /usr/include/llvm/ADT/STLExtras.h:98. #8 0x00007ffff43bffb3 in llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) () from /home/yuka/module-relwithdeb/lib/libCling.so. #9 0x00007ffff43c00a5 in RunSafelyOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #10 0x00007ffff44360ad in ExecuteOnThread_Dispatch(void*) () from /home/yuka/module-relwithdeb/lib/libCling.so. #11 0x00007ffff6e3d08c in start_thread () from /usr/lib/libpthread.so.0. #12 0x00007ffff6b74e7f in clone () from /usr/lib/libc.so.6. ```. My point is. 1. In user's machine, I think it is unlikely that LD_LIBRARY_PATH and DYLD_LIBRARY_PATH is unset because if ROOT is successfully installed in the machine, they should be set. Thus I'm not 100% sure that we should add DynamicPath to search because it causes overhead in the lookup. 2. Instead, I think we can change Clang code to abort when it generates implicit modules on-demand and emit error messages. What do you think?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:60,deployability,modul,module,60,I think we already search LD_LIBRARY_PATH to get a prebuild module cache?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:60,modifiability,modul,module,60,I think we already search LD_LIBRARY_PATH to get a prebuild module cache?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:67,performance,cach,cache,67,I think we already search LD_LIBRARY_PATH to get a prebuild module cache?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:60,safety,modul,module,60,I think we already search LD_LIBRARY_PATH to get a prebuild module cache?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:305,interoperability,specif,specific,305,"We have similar functionality in the [CIFactory.cpp](https://github.com/root-project/root/blob/master/interpreter/cling/lib/Interpreter/CIFactory.cpp#L1085-L1090) already. However, I can't really decide which is the better approach here. Maybe this one is still preferable because this feature seems ROOT-specific.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:262,usability,prefer,preferable,262,"We have similar functionality in the [CIFactory.cpp](https://github.com/root-project/root/blob/master/interpreter/cling/lib/Interpreter/CIFactory.cpp#L1085-L1090) already. However, I can't really decide which is the better approach here. Maybe this one is still preferable because this feature seems ROOT-specific.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:75,availability,failur,failures,75,"@vgvassilev , @yamaguchi1024 Is this PR still relevant ? Should we fix the failures and merge ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:75,deployability,fail,failures,75,"@vgvassilev , @yamaguchi1024 Is this PR still relevant ? Should we fix the failures and merge ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:75,performance,failur,failures,75,"@vgvassilev , @yamaguchi1024 Is this PR still relevant ? Should we fix the failures and merge ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:75,reliability,fail,failures,75,"@vgvassilev , @yamaguchi1024 Is this PR still relevant ? Should we fix the failures and merge ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:19,deployability,version,version,19,There is different version of this code in the codebase already.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:19,integrability,version,version,19,There is different version of this code in the codebase already.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1761:19,modifiability,version,version,19,There is different version of this code in the codebase already.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1761
https://github.com/root-project/root/pull/1762:247,performance,memor,memory,247,I do not understand this PR. It's swapping `GetListOfMethods()` (which creates AST nodes for all functions) by `gInterpreter->MethodInfo_Next(t)` (which creates AST nodes for all functions). Which also explains why there's almost no difference in memory usage - the only difference *could* be that we don't create `TMethod` objects for the AST nodes.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1762
https://github.com/root-project/root/pull/1762:9,testability,understand,understand,9,I do not understand this PR. It's swapping `GetListOfMethods()` (which creates AST nodes for all functions) by `gInterpreter->MethodInfo_Next(t)` (which creates AST nodes for all functions). Which also explains why there's almost no difference in memory usage - the only difference *could* be that we don't create `TMethod` objects for the AST nodes.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1762
https://github.com/root-project/root/pull/1762:247,usability,memor,memory,247,I do not understand this PR. It's swapping `GetListOfMethods()` (which creates AST nodes for all functions) by `gInterpreter->MethodInfo_Next(t)` (which creates AST nodes for all functions). Which also explains why there's almost no difference in memory usage - the only difference *could* be that we don't create `TMethod` objects for the AST nodes.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1762
https://github.com/root-project/root/pull/1763:1,interoperability,Share,SharedMem,1,"""SharedMem"" reads as ""shared memory"" [ http://man7.org/linux/man-pages/man7/shm_overview.7.html ] . Is that the intent?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1763
https://github.com/root-project/root/pull/1763:22,interoperability,share,shared,22,"""SharedMem"" reads as ""shared memory"" [ http://man7.org/linux/man-pages/man7/shm_overview.7.html ] . Is that the intent?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1763
https://github.com/root-project/root/pull/1763:29,performance,memor,memory,29,"""SharedMem"" reads as ""shared memory"" [ http://man7.org/linux/man-pages/man7/shm_overview.7.html ] . Is that the intent?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1763
https://github.com/root-project/root/pull/1763:29,usability,memor,memory,29,"""SharedMem"" reads as ""shared memory"" [ http://man7.org/linux/man-pages/man7/shm_overview.7.html ] . Is that the intent?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1763
https://github.com/root-project/root/pull/1763:36,safety,review,review,36,@pcanal it's ready to merge; please review.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1763
https://github.com/root-project/root/pull/1763:36,testability,review,review,36,@pcanal it's ready to merge; please review.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1763
https://github.com/root-project/root/pull/1764:44,deployability,integr,integration,44,great PR! Do we want to have unit tests and integration tests too?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1764
https://github.com/root-project/root/pull/1764:44,integrability,integration test,integration tests,44,great PR! Do we want to have unit tests and integration tests too?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1764
https://github.com/root-project/root/pull/1764:44,interoperability,integr,integration,44,great PR! Do we want to have unit tests and integration tests too?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1764
https://github.com/root-project/root/pull/1764:44,modifiability,integr,integration,44,great PR! Do we want to have unit tests and integration tests too?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1764
https://github.com/root-project/root/pull/1764:44,reliability,integr,integration,44,great PR! Do we want to have unit tests and integration tests too?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1764
https://github.com/root-project/root/pull/1764:34,safety,test,tests,34,great PR! Do we want to have unit tests and integration tests too?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1764
https://github.com/root-project/root/pull/1764:56,safety,test,tests,56,great PR! Do we want to have unit tests and integration tests too?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1764
https://github.com/root-project/root/pull/1764:44,security,integr,integration,44,great PR! Do we want to have unit tests and integration tests too?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1764
https://github.com/root-project/root/pull/1764:29,testability,unit,unit,29,great PR! Do we want to have unit tests and integration tests too?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1764
https://github.com/root-project/root/pull/1764:34,testability,test,tests,34,great PR! Do we want to have unit tests and integration tests too?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1764
https://github.com/root-project/root/pull/1764:44,testability,integr,integration,44,great PR! Do we want to have unit tests and integration tests too?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1764
https://github.com/root-project/root/pull/1764:56,testability,test,tests,56,great PR! Do we want to have unit tests and integration tests too?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1764
https://github.com/root-project/root/pull/1764:4,availability,failur,failure,4,"The failure of the snapshot test is understood, a complementary PR will come for roottest.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1764
https://github.com/root-project/root/pull/1764:4,deployability,fail,failure,4,"The failure of the snapshot test is understood, a complementary PR will come for roottest.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1764
https://github.com/root-project/root/pull/1764:4,performance,failur,failure,4,"The failure of the snapshot test is understood, a complementary PR will come for roottest.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1764
https://github.com/root-project/root/pull/1764:4,reliability,fail,failure,4,"The failure of the snapshot test is understood, a complementary PR will come for roottest.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1764
https://github.com/root-project/root/pull/1764:28,safety,test,test,28,"The failure of the snapshot test is understood, a complementary PR will come for roottest.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1764
https://github.com/root-project/root/pull/1764:50,safety,compl,complementary,50,"The failure of the snapshot test is understood, a complementary PR will come for roottest.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1764
https://github.com/root-project/root/pull/1764:50,security,compl,complementary,50,"The failure of the snapshot test is understood, a complementary PR will come for roottest.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1764
https://github.com/root-project/root/pull/1764:28,testability,test,test,28,"The failure of the snapshot test is understood, a complementary PR will come for roottest.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1764
https://github.com/root-project/root/pull/1766:13,usability,support,supported,13,DAVIX is not supported and should be disabled on Windows.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1766
https://github.com/root-project/root/pull/1766:11,deployability,build,build,11,@phsft-bot build with flags -Dbuiltin_davix=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1766
https://github.com/root-project/root/pull/1766:9,availability,failur,failures,9,"Previous failures were expected (could not find Davix 0.6.4, because externals has version 0.6.2 only, which fails tests).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1766
https://github.com/root-project/root/pull/1766:9,deployability,fail,failures,9,"Previous failures were expected (could not find Davix 0.6.4, because externals has version 0.6.2 only, which fails tests).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1766
https://github.com/root-project/root/pull/1766:83,deployability,version,version,83,"Previous failures were expected (could not find Davix 0.6.4, because externals has version 0.6.2 only, which fails tests).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1766
https://github.com/root-project/root/pull/1766:109,deployability,fail,fails,109,"Previous failures were expected (could not find Davix 0.6.4, because externals has version 0.6.2 only, which fails tests).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1766
https://github.com/root-project/root/pull/1766:83,integrability,version,version,83,"Previous failures were expected (could not find Davix 0.6.4, because externals has version 0.6.2 only, which fails tests).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1766
https://github.com/root-project/root/pull/1766:83,modifiability,version,version,83,"Previous failures were expected (could not find Davix 0.6.4, because externals has version 0.6.2 only, which fails tests).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1766
https://github.com/root-project/root/pull/1766:9,performance,failur,failures,9,"Previous failures were expected (could not find Davix 0.6.4, because externals has version 0.6.2 only, which fails tests).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1766
https://github.com/root-project/root/pull/1766:9,reliability,fail,failures,9,"Previous failures were expected (could not find Davix 0.6.4, because externals has version 0.6.2 only, which fails tests).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1766
https://github.com/root-project/root/pull/1766:109,reliability,fail,fails,109,"Previous failures were expected (could not find Davix 0.6.4, because externals has version 0.6.2 only, which fails tests).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1766
https://github.com/root-project/root/pull/1766:115,safety,test,tests,115,"Previous failures were expected (could not find Davix 0.6.4, because externals has version 0.6.2 only, which fails tests).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1766
https://github.com/root-project/root/pull/1766:115,testability,test,tests,115,"Previous failures were expected (could not find Davix 0.6.4, because externals has version 0.6.2 only, which fails tests).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1766
https://github.com/root-project/root/pull/1766:17,deployability,Fail,Failed,17,Checked locally. Failed on mac because it couldn't find OpenSSL. Should work with next command.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1766
https://github.com/root-project/root/pull/1766:17,reliability,Fail,Failed,17,Checked locally. Failed on mac because it couldn't find OpenSSL. Should work with next command.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1766
https://github.com/root-project/root/pull/1766:87,usability,command,command,87,Checked locally. Failed on mac because it couldn't find OpenSSL. Should work with next command.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1766
https://github.com/root-project/root/pull/1766:11,deployability,build,build,11,@phsft-bot build just on mac1013/native with flags -Dbuiltin_davix=ON -Dbuiltin_openssl=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1766
https://github.com/root-project/root/pull/1766:20,deployability,updat,update,20,Merged with OpenSSL update in #1845. Closing this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1766
https://github.com/root-project/root/pull/1766:20,safety,updat,update,20,Merged with OpenSSL update in #1845. Closing this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1766
https://github.com/root-project/root/pull/1766:20,security,updat,update,20,Merged with OpenSSL update in #1845. Closing this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1766
https://github.com/root-project/root/pull/1768:157,modifiability,inherit,inherited,157,"Very nice investigation. Thanks! For completeness sake, it should be noted that to be used in THashList search by name, TNamedBranchProxy should have either inherited from TNamed or overload TObject::Hash. > A real usecase from CMS where the mass of the W boson is studied shows a significant speedup (30%). I assume the gain comes mostly from not reading the branch twice rather than a significant speed difference between THashList and unordered_map. Thanks,. Philippe.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1768
https://github.com/root-project/root/pull/1768:37,safety,compl,completeness,37,"Very nice investigation. Thanks! For completeness sake, it should be noted that to be used in THashList search by name, TNamedBranchProxy should have either inherited from TNamed or overload TObject::Hash. > A real usecase from CMS where the mass of the W boson is studied shows a significant speedup (30%). I assume the gain comes mostly from not reading the branch twice rather than a significant speed difference between THashList and unordered_map. Thanks,. Philippe.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1768
https://github.com/root-project/root/pull/1768:37,security,compl,completeness,37,"Very nice investigation. Thanks! For completeness sake, it should be noted that to be used in THashList search by name, TNamedBranchProxy should have either inherited from TNamed or overload TObject::Hash. > A real usecase from CMS where the mass of the W boson is studied shows a significant speedup (30%). I assume the gain comes mostly from not reading the branch twice rather than a significant speed difference between THashList and unordered_map. Thanks,. Philippe.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1768
https://github.com/root-project/root/pull/1768:200,security,Hash,Hash,200,"Very nice investigation. Thanks! For completeness sake, it should be noted that to be used in THashList search by name, TNamedBranchProxy should have either inherited from TNamed or overload TObject::Hash. > A real usecase from CMS where the mass of the W boson is studied shows a significant speedup (30%). I assume the gain comes mostly from not reading the branch twice rather than a significant speed difference between THashList and unordered_map. Thanks,. Philippe.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1768
https://github.com/root-project/root/pull/1768:281,security,sign,significant,281,"Very nice investigation. Thanks! For completeness sake, it should be noted that to be used in THashList search by name, TNamedBranchProxy should have either inherited from TNamed or overload TObject::Hash. > A real usecase from CMS where the mass of the W boson is studied shows a significant speedup (30%). I assume the gain comes mostly from not reading the branch twice rather than a significant speed difference between THashList and unordered_map. Thanks,. Philippe.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1768
https://github.com/root-project/root/pull/1768:387,security,sign,significant,387,"Very nice investigation. Thanks! For completeness sake, it should be noted that to be used in THashList search by name, TNamedBranchProxy should have either inherited from TNamed or overload TObject::Hash. > A real usecase from CMS where the mass of the W boson is studied shows a significant speedup (30%). I assume the gain comes mostly from not reading the branch twice rather than a significant speed difference between THashList and unordered_map. Thanks,. Philippe.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1768
https://github.com/root-project/root/pull/1768:1001,availability,consist,consist,1001,"@pcanal . One could have used TNamed: I did not think about that. That might not have been enough though: see my comment below. About the speedup: it is indeed not due to the different container! If there is a difference in runtime between the two, it is undetectable. The difference comes from the fact that the graph built with TDF nodes is sophisticated and the same columns end up being inputs of Filters and Defines. As a result a single column, even holding a long-ish array, ends up being read many times. Given that the proxy is not re-used, deserialisation happened N times, with the associated overhead. @Axel-Naumann . About the crashes: I am surprised about so many crashes - checked the TDF tests on ubu16 before creating the PR and only the dataframe_friends test failed. I think that one is understood. The problem is that the same proxy is used for branches with the same name even if they come from two different trees which are friends. To solve this case, a possible solution would consist in hashing (with a map or an unordered_set, to be seen) not only the branch name but also some info about the tree to distinguish the two cases. About the other crashes, working on those to understand where they are coming from.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1768
https://github.com/root-project/root/pull/1768:185,deployability,contain,container,185,"@pcanal . One could have used TNamed: I did not think about that. That might not have been enough though: see my comment below. About the speedup: it is indeed not due to the different container! If there is a difference in runtime between the two, it is undetectable. The difference comes from the fact that the graph built with TDF nodes is sophisticated and the same columns end up being inputs of Filters and Defines. As a result a single column, even holding a long-ish array, ends up being read many times. Given that the proxy is not re-used, deserialisation happened N times, with the associated overhead. @Axel-Naumann . About the crashes: I am surprised about so many crashes - checked the TDF tests on ubu16 before creating the PR and only the dataframe_friends test failed. I think that one is understood. The problem is that the same proxy is used for branches with the same name even if they come from two different trees which are friends. To solve this case, a possible solution would consist in hashing (with a map or an unordered_set, to be seen) not only the branch name but also some info about the tree to distinguish the two cases. About the other crashes, working on those to understand where they are coming from.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1768
https://github.com/root-project/root/pull/1768:778,deployability,fail,failed,778,"@pcanal . One could have used TNamed: I did not think about that. That might not have been enough though: see my comment below. About the speedup: it is indeed not due to the different container! If there is a difference in runtime between the two, it is undetectable. The difference comes from the fact that the graph built with TDF nodes is sophisticated and the same columns end up being inputs of Filters and Defines. As a result a single column, even holding a long-ish array, ends up being read many times. Given that the proxy is not re-used, deserialisation happened N times, with the associated overhead. @Axel-Naumann . About the crashes: I am surprised about so many crashes - checked the TDF tests on ubu16 before creating the PR and only the dataframe_friends test failed. I think that one is understood. The problem is that the same proxy is used for branches with the same name even if they come from two different trees which are friends. To solve this case, a possible solution would consist in hashing (with a map or an unordered_set, to be seen) not only the branch name but also some info about the tree to distinguish the two cases. About the other crashes, working on those to understand where they are coming from.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1768
https://github.com/root-project/root/pull/1768:401,integrability,Filter,Filters,401,"@pcanal . One could have used TNamed: I did not think about that. That might not have been enough though: see my comment below. About the speedup: it is indeed not due to the different container! If there is a difference in runtime between the two, it is undetectable. The difference comes from the fact that the graph built with TDF nodes is sophisticated and the same columns end up being inputs of Filters and Defines. As a result a single column, even holding a long-ish array, ends up being read many times. Given that the proxy is not re-used, deserialisation happened N times, with the associated overhead. @Axel-Naumann . About the crashes: I am surprised about so many crashes - checked the TDF tests on ubu16 before creating the PR and only the dataframe_friends test failed. I think that one is understood. The problem is that the same proxy is used for branches with the same name even if they come from two different trees which are friends. To solve this case, a possible solution would consist in hashing (with a map or an unordered_set, to be seen) not only the branch name but also some info about the tree to distinguish the two cases. About the other crashes, working on those to understand where they are coming from.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1768
https://github.com/root-project/root/pull/1768:528,interoperability,prox,proxy,528,"@pcanal . One could have used TNamed: I did not think about that. That might not have been enough though: see my comment below. About the speedup: it is indeed not due to the different container! If there is a difference in runtime between the two, it is undetectable. The difference comes from the fact that the graph built with TDF nodes is sophisticated and the same columns end up being inputs of Filters and Defines. As a result a single column, even holding a long-ish array, ends up being read many times. Given that the proxy is not re-used, deserialisation happened N times, with the associated overhead. @Axel-Naumann . About the crashes: I am surprised about so many crashes - checked the TDF tests on ubu16 before creating the PR and only the dataframe_friends test failed. I think that one is understood. The problem is that the same proxy is used for branches with the same name even if they come from two different trees which are friends. To solve this case, a possible solution would consist in hashing (with a map or an unordered_set, to be seen) not only the branch name but also some info about the tree to distinguish the two cases. About the other crashes, working on those to understand where they are coming from.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1768
https://github.com/root-project/root/pull/1768:847,interoperability,prox,proxy,847,"@pcanal . One could have used TNamed: I did not think about that. That might not have been enough though: see my comment below. About the speedup: it is indeed not due to the different container! If there is a difference in runtime between the two, it is undetectable. The difference comes from the fact that the graph built with TDF nodes is sophisticated and the same columns end up being inputs of Filters and Defines. As a result a single column, even holding a long-ish array, ends up being read many times. Given that the proxy is not re-used, deserialisation happened N times, with the associated overhead. @Axel-Naumann . About the crashes: I am surprised about so many crashes - checked the TDF tests on ubu16 before creating the PR and only the dataframe_friends test failed. I think that one is understood. The problem is that the same proxy is used for branches with the same name even if they come from two different trees which are friends. To solve this case, a possible solution would consist in hashing (with a map or an unordered_set, to be seen) not only the branch name but also some info about the tree to distinguish the two cases. About the other crashes, working on those to understand where they are coming from.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1768
https://github.com/root-project/root/pull/1768:506,performance,time,times,506,"@pcanal . One could have used TNamed: I did not think about that. That might not have been enough though: see my comment below. About the speedup: it is indeed not due to the different container! If there is a difference in runtime between the two, it is undetectable. The difference comes from the fact that the graph built with TDF nodes is sophisticated and the same columns end up being inputs of Filters and Defines. As a result a single column, even holding a long-ish array, ends up being read many times. Given that the proxy is not re-used, deserialisation happened N times, with the associated overhead. @Axel-Naumann . About the crashes: I am surprised about so many crashes - checked the TDF tests on ubu16 before creating the PR and only the dataframe_friends test failed. I think that one is understood. The problem is that the same proxy is used for branches with the same name even if they come from two different trees which are friends. To solve this case, a possible solution would consist in hashing (with a map or an unordered_set, to be seen) not only the branch name but also some info about the tree to distinguish the two cases. About the other crashes, working on those to understand where they are coming from.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1768
https://github.com/root-project/root/pull/1768:577,performance,time,times,577,"@pcanal . One could have used TNamed: I did not think about that. That might not have been enough though: see my comment below. About the speedup: it is indeed not due to the different container! If there is a difference in runtime between the two, it is undetectable. The difference comes from the fact that the graph built with TDF nodes is sophisticated and the same columns end up being inputs of Filters and Defines. As a result a single column, even holding a long-ish array, ends up being read many times. Given that the proxy is not re-used, deserialisation happened N times, with the associated overhead. @Axel-Naumann . About the crashes: I am surprised about so many crashes - checked the TDF tests on ubu16 before creating the PR and only the dataframe_friends test failed. I think that one is understood. The problem is that the same proxy is used for branches with the same name even if they come from two different trees which are friends. To solve this case, a possible solution would consist in hashing (with a map or an unordered_set, to be seen) not only the branch name but also some info about the tree to distinguish the two cases. About the other crashes, working on those to understand where they are coming from.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1768
https://github.com/root-project/root/pull/1768:604,performance,overhead,overhead,604,"@pcanal . One could have used TNamed: I did not think about that. That might not have been enough though: see my comment below. About the speedup: it is indeed not due to the different container! If there is a difference in runtime between the two, it is undetectable. The difference comes from the fact that the graph built with TDF nodes is sophisticated and the same columns end up being inputs of Filters and Defines. As a result a single column, even holding a long-ish array, ends up being read many times. Given that the proxy is not re-used, deserialisation happened N times, with the associated overhead. @Axel-Naumann . About the crashes: I am surprised about so many crashes - checked the TDF tests on ubu16 before creating the PR and only the dataframe_friends test failed. I think that one is understood. The problem is that the same proxy is used for branches with the same name even if they come from two different trees which are friends. To solve this case, a possible solution would consist in hashing (with a map or an unordered_set, to be seen) not only the branch name but also some info about the tree to distinguish the two cases. About the other crashes, working on those to understand where they are coming from.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1768
https://github.com/root-project/root/pull/1768:778,reliability,fail,failed,778,"@pcanal . One could have used TNamed: I did not think about that. That might not have been enough though: see my comment below. About the speedup: it is indeed not due to the different container! If there is a difference in runtime between the two, it is undetectable. The difference comes from the fact that the graph built with TDF nodes is sophisticated and the same columns end up being inputs of Filters and Defines. As a result a single column, even holding a long-ish array, ends up being read many times. Given that the proxy is not re-used, deserialisation happened N times, with the associated overhead. @Axel-Naumann . About the crashes: I am surprised about so many crashes - checked the TDF tests on ubu16 before creating the PR and only the dataframe_friends test failed. I think that one is understood. The problem is that the same proxy is used for branches with the same name even if they come from two different trees which are friends. To solve this case, a possible solution would consist in hashing (with a map or an unordered_set, to be seen) not only the branch name but also some info about the tree to distinguish the two cases. About the other crashes, working on those to understand where they are coming from.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1768
https://github.com/root-project/root/pull/1768:391,safety,input,inputs,391,"@pcanal . One could have used TNamed: I did not think about that. That might not have been enough though: see my comment below. About the speedup: it is indeed not due to the different container! If there is a difference in runtime between the two, it is undetectable. The difference comes from the fact that the graph built with TDF nodes is sophisticated and the same columns end up being inputs of Filters and Defines. As a result a single column, even holding a long-ish array, ends up being read many times. Given that the proxy is not re-used, deserialisation happened N times, with the associated overhead. @Axel-Naumann . About the crashes: I am surprised about so many crashes - checked the TDF tests on ubu16 before creating the PR and only the dataframe_friends test failed. I think that one is understood. The problem is that the same proxy is used for branches with the same name even if they come from two different trees which are friends. To solve this case, a possible solution would consist in hashing (with a map or an unordered_set, to be seen) not only the branch name but also some info about the tree to distinguish the two cases. About the other crashes, working on those to understand where they are coming from.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1768
https://github.com/root-project/root/pull/1768:704,safety,test,tests,704,"@pcanal . One could have used TNamed: I did not think about that. That might not have been enough though: see my comment below. About the speedup: it is indeed not due to the different container! If there is a difference in runtime between the two, it is undetectable. The difference comes from the fact that the graph built with TDF nodes is sophisticated and the same columns end up being inputs of Filters and Defines. As a result a single column, even holding a long-ish array, ends up being read many times. Given that the proxy is not re-used, deserialisation happened N times, with the associated overhead. @Axel-Naumann . About the crashes: I am surprised about so many crashes - checked the TDF tests on ubu16 before creating the PR and only the dataframe_friends test failed. I think that one is understood. The problem is that the same proxy is used for branches with the same name even if they come from two different trees which are friends. To solve this case, a possible solution would consist in hashing (with a map or an unordered_set, to be seen) not only the branch name but also some info about the tree to distinguish the two cases. About the other crashes, working on those to understand where they are coming from.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1768
https://github.com/root-project/root/pull/1768:773,safety,test,test,773,"@pcanal . One could have used TNamed: I did not think about that. That might not have been enough though: see my comment below. About the speedup: it is indeed not due to the different container! If there is a difference in runtime between the two, it is undetectable. The difference comes from the fact that the graph built with TDF nodes is sophisticated and the same columns end up being inputs of Filters and Defines. As a result a single column, even holding a long-ish array, ends up being read many times. Given that the proxy is not re-used, deserialisation happened N times, with the associated overhead. @Axel-Naumann . About the crashes: I am surprised about so many crashes - checked the TDF tests on ubu16 before creating the PR and only the dataframe_friends test failed. I think that one is understood. The problem is that the same proxy is used for branches with the same name even if they come from two different trees which are friends. To solve this case, a possible solution would consist in hashing (with a map or an unordered_set, to be seen) not only the branch name but also some info about the tree to distinguish the two cases. About the other crashes, working on those to understand where they are coming from.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1768
https://github.com/root-project/root/pull/1768:1012,security,hash,hashing,1012,"@pcanal . One could have used TNamed: I did not think about that. That might not have been enough though: see my comment below. About the speedup: it is indeed not due to the different container! If there is a difference in runtime between the two, it is undetectable. The difference comes from the fact that the graph built with TDF nodes is sophisticated and the same columns end up being inputs of Filters and Defines. As a result a single column, even holding a long-ish array, ends up being read many times. Given that the proxy is not re-used, deserialisation happened N times, with the associated overhead. @Axel-Naumann . About the crashes: I am surprised about so many crashes - checked the TDF tests on ubu16 before creating the PR and only the dataframe_friends test failed. I think that one is understood. The problem is that the same proxy is used for branches with the same name even if they come from two different trees which are friends. To solve this case, a possible solution would consist in hashing (with a map or an unordered_set, to be seen) not only the branch name but also some info about the tree to distinguish the two cases. About the other crashes, working on those to understand where they are coming from.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1768
https://github.com/root-project/root/pull/1768:704,testability,test,tests,704,"@pcanal . One could have used TNamed: I did not think about that. That might not have been enough though: see my comment below. About the speedup: it is indeed not due to the different container! If there is a difference in runtime between the two, it is undetectable. The difference comes from the fact that the graph built with TDF nodes is sophisticated and the same columns end up being inputs of Filters and Defines. As a result a single column, even holding a long-ish array, ends up being read many times. Given that the proxy is not re-used, deserialisation happened N times, with the associated overhead. @Axel-Naumann . About the crashes: I am surprised about so many crashes - checked the TDF tests on ubu16 before creating the PR and only the dataframe_friends test failed. I think that one is understood. The problem is that the same proxy is used for branches with the same name even if they come from two different trees which are friends. To solve this case, a possible solution would consist in hashing (with a map or an unordered_set, to be seen) not only the branch name but also some info about the tree to distinguish the two cases. About the other crashes, working on those to understand where they are coming from.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1768
https://github.com/root-project/root/pull/1768:773,testability,test,test,773,"@pcanal . One could have used TNamed: I did not think about that. That might not have been enough though: see my comment below. About the speedup: it is indeed not due to the different container! If there is a difference in runtime between the two, it is undetectable. The difference comes from the fact that the graph built with TDF nodes is sophisticated and the same columns end up being inputs of Filters and Defines. As a result a single column, even holding a long-ish array, ends up being read many times. Given that the proxy is not re-used, deserialisation happened N times, with the associated overhead. @Axel-Naumann . About the crashes: I am surprised about so many crashes - checked the TDF tests on ubu16 before creating the PR and only the dataframe_friends test failed. I think that one is understood. The problem is that the same proxy is used for branches with the same name even if they come from two different trees which are friends. To solve this case, a possible solution would consist in hashing (with a map or an unordered_set, to be seen) not only the branch name but also some info about the tree to distinguish the two cases. About the other crashes, working on those to understand where they are coming from.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1768
https://github.com/root-project/root/pull/1768:1199,testability,understand,understand,1199,"@pcanal . One could have used TNamed: I did not think about that. That might not have been enough though: see my comment below. About the speedup: it is indeed not due to the different container! If there is a difference in runtime between the two, it is undetectable. The difference comes from the fact that the graph built with TDF nodes is sophisticated and the same columns end up being inputs of Filters and Defines. As a result a single column, even holding a long-ish array, ends up being read many times. Given that the proxy is not re-used, deserialisation happened N times, with the associated overhead. @Axel-Naumann . About the crashes: I am surprised about so many crashes - checked the TDF tests on ubu16 before creating the PR and only the dataframe_friends test failed. I think that one is understood. The problem is that the same proxy is used for branches with the same name even if they come from two different trees which are friends. To solve this case, a possible solution would consist in hashing (with a map or an unordered_set, to be seen) not only the branch name but also some info about the tree to distinguish the two cases. About the other crashes, working on those to understand where they are coming from.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1768
https://github.com/root-project/root/pull/1768:391,usability,input,inputs,391,"@pcanal . One could have used TNamed: I did not think about that. That might not have been enough though: see my comment below. About the speedup: it is indeed not due to the different container! If there is a difference in runtime between the two, it is undetectable. The difference comes from the fact that the graph built with TDF nodes is sophisticated and the same columns end up being inputs of Filters and Defines. As a result a single column, even holding a long-ish array, ends up being read many times. Given that the proxy is not re-used, deserialisation happened N times, with the associated overhead. @Axel-Naumann . About the crashes: I am surprised about so many crashes - checked the TDF tests on ubu16 before creating the PR and only the dataframe_friends test failed. I think that one is understood. The problem is that the same proxy is used for branches with the same name even if they come from two different trees which are friends. To solve this case, a possible solution would consist in hashing (with a map or an unordered_set, to be seen) not only the branch name but also some info about the tree to distinguish the two cases. About the other crashes, working on those to understand where they are coming from.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1768
https://github.com/root-project/root/pull/1768:1001,usability,consist,consist,1001,"@pcanal . One could have used TNamed: I did not think about that. That might not have been enough though: see my comment below. About the speedup: it is indeed not due to the different container! If there is a difference in runtime between the two, it is undetectable. The difference comes from the fact that the graph built with TDF nodes is sophisticated and the same columns end up being inputs of Filters and Defines. As a result a single column, even holding a long-ish array, ends up being read many times. Given that the proxy is not re-used, deserialisation happened N times, with the associated overhead. @Axel-Naumann . About the crashes: I am surprised about so many crashes - checked the TDF tests on ubu16 before creating the PR and only the dataframe_friends test failed. I think that one is understood. The problem is that the same proxy is used for branches with the same name even if they come from two different trees which are friends. To solve this case, a possible solution would consist in hashing (with a map or an unordered_set, to be seen) not only the branch name but also some info about the tree to distinguish the two cases. About the other crashes, working on those to understand where they are coming from.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1768
https://github.com/root-project/root/pull/1768:40,availability,failur,failures,40,"Working on osx, I now can reproduce the failures. Apart from ttree_friends, they are due to some change between these two commits: d3b27fb46c..c82254e4de",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1768
https://github.com/root-project/root/pull/1768:40,deployability,fail,failures,40,"Working on osx, I now can reproduce the failures. Apart from ttree_friends, they are due to some change between these two commits: d3b27fb46c..c82254e4de",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1768
https://github.com/root-project/root/pull/1768:40,performance,failur,failures,40,"Working on osx, I now can reproduce the failures. Apart from ttree_friends, they are due to some change between these two commits: d3b27fb46c..c82254e4de",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1768
https://github.com/root-project/root/pull/1768:40,reliability,fail,failures,40,"Working on osx, I now can reproduce the failures. Apart from ttree_friends, they are due to some change between these two commits: d3b27fb46c..c82254e4de",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1768
https://github.com/root-project/root/pull/1769:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1769
https://github.com/root-project/root/pull/1769:79,deployability,log,log,79,"@dan131riley For the record, you should consider adding here and/or the commit log, the longer explanation of the mechanism of the problem that you sent by email. Thanks.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1769
https://github.com/root-project/root/pull/1769:79,safety,log,log,79,"@dan131riley For the record, you should consider adding here and/or the commit log, the longer explanation of the mechanism of the problem that you sent by email. Thanks.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1769
https://github.com/root-project/root/pull/1769:79,security,log,log,79,"@dan131riley For the record, you should consider adding here and/or the commit log, the longer explanation of the mechanism of the problem that you sent by email. Thanks.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1769
https://github.com/root-project/root/pull/1769:79,testability,log,log,79,"@dan131riley For the record, you should consider adding here and/or the commit log, the longer explanation of the mechanism of the problem that you sent by email. Thanks.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1769
https://github.com/root-project/root/pull/1769:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1769
https://github.com/root-project/root/pull/1772:6,deployability,updat,update,6,TODO: update release notes to mention the change in behavior,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1772
https://github.com/root-project/root/pull/1772:13,deployability,releas,release,13,TODO: update release notes to mention the change in behavior,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1772
https://github.com/root-project/root/pull/1772:6,safety,updat,update,6,TODO: update release notes to mention the change in behavior,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1772
https://github.com/root-project/root/pull/1772:6,security,updat,update,6,TODO: update release notes to mention the change in behavior,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1772
https://github.com/root-project/root/pull/1772:52,usability,behavi,behavior,52,TODO: update release notes to mention the change in behavior,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1772
https://github.com/root-project/root/pull/1773:31,safety,test,test-case,31,"@etejedor @dpiparo I changed a test-case to use a different input file for the friend and the main TTree. If I'm not mistaken, it turns out that we never read the friend in this case, we always read the main tree. If it's true, this is a big fat bug.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1773
https://github.com/root-project/root/pull/1773:60,safety,input,input,60,"@etejedor @dpiparo I changed a test-case to use a different input file for the friend and the main TTree. If I'm not mistaken, it turns out that we never read the friend in this case, we always read the main tree. If it's true, this is a big fat bug.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1773
https://github.com/root-project/root/pull/1773:31,testability,test,test-case,31,"@etejedor @dpiparo I changed a test-case to use a different input file for the friend and the main TTree. If I'm not mistaken, it turns out that we never read the friend in this case, we always read the main tree. If it's true, this is a big fat bug.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1773
https://github.com/root-project/root/pull/1773:60,usability,input,input,60,"@etejedor @dpiparo I changed a test-case to use a different input file for the friend and the main TTree. If I'm not mistaken, it turns out that we never read the friend in this case, we always read the main tree. If it's true, this is a big fat bug.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1773
https://github.com/root-project/root/pull/1773:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1773
https://github.com/root-project/root/pull/1773:11,deployability,build,build,11,@phsft-bot build please,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1773
https://github.com/root-project/root/pull/1774:42,deployability,build,building,42,"Hi @Axel-Naumann , great! But here we are building the entire ROOT + cling with O3, something like an OPTIMIZED build - doesn't this potentially introduce changes in the results of the users? I am not against it in principle, on the contrary, I encourage aggressive flags, but they may have a consequence, right?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1774
https://github.com/root-project/root/pull/1774:112,deployability,build,build,112,"Hi @Axel-Naumann , great! But here we are building the entire ROOT + cling with O3, something like an OPTIMIZED build - doesn't this potentially introduce changes in the results of the users? I am not against it in principle, on the contrary, I encourage aggressive flags, but they may have a consequence, right?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1774
https://github.com/root-project/root/pull/1774:102,energy efficiency,OPTIM,OPTIMIZED,102,"Hi @Axel-Naumann , great! But here we are building the entire ROOT + cling with O3, something like an OPTIMIZED build - doesn't this potentially introduce changes in the results of the users? I am not against it in principle, on the contrary, I encourage aggressive flags, but they may have a consequence, right?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1774
https://github.com/root-project/root/pull/1774:102,performance,OPTIMIZ,OPTIMIZED,102,"Hi @Axel-Naumann , great! But here we are building the entire ROOT + cling with O3, something like an OPTIMIZED build - doesn't this potentially introduce changes in the results of the users? I am not against it in principle, on the contrary, I encourage aggressive flags, but they may have a consequence, right?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1774
https://github.com/root-project/root/pull/1774:120,reliability,doe,doesn,120,"Hi @Axel-Naumann , great! But here we are building the entire ROOT + cling with O3, something like an OPTIMIZED build - doesn't this potentially introduce changes in the results of the users? I am not against it in principle, on the contrary, I encourage aggressive flags, but they may have a consequence, right?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1774
https://github.com/root-project/root/pull/1774:185,usability,user,users,185,"Hi @Axel-Naumann , great! But here we are building the entire ROOT + cling with O3, something like an OPTIMIZED build - doesn't this potentially introduce changes in the results of the users? I am not against it in principle, on the contrary, I encourage aggressive flags, but they may have a consequence, right?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1774
https://github.com/root-project/root/pull/1775:30,safety,review,review,30,@Axel-Naumann About ready for review. Points that might be likely discussion points and could be changed:. * separation of ci scripts to `.ci` directory. * can the block than cannot match be removed entirely?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1775
https://github.com/root-project/root/pull/1775:30,testability,review,review,30,@Axel-Naumann About ready for review. Points that might be likely discussion points and could be changed:. * separation of ci scripts to `.ci` directory. * can the block than cannot match be removed entirely?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1775
https://github.com/root-project/root/pull/1775:202,deployability,build,build,202,"Delegating to Vassil, since he originally wrote the Travis CI scripts. After this is merged, I would rather create a `scripts` directory in ROOT, and move these scripts and scripts currently under the `build` directory there. It's a common pattern to do `mkdir build && cd build && cmake .. && cmake --build .` from a source directory of a project built with CMake.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1775
https://github.com/root-project/root/pull/1775:261,deployability,build,build,261,"Delegating to Vassil, since he originally wrote the Travis CI scripts. After this is merged, I would rather create a `scripts` directory in ROOT, and move these scripts and scripts currently under the `build` directory there. It's a common pattern to do `mkdir build && cd build && cmake .. && cmake --build .` from a source directory of a project built with CMake.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1775
https://github.com/root-project/root/pull/1775:273,deployability,build,build,273,"Delegating to Vassil, since he originally wrote the Travis CI scripts. After this is merged, I would rather create a `scripts` directory in ROOT, and move these scripts and scripts currently under the `build` directory there. It's a common pattern to do `mkdir build && cd build && cmake .. && cmake --build .` from a source directory of a project built with CMake.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1775
https://github.com/root-project/root/pull/1775:302,deployability,build,build,302,"Delegating to Vassil, since he originally wrote the Travis CI scripts. After this is merged, I would rather create a `scripts` directory in ROOT, and move these scripts and scripts currently under the `build` directory there. It's a common pattern to do `mkdir build && cd build && cmake .. && cmake --build .` from a source directory of a project built with CMake.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1775
https://github.com/root-project/root/pull/1775:181,energy efficiency,current,currently,181,"Delegating to Vassil, since he originally wrote the Travis CI scripts. After this is merged, I would rather create a `scripts` directory in ROOT, and move these scripts and scripts currently under the `build` directory there. It's a common pattern to do `mkdir build && cd build && cmake .. && cmake --build .` from a source directory of a project built with CMake.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1775
https://github.com/root-project/root/pull/1775:26,availability,avail,available,26,"I'd love `build` being an available folder name, and preferably even listed in `.gitignore`, for exactly that reason! ROOT is just about the only project where I can't do the standard `cmake ..` from `build`. (Actually, I like something like `*build*` in the git ignore, because I tend to make several build directories with different configurations, like llvm and gcc). @vgvassilev Let me know if I need to move the scripts currently in `.ci` for this PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1775
https://github.com/root-project/root/pull/1775:10,deployability,build,build,10,"I'd love `build` being an available folder name, and preferably even listed in `.gitignore`, for exactly that reason! ROOT is just about the only project where I can't do the standard `cmake ..` from `build`. (Actually, I like something like `*build*` in the git ignore, because I tend to make several build directories with different configurations, like llvm and gcc). @vgvassilev Let me know if I need to move the scripts currently in `.ci` for this PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1775
https://github.com/root-project/root/pull/1775:201,deployability,build,build,201,"I'd love `build` being an available folder name, and preferably even listed in `.gitignore`, for exactly that reason! ROOT is just about the only project where I can't do the standard `cmake ..` from `build`. (Actually, I like something like `*build*` in the git ignore, because I tend to make several build directories with different configurations, like llvm and gcc). @vgvassilev Let me know if I need to move the scripts currently in `.ci` for this PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1775
https://github.com/root-project/root/pull/1775:244,deployability,build,build,244,"I'd love `build` being an available folder name, and preferably even listed in `.gitignore`, for exactly that reason! ROOT is just about the only project where I can't do the standard `cmake ..` from `build`. (Actually, I like something like `*build*` in the git ignore, because I tend to make several build directories with different configurations, like llvm and gcc). @vgvassilev Let me know if I need to move the scripts currently in `.ci` for this PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1775
https://github.com/root-project/root/pull/1775:302,deployability,build,build,302,"I'd love `build` being an available folder name, and preferably even listed in `.gitignore`, for exactly that reason! ROOT is just about the only project where I can't do the standard `cmake ..` from `build`. (Actually, I like something like `*build*` in the git ignore, because I tend to make several build directories with different configurations, like llvm and gcc). @vgvassilev Let me know if I need to move the scripts currently in `.ci` for this PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1775
https://github.com/root-project/root/pull/1775:335,deployability,configurat,configurations,335,"I'd love `build` being an available folder name, and preferably even listed in `.gitignore`, for exactly that reason! ROOT is just about the only project where I can't do the standard `cmake ..` from `build`. (Actually, I like something like `*build*` in the git ignore, because I tend to make several build directories with different configurations, like llvm and gcc). @vgvassilev Let me know if I need to move the scripts currently in `.ci` for this PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1775
https://github.com/root-project/root/pull/1775:425,energy efficiency,current,currently,425,"I'd love `build` being an available folder name, and preferably even listed in `.gitignore`, for exactly that reason! ROOT is just about the only project where I can't do the standard `cmake ..` from `build`. (Actually, I like something like `*build*` in the git ignore, because I tend to make several build directories with different configurations, like llvm and gcc). @vgvassilev Let me know if I need to move the scripts currently in `.ci` for this PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1775
https://github.com/root-project/root/pull/1775:335,integrability,configur,configurations,335,"I'd love `build` being an available folder name, and preferably even listed in `.gitignore`, for exactly that reason! ROOT is just about the only project where I can't do the standard `cmake ..` from `build`. (Actually, I like something like `*build*` in the git ignore, because I tend to make several build directories with different configurations, like llvm and gcc). @vgvassilev Let me know if I need to move the scripts currently in `.ci` for this PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1775
https://github.com/root-project/root/pull/1775:175,interoperability,standard,standard,175,"I'd love `build` being an available folder name, and preferably even listed in `.gitignore`, for exactly that reason! ROOT is just about the only project where I can't do the standard `cmake ..` from `build`. (Actually, I like something like `*build*` in the git ignore, because I tend to make several build directories with different configurations, like llvm and gcc). @vgvassilev Let me know if I need to move the scripts currently in `.ci` for this PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1775
https://github.com/root-project/root/pull/1775:335,modifiability,configur,configurations,335,"I'd love `build` being an available folder name, and preferably even listed in `.gitignore`, for exactly that reason! ROOT is just about the only project where I can't do the standard `cmake ..` from `build`. (Actually, I like something like `*build*` in the git ignore, because I tend to make several build directories with different configurations, like llvm and gcc). @vgvassilev Let me know if I need to move the scripts currently in `.ci` for this PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1775
https://github.com/root-project/root/pull/1775:26,reliability,availab,available,26,"I'd love `build` being an available folder name, and preferably even listed in `.gitignore`, for exactly that reason! ROOT is just about the only project where I can't do the standard `cmake ..` from `build`. (Actually, I like something like `*build*` in the git ignore, because I tend to make several build directories with different configurations, like llvm and gcc). @vgvassilev Let me know if I need to move the scripts currently in `.ci` for this PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1775
https://github.com/root-project/root/pull/1775:26,safety,avail,available,26,"I'd love `build` being an available folder name, and preferably even listed in `.gitignore`, for exactly that reason! ROOT is just about the only project where I can't do the standard `cmake ..` from `build`. (Actually, I like something like `*build*` in the git ignore, because I tend to make several build directories with different configurations, like llvm and gcc). @vgvassilev Let me know if I need to move the scripts currently in `.ci` for this PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1775
https://github.com/root-project/root/pull/1775:26,security,availab,available,26,"I'd love `build` being an available folder name, and preferably even listed in `.gitignore`, for exactly that reason! ROOT is just about the only project where I can't do the standard `cmake ..` from `build`. (Actually, I like something like `*build*` in the git ignore, because I tend to make several build directories with different configurations, like llvm and gcc). @vgvassilev Let me know if I need to move the scripts currently in `.ci` for this PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1775
https://github.com/root-project/root/pull/1775:335,security,configur,configurations,335,"I'd love `build` being an available folder name, and preferably even listed in `.gitignore`, for exactly that reason! ROOT is just about the only project where I can't do the standard `cmake ..` from `build`. (Actually, I like something like `*build*` in the git ignore, because I tend to make several build directories with different configurations, like llvm and gcc). @vgvassilev Let me know if I need to move the scripts currently in `.ci` for this PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1775
https://github.com/root-project/root/pull/1775:53,usability,prefer,preferably,53,"I'd love `build` being an available folder name, and preferably even listed in `.gitignore`, for exactly that reason! ROOT is just about the only project where I can't do the standard `cmake ..` from `build`. (Actually, I like something like `*build*` in the git ignore, because I tend to make several build directories with different configurations, like llvm and gcc). @vgvassilev Let me know if I need to move the scripts currently in `.ci` for this PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1775
https://github.com/root-project/root/pull/1776:11,deployability,build,build,11,@phsft-bot build with flags -Dftgl=OFF -Dgl2ps=OFF -Dbuiltin_gl2ps=OFF -Dbuiltin_ftgl=OFF,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1776
https://github.com/root-project/root/pull/1776:11,deployability,build,build,11,@phsft-bot build with flags -Dftgl=OFF -Dgl2ps=OFF -Dbuiltin_gl2ps=OFF -Dbuiltin_ftgl=OFF -Dopengl=OFF,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1776
https://github.com/root-project/root/pull/1777:57,reliability,doe,does,57,I'll recompile and check with python3 locally as Jenkins does not test it (?),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:66,safety,test,test,66,I'll recompile and check with python3 locally as Jenkins does not test it (?),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:66,testability,test,test,66,I'll recompile and check with python3 locally as Jenkins does not test it (?),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:129,deployability,infrastructur,infrastructure,129,"We can change the flags here, but we also need to change the externals for Python3, and that requires non-trivial changes to the infrastructure.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:60,deployability,fail,fails,60,"Hu alright, on my test system `ROOT.std.vector(""float"")(1)` fails with python3, I'll investigate further.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:60,reliability,fail,fails,60,"Hu alright, on my test system `ROOT.std.vector(""float"")(1)` fails with python3, I'll investigate further.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:18,safety,test,test,18,"Hu alright, on my test system `ROOT.std.vector(""float"")(1)` fails with python3, I'll investigate further.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:18,testability,test,test,18,"Hu alright, on my test system `ROOT.std.vector(""float"")(1)` fails with python3, I'll investigate further.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:53,availability,error,error,53,Here's the current status of the PR: The compilation error is fixed but the py3 version of PyROOT behaves somehow differently than the py2 one. I'll explain more closely in the code review.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:80,deployability,version,version,80,Here's the current status of the PR: The compilation error is fixed but the py3 version of PyROOT behaves somehow differently than the py2 one. I'll explain more closely in the code review.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:11,energy efficiency,current,current,11,Here's the current status of the PR: The compilation error is fixed but the py3 version of PyROOT behaves somehow differently than the py2 one. I'll explain more closely in the code review.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:80,integrability,version,version,80,Here's the current status of the PR: The compilation error is fixed but the py3 version of PyROOT behaves somehow differently than the py2 one. I'll explain more closely in the code review.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:80,modifiability,version,version,80,Here's the current status of the PR: The compilation error is fixed but the py3 version of PyROOT behaves somehow differently than the py2 one. I'll explain more closely in the code review.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:53,performance,error,error,53,Here's the current status of the PR: The compilation error is fixed but the py3 version of PyROOT behaves somehow differently than the py2 one. I'll explain more closely in the code review.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:53,safety,error,error,53,Here's the current status of the PR: The compilation error is fixed but the py3 version of PyROOT behaves somehow differently than the py2 one. I'll explain more closely in the code review.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:182,safety,review,review,182,Here's the current status of the PR: The compilation error is fixed but the py3 version of PyROOT behaves somehow differently than the py2 one. I'll explain more closely in the code review.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:182,testability,review,review,182,Here's the current status of the PR: The compilation error is fixed but the py3 version of PyROOT behaves somehow differently than the py2 one. I'll explain more closely in the code review.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:19,usability,statu,status,19,Here's the current status of the PR: The compilation error is fixed but the py3 version of PyROOT behaves somehow differently than the py2 one. I'll explain more closely in the code review.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:53,usability,error,error,53,Here's the current status of the PR: The compilation error is fixed but the py3 version of PyROOT behaves somehow differently than the py2 one. I'll explain more closely in the code review.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:162,usability,close,closely,162,Here's the current status of the PR: The compilation error is fixed but the py3 version of PyROOT behaves somehow differently than the py2 one. I'll explain more closely in the code review.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:174,availability,operat,operator,174,"The py3 behavious is not a feature of this PR. You can add this to `Pythonize.cxx` and simply run `import ROOT`:. ```cpp. if ( name == ""TObject"" ) {. // support for the 'in' operator. Utility::AddToClass( pyclass, ""__contains__"", (PyCFunction) TObjectContains, METH_O );. PyObject_Print(PyObject_GetAttrString(pyclass, ""__contains__""), stdout, 0);. ... }. ```. **py2:**. ```. >>> import ROOT. <unbound method TObject.__contains__>>>>. ```. **py3:**. ```. >>> import ROOT. <bound method __contains__ of <NULL>>>>> . ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:87,testability,simpl,simply,87,"The py3 behavious is not a feature of this PR. You can add this to `Pythonize.cxx` and simply run `import ROOT`:. ```cpp. if ( name == ""TObject"" ) {. // support for the 'in' operator. Utility::AddToClass( pyclass, ""__contains__"", (PyCFunction) TObjectContains, METH_O );. PyObject_Print(PyObject_GetAttrString(pyclass, ""__contains__""), stdout, 0);. ... }. ```. **py2:**. ```. >>> import ROOT. <unbound method TObject.__contains__>>>>. ```. **py3:**. ```. >>> import ROOT. <bound method __contains__ of <NULL>>>>> . ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:8,usability,behavi,behavious,8,"The py3 behavious is not a feature of this PR. You can add this to `Pythonize.cxx` and simply run `import ROOT`:. ```cpp. if ( name == ""TObject"" ) {. // support for the 'in' operator. Utility::AddToClass( pyclass, ""__contains__"", (PyCFunction) TObjectContains, METH_O );. PyObject_Print(PyObject_GetAttrString(pyclass, ""__contains__""), stdout, 0);. ... }. ```. **py2:**. ```. >>> import ROOT. <unbound method TObject.__contains__>>>>. ```. **py3:**. ```. >>> import ROOT. <bound method __contains__ of <NULL>>>>> . ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:87,usability,simpl,simply,87,"The py3 behavious is not a feature of this PR. You can add this to `Pythonize.cxx` and simply run `import ROOT`:. ```cpp. if ( name == ""TObject"" ) {. // support for the 'in' operator. Utility::AddToClass( pyclass, ""__contains__"", (PyCFunction) TObjectContains, METH_O );. PyObject_Print(PyObject_GetAttrString(pyclass, ""__contains__""), stdout, 0);. ... }. ```. **py2:**. ```. >>> import ROOT. <unbound method TObject.__contains__>>>>. ```. **py3:**. ```. >>> import ROOT. <bound method __contains__ of <NULL>>>>> . ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:153,usability,support,support,153,"The py3 behavious is not a feature of this PR. You can add this to `Pythonize.cxx` and simply run `import ROOT`:. ```cpp. if ( name == ""TObject"" ) {. // support for the 'in' operator. Utility::AddToClass( pyclass, ""__contains__"", (PyCFunction) TObjectContains, METH_O );. PyObject_Print(PyObject_GetAttrString(pyclass, ""__contains__""), stdout, 0);. ... }. ```. **py2:**. ```. >>> import ROOT. <unbound method TObject.__contains__>>>>. ```. **py3:**. ```. >>> import ROOT. <bound method __contains__ of <NULL>>>>> . ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:39,reliability,doe,does,39,"Digging deeper into this: py3 acutally does not have any unbound methods anymore, there it should be a function:. **py3:**. ```. >>> class A:. ... def foo(self):. ... return. ... . >>> A().foo. <bound method A.foo of <__main__.A object at 0x7f2a3baf7278>>. >>> A.foo. <function A.foo at 0x7f2a3d1729d8>. ```. **py2:**. ```. >>> class A:. ... def foo(self):. ... return. ... . >>> A().foo. <bound method A.foo of <__main__.A instance at 0x7fb49b73c368>>. >>> A.foo. <unbound method A.foo>. ```. However, what we get in PyROOT is an unbound method for py2 and a bound method to `NULL` for py3. It should be the same like this:. **py3:**. ```. >>> def bar():. ... return. >>> bar. <function bar at 0x7f5989eba950>. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:10,reliability,Doe,Does,10,@stwunsch Does this PR need more work or already include the result of your investigation?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:7,testability,simpl,simple,7,"Here a simple example of this issue:. **py3:**. ```. >>> import ROOT. >>> ROOT.TObject().__contains__. <bound method __contains__ of <ROOT.TObject object (""TObject"") at 0x39895d0>>. >>> type(ROOT.TObject()).__contains__. <bound method __contains__ of <NULL>>. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:7,usability,simpl,simple,7,"Here a simple example of this issue:. **py3:**. ```. >>> import ROOT. >>> ROOT.TObject().__contains__. <bound method __contains__ of <ROOT.TObject object (""TObject"") at 0x39895d0>>. >>> type(ROOT.TObject()).__contains__. <bound method __contains__ of <NULL>>. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:220,interoperability,bind,bind,220,"I've pushed a fix for the issue to this branch: https://github.com/stwunsch/root/tree/impl_array_interface_2. You can solve the problem by adding the `property` in `ROOT.py` and not in the `Pythonize.cxx`. Then, you can bind the falsely bound method with the `NULL` object to a property through a proxy function without python trying to access the `NULL` object. Not the nicest solution though...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:297,interoperability,prox,proxy,297,"I've pushed a fix for the issue to this branch: https://github.com/stwunsch/root/tree/impl_array_interface_2. You can solve the problem by adding the `property` in `ROOT.py` and not in the `Pythonize.cxx`. Then, you can bind the falsely bound method with the `NULL` object to a property through a proxy function without python trying to access the `NULL` object. Not the nicest solution though...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:220,modifiability,bind,bind,220,"I've pushed a fix for the issue to this branch: https://github.com/stwunsch/root/tree/impl_array_interface_2. You can solve the problem by adding the `property` in `ROOT.py` and not in the `Pythonize.cxx`. Then, you can bind the falsely bound method with the `NULL` object to a property through a proxy function without python trying to access the `NULL` object. Not the nicest solution though...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:337,security,access,access,337,"I've pushed a fix for the issue to this branch: https://github.com/stwunsch/root/tree/impl_array_interface_2. You can solve the problem by adding the `property` in `ROOT.py` and not in the `Pythonize.cxx`. Then, you can bind the falsely bound method with the `NULL` object to a property through a proxy function without python trying to access the `NULL` object. Not the nicest solution though...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:83,availability,error,error,83,"Hi @stwunsch , thanks for the detailed investigation! Where do you see exactly the error in Python3, is it the line:. ```cpp. PyObject *property_obj = PyObject_CallObject(property_class, arglist);. ```. or the line:. ```cpp. PyObject_SetAttrString(pyclass, property, property_obj);. ```. As you pointed out, in the case of `Utility::AddToClass`, Python3 also adds a bound method to the class. Do you understand why in the case of `Utility::AddToClass` this is not an issue, but it is an issue in the case of `Utility::AddProperty`?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:83,performance,error,error,83,"Hi @stwunsch , thanks for the detailed investigation! Where do you see exactly the error in Python3, is it the line:. ```cpp. PyObject *property_obj = PyObject_CallObject(property_class, arglist);. ```. or the line:. ```cpp. PyObject_SetAttrString(pyclass, property, property_obj);. ```. As you pointed out, in the case of `Utility::AddToClass`, Python3 also adds a bound method to the class. Do you understand why in the case of `Utility::AddToClass` this is not an issue, but it is an issue in the case of `Utility::AddProperty`?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:83,safety,error,error,83,"Hi @stwunsch , thanks for the detailed investigation! Where do you see exactly the error in Python3, is it the line:. ```cpp. PyObject *property_obj = PyObject_CallObject(property_class, arglist);. ```. or the line:. ```cpp. PyObject_SetAttrString(pyclass, property, property_obj);. ```. As you pointed out, in the case of `Utility::AddToClass`, Python3 also adds a bound method to the class. Do you understand why in the case of `Utility::AddToClass` this is not an issue, but it is an issue in the case of `Utility::AddProperty`?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:400,testability,understand,understand,400,"Hi @stwunsch , thanks for the detailed investigation! Where do you see exactly the error in Python3, is it the line:. ```cpp. PyObject *property_obj = PyObject_CallObject(property_class, arglist);. ```. or the line:. ```cpp. PyObject_SetAttrString(pyclass, property, property_obj);. ```. As you pointed out, in the case of `Utility::AddToClass`, Python3 also adds a bound method to the class. Do you understand why in the case of `Utility::AddToClass` this is not an issue, but it is an issue in the case of `Utility::AddProperty`?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:83,usability,error,error,83,"Hi @stwunsch , thanks for the detailed investigation! Where do you see exactly the error in Python3, is it the line:. ```cpp. PyObject *property_obj = PyObject_CallObject(property_class, arglist);. ```. or the line:. ```cpp. PyObject_SetAttrString(pyclass, property, property_obj);. ```. As you pointed out, in the case of `Utility::AddToClass`, Python3 also adds a bound method to the class. Do you understand why in the case of `Utility::AddToClass` this is not an issue, but it is an issue in the case of `Utility::AddProperty`?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:247,availability,error,error,247,"It fails when doing the `property(method)` call, so in `PyObject_CallObject(property_class, arglist)`. In case the method is bound, the underlying code does explicitely access the `self` object, which throws an `Bad argument to internal function` error in python if it's `NULL` (super cryptic!). Regarding the second question, I've to check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:3,deployability,fail,fails,3,"It fails when doing the `property(method)` call, so in `PyObject_CallObject(property_class, arglist)`. In case the method is bound, the underlying code does explicitely access the `self` object, which throws an `Bad argument to internal function` error in python if it's `NULL` (super cryptic!). Regarding the second question, I've to check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:247,performance,error,error,247,"It fails when doing the `property(method)` call, so in `PyObject_CallObject(property_class, arglist)`. In case the method is bound, the underlying code does explicitely access the `self` object, which throws an `Bad argument to internal function` error in python if it's `NULL` (super cryptic!). Regarding the second question, I've to check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:3,reliability,fail,fails,3,"It fails when doing the `property(method)` call, so in `PyObject_CallObject(property_class, arglist)`. In case the method is bound, the underlying code does explicitely access the `self` object, which throws an `Bad argument to internal function` error in python if it's `NULL` (super cryptic!). Regarding the second question, I've to check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:152,reliability,doe,does,152,"It fails when doing the `property(method)` call, so in `PyObject_CallObject(property_class, arglist)`. In case the method is bound, the underlying code does explicitely access the `self` object, which throws an `Bad argument to internal function` error in python if it's `NULL` (super cryptic!). Regarding the second question, I've to check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:247,safety,error,error,247,"It fails when doing the `property(method)` call, so in `PyObject_CallObject(property_class, arglist)`. In case the method is bound, the underlying code does explicitely access the `self` object, which throws an `Bad argument to internal function` error in python if it's `NULL` (super cryptic!). Regarding the second question, I've to check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:169,security,access,access,169,"It fails when doing the `property(method)` call, so in `PyObject_CallObject(property_class, arglist)`. In case the method is bound, the underlying code does explicitely access the `self` object, which throws an `Bad argument to internal function` error in python if it's `NULL` (super cryptic!). Regarding the second question, I've to check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:247,usability,error,error,247,"It fails when doing the `property(method)` call, so in `PyObject_CallObject(property_class, arglist)`. In case the method is bound, the underlying code does explicitely access the `self` object, which throws an `Bad argument to internal function` error in python if it's `NULL` (super cryptic!). Regarding the second question, I've to check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:302,security,access,accesses,302,"Then the difference is that `AddToClass` calls:. ```cpp. method = MethodProxy_New( label, pyfunc );. ```. and that is fine even when pyfunc is a method bound to a null object in Py3, but for `AddProperty`, the line:. ```cpp. PyObject *property_obj = PyObject_CallObject(property_class, arglist);. ```. accesses the null object and crashes.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:23,deployability,stack,stackoverflow,23,"Perhaps [this](https://stackoverflow.com/questions/10161609/class-property-using-python-c-api) could help us get rid of the `null` problem. That example constructs a property differently, by creating an object of a certain type `P`, and type `P` has its attribute `tp_descr_get` set. In our case, `tp_descr_get` would point to the function that `AddArrayInterface` receives. With this solution, we would not need to call `PyObject_CallObject(property_class, arglist)` and thus we should not have the `null` issue. This technique is implemented throughout PyROOT several times (e.g. to get the value of a data member of a C++ object accessed from Python). If this does not work either we could go for the implementation in Python that you proposed, although this would contribute to make `ROOT.py` even fatter.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:90,deployability,api,api,90,"Perhaps [this](https://stackoverflow.com/questions/10161609/class-property-using-python-c-api) could help us get rid of the `null` problem. That example constructs a property differently, by creating an object of a certain type `P`, and type `P` has its attribute `tp_descr_get` set. In our case, `tp_descr_get` would point to the function that `AddArrayInterface` receives. With this solution, we would not need to call `PyObject_CallObject(property_class, arglist)` and thus we should not have the `null` issue. This technique is implemented throughout PyROOT several times (e.g. to get the value of a data member of a C++ object accessed from Python). If this does not work either we could go for the implementation in Python that you proposed, although this would contribute to make `ROOT.py` even fatter.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:90,integrability,api,api,90,"Perhaps [this](https://stackoverflow.com/questions/10161609/class-property-using-python-c-api) could help us get rid of the `null` problem. That example constructs a property differently, by creating an object of a certain type `P`, and type `P` has its attribute `tp_descr_get` set. In our case, `tp_descr_get` would point to the function that `AddArrayInterface` receives. With this solution, we would not need to call `PyObject_CallObject(property_class, arglist)` and thus we should not have the `null` issue. This technique is implemented throughout PyROOT several times (e.g. to get the value of a data member of a C++ object accessed from Python). If this does not work either we could go for the implementation in Python that you proposed, although this would contribute to make `ROOT.py` even fatter.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:90,interoperability,api,api,90,"Perhaps [this](https://stackoverflow.com/questions/10161609/class-property-using-python-c-api) could help us get rid of the `null` problem. That example constructs a property differently, by creating an object of a certain type `P`, and type `P` has its attribute `tp_descr_get` set. In our case, `tp_descr_get` would point to the function that `AddArrayInterface` receives. With this solution, we would not need to call `PyObject_CallObject(property_class, arglist)` and thus we should not have the `null` issue. This technique is implemented throughout PyROOT several times (e.g. to get the value of a data member of a C++ object accessed from Python). If this does not work either we could go for the implementation in Python that you proposed, although this would contribute to make `ROOT.py` even fatter.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:570,performance,time,times,570,"Perhaps [this](https://stackoverflow.com/questions/10161609/class-property-using-python-c-api) could help us get rid of the `null` problem. That example constructs a property differently, by creating an object of a certain type `P`, and type `P` has its attribute `tp_descr_get` set. In our case, `tp_descr_get` would point to the function that `AddArrayInterface` receives. With this solution, we would not need to call `PyObject_CallObject(property_class, arglist)` and thus we should not have the `null` issue. This technique is implemented throughout PyROOT several times (e.g. to get the value of a data member of a C++ object accessed from Python). If this does not work either we could go for the implementation in Python that you proposed, although this would contribute to make `ROOT.py` even fatter.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:663,reliability,doe,does,663,"Perhaps [this](https://stackoverflow.com/questions/10161609/class-property-using-python-c-api) could help us get rid of the `null` problem. That example constructs a property differently, by creating an object of a certain type `P`, and type `P` has its attribute `tp_descr_get` set. In our case, `tp_descr_get` would point to the function that `AddArrayInterface` receives. With this solution, we would not need to call `PyObject_CallObject(property_class, arglist)` and thus we should not have the `null` issue. This technique is implemented throughout PyROOT several times (e.g. to get the value of a data member of a C++ object accessed from Python). If this does not work either we could go for the implementation in Python that you proposed, although this would contribute to make `ROOT.py` even fatter.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:632,security,access,accessed,632,"Perhaps [this](https://stackoverflow.com/questions/10161609/class-property-using-python-c-api) could help us get rid of the `null` problem. That example constructs a property differently, by creating an object of a certain type `P`, and type `P` has its attribute `tp_descr_get` set. In our case, `tp_descr_get` would point to the function that `AddArrayInterface` receives. With this solution, we would not need to call `PyObject_CallObject(property_class, arglist)` and thus we should not have the `null` issue. This technique is implemented throughout PyROOT several times (e.g. to get the value of a data member of a C++ object accessed from Python). If this does not work either we could go for the implementation in Python that you proposed, although this would contribute to make `ROOT.py` even fatter.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:101,usability,help,help,101,"Perhaps [this](https://stackoverflow.com/questions/10161609/class-property-using-python-c-api) could help us get rid of the `null` problem. That example constructs a property differently, by creating an object of a certain type `P`, and type `P` has its attribute `tp_descr_get` set. In our case, `tp_descr_get` would point to the function that `AddArrayInterface` receives. With this solution, we would not need to call `PyObject_CallObject(property_class, arglist)` and thus we should not have the `null` issue. This technique is implemented throughout PyROOT several times (e.g. to get the value of a data member of a C++ object accessed from Python). If this does not work either we could go for the implementation in Python that you proposed, although this would contribute to make `ROOT.py` even fatter.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:5,usability,close,close,5,I'll close this one and make a clean new one with clearly separated features compared to the `AsMatrix` PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1777:50,usability,clear,clearly,50,I'll close this one and make a clean new one with clearly separated features compared to the `AsMatrix` PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1777
https://github.com/root-project/root/pull/1778:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1778
https://github.com/root-project/root/pull/1781:11,deployability,build,build,11,@phsft-bot build.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1781
https://github.com/root-project/root/pull/1781:11,deployability,build,build,11,@phsft-bot build -Dimt=OFF,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1781
https://github.com/root-project/root/pull/1781:11,deployability,build,build,11,@phsft-bot build with flags -Dimt=Off,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1781
https://github.com/root-project/root/pull/1781:11,deployability,build,build,11,@phsft-bot build with flags -Dimt=Off,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1781
https://github.com/root-project/root/pull/1781:11,deployability,build,build,11,@phsft-bot build with flags -Dimt=Off.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1781
https://github.com/root-project/root/pull/1785:581,deployability,manag,management,581,"@Axel-Naumann . Hi, I resolve most comments. Two points could be solved as extra PR:. - use vector<unsigned char> as blob buffer. Can be done. - provide several predefined methods in THttpCallArg class to set together content type and content, including binary buffer. Can be done. Major problem is ownership of THttpCallArg. In normal situation user does not care at all - it uses THttpCallArg in ProcessRequest() and fill it with reply. Only for long poll engine special mode is required. Probably, I can provide solution, where shared_ptr<THttpCallArg> used for internal memory management, but does not appeared in user API. At least, old methods signature supported as is. Probably, one declare them as deprecated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1785:623,deployability,API,API,623,"@Axel-Naumann . Hi, I resolve most comments. Two points could be solved as extra PR:. - use vector<unsigned char> as blob buffer. Can be done. - provide several predefined methods in THttpCallArg class to set together content type and content, including binary buffer. Can be done. Major problem is ownership of THttpCallArg. In normal situation user does not care at all - it uses THttpCallArg in ProcessRequest() and fill it with reply. Only for long poll engine special mode is required. Probably, I can provide solution, where shared_ptr<THttpCallArg> used for internal memory management, but does not appeared in user API. At least, old methods signature supported as is. Probably, one declare them as deprecated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1785:581,energy efficiency,manag,management,581,"@Axel-Naumann . Hi, I resolve most comments. Two points could be solved as extra PR:. - use vector<unsigned char> as blob buffer. Can be done. - provide several predefined methods in THttpCallArg class to set together content type and content, including binary buffer. Can be done. Major problem is ownership of THttpCallArg. In normal situation user does not care at all - it uses THttpCallArg in ProcessRequest() and fill it with reply. Only for long poll engine special mode is required. Probably, I can provide solution, where shared_ptr<THttpCallArg> used for internal memory management, but does not appeared in user API. At least, old methods signature supported as is. Probably, one declare them as deprecated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1785:122,integrability,buffer,buffer,122,"@Axel-Naumann . Hi, I resolve most comments. Two points could be solved as extra PR:. - use vector<unsigned char> as blob buffer. Can be done. - provide several predefined methods in THttpCallArg class to set together content type and content, including binary buffer. Can be done. Major problem is ownership of THttpCallArg. In normal situation user does not care at all - it uses THttpCallArg in ProcessRequest() and fill it with reply. Only for long poll engine special mode is required. Probably, I can provide solution, where shared_ptr<THttpCallArg> used for internal memory management, but does not appeared in user API. At least, old methods signature supported as is. Probably, one declare them as deprecated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1785:261,integrability,buffer,buffer,261,"@Axel-Naumann . Hi, I resolve most comments. Two points could be solved as extra PR:. - use vector<unsigned char> as blob buffer. Can be done. - provide several predefined methods in THttpCallArg class to set together content type and content, including binary buffer. Can be done. Major problem is ownership of THttpCallArg. In normal situation user does not care at all - it uses THttpCallArg in ProcessRequest() and fill it with reply. Only for long poll engine special mode is required. Probably, I can provide solution, where shared_ptr<THttpCallArg> used for internal memory management, but does not appeared in user API. At least, old methods signature supported as is. Probably, one declare them as deprecated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1785:623,integrability,API,API,623,"@Axel-Naumann . Hi, I resolve most comments. Two points could be solved as extra PR:. - use vector<unsigned char> as blob buffer. Can be done. - provide several predefined methods in THttpCallArg class to set together content type and content, including binary buffer. Can be done. Major problem is ownership of THttpCallArg. In normal situation user does not care at all - it uses THttpCallArg in ProcessRequest() and fill it with reply. Only for long poll engine special mode is required. Probably, I can provide solution, where shared_ptr<THttpCallArg> used for internal memory management, but does not appeared in user API. At least, old methods signature supported as is. Probably, one declare them as deprecated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1785:623,interoperability,API,API,623,"@Axel-Naumann . Hi, I resolve most comments. Two points could be solved as extra PR:. - use vector<unsigned char> as blob buffer. Can be done. - provide several predefined methods in THttpCallArg class to set together content type and content, including binary buffer. Can be done. Major problem is ownership of THttpCallArg. In normal situation user does not care at all - it uses THttpCallArg in ProcessRequest() and fill it with reply. Only for long poll engine special mode is required. Probably, I can provide solution, where shared_ptr<THttpCallArg> used for internal memory management, but does not appeared in user API. At least, old methods signature supported as is. Probably, one declare them as deprecated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1785:218,performance,content,content,218,"@Axel-Naumann . Hi, I resolve most comments. Two points could be solved as extra PR:. - use vector<unsigned char> as blob buffer. Can be done. - provide several predefined methods in THttpCallArg class to set together content type and content, including binary buffer. Can be done. Major problem is ownership of THttpCallArg. In normal situation user does not care at all - it uses THttpCallArg in ProcessRequest() and fill it with reply. Only for long poll engine special mode is required. Probably, I can provide solution, where shared_ptr<THttpCallArg> used for internal memory management, but does not appeared in user API. At least, old methods signature supported as is. Probably, one declare them as deprecated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1785:235,performance,content,content,235,"@Axel-Naumann . Hi, I resolve most comments. Two points could be solved as extra PR:. - use vector<unsigned char> as blob buffer. Can be done. - provide several predefined methods in THttpCallArg class to set together content type and content, including binary buffer. Can be done. Major problem is ownership of THttpCallArg. In normal situation user does not care at all - it uses THttpCallArg in ProcessRequest() and fill it with reply. Only for long poll engine special mode is required. Probably, I can provide solution, where shared_ptr<THttpCallArg> used for internal memory management, but does not appeared in user API. At least, old methods signature supported as is. Probably, one declare them as deprecated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1785:574,performance,memor,memory,574,"@Axel-Naumann . Hi, I resolve most comments. Two points could be solved as extra PR:. - use vector<unsigned char> as blob buffer. Can be done. - provide several predefined methods in THttpCallArg class to set together content type and content, including binary buffer. Can be done. Major problem is ownership of THttpCallArg. In normal situation user does not care at all - it uses THttpCallArg in ProcessRequest() and fill it with reply. Only for long poll engine special mode is required. Probably, I can provide solution, where shared_ptr<THttpCallArg> used for internal memory management, but does not appeared in user API. At least, old methods signature supported as is. Probably, one declare them as deprecated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1785:351,reliability,doe,does,351,"@Axel-Naumann . Hi, I resolve most comments. Two points could be solved as extra PR:. - use vector<unsigned char> as blob buffer. Can be done. - provide several predefined methods in THttpCallArg class to set together content type and content, including binary buffer. Can be done. Major problem is ownership of THttpCallArg. In normal situation user does not care at all - it uses THttpCallArg in ProcessRequest() and fill it with reply. Only for long poll engine special mode is required. Probably, I can provide solution, where shared_ptr<THttpCallArg> used for internal memory management, but does not appeared in user API. At least, old methods signature supported as is. Probably, one declare them as deprecated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1785:597,reliability,doe,does,597,"@Axel-Naumann . Hi, I resolve most comments. Two points could be solved as extra PR:. - use vector<unsigned char> as blob buffer. Can be done. - provide several predefined methods in THttpCallArg class to set together content type and content, including binary buffer. Can be done. Major problem is ownership of THttpCallArg. In normal situation user does not care at all - it uses THttpCallArg in ProcessRequest() and fill it with reply. Only for long poll engine special mode is required. Probably, I can provide solution, where shared_ptr<THttpCallArg> used for internal memory management, but does not appeared in user API. At least, old methods signature supported as is. Probably, one declare them as deprecated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1785:581,safety,manag,management,581,"@Axel-Naumann . Hi, I resolve most comments. Two points could be solved as extra PR:. - use vector<unsigned char> as blob buffer. Can be done. - provide several predefined methods in THttpCallArg class to set together content type and content, including binary buffer. Can be done. Major problem is ownership of THttpCallArg. In normal situation user does not care at all - it uses THttpCallArg in ProcessRequest() and fill it with reply. Only for long poll engine special mode is required. Probably, I can provide solution, where shared_ptr<THttpCallArg> used for internal memory management, but does not appeared in user API. At least, old methods signature supported as is. Probably, one declare them as deprecated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1785:650,security,sign,signature,650,"@Axel-Naumann . Hi, I resolve most comments. Two points could be solved as extra PR:. - use vector<unsigned char> as blob buffer. Can be done. - provide several predefined methods in THttpCallArg class to set together content type and content, including binary buffer. Can be done. Major problem is ownership of THttpCallArg. In normal situation user does not care at all - it uses THttpCallArg in ProcessRequest() and fill it with reply. Only for long poll engine special mode is required. Probably, I can provide solution, where shared_ptr<THttpCallArg> used for internal memory management, but does not appeared in user API. At least, old methods signature supported as is. Probably, one declare them as deprecated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1785:346,usability,user,user,346,"@Axel-Naumann . Hi, I resolve most comments. Two points could be solved as extra PR:. - use vector<unsigned char> as blob buffer. Can be done. - provide several predefined methods in THttpCallArg class to set together content type and content, including binary buffer. Can be done. Major problem is ownership of THttpCallArg. In normal situation user does not care at all - it uses THttpCallArg in ProcessRequest() and fill it with reply. Only for long poll engine special mode is required. Probably, I can provide solution, where shared_ptr<THttpCallArg> used for internal memory management, but does not appeared in user API. At least, old methods signature supported as is. Probably, one declare them as deprecated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1785:574,usability,memor,memory,574,"@Axel-Naumann . Hi, I resolve most comments. Two points could be solved as extra PR:. - use vector<unsigned char> as blob buffer. Can be done. - provide several predefined methods in THttpCallArg class to set together content type and content, including binary buffer. Can be done. Major problem is ownership of THttpCallArg. In normal situation user does not care at all - it uses THttpCallArg in ProcessRequest() and fill it with reply. Only for long poll engine special mode is required. Probably, I can provide solution, where shared_ptr<THttpCallArg> used for internal memory management, but does not appeared in user API. At least, old methods signature supported as is. Probably, one declare them as deprecated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1785:618,usability,user,user,618,"@Axel-Naumann . Hi, I resolve most comments. Two points could be solved as extra PR:. - use vector<unsigned char> as blob buffer. Can be done. - provide several predefined methods in THttpCallArg class to set together content type and content, including binary buffer. Can be done. Major problem is ownership of THttpCallArg. In normal situation user does not care at all - it uses THttpCallArg in ProcessRequest() and fill it with reply. Only for long poll engine special mode is required. Probably, I can provide solution, where shared_ptr<THttpCallArg> used for internal memory management, but does not appeared in user API. At least, old methods signature supported as is. Probably, one declare them as deprecated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1785:660,usability,support,supported,660,"@Axel-Naumann . Hi, I resolve most comments. Two points could be solved as extra PR:. - use vector<unsigned char> as blob buffer. Can be done. - provide several predefined methods in THttpCallArg class to set together content type and content, including binary buffer. Can be done. Major problem is ownership of THttpCallArg. In normal situation user does not care at all - it uses THttpCallArg in ProcessRequest() and fill it with reply. Only for long poll engine special mode is required. Probably, I can provide solution, where shared_ptr<THttpCallArg> used for internal memory management, but does not appeared in user API. At least, old methods signature supported as is. Probably, one declare them as deprecated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1785:50,integrability,Interfac,Interface,50,"This is significant change on top of original PR. Interface of THttpServer classes changed in several places. 1. To make clear ownership, `std::shared_ptr<THttpCallArg>` is used to exchange these objects. between application code and THttpServer. 2. Also use `std::shared_ptr<THttpWSEngine>` for keep clear ownership of helper objects, which are supporting different websockets kinds. 3. Use std::string to store text or binary data, assigned to THttpCallArg. . Before special binary storage with malloc/mfree was used. Used for content and post data. 4. Declare several methods in http classes as deprecated. For each method there is replacement with similar functionality, but other arguments. I used ROOT 6.18 as boundary, but this can be changed. 5. Latest JSROOT .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1785:50,interoperability,Interfac,Interface,50,"This is significant change on top of original PR. Interface of THttpServer classes changed in several places. 1. To make clear ownership, `std::shared_ptr<THttpCallArg>` is used to exchange these objects. between application code and THttpServer. 2. Also use `std::shared_ptr<THttpWSEngine>` for keep clear ownership of helper objects, which are supporting different websockets kinds. 3. Use std::string to store text or binary data, assigned to THttpCallArg. . Before special binary storage with malloc/mfree was used. Used for content and post data. 4. Declare several methods in http classes as deprecated. For each method there is replacement with similar functionality, but other arguments. I used ROOT 6.18 as boundary, but this can be changed. 5. Latest JSROOT .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1785:181,interoperability,exchang,exchange,181,"This is significant change on top of original PR. Interface of THttpServer classes changed in several places. 1. To make clear ownership, `std::shared_ptr<THttpCallArg>` is used to exchange these objects. between application code and THttpServer. 2. Also use `std::shared_ptr<THttpWSEngine>` for keep clear ownership of helper objects, which are supporting different websockets kinds. 3. Use std::string to store text or binary data, assigned to THttpCallArg. . Before special binary storage with malloc/mfree was used. Used for content and post data. 4. Declare several methods in http classes as deprecated. For each method there is replacement with similar functionality, but other arguments. I used ROOT 6.18 as boundary, but this can be changed. 5. Latest JSROOT .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1785:50,modifiability,Interfac,Interface,50,"This is significant change on top of original PR. Interface of THttpServer classes changed in several places. 1. To make clear ownership, `std::shared_ptr<THttpCallArg>` is used to exchange these objects. between application code and THttpServer. 2. Also use `std::shared_ptr<THttpWSEngine>` for keep clear ownership of helper objects, which are supporting different websockets kinds. 3. Use std::string to store text or binary data, assigned to THttpCallArg. . Before special binary storage with malloc/mfree was used. Used for content and post data. 4. Declare several methods in http classes as deprecated. For each method there is replacement with similar functionality, but other arguments. I used ROOT 6.18 as boundary, but this can be changed. 5. Latest JSROOT .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1785:529,performance,content,content,529,"This is significant change on top of original PR. Interface of THttpServer classes changed in several places. 1. To make clear ownership, `std::shared_ptr<THttpCallArg>` is used to exchange these objects. between application code and THttpServer. 2. Also use `std::shared_ptr<THttpWSEngine>` for keep clear ownership of helper objects, which are supporting different websockets kinds. 3. Use std::string to store text or binary data, assigned to THttpCallArg. . Before special binary storage with malloc/mfree was used. Used for content and post data. 4. Declare several methods in http classes as deprecated. For each method there is replacement with similar functionality, but other arguments. I used ROOT 6.18 as boundary, but this can be changed. 5. Latest JSROOT .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1785:8,security,sign,significant,8,"This is significant change on top of original PR. Interface of THttpServer classes changed in several places. 1. To make clear ownership, `std::shared_ptr<THttpCallArg>` is used to exchange these objects. between application code and THttpServer. 2. Also use `std::shared_ptr<THttpWSEngine>` for keep clear ownership of helper objects, which are supporting different websockets kinds. 3. Use std::string to store text or binary data, assigned to THttpCallArg. . Before special binary storage with malloc/mfree was used. Used for content and post data. 4. Declare several methods in http classes as deprecated. For each method there is replacement with similar functionality, but other arguments. I used ROOT 6.18 as boundary, but this can be changed. 5. Latest JSROOT .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1785:121,usability,clear,clear,121,"This is significant change on top of original PR. Interface of THttpServer classes changed in several places. 1. To make clear ownership, `std::shared_ptr<THttpCallArg>` is used to exchange these objects. between application code and THttpServer. 2. Also use `std::shared_ptr<THttpWSEngine>` for keep clear ownership of helper objects, which are supporting different websockets kinds. 3. Use std::string to store text or binary data, assigned to THttpCallArg. . Before special binary storage with malloc/mfree was used. Used for content and post data. 4. Declare several methods in http classes as deprecated. For each method there is replacement with similar functionality, but other arguments. I used ROOT 6.18 as boundary, but this can be changed. 5. Latest JSROOT .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1785:301,usability,clear,clear,301,"This is significant change on top of original PR. Interface of THttpServer classes changed in several places. 1. To make clear ownership, `std::shared_ptr<THttpCallArg>` is used to exchange these objects. between application code and THttpServer. 2. Also use `std::shared_ptr<THttpWSEngine>` for keep clear ownership of helper objects, which are supporting different websockets kinds. 3. Use std::string to store text or binary data, assigned to THttpCallArg. . Before special binary storage with malloc/mfree was used. Used for content and post data. 4. Declare several methods in http classes as deprecated. For each method there is replacement with similar functionality, but other arguments. I used ROOT 6.18 as boundary, but this can be changed. 5. Latest JSROOT .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1785:320,usability,help,helper,320,"This is significant change on top of original PR. Interface of THttpServer classes changed in several places. 1. To make clear ownership, `std::shared_ptr<THttpCallArg>` is used to exchange these objects. between application code and THttpServer. 2. Also use `std::shared_ptr<THttpWSEngine>` for keep clear ownership of helper objects, which are supporting different websockets kinds. 3. Use std::string to store text or binary data, assigned to THttpCallArg. . Before special binary storage with malloc/mfree was used. Used for content and post data. 4. Declare several methods in http classes as deprecated. For each method there is replacement with similar functionality, but other arguments. I used ROOT 6.18 as boundary, but this can be changed. 5. Latest JSROOT .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1785:346,usability,support,supporting,346,"This is significant change on top of original PR. Interface of THttpServer classes changed in several places. 1. To make clear ownership, `std::shared_ptr<THttpCallArg>` is used to exchange these objects. between application code and THttpServer. 2. Also use `std::shared_ptr<THttpWSEngine>` for keep clear ownership of helper objects, which are supporting different websockets kinds. 3. Use std::string to store text or binary data, assigned to THttpCallArg. . Before special binary storage with malloc/mfree was used. Used for content and post data. 4. Declare several methods in http classes as deprecated. For each method there is replacement with similar functionality, but other arguments. I used ROOT 6.18 as boundary, but this can be changed. 5. Latest JSROOT .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1785:170,energy efficiency,core,core,170,"@bellenot . Hi Bertrand,. Seems to be, there are problems with _R__DEPRECATED macros on Windows. They are defined here:. https://github.com/root-project/root/blob/master/core/base/inc/ROOT/RConfig.h#L463-L476. Probably, one should just provide dummy defines for MS. . This is not done for _R_DEPRECATED_REMOVE_NOW macro.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1785:240,interoperability,xml,xml,240,"@Axel-Naumann @bellenot . One important remarks: now THttpCallArg has convenience methods to set content and predefined content type in one call. These methods are:. void SetTextContent(std::string &&txt);. void SetXmlContent(std::string &&xml);. void SetJsonContent(std::string &&json);. void SetBinaryContent(std::string &&bin);. If necessary, one could add few more types (like HTML). In THttpServer and TWebWindow in most cases these methods are used. P.S. And seems to be, Windows is working now. I just disable `_R__DEPRECATED` macros, Bertand could investigate separately if one can enable them again on Windows.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1785:97,performance,content,content,97,"@Axel-Naumann @bellenot . One important remarks: now THttpCallArg has convenience methods to set content and predefined content type in one call. These methods are:. void SetTextContent(std::string &&txt);. void SetXmlContent(std::string &&xml);. void SetJsonContent(std::string &&json);. void SetBinaryContent(std::string &&bin);. If necessary, one could add few more types (like HTML). In THttpServer and TWebWindow in most cases these methods are used. P.S. And seems to be, Windows is working now. I just disable `_R__DEPRECATED` macros, Bertand could investigate separately if one can enable them again on Windows.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1785:120,performance,content,content,120,"@Axel-Naumann @bellenot . One important remarks: now THttpCallArg has convenience methods to set content and predefined content type in one call. These methods are:. void SetTextContent(std::string &&txt);. void SetXmlContent(std::string &&xml);. void SetJsonContent(std::string &&json);. void SetBinaryContent(std::string &&bin);. If necessary, one could add few more types (like HTML). In THttpServer and TWebWindow in most cases these methods are used. P.S. And seems to be, Windows is working now. I just disable `_R__DEPRECATED` macros, Bertand could investigate separately if one can enable them again on Windows.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1785:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1785:145,integrability,sub,submit,145,"@Axel-Naumann . I apply all requested changes here: . https://github.com/linev/root/tree/webwin_https. Once you merged this PR and #1836, I will submit it as next PR.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1785:104,integrability,sub,subsequent,104,I'll merge as is; please consider removing `fDefaultPageCont.clear();` from the `THttpServer` ctor in a subsequent PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1785:61,usability,clear,clear,61,I'll merge as is; please consider removing `fDefaultPageCont.clear();` from the `THttpServer` ctor in a subsequent PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1785
https://github.com/root-project/root/pull/1787:166,integrability,Filter,Filter,166,"that issue is weirder than the title suggests: the following works fine:. ```c++. root [0] ROOT::Experimental::TDF::TInterface<ROOT::Detail::TDF::TFilterBase> c2 = d.Filter([]() { return true; }). ```. but this, with `auto` instead of the full name typed out, doesn't:. ```c++. root [1] auto c = d.Filter([]() { return true; }. ```. maybe we could add a test?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1787
https://github.com/root-project/root/pull/1787:298,integrability,Filter,Filter,298,"that issue is weirder than the title suggests: the following works fine:. ```c++. root [0] ROOT::Experimental::TDF::TInterface<ROOT::Detail::TDF::TFilterBase> c2 = d.Filter([]() { return true; }). ```. but this, with `auto` instead of the full name typed out, doesn't:. ```c++. root [1] auto c = d.Filter([]() { return true; }. ```. maybe we could add a test?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1787
https://github.com/root-project/root/pull/1787:260,reliability,doe,doesn,260,"that issue is weirder than the title suggests: the following works fine:. ```c++. root [0] ROOT::Experimental::TDF::TInterface<ROOT::Detail::TDF::TFilterBase> c2 = d.Filter([]() { return true; }). ```. but this, with `auto` instead of the full name typed out, doesn't:. ```c++. root [1] auto c = d.Filter([]() { return true; }. ```. maybe we could add a test?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1787
https://github.com/root-project/root/pull/1787:354,safety,test,test,354,"that issue is weirder than the title suggests: the following works fine:. ```c++. root [0] ROOT::Experimental::TDF::TInterface<ROOT::Detail::TDF::TFilterBase> c2 = d.Filter([]() { return true; }). ```. but this, with `auto` instead of the full name typed out, doesn't:. ```c++. root [1] auto c = d.Filter([]() { return true; }. ```. maybe we could add a test?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1787
https://github.com/root-project/root/pull/1787:354,testability,test,test,354,"that issue is weirder than the title suggests: the following works fine:. ```c++. root [0] ROOT::Experimental::TDF::TInterface<ROOT::Detail::TDF::TFilterBase> c2 = d.Filter([]() { return true; }). ```. but this, with `auto` instead of the full name typed out, doesn't:. ```c++. root [1] auto c = d.Filter([]() { return true; }. ```. maybe we could add a test?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1787
https://github.com/root-project/root/pull/1787:46,safety,test,test,46,I think I know where the problem is. I have a test that triggers it as part of this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1787
https://github.com/root-project/root/pull/1787:46,testability,test,test,46,I think I know where the problem is. I have a test that triggers it as part of this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1787
https://github.com/root-project/root/pull/1787:317,availability,failur,failures,317,"@vgvassilev how did you address the comment https://github.com/root-project/root/pull/1787#pullrequestreview-106971834 by @pcanal:. > Please make sure that this does not hide a missing feature in GetFullyQualifiedType which is supposed to already have built-in the full qualification. I am collecting a set of tests (failures) of the clang version of `GetFullyQualifiedName`. Adding ""your cases"" to that list might be a way of addressing Philippe's comment. Do you have such test cases?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1787
https://github.com/root-project/root/pull/1787:317,deployability,fail,failures,317,"@vgvassilev how did you address the comment https://github.com/root-project/root/pull/1787#pullrequestreview-106971834 by @pcanal:. > Please make sure that this does not hide a missing feature in GetFullyQualifiedType which is supposed to already have built-in the full qualification. I am collecting a set of tests (failures) of the clang version of `GetFullyQualifiedName`. Adding ""your cases"" to that list might be a way of addressing Philippe's comment. Do you have such test cases?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1787
https://github.com/root-project/root/pull/1787:340,deployability,version,version,340,"@vgvassilev how did you address the comment https://github.com/root-project/root/pull/1787#pullrequestreview-106971834 by @pcanal:. > Please make sure that this does not hide a missing feature in GetFullyQualifiedType which is supposed to already have built-in the full qualification. I am collecting a set of tests (failures) of the clang version of `GetFullyQualifiedName`. Adding ""your cases"" to that list might be a way of addressing Philippe's comment. Do you have such test cases?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1787
https://github.com/root-project/root/pull/1787:340,integrability,version,version,340,"@vgvassilev how did you address the comment https://github.com/root-project/root/pull/1787#pullrequestreview-106971834 by @pcanal:. > Please make sure that this does not hide a missing feature in GetFullyQualifiedType which is supposed to already have built-in the full qualification. I am collecting a set of tests (failures) of the clang version of `GetFullyQualifiedName`. Adding ""your cases"" to that list might be a way of addressing Philippe's comment. Do you have such test cases?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1787
https://github.com/root-project/root/pull/1787:340,modifiability,version,version,340,"@vgvassilev how did you address the comment https://github.com/root-project/root/pull/1787#pullrequestreview-106971834 by @pcanal:. > Please make sure that this does not hide a missing feature in GetFullyQualifiedType which is supposed to already have built-in the full qualification. I am collecting a set of tests (failures) of the clang version of `GetFullyQualifiedName`. Adding ""your cases"" to that list might be a way of addressing Philippe's comment. Do you have such test cases?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1787
https://github.com/root-project/root/pull/1787:317,performance,failur,failures,317,"@vgvassilev how did you address the comment https://github.com/root-project/root/pull/1787#pullrequestreview-106971834 by @pcanal:. > Please make sure that this does not hide a missing feature in GetFullyQualifiedType which is supposed to already have built-in the full qualification. I am collecting a set of tests (failures) of the clang version of `GetFullyQualifiedName`. Adding ""your cases"" to that list might be a way of addressing Philippe's comment. Do you have such test cases?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1787
https://github.com/root-project/root/pull/1787:161,reliability,doe,does,161,"@vgvassilev how did you address the comment https://github.com/root-project/root/pull/1787#pullrequestreview-106971834 by @pcanal:. > Please make sure that this does not hide a missing feature in GetFullyQualifiedType which is supposed to already have built-in the full qualification. I am collecting a set of tests (failures) of the clang version of `GetFullyQualifiedName`. Adding ""your cases"" to that list might be a way of addressing Philippe's comment. Do you have such test cases?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1787
https://github.com/root-project/root/pull/1787:317,reliability,fail,failures,317,"@vgvassilev how did you address the comment https://github.com/root-project/root/pull/1787#pullrequestreview-106971834 by @pcanal:. > Please make sure that this does not hide a missing feature in GetFullyQualifiedType which is supposed to already have built-in the full qualification. I am collecting a set of tests (failures) of the clang version of `GetFullyQualifiedName`. Adding ""your cases"" to that list might be a way of addressing Philippe's comment. Do you have such test cases?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1787
https://github.com/root-project/root/pull/1787:310,safety,test,tests,310,"@vgvassilev how did you address the comment https://github.com/root-project/root/pull/1787#pullrequestreview-106971834 by @pcanal:. > Please make sure that this does not hide a missing feature in GetFullyQualifiedType which is supposed to already have built-in the full qualification. I am collecting a set of tests (failures) of the clang version of `GetFullyQualifiedName`. Adding ""your cases"" to that list might be a way of addressing Philippe's comment. Do you have such test cases?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1787
https://github.com/root-project/root/pull/1787:475,safety,test,test,475,"@vgvassilev how did you address the comment https://github.com/root-project/root/pull/1787#pullrequestreview-106971834 by @pcanal:. > Please make sure that this does not hide a missing feature in GetFullyQualifiedType which is supposed to already have built-in the full qualification. I am collecting a set of tests (failures) of the clang version of `GetFullyQualifiedName`. Adding ""your cases"" to that list might be a way of addressing Philippe's comment. Do you have such test cases?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1787
https://github.com/root-project/root/pull/1787:310,testability,test,tests,310,"@vgvassilev how did you address the comment https://github.com/root-project/root/pull/1787#pullrequestreview-106971834 by @pcanal:. > Please make sure that this does not hide a missing feature in GetFullyQualifiedType which is supposed to already have built-in the full qualification. I am collecting a set of tests (failures) of the clang version of `GetFullyQualifiedName`. Adding ""your cases"" to that list might be a way of addressing Philippe's comment. Do you have such test cases?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1787
https://github.com/root-project/root/pull/1787:475,testability,test,test,475,"@vgvassilev how did you address the comment https://github.com/root-project/root/pull/1787#pullrequestreview-106971834 by @pcanal:. > Please make sure that this does not hide a missing feature in GetFullyQualifiedType which is supposed to already have built-in the full qualification. I am collecting a set of tests (failures) of the clang version of `GetFullyQualifiedName`. Adding ""your cases"" to that list might be a way of addressing Philippe's comment. Do you have such test cases?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1787
https://github.com/root-project/root/pull/1787:32,safety,test,test,32,"Hmm I guess the addition to the test suite qualifies for that. Thanks, settled!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1787
https://github.com/root-project/root/pull/1787:32,testability,test,test,32,"Hmm I guess the addition to the test suite qualifies for that. Thanks, settled!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1787
https://github.com/root-project/root/pull/1788:41,deployability,configurat,configuration,41,Please make sure to not set it for multi-configuration generators (i.e. Visual Studio). It may break the configuration in that case.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1788
https://github.com/root-project/root/pull/1788:105,deployability,configurat,configuration,105,Please make sure to not set it for multi-configuration generators (i.e. Visual Studio). It may break the configuration in that case.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1788
https://github.com/root-project/root/pull/1788:41,integrability,configur,configuration,41,Please make sure to not set it for multi-configuration generators (i.e. Visual Studio). It may break the configuration in that case.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1788
https://github.com/root-project/root/pull/1788:105,integrability,configur,configuration,105,Please make sure to not set it for multi-configuration generators (i.e. Visual Studio). It may break the configuration in that case.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1788
https://github.com/root-project/root/pull/1788:41,modifiability,configur,configuration,41,Please make sure to not set it for multi-configuration generators (i.e. Visual Studio). It may break the configuration in that case.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1788
https://github.com/root-project/root/pull/1788:105,modifiability,configur,configuration,105,Please make sure to not set it for multi-configuration generators (i.e. Visual Studio). It may break the configuration in that case.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1788
https://github.com/root-project/root/pull/1788:41,security,configur,configuration,41,Please make sure to not set it for multi-configuration generators (i.e. Visual Studio). It may break the configuration in that case.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1788
https://github.com/root-project/root/pull/1788:105,security,configur,configuration,105,Please make sure to not set it for multi-configuration generators (i.e. Visual Studio). It may break the configuration in that case.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1788
https://github.com/root-project/root/pull/1788:72,usability,Visual,Visual,72,Please make sure to not set it for multi-configuration generators (i.e. Visual Studio). It may break the configuration in that case.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1788
https://github.com/root-project/root/pull/1789:4,availability,failur,failures,4,All failures were due to git transfer issues.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1789
https://github.com/root-project/root/pull/1789:4,deployability,fail,failures,4,All failures were due to git transfer issues.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1789
https://github.com/root-project/root/pull/1789:4,performance,failur,failures,4,All failures were due to git transfer issues.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1789
https://github.com/root-project/root/pull/1789:4,reliability,fail,failures,4,All failures were due to git transfer issues.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1789
https://github.com/root-project/root/pull/1790:32,energy efficiency,cpu,cpu,32,"Hi @yamaguchi1024 , you mention cpu time. Would it be better to focus on real time since we are optimising for a warm body waiting for ROOT to start?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1790
https://github.com/root-project/root/pull/1790:96,energy efficiency,optim,optimising,96,"Hi @yamaguchi1024 , you mention cpu time. Would it be better to focus on real time since we are optimising for a warm body waiting for ROOT to start?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1790
https://github.com/root-project/root/pull/1790:32,performance,cpu,cpu,32,"Hi @yamaguchi1024 , you mention cpu time. Would it be better to focus on real time since we are optimising for a warm body waiting for ROOT to start?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1790
https://github.com/root-project/root/pull/1790:36,performance,time,time,36,"Hi @yamaguchi1024 , you mention cpu time. Would it be better to focus on real time since we are optimising for a warm body waiting for ROOT to start?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1790
https://github.com/root-project/root/pull/1790:78,performance,time,time,78,"Hi @yamaguchi1024 , you mention cpu time. Would it be better to focus on real time since we are optimising for a warm body waiting for ROOT to start?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1790
https://github.com/root-project/root/pull/1790:81,energy efficiency,cool,cool,81,"btw @yamaguchi1024 , amzing! with these minimal changes we save 10MB at startup, cool!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1790
https://github.com/root-project/root/pull/1790:40,usability,minim,minimal,40,"btw @yamaguchi1024 , amzing! with these minimal changes we save 10MB at startup, cool!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1790
https://github.com/root-project/root/pull/1790:40,performance,time,time,40,@dpiparo Thanks! Agree I'll post a real-time comparison as well.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1790
https://github.com/root-project/root/pull/1790:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1790
https://github.com/root-project/root/pull/1790:326,energy efficiency,load,loading,326,"FWIW, we need to fix this odd behavior in the ASTReader. This PR is a good for ROOT because it eliminates some bad coding practices. However, there is a lot of code out there which we cannot control and makes sense fixing. The underlying issue is that the clang ASTReader eagerly deserializes vtables and inlines upon PCH/PCM loading time. There is no good reason for doing that and we can switch this code to lazily deserialize the entities on demand.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1790
https://github.com/root-project/root/pull/1790:326,performance,load,loading,326,"FWIW, we need to fix this odd behavior in the ASTReader. This PR is a good for ROOT because it eliminates some bad coding practices. However, there is a lot of code out there which we cannot control and makes sense fixing. The underlying issue is that the clang ASTReader eagerly deserializes vtables and inlines upon PCH/PCM loading time. There is no good reason for doing that and we can switch this code to lazily deserialize the entities on demand.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1790
https://github.com/root-project/root/pull/1790:334,performance,time,time,334,"FWIW, we need to fix this odd behavior in the ASTReader. This PR is a good for ROOT because it eliminates some bad coding practices. However, there is a lot of code out there which we cannot control and makes sense fixing. The underlying issue is that the clang ASTReader eagerly deserializes vtables and inlines upon PCH/PCM loading time. There is no good reason for doing that and we can switch this code to lazily deserialize the entities on demand.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1790
https://github.com/root-project/root/pull/1790:122,reliability,pra,practices,122,"FWIW, we need to fix this odd behavior in the ASTReader. This PR is a good for ROOT because it eliminates some bad coding practices. However, there is a lot of code out there which we cannot control and makes sense fixing. The underlying issue is that the clang ASTReader eagerly deserializes vtables and inlines upon PCH/PCM loading time. There is no good reason for doing that and we can switch this code to lazily deserialize the entities on demand.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1790
https://github.com/root-project/root/pull/1790:191,security,control,control,191,"FWIW, we need to fix this odd behavior in the ASTReader. This PR is a good for ROOT because it eliminates some bad coding practices. However, there is a lot of code out there which we cannot control and makes sense fixing. The underlying issue is that the clang ASTReader eagerly deserializes vtables and inlines upon PCH/PCM loading time. There is no good reason for doing that and we can switch this code to lazily deserialize the entities on demand.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1790
https://github.com/root-project/root/pull/1790:191,testability,control,control,191,"FWIW, we need to fix this odd behavior in the ASTReader. This PR is a good for ROOT because it eliminates some bad coding practices. However, there is a lot of code out there which we cannot control and makes sense fixing. The underlying issue is that the clang ASTReader eagerly deserializes vtables and inlines upon PCH/PCM loading time. There is no good reason for doing that and we can switch this code to lazily deserialize the entities on demand.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1790
https://github.com/root-project/root/pull/1790:30,usability,behavi,behavior,30,"FWIW, we need to fix this odd behavior in the ASTReader. This PR is a good for ROOT because it eliminates some bad coding practices. However, there is a lot of code out there which we cannot control and makes sense fixing. The underlying issue is that the clang ASTReader eagerly deserializes vtables and inlines upon PCH/PCM loading time. There is no good reason for doing that and we can switch this code to lazily deserialize the entities on demand.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1790
https://github.com/root-project/root/pull/1790:109,performance,time,time,109,"@yamaguchi1024, I only noticed once I merged. Please make sure you have good-looking git commit history next time!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1790
https://github.com/root-project/root/pull/1796:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1796
https://github.com/root-project/root/pull/1796:22,deployability,integr,integrated,22,"@vgvassilev , we have integrated this in CMSSW ROOT6 IBs and every things looks good. We also see some improvement on the memory usage (on avg 20MB less RSS used during our tests.)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1796
https://github.com/root-project/root/pull/1796:22,integrability,integr,integrated,22,"@vgvassilev , we have integrated this in CMSSW ROOT6 IBs and every things looks good. We also see some improvement on the memory usage (on avg 20MB less RSS used during our tests.)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1796
https://github.com/root-project/root/pull/1796:22,interoperability,integr,integrated,22,"@vgvassilev , we have integrated this in CMSSW ROOT6 IBs and every things looks good. We also see some improvement on the memory usage (on avg 20MB less RSS used during our tests.)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1796
https://github.com/root-project/root/pull/1796:22,modifiability,integr,integrated,22,"@vgvassilev , we have integrated this in CMSSW ROOT6 IBs and every things looks good. We also see some improvement on the memory usage (on avg 20MB less RSS used during our tests.)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1796
https://github.com/root-project/root/pull/1796:122,performance,memor,memory,122,"@vgvassilev , we have integrated this in CMSSW ROOT6 IBs and every things looks good. We also see some improvement on the memory usage (on avg 20MB less RSS used during our tests.)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1796
https://github.com/root-project/root/pull/1796:22,reliability,integr,integrated,22,"@vgvassilev , we have integrated this in CMSSW ROOT6 IBs and every things looks good. We also see some improvement on the memory usage (on avg 20MB less RSS used during our tests.)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1796
https://github.com/root-project/root/pull/1796:173,safety,test,tests,173,"@vgvassilev , we have integrated this in CMSSW ROOT6 IBs and every things looks good. We also see some improvement on the memory usage (on avg 20MB less RSS used during our tests.)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1796
https://github.com/root-project/root/pull/1796:22,security,integr,integrated,22,"@vgvassilev , we have integrated this in CMSSW ROOT6 IBs and every things looks good. We also see some improvement on the memory usage (on avg 20MB less RSS used during our tests.)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1796
https://github.com/root-project/root/pull/1796:22,testability,integr,integrated,22,"@vgvassilev , we have integrated this in CMSSW ROOT6 IBs and every things looks good. We also see some improvement on the memory usage (on avg 20MB less RSS used during our tests.)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1796
https://github.com/root-project/root/pull/1796:173,testability,test,tests,173,"@vgvassilev , we have integrated this in CMSSW ROOT6 IBs and every things looks good. We also see some improvement on the memory usage (on avg 20MB less RSS used during our tests.)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1796
https://github.com/root-project/root/pull/1796:122,usability,memor,memory,122,"@vgvassilev , we have integrated this in CMSSW ROOT6 IBs and every things looks good. We also see some improvement on the memory usage (on avg 20MB less RSS used during our tests.)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1796
https://github.com/root-project/root/pull/1799:394,deployability,updat,update,394,"As a side note, TTree::Draw does not support (in v5 nor v6) function returns reference to numerical type (so std::vector<int>::at). While in v5 TTree::Draw was supporting functions returning reference to object type. I do not plan to lift the limitation for numerical type as in most case one would either return a numerical type by value or can use the implicit looping in TTree::Draw and the update would require a bit of coding (need handle all the numerical types separately). For other cases, it might be better to switch to TDF.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1799
https://github.com/root-project/root/pull/1799:23,energy efficiency,Draw,Draw,23,"As a side note, TTree::Draw does not support (in v5 nor v6) function returns reference to numerical type (so std::vector<int>::at). While in v5 TTree::Draw was supporting functions returning reference to object type. I do not plan to lift the limitation for numerical type as in most case one would either return a numerical type by value or can use the implicit looping in TTree::Draw and the update would require a bit of coding (need handle all the numerical types separately). For other cases, it might be better to switch to TDF.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1799
https://github.com/root-project/root/pull/1799:151,energy efficiency,Draw,Draw,151,"As a side note, TTree::Draw does not support (in v5 nor v6) function returns reference to numerical type (so std::vector<int>::at). While in v5 TTree::Draw was supporting functions returning reference to object type. I do not plan to lift the limitation for numerical type as in most case one would either return a numerical type by value or can use the implicit looping in TTree::Draw and the update would require a bit of coding (need handle all the numerical types separately). For other cases, it might be better to switch to TDF.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1799
https://github.com/root-project/root/pull/1799:381,energy efficiency,Draw,Draw,381,"As a side note, TTree::Draw does not support (in v5 nor v6) function returns reference to numerical type (so std::vector<int>::at). While in v5 TTree::Draw was supporting functions returning reference to object type. I do not plan to lift the limitation for numerical type as in most case one would either return a numerical type by value or can use the implicit looping in TTree::Draw and the update would require a bit of coding (need handle all the numerical types separately). For other cases, it might be better to switch to TDF.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1799
https://github.com/root-project/root/pull/1799:28,reliability,doe,does,28,"As a side note, TTree::Draw does not support (in v5 nor v6) function returns reference to numerical type (so std::vector<int>::at). While in v5 TTree::Draw was supporting functions returning reference to object type. I do not plan to lift the limitation for numerical type as in most case one would either return a numerical type by value or can use the implicit looping in TTree::Draw and the update would require a bit of coding (need handle all the numerical types separately). For other cases, it might be better to switch to TDF.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1799
https://github.com/root-project/root/pull/1799:394,safety,updat,update,394,"As a side note, TTree::Draw does not support (in v5 nor v6) function returns reference to numerical type (so std::vector<int>::at). While in v5 TTree::Draw was supporting functions returning reference to object type. I do not plan to lift the limitation for numerical type as in most case one would either return a numerical type by value or can use the implicit looping in TTree::Draw and the update would require a bit of coding (need handle all the numerical types separately). For other cases, it might be better to switch to TDF.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1799
https://github.com/root-project/root/pull/1799:394,security,updat,update,394,"As a side note, TTree::Draw does not support (in v5 nor v6) function returns reference to numerical type (so std::vector<int>::at). While in v5 TTree::Draw was supporting functions returning reference to object type. I do not plan to lift the limitation for numerical type as in most case one would either return a numerical type by value or can use the implicit looping in TTree::Draw and the update would require a bit of coding (need handle all the numerical types separately). For other cases, it might be better to switch to TDF.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1799
https://github.com/root-project/root/pull/1799:226,testability,plan,plan,226,"As a side note, TTree::Draw does not support (in v5 nor v6) function returns reference to numerical type (so std::vector<int>::at). While in v5 TTree::Draw was supporting functions returning reference to object type. I do not plan to lift the limitation for numerical type as in most case one would either return a numerical type by value or can use the implicit looping in TTree::Draw and the update would require a bit of coding (need handle all the numerical types separately). For other cases, it might be better to switch to TDF.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1799
https://github.com/root-project/root/pull/1799:37,usability,support,support,37,"As a side note, TTree::Draw does not support (in v5 nor v6) function returns reference to numerical type (so std::vector<int>::at). While in v5 TTree::Draw was supporting functions returning reference to object type. I do not plan to lift the limitation for numerical type as in most case one would either return a numerical type by value or can use the implicit looping in TTree::Draw and the update would require a bit of coding (need handle all the numerical types separately). For other cases, it might be better to switch to TDF.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1799
https://github.com/root-project/root/pull/1799:160,usability,support,supporting,160,"As a side note, TTree::Draw does not support (in v5 nor v6) function returns reference to numerical type (so std::vector<int>::at). While in v5 TTree::Draw was supporting functions returning reference to object type. I do not plan to lift the limitation for numerical type as in most case one would either return a numerical type by value or can use the implicit looping in TTree::Draw and the update would require a bit of coding (need handle all the numerical types separately). For other cases, it might be better to switch to TDF.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1799
https://github.com/root-project/root/pull/1799:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1799
https://github.com/root-project/root/pull/1799:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1799
https://github.com/root-project/root/pull/1800:278,availability,failur,failures,278,"Hi @pcanal , this PR was merged even though it broke `gtest_tree_treeplayer_test_dataframe_snapshot`. That test was ok on the [29th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-30) (except for the know failures on 32bit). It started failing consistently in the nightlies since the [30th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-31). . I can reproduce the failures locally in about one out of four runs. A quick investigation shows that reverting `6657223efb` (""Ensure TTreeCloner keep the AutoFlush history."") brings the test back to green (or at least I can't seem to make it fail anymore). Can we revert commit `6657223efb`? EDIT: if yes, the PR is ready at #1813",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1800
https://github.com/root-project/root/pull/1800:317,availability,consist,consistently,317,"Hi @pcanal , this PR was merged even though it broke `gtest_tree_treeplayer_test_dataframe_snapshot`. That test was ok on the [29th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-30) (except for the know failures on 32bit). It started failing consistently in the nightlies since the [30th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-31). . I can reproduce the failures locally in about one out of four runs. A quick investigation shows that reverting `6657223efb` (""Ensure TTreeCloner keep the AutoFlush history."") brings the test back to green (or at least I can't seem to make it fail anymore). Can we revert commit `6657223efb`? EDIT: if yes, the PR is ready at #1813",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1800
https://github.com/root-project/root/pull/1800:511,availability,failur,failures,511,"Hi @pcanal , this PR was merged even though it broke `gtest_tree_treeplayer_test_dataframe_snapshot`. That test was ok on the [29th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-30) (except for the know failures on 32bit). It started failing consistently in the nightlies since the [30th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-31). . I can reproduce the failures locally in about one out of four runs. A quick investigation shows that reverting `6657223efb` (""Ensure TTreeCloner keep the AutoFlush history."") brings the test back to green (or at least I can't seem to make it fail anymore). Can we revert commit `6657223efb`? EDIT: if yes, the PR is ready at #1813",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1800
https://github.com/root-project/root/pull/1800:278,deployability,fail,failures,278,"Hi @pcanal , this PR was merged even though it broke `gtest_tree_treeplayer_test_dataframe_snapshot`. That test was ok on the [29th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-30) (except for the know failures on 32bit). It started failing consistently in the nightlies since the [30th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-31). . I can reproduce the failures locally in about one out of four runs. A quick investigation shows that reverting `6657223efb` (""Ensure TTreeCloner keep the AutoFlush history."") brings the test back to green (or at least I can't seem to make it fail anymore). Can we revert commit `6657223efb`? EDIT: if yes, the PR is ready at #1813",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1800
https://github.com/root-project/root/pull/1800:309,deployability,fail,failing,309,"Hi @pcanal , this PR was merged even though it broke `gtest_tree_treeplayer_test_dataframe_snapshot`. That test was ok on the [29th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-30) (except for the know failures on 32bit). It started failing consistently in the nightlies since the [30th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-31). . I can reproduce the failures locally in about one out of four runs. A quick investigation shows that reverting `6657223efb` (""Ensure TTreeCloner keep the AutoFlush history."") brings the test back to green (or at least I can't seem to make it fail anymore). Can we revert commit `6657223efb`? EDIT: if yes, the PR is ready at #1813",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1800
https://github.com/root-project/root/pull/1800:511,deployability,fail,failures,511,"Hi @pcanal , this PR was merged even though it broke `gtest_tree_treeplayer_test_dataframe_snapshot`. That test was ok on the [29th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-30) (except for the know failures on 32bit). It started failing consistently in the nightlies since the [30th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-31). . I can reproduce the failures locally in about one out of four runs. A quick investigation shows that reverting `6657223efb` (""Ensure TTreeCloner keep the AutoFlush history."") brings the test back to green (or at least I can't seem to make it fail anymore). Can we revert commit `6657223efb`? EDIT: if yes, the PR is ready at #1813",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1800
https://github.com/root-project/root/pull/1800:733,deployability,fail,fail,733,"Hi @pcanal , this PR was merged even though it broke `gtest_tree_treeplayer_test_dataframe_snapshot`. That test was ok on the [29th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-30) (except for the know failures on 32bit). It started failing consistently in the nightlies since the [30th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-31). . I can reproduce the failures locally in about one out of four runs. A quick investigation shows that reverting `6657223efb` (""Ensure TTreeCloner keep the AutoFlush history."") brings the test back to green (or at least I can't seem to make it fail anymore). Can we revert commit `6657223efb`? EDIT: if yes, the PR is ready at #1813",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1800
https://github.com/root-project/root/pull/1800:690,energy efficiency,green,green,690,"Hi @pcanal , this PR was merged even though it broke `gtest_tree_treeplayer_test_dataframe_snapshot`. That test was ok on the [29th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-30) (except for the know failures on 32bit). It started failing consistently in the nightlies since the [30th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-31). . I can reproduce the failures locally in about one out of four runs. A quick investigation shows that reverting `6657223efb` (""Ensure TTreeCloner keep the AutoFlush history."") brings the test back to green (or at least I can't seem to make it fail anymore). Can we revert commit `6657223efb`? EDIT: if yes, the PR is ready at #1813",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1800
https://github.com/root-project/root/pull/1800:278,performance,failur,failures,278,"Hi @pcanal , this PR was merged even though it broke `gtest_tree_treeplayer_test_dataframe_snapshot`. That test was ok on the [29th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-30) (except for the know failures on 32bit). It started failing consistently in the nightlies since the [30th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-31). . I can reproduce the failures locally in about one out of four runs. A quick investigation shows that reverting `6657223efb` (""Ensure TTreeCloner keep the AutoFlush history."") brings the test back to green (or at least I can't seem to make it fail anymore). Can we revert commit `6657223efb`? EDIT: if yes, the PR is ready at #1813",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1800
https://github.com/root-project/root/pull/1800:511,performance,failur,failures,511,"Hi @pcanal , this PR was merged even though it broke `gtest_tree_treeplayer_test_dataframe_snapshot`. That test was ok on the [29th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-30) (except for the know failures on 32bit). It started failing consistently in the nightlies since the [30th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-31). . I can reproduce the failures locally in about one out of four runs. A quick investigation shows that reverting `6657223efb` (""Ensure TTreeCloner keep the AutoFlush history."") brings the test back to green (or at least I can't seem to make it fail anymore). Can we revert commit `6657223efb`? EDIT: if yes, the PR is ready at #1813",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1800
https://github.com/root-project/root/pull/1800:278,reliability,fail,failures,278,"Hi @pcanal , this PR was merged even though it broke `gtest_tree_treeplayer_test_dataframe_snapshot`. That test was ok on the [29th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-30) (except for the know failures on 32bit). It started failing consistently in the nightlies since the [30th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-31). . I can reproduce the failures locally in about one out of four runs. A quick investigation shows that reverting `6657223efb` (""Ensure TTreeCloner keep the AutoFlush history."") brings the test back to green (or at least I can't seem to make it fail anymore). Can we revert commit `6657223efb`? EDIT: if yes, the PR is ready at #1813",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1800
https://github.com/root-project/root/pull/1800:309,reliability,fail,failing,309,"Hi @pcanal , this PR was merged even though it broke `gtest_tree_treeplayer_test_dataframe_snapshot`. That test was ok on the [29th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-30) (except for the know failures on 32bit). It started failing consistently in the nightlies since the [30th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-31). . I can reproduce the failures locally in about one out of four runs. A quick investigation shows that reverting `6657223efb` (""Ensure TTreeCloner keep the AutoFlush history."") brings the test back to green (or at least I can't seem to make it fail anymore). Can we revert commit `6657223efb`? EDIT: if yes, the PR is ready at #1813",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1800
https://github.com/root-project/root/pull/1800:511,reliability,fail,failures,511,"Hi @pcanal , this PR was merged even though it broke `gtest_tree_treeplayer_test_dataframe_snapshot`. That test was ok on the [29th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-30) (except for the know failures on 32bit). It started failing consistently in the nightlies since the [30th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-31). . I can reproduce the failures locally in about one out of four runs. A quick investigation shows that reverting `6657223efb` (""Ensure TTreeCloner keep the AutoFlush history."") brings the test back to green (or at least I can't seem to make it fail anymore). Can we revert commit `6657223efb`? EDIT: if yes, the PR is ready at #1813",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1800
https://github.com/root-project/root/pull/1800:733,reliability,fail,fail,733,"Hi @pcanal , this PR was merged even though it broke `gtest_tree_treeplayer_test_dataframe_snapshot`. That test was ok on the [29th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-30) (except for the know failures on 32bit). It started failing consistently in the nightlies since the [30th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-31). . I can reproduce the failures locally in about one out of four runs. A quick investigation shows that reverting `6657223efb` (""Ensure TTreeCloner keep the AutoFlush history."") brings the test back to green (or at least I can't seem to make it fail anymore). Can we revert commit `6657223efb`? EDIT: if yes, the PR is ready at #1813",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1800
https://github.com/root-project/root/pull/1800:107,safety,test,test,107,"Hi @pcanal , this PR was merged even though it broke `gtest_tree_treeplayer_test_dataframe_snapshot`. That test was ok on the [29th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-30) (except for the know failures on 32bit). It started failing consistently in the nightlies since the [30th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-31). . I can reproduce the failures locally in about one out of four runs. A quick investigation shows that reverting `6657223efb` (""Ensure TTreeCloner keep the AutoFlush history."") brings the test back to green (or at least I can't seem to make it fail anymore). Can we revert commit `6657223efb`? EDIT: if yes, the PR is ready at #1813",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1800
https://github.com/root-project/root/pull/1800:163,safety,test,testSummary,163,"Hi @pcanal , this PR was merged even though it broke `gtest_tree_treeplayer_test_dataframe_snapshot`. That test was ok on the [29th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-30) (except for the know failures on 32bit). It started failing consistently in the nightlies since the [30th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-31). . I can reproduce the failures locally in about one out of four runs. A quick investigation shows that reverting `6657223efb` (""Ensure TTreeCloner keep the AutoFlush history."") brings the test back to green (or at least I can't seem to make it fail anymore). Can we revert commit `6657223efb`? EDIT: if yes, the PR is ready at #1813",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1800
https://github.com/root-project/root/pull/1800:216,safety,test,test-dataframe-snapshot,216,"Hi @pcanal , this PR was merged even though it broke `gtest_tree_treeplayer_test_dataframe_snapshot`. That test was ok on the [29th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-30) (except for the know failures on 32bit). It started failing consistently in the nightlies since the [30th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-31). . I can reproduce the failures locally in about one out of four runs. A quick investigation shows that reverting `6657223efb` (""Ensure TTreeCloner keep the AutoFlush history."") brings the test back to green (or at least I can't seem to make it fail anymore). Can we revert commit `6657223efb`? EDIT: if yes, the PR is ready at #1813",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1800
https://github.com/root-project/root/pull/1800:258,safety,except,except,258,"Hi @pcanal , this PR was merged even though it broke `gtest_tree_treeplayer_test_dataframe_snapshot`. That test was ok on the [29th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-30) (except for the know failures on 32bit). It started failing consistently in the nightlies since the [30th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-31). . I can reproduce the failures locally in about one out of four runs. A quick investigation shows that reverting `6657223efb` (""Ensure TTreeCloner keep the AutoFlush history."") brings the test back to green (or at least I can't seem to make it fail anymore). Can we revert commit `6657223efb`? EDIT: if yes, the PR is ready at #1813",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1800
https://github.com/root-project/root/pull/1800:394,safety,test,testSummary,394,"Hi @pcanal , this PR was merged even though it broke `gtest_tree_treeplayer_test_dataframe_snapshot`. That test was ok on the [29th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-30) (except for the know failures on 32bit). It started failing consistently in the nightlies since the [30th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-31). . I can reproduce the failures locally in about one out of four runs. A quick investigation shows that reverting `6657223efb` (""Ensure TTreeCloner keep the AutoFlush history."") brings the test back to green (or at least I can't seem to make it fail anymore). Can we revert commit `6657223efb`? EDIT: if yes, the PR is ready at #1813",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1800
https://github.com/root-project/root/pull/1800:447,safety,test,test-dataframe-snapshot,447,"Hi @pcanal , this PR was merged even though it broke `gtest_tree_treeplayer_test_dataframe_snapshot`. That test was ok on the [29th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-30) (except for the know failures on 32bit). It started failing consistently in the nightlies since the [30th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-31). . I can reproduce the failures locally in about one out of four runs. A quick investigation shows that reverting `6657223efb` (""Ensure TTreeCloner keep the AutoFlush history."") brings the test back to green (or at least I can't seem to make it fail anymore). Can we revert commit `6657223efb`? EDIT: if yes, the PR is ready at #1813",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1800
https://github.com/root-project/root/pull/1800:677,safety,test,test,677,"Hi @pcanal , this PR was merged even though it broke `gtest_tree_treeplayer_test_dataframe_snapshot`. That test was ok on the [29th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-30) (except for the know failures on 32bit). It started failing consistently in the nightlies since the [30th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-31). . I can reproduce the failures locally in about one out of four runs. A quick investigation shows that reverting `6657223efb` (""Ensure TTreeCloner keep the AutoFlush history."") brings the test back to green (or at least I can't seem to make it fail anymore). Can we revert commit `6657223efb`? EDIT: if yes, the PR is ready at #1813",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1800
https://github.com/root-project/root/pull/1800:107,testability,test,test,107,"Hi @pcanal , this PR was merged even though it broke `gtest_tree_treeplayer_test_dataframe_snapshot`. That test was ok on the [29th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-30) (except for the know failures on 32bit). It started failing consistently in the nightlies since the [30th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-31). . I can reproduce the failures locally in about one out of four runs. A quick investigation shows that reverting `6657223efb` (""Ensure TTreeCloner keep the AutoFlush history."") brings the test back to green (or at least I can't seem to make it fail anymore). Can we revert commit `6657223efb`? EDIT: if yes, the PR is ready at #1813",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1800
https://github.com/root-project/root/pull/1800:163,testability,test,testSummary,163,"Hi @pcanal , this PR was merged even though it broke `gtest_tree_treeplayer_test_dataframe_snapshot`. That test was ok on the [29th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-30) (except for the know failures on 32bit). It started failing consistently in the nightlies since the [30th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-31). . I can reproduce the failures locally in about one out of four runs. A quick investigation shows that reverting `6657223efb` (""Ensure TTreeCloner keep the AutoFlush history."") brings the test back to green (or at least I can't seem to make it fail anymore). Can we revert commit `6657223efb`? EDIT: if yes, the PR is ready at #1813",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1800
https://github.com/root-project/root/pull/1800:216,testability,test,test-dataframe-snapshot,216,"Hi @pcanal , this PR was merged even though it broke `gtest_tree_treeplayer_test_dataframe_snapshot`. That test was ok on the [29th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-30) (except for the know failures on 32bit). It started failing consistently in the nightlies since the [30th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-31). . I can reproduce the failures locally in about one out of four runs. A quick investigation shows that reverting `6657223efb` (""Ensure TTreeCloner keep the AutoFlush history."") brings the test back to green (or at least I can't seem to make it fail anymore). Can we revert commit `6657223efb`? EDIT: if yes, the PR is ready at #1813",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1800
https://github.com/root-project/root/pull/1800:394,testability,test,testSummary,394,"Hi @pcanal , this PR was merged even though it broke `gtest_tree_treeplayer_test_dataframe_snapshot`. That test was ok on the [29th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-30) (except for the know failures on 32bit). It started failing consistently in the nightlies since the [30th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-31). . I can reproduce the failures locally in about one out of four runs. A quick investigation shows that reverting `6657223efb` (""Ensure TTreeCloner keep the AutoFlush history."") brings the test back to green (or at least I can't seem to make it fail anymore). Can we revert commit `6657223efb`? EDIT: if yes, the PR is ready at #1813",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1800
https://github.com/root-project/root/pull/1800:447,testability,test,test-dataframe-snapshot,447,"Hi @pcanal , this PR was merged even though it broke `gtest_tree_treeplayer_test_dataframe_snapshot`. That test was ok on the [29th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-30) (except for the know failures on 32bit). It started failing consistently in the nightlies since the [30th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-31). . I can reproduce the failures locally in about one out of four runs. A quick investigation shows that reverting `6657223efb` (""Ensure TTreeCloner keep the AutoFlush history."") brings the test back to green (or at least I can't seem to make it fail anymore). Can we revert commit `6657223efb`? EDIT: if yes, the PR is ready at #1813",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1800
https://github.com/root-project/root/pull/1800:677,testability,test,test,677,"Hi @pcanal , this PR was merged even though it broke `gtest_tree_treeplayer_test_dataframe_snapshot`. That test was ok on the [29th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-30) (except for the know failures on 32bit). It started failing consistently in the nightlies since the [30th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-31). . I can reproduce the failures locally in about one out of four runs. A quick investigation shows that reverting `6657223efb` (""Ensure TTreeCloner keep the AutoFlush history."") brings the test back to green (or at least I can't seem to make it fail anymore). Can we revert commit `6657223efb`? EDIT: if yes, the PR is ready at #1813",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1800
https://github.com/root-project/root/pull/1800:317,usability,consist,consistently,317,"Hi @pcanal , this PR was merged even though it broke `gtest_tree_treeplayer_test_dataframe_snapshot`. That test was ok on the [29th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-30) (except for the know failures on 32bit). It started failing consistently in the nightlies since the [30th of March](http://cdash.cern.ch/testSummary.php?project=1&name=gtest-tree-treeplayer-test-dataframe-snapshot&date=2018-03-31). . I can reproduce the failures locally in about one out of four runs. A quick investigation shows that reverting `6657223efb` (""Ensure TTreeCloner keep the AutoFlush history."") brings the test back to green (or at least I can't seem to make it fail anymore). Can we revert commit `6657223efb`? EDIT: if yes, the PR is ready at #1813",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1800
https://github.com/root-project/root/pull/1801:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1801
https://github.com/root-project/root/pull/1801:8,interoperability,share,share,8,Can you share the benchmark that you use to assert the improvement and its result? Thanks.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1801
https://github.com/root-project/root/pull/1801:44,testability,assert,assert,44,Can you share the benchmark that you use to assert the improvement and its result? Thanks.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1801
https://github.com/root-project/root/pull/1801:30,deployability,updat,update,30,@silas-gross Could you please update your branch to address the issues shown above by the CI system? Thank you.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1801
https://github.com/root-project/root/pull/1801:30,safety,updat,update,30,@silas-gross Could you please update your branch to address the issues shown above by the CI system? Thank you.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1801
https://github.com/root-project/root/pull/1801:30,security,updat,update,30,@silas-gross Could you please update your branch to address the issues shown above by the CI system? Thank you.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1801
https://github.com/root-project/root/pull/1803:11,deployability,build,build,11,@phsft-bot build please.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1803
https://github.com/root-project/root/pull/1807:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1807
https://github.com/root-project/root/pull/1808:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1808
https://github.com/root-project/root/pull/1809:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1809
https://github.com/root-project/root/pull/1809:31,deployability,fail,failing,31,"Those two tests in Jenkins are failing on other PRs as well, it looks like.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1809
https://github.com/root-project/root/pull/1809:31,reliability,fail,failing,31,"Those two tests in Jenkins are failing on other PRs as well, it looks like.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1809
https://github.com/root-project/root/pull/1809:10,safety,test,tests,10,"Those two tests in Jenkins are failing on other PRs as well, it looks like.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1809
https://github.com/root-project/root/pull/1809:10,testability,test,tests,10,"Those two tests in Jenkins are failing on other PRs as well, it looks like.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1809
https://github.com/root-project/root/pull/1809:38,integrability,interfac,interface,38,Merged locally without using GitHub's interface.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1809
https://github.com/root-project/root/pull/1809:38,interoperability,interfac,interface,38,Merged locally without using GitHub's interface.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1809
https://github.com/root-project/root/pull/1809:38,modifiability,interfac,interface,38,Merged locally without using GitHub's interface.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1809
https://github.com/root-project/root/pull/1810:300,performance,I/O,I/O,300,"@vgvassilev it seems `Snapshot` here is writing 194 entries instead of 100 for one out of three compression algorithms (cannot tell which one). This is weird to say the least, and it looks unrelated to the PR, but we have never seen this effect before: is there a chance that your changes affect the I/O?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1810
https://github.com/root-project/root/pull/1810:11,deployability,build,build,11,"@phsft-bot build! @bluehood, the patch affects the interpreter, thus IO. However, I do not see how it might relate to it.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1810
https://github.com/root-project/root/pull/1810:33,deployability,patch,patch,33,"@phsft-bot build! @bluehood, the patch affects the interpreter, thus IO. However, I do not see how it might relate to it.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1810
https://github.com/root-project/root/pull/1810:33,safety,patch,patch,33,"@phsft-bot build! @bluehood, the patch affects the interpreter, thus IO. However, I do not see how it might relate to it.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1810
https://github.com/root-project/root/pull/1810:33,security,patch,patch,33,"@phsft-bot build! @bluehood, the patch affects the interpreter, thus IO. However, I do not see how it might relate to it.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1810
https://github.com/root-project/root/pull/1810:34,usability,behavi,behavior,34,"@vgvassilev nevertheless imo this behavior should be understood before merging -- writing bogus data is bad. EDIT: could very well be a bug in TDF, but as I said we never saw this behavior before",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1810
https://github.com/root-project/root/pull/1810:180,usability,behavi,behavior,180,"@vgvassilev nevertheless imo this behavior should be understood before merging -- writing bogus data is bad. EDIT: could very well be a bug in TDF, but as I said we never saw this behavior before",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1810
https://github.com/root-project/root/pull/1810:41,deployability,fail,failing,41,"@vgvassilev I take it back, this started failing last week and it can be seen in the nightlies -- it's definitely not your PR. sorry i just got back and am still catching up",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1810
https://github.com/root-project/root/pull/1810:41,reliability,fail,failing,41,"@vgvassilev I take it back, this started failing last week and it can be seen in the nightlies -- it's definitely not your PR. sorry i just got back and am still catching up",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1810
https://github.com/root-project/root/pull/1813:0,availability,Failur,Failures,0,Failures are fixed by commit deef68254.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1813
https://github.com/root-project/root/pull/1813:0,deployability,Fail,Failures,0,Failures are fixed by commit deef68254.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1813
https://github.com/root-project/root/pull/1813:0,performance,Failur,Failures,0,Failures are fixed by commit deef68254.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1813
https://github.com/root-project/root/pull/1813:0,reliability,Fail,Failures,0,Failures are fixed by commit deef68254.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1813
https://github.com/root-project/root/pull/1814:11,deployability,build,build,11,@phsft-bot build just on slc6/gcc62 with flags -Druntime_cxxmodules=On -Dctest_test_exclude_none=on,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:11,deployability,build,build,11,@phsft-bot build just on slc6/gcc62 with flags -Druntime_cxxmodules=On -Dctest_test_exclude_none=on,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:11,deployability,build,build,11,@phsft-bot build just on slc6/gcc62 with flags -Druntime_cxxmodules=On -Dctest_test_exclude_none=on,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:11,deployability,build,build,11,@phsft-bot build just on slc6/gcc62 with flags -Druntime_cxxmodules=On -Dctest_test_exclude_none=on,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:11,deployability,build,build,11,@phsft-bot build just on slc6/gcc62 with flags -Druntime_cxxmodules=On -Dctest_test_exclude_none=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:11,deployability,build,build,11,@phsft-bot build just on slc6/gcc62 with flags -Druntime_cxxmodules=On -Dctest_test_exclude_none=On -DCMAKE_BUILD_TYPE=Release,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:119,deployability,Releas,Release,119,@phsft-bot build just on slc6/gcc62 with flags -Druntime_cxxmodules=On -Dctest_test_exclude_none=On -DCMAKE_BUILD_TYPE=Release,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:11,deployability,build,build,11,@phsft-bot build just on slc6/gcc62 with flags -Druntime_cxxmodules=On -Dctest_test_exclude_none=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:11,deployability,build,build,11,@phsft-bot build just on slc6/gcc62 with flags -DLLVM_BUILD_TYPE=Debug -Droofit=Off -Druntime_cxxmodules=On -DCMAKE_VERBOSE_MAKEFILE:BOOL=On -Dctest_test_exclude_none=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:11,deployability,build,build,11,@phsft-bot build just on slc6/gcc62 with flags -DLLVM_BUILD_TYPE=Debug -Droofit=Off -Druntime_cxxmodules=On -DCMAKE_VERBOSE_MAKEFILE:BOOL=On -Dctest_test_exclude_none=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:11,deployability,build,build,11,@phsft-bot build just on slc6/gcc62 with flags -DLLVM_BUILD_TYPE=Debug -Droofit=Off -Druntime_cxxmodules=On -Dctest_test_exclude_none=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:11,deployability,build,build,11,@phsft-bot build just on slc6/gcc62 with flags -DLLVM_BUILD_TYPE=Debug -Droofit=Off -Druntime_cxxmodules=On -Dctest_test_exclude_none=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:11,deployability,build,build,11,@phsft-bot build just on slc6/gcc62 with flags -DLLVM_BUILD_TYPE=Debug -Droofit=Off -Druntime_cxxmodules=On -Dctest_test_exclude_none=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:11,deployability,build,build,11,@phsft-bot build just on slc6/gcc62 with flags -Droofit=Off -Druntime_cxxmodules=On -Dctest_test_exclude_none=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:11,deployability,build,build,11,@phsft-bot build just on slc6/gcc62 with flags -Droofit=Off -Druntime_cxxmodules=On -Dctest_test_exclude_none=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:11,deployability,build,build,11,@phsft-bot build just on slc6/gcc62 with flags -DLLVM_BUILD_TYPE=Debug -Droofit=Off -Druntime_cxxmodules=On -Dctest_test_exclude_none=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:11,deployability,build,build,11,@phsft-bot build just on slc6/gcc62 with flags -DLLVM_BUILD_TYPE=Debug -Droofit=Off -Druntime_cxxmodules=On -Dctest_test_exclude_none=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:142,deployability,fail,failing,142,"@Axel-Naumann . I think you wanted to comment to #1824 ? Comments are anyway welcome, but I'm cherry-picking commits from other prs which fix failing tests to here to see if they actually fix on server with allmodules.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:142,reliability,fail,failing,142,"@Axel-Naumann . I think you wanted to comment to #1824 ? Comments are anyway welcome, but I'm cherry-picking commits from other prs which fix failing tests to here to see if they actually fix on server with allmodules.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:150,safety,test,tests,150,"@Axel-Naumann . I think you wanted to comment to #1824 ? Comments are anyway welcome, but I'm cherry-picking commits from other prs which fix failing tests to here to see if they actually fix on server with allmodules.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:150,testability,test,tests,150,"@Axel-Naumann . I think you wanted to comment to #1824 ? Comments are anyway welcome, but I'm cherry-picking commits from other prs which fix failing tests to here to see if they actually fix on server with allmodules.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:93,deployability,stage,stage,93,"Well this PR here says ""needs review"" so there you go... If you're not in the ""needs review"" stage then please remove the tag.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:30,safety,review,review,30,"Well this PR here says ""needs review"" so there you go... If you're not in the ""needs review"" stage then please remove the tag.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:85,safety,review,review,85,"Well this PR here says ""needs review"" so there you go... If you're not in the ""needs review"" stage then please remove the tag.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:30,testability,review,review,30,"Well this PR here says ""needs review"" so there you go... If you're not in the ""needs review"" stage then please remove the tag.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:85,testability,review,review,85,"Well this PR here says ""needs review"" so there you go... If you're not in the ""needs review"" stage then please remove the tag.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:209,deployability,modul,modules,209,"I need reviews with ff92206745ba8c800bd6354405d00ac874fa26c0 commit. For other PRs, I'll cherry-pick them to here when we change. But I'd like to land other PRs first because this PR affects only with runtime modules but other PRs also affects non-module builds.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:248,deployability,modul,module,248,"I need reviews with ff92206745ba8c800bd6354405d00ac874fa26c0 commit. For other PRs, I'll cherry-pick them to here when we change. But I'd like to land other PRs first because this PR affects only with runtime modules but other PRs also affects non-module builds.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:255,deployability,build,builds,255,"I need reviews with ff92206745ba8c800bd6354405d00ac874fa26c0 commit. For other PRs, I'll cherry-pick them to here when we change. But I'd like to land other PRs first because this PR affects only with runtime modules but other PRs also affects non-module builds.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:209,modifiability,modul,modules,209,"I need reviews with ff92206745ba8c800bd6354405d00ac874fa26c0 commit. For other PRs, I'll cherry-pick them to here when we change. But I'd like to land other PRs first because this PR affects only with runtime modules but other PRs also affects non-module builds.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:248,modifiability,modul,module,248,"I need reviews with ff92206745ba8c800bd6354405d00ac874fa26c0 commit. For other PRs, I'll cherry-pick them to here when we change. But I'd like to land other PRs first because this PR affects only with runtime modules but other PRs also affects non-module builds.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:7,safety,review,reviews,7,"I need reviews with ff92206745ba8c800bd6354405d00ac874fa26c0 commit. For other PRs, I'll cherry-pick them to here when we change. But I'd like to land other PRs first because this PR affects only with runtime modules but other PRs also affects non-module builds.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:209,safety,modul,modules,209,"I need reviews with ff92206745ba8c800bd6354405d00ac874fa26c0 commit. For other PRs, I'll cherry-pick them to here when we change. But I'd like to land other PRs first because this PR affects only with runtime modules but other PRs also affects non-module builds.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:248,safety,modul,module,248,"I need reviews with ff92206745ba8c800bd6354405d00ac874fa26c0 commit. For other PRs, I'll cherry-pick them to here when we change. But I'd like to land other PRs first because this PR affects only with runtime modules but other PRs also affects non-module builds.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:7,testability,review,reviews,7,"I need reviews with ff92206745ba8c800bd6354405d00ac874fa26c0 commit. For other PRs, I'll cherry-pick them to here when we change. But I'd like to land other PRs first because this PR affects only with runtime modules but other PRs also affects non-module builds.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:11,deployability,build,build,11,@phsft-bot build just on slc6/gcc62 with flags -Druntime_cxxmodules=On -Dctest_test_exclude_none=on,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:11,deployability,build,build,11,@phsft-bot build just on slc6/gcc62 with flags -Druntime_cxxmodules=On -Dctest_test_exclude_none=on,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:11,deployability,build,build,11,@phsft-bot build just on slc6/gcc62 with flags -DLLVM_BUILD_TYPE=Debug -Droofit=Off -Druntime_cxxmodules=On -Dctest_test_exclude_none=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:11,deployability,build,build,11,@phsft-bot build just on slc6/gcc62 with flags -DLLVM_BUILD_TYPE=Debug -Droofit=Off -Druntime_cxxmodules=On -Dctest_test_exclude_none=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:11,deployability,build,build,11,@phsft-bot build just on slc6/gcc62 with flags -DLLVM_BUILD_TYPE=Debug -Droofit=Off -Druntime_cxxmodules=On -Dctest_test_exclude_none=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:11,deployability,build,build,11,"@phsft-bot build on slc6/clang39, slc6/gcc48, slc6/gcc48, slc6/gcc49, slc6/gcc52, centos7/gcc62, centos7/gcc7, centos7/gcc7, ubuntu16/native, mac1013/native, windows10/vc15 with flags -Dvc=OFF -Dimt=ON -Dccache=ON",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:11,deployability,build,build,11,@phsft-bot build!!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:11,deployability,build,build,11,@phsft-bot build!!!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:11,deployability,build,build,11,@phsft-bot build!!!!!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:11,deployability,build,build,11,@phsft-bot build just on slc6/gcc62 with flags -Druntime_cxxmodules=On -Dctest_test_exclude_none=on,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:11,deployability,build,build,11,"@phsft-bot build on slc6/clang39, slc6/gcc48, slc6/gcc48, slc6/gcc49, slc6/gcc52, centos7/gcc62, centos7/gcc7, centos7/gcc7, ubuntu16/native, mac1013/native, windows10/vc15 with flags -Dvc=OFF -Dimt=ON -Dccache=ON",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:22,safety,review,review,22,@Axel-Naumann Can you review?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:22,testability,review,review,22,@Axel-Naumann Can you review?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:41,availability,failur,failure,41,"Could a comment be added here on why the failure ""projectroot.roottest.root.meta.roottest_root_meta_execUnloading_auto"" does not prevent merging? (i.e. what is the plan to resolve it (upcoming fix in ROOT or ROOTTEST or revert this PR or something else?) ... in the meantime this will show up in all master builds including new PRs ... )",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:41,deployability,fail,failure,41,"Could a comment be added here on why the failure ""projectroot.roottest.root.meta.roottest_root_meta_execUnloading_auto"" does not prevent merging? (i.e. what is the plan to resolve it (upcoming fix in ROOT or ROOTTEST or revert this PR or something else?) ... in the meantime this will show up in all master builds including new PRs ... )",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:307,deployability,build,builds,307,"Could a comment be added here on why the failure ""projectroot.roottest.root.meta.roottest_root_meta_execUnloading_auto"" does not prevent merging? (i.e. what is the plan to resolve it (upcoming fix in ROOT or ROOTTEST or revert this PR or something else?) ... in the meantime this will show up in all master builds including new PRs ... )",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:41,performance,failur,failure,41,"Could a comment be added here on why the failure ""projectroot.roottest.root.meta.roottest_root_meta_execUnloading_auto"" does not prevent merging? (i.e. what is the plan to resolve it (upcoming fix in ROOT or ROOTTEST or revert this PR or something else?) ... in the meantime this will show up in all master builds including new PRs ... )",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:41,reliability,fail,failure,41,"Could a comment be added here on why the failure ""projectroot.roottest.root.meta.roottest_root_meta_execUnloading_auto"" does not prevent merging? (i.e. what is the plan to resolve it (upcoming fix in ROOT or ROOTTEST or revert this PR or something else?) ... in the meantime this will show up in all master builds including new PRs ... )",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:120,reliability,doe,does,120,"Could a comment be added here on why the failure ""projectroot.roottest.root.meta.roottest_root_meta_execUnloading_auto"" does not prevent merging? (i.e. what is the plan to resolve it (upcoming fix in ROOT or ROOTTEST or revert this PR or something else?) ... in the meantime this will show up in all master builds including new PRs ... )",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:129,safety,prevent,prevent,129,"Could a comment be added here on why the failure ""projectroot.roottest.root.meta.roottest_root_meta_execUnloading_auto"" does not prevent merging? (i.e. what is the plan to resolve it (upcoming fix in ROOT or ROOTTEST or revert this PR or something else?) ... in the meantime this will show up in all master builds including new PRs ... )",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:129,security,preven,prevent,129,"Could a comment be added here on why the failure ""projectroot.roottest.root.meta.roottest_root_meta_execUnloading_auto"" does not prevent merging? (i.e. what is the plan to resolve it (upcoming fix in ROOT or ROOTTEST or revert this PR or something else?) ... in the meantime this will show up in all master builds including new PRs ... )",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:164,testability,plan,plan,164,"Could a comment be added here on why the failure ""projectroot.roottest.root.meta.roottest_root_meta_execUnloading_auto"" does not prevent merging? (i.e. what is the plan to resolve it (upcoming fix in ROOT or ROOTTEST or revert this PR or something else?) ... in the meantime this will show up in all master builds including new PRs ... )",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:50,deployability,updat,updated,50,To answer my own question:. The test needed to be updated and was updated by https://github.com/root-project/roottest/pull/180. Several PR and incremental failed due to the (unavoidable) lag between this PR being merged in and the roottest PR being merged in.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:66,deployability,updat,updated,66,To answer my own question:. The test needed to be updated and was updated by https://github.com/root-project/roottest/pull/180. Several PR and incremental failed due to the (unavoidable) lag between this PR being merged in and the roottest PR being merged in.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:155,deployability,fail,failed,155,To answer my own question:. The test needed to be updated and was updated by https://github.com/root-project/roottest/pull/180. Several PR and incremental failed due to the (unavoidable) lag between this PR being merged in and the roottest PR being merged in.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:155,reliability,fail,failed,155,To answer my own question:. The test needed to be updated and was updated by https://github.com/root-project/roottest/pull/180. Several PR and incremental failed due to the (unavoidable) lag between this PR being merged in and the roottest PR being merged in.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:32,safety,test,test,32,To answer my own question:. The test needed to be updated and was updated by https://github.com/root-project/roottest/pull/180. Several PR and incremental failed due to the (unavoidable) lag between this PR being merged in and the roottest PR being merged in.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:50,safety,updat,updated,50,To answer my own question:. The test needed to be updated and was updated by https://github.com/root-project/roottest/pull/180. Several PR and incremental failed due to the (unavoidable) lag between this PR being merged in and the roottest PR being merged in.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:66,safety,updat,updated,66,To answer my own question:. The test needed to be updated and was updated by https://github.com/root-project/roottest/pull/180. Several PR and incremental failed due to the (unavoidable) lag between this PR being merged in and the roottest PR being merged in.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:50,security,updat,updated,50,To answer my own question:. The test needed to be updated and was updated by https://github.com/root-project/roottest/pull/180. Several PR and incremental failed due to the (unavoidable) lag between this PR being merged in and the roottest PR being merged in.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:66,security,updat,updated,66,To answer my own question:. The test needed to be updated and was updated by https://github.com/root-project/roottest/pull/180. Several PR and incremental failed due to the (unavoidable) lag between this PR being merged in and the roottest PR being merged in.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1814:32,testability,test,test,32,To answer my own question:. The test needed to be updated and was updated by https://github.com/root-project/roottest/pull/180. Several PR and incremental failed due to the (unavoidable) lag between this PR being merged in and the roottest PR being merged in.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1814
https://github.com/root-project/root/pull/1817:78,reliability,doe,does,78,"@pcanal . I am not sure if we should touch this code. Seems to be, TBufferSQL does not use streamer actions, which are relevant for us. Probably, one could keep code as is.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1817
https://github.com/root-project/root/pull/1817:152,energy efficiency,optim,optimizations,152,> I am not sure if we should touch this code. I did not look into but I thought you said this would be blocking progress in TBufferText and TBufferFile optimizations.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1817
https://github.com/root-project/root/pull/1817:152,performance,optimiz,optimizations,152,> I am not sure if we should touch this code. I did not look into but I thought you said this would be blocking progress in TBufferText and TBufferFile optimizations.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1817
https://github.com/root-project/root/pull/1817:112,usability,progress,progress,112,> I am not sure if we should touch this code. I did not look into but I thought you said this would be blocking progress in TBufferText and TBufferFile optimizations.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1817
https://github.com/root-project/root/pull/1817:108,energy efficiency,optim,optimizations,108,> I did not look into but I thought you said this would be blocking progress in TBufferText and TBufferFile optimizations. Now I check it more precisely - TBufferSQL cannot support objects or even simple TString in TBasketSQL. Therefore it can be used even when we change streamer actions.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1817
https://github.com/root-project/root/pull/1817:108,performance,optimiz,optimizations,108,> I did not look into but I thought you said this would be blocking progress in TBufferText and TBufferFile optimizations. Now I check it more precisely - TBufferSQL cannot support objects or even simple TString in TBasketSQL. Therefore it can be used even when we change streamer actions.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1817
https://github.com/root-project/root/pull/1817:197,testability,simpl,simple,197,> I did not look into but I thought you said this would be blocking progress in TBufferText and TBufferFile optimizations. Now I check it more precisely - TBufferSQL cannot support objects or even simple TString in TBasketSQL. Therefore it can be used even when we change streamer actions.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1817
https://github.com/root-project/root/pull/1817:68,usability,progress,progress,68,> I did not look into but I thought you said this would be blocking progress in TBufferText and TBufferFile optimizations. Now I check it more precisely - TBufferSQL cannot support objects or even simple TString in TBasketSQL. Therefore it can be used even when we change streamer actions.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1817
https://github.com/root-project/root/pull/1817:173,usability,support,support,173,> I did not look into but I thought you said this would be blocking progress in TBufferText and TBufferFile optimizations. Now I check it more precisely - TBufferSQL cannot support objects or even simple TString in TBasketSQL. Therefore it can be used even when we change streamer actions.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1817
https://github.com/root-project/root/pull/1817:197,usability,simpl,simple,197,> I did not look into but I thought you said this would be blocking progress in TBufferText and TBufferFile optimizations. Now I check it more precisely - TBufferSQL cannot support objects or even simple TString in TBasketSQL. Therefore it can be used even when we change streamer actions.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1817
https://github.com/root-project/root/pull/1817:23,usability,close,close,23,"Fair enough, should we close this PR?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1817
https://github.com/root-project/root/pull/1821:60,deployability,fail,failing,60,> also we expect this solves cxxmodules ABI incompatibility failing tests. Why would this 'solve' ABI incompatibility? (Wouldn't avoiding a search only 'reduce' the risk the case where a real incompatibility (that needs addressed) is stumbled upon?),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1821
https://github.com/root-project/root/pull/1821:153,energy efficiency,reduc,reduce,153,> also we expect this solves cxxmodules ABI incompatibility failing tests. Why would this 'solve' ABI incompatibility? (Wouldn't avoiding a search only 'reduce' the risk the case where a real incompatibility (that needs addressed) is stumbled upon?),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1821
https://github.com/root-project/root/pull/1821:44,interoperability,incompatib,incompatibility,44,> also we expect this solves cxxmodules ABI incompatibility failing tests. Why would this 'solve' ABI incompatibility? (Wouldn't avoiding a search only 'reduce' the risk the case where a real incompatibility (that needs addressed) is stumbled upon?),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1821
https://github.com/root-project/root/pull/1821:102,interoperability,incompatib,incompatibility,102,> also we expect this solves cxxmodules ABI incompatibility failing tests. Why would this 'solve' ABI incompatibility? (Wouldn't avoiding a search only 'reduce' the risk the case where a real incompatibility (that needs addressed) is stumbled upon?),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1821
https://github.com/root-project/root/pull/1821:192,interoperability,incompatib,incompatibility,192,> also we expect this solves cxxmodules ABI incompatibility failing tests. Why would this 'solve' ABI incompatibility? (Wouldn't avoiding a search only 'reduce' the risk the case where a real incompatibility (that needs addressed) is stumbled upon?),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1821
https://github.com/root-project/root/pull/1821:60,reliability,fail,failing,60,> also we expect this solves cxxmodules ABI incompatibility failing tests. Why would this 'solve' ABI incompatibility? (Wouldn't avoiding a search only 'reduce' the risk the case where a real incompatibility (that needs addressed) is stumbled upon?),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1821
https://github.com/root-project/root/pull/1821:68,safety,test,tests,68,> also we expect this solves cxxmodules ABI incompatibility failing tests. Why would this 'solve' ABI incompatibility? (Wouldn't avoiding a search only 'reduce' the risk the case where a real incompatibility (that needs addressed) is stumbled upon?),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1821
https://github.com/root-project/root/pull/1821:129,safety,avoid,avoiding,129,> also we expect this solves cxxmodules ABI incompatibility failing tests. Why would this 'solve' ABI incompatibility? (Wouldn't avoiding a search only 'reduce' the risk the case where a real incompatibility (that needs addressed) is stumbled upon?),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1821
https://github.com/root-project/root/pull/1821:165,safety,risk,risk,165,> also we expect this solves cxxmodules ABI incompatibility failing tests. Why would this 'solve' ABI incompatibility? (Wouldn't avoiding a search only 'reduce' the risk the case where a real incompatibility (that needs addressed) is stumbled upon?),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1821
https://github.com/root-project/root/pull/1821:165,security,risk,risk,165,> also we expect this solves cxxmodules ABI incompatibility failing tests. Why would this 'solve' ABI incompatibility? (Wouldn't avoiding a search only 'reduce' the risk the case where a real incompatibility (that needs addressed) is stumbled upon?),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1821
https://github.com/root-project/root/pull/1821:68,testability,test,tests,68,> also we expect this solves cxxmodules ABI incompatibility failing tests. Why would this 'solve' ABI incompatibility? (Wouldn't avoiding a search only 'reduce' the risk the case where a real incompatibility (that needs addressed) is stumbled upon?),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1821
https://github.com/root-project/root/pull/1821:113,energy efficiency,reduc,reduce,113,"@pcanal Probably ""solve"" is too much, these incompatibilities are anyway already solved in gcc72. I just want to reduce the risk of doing dangerous things. (Also this was bad for the performance)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1821
https://github.com/root-project/root/pull/1821:44,interoperability,incompatib,incompatibilities,44,"@pcanal Probably ""solve"" is too much, these incompatibilities are anyway already solved in gcc72. I just want to reduce the risk of doing dangerous things. (Also this was bad for the performance)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1821
https://github.com/root-project/root/pull/1821:183,performance,perform,performance,183,"@pcanal Probably ""solve"" is too much, these incompatibilities are anyway already solved in gcc72. I just want to reduce the risk of doing dangerous things. (Also this was bad for the performance)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1821
https://github.com/root-project/root/pull/1821:124,safety,risk,risk,124,"@pcanal Probably ""solve"" is too much, these incompatibilities are anyway already solved in gcc72. I just want to reduce the risk of doing dangerous things. (Also this was bad for the performance)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1821
https://github.com/root-project/root/pull/1821:124,security,risk,risk,124,"@pcanal Probably ""solve"" is too much, these incompatibilities are anyway already solved in gcc72. I just want to reduce the risk of doing dangerous things. (Also this was bad for the performance)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1821
https://github.com/root-project/root/pull/1821:183,usability,perform,performance,183,"@pcanal Probably ""solve"" is too much, these incompatibilities are anyway already solved in gcc72. I just want to reduce the risk of doing dangerous things. (Also this was bad for the performance)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1821
https://github.com/root-project/root/pull/1821:9,modifiability,paramet,parameters,9,"Function parameters were in ""fBody"". Do you think it's better to rename it to ""fParams"" in maybe another PR?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1821
https://github.com/root-project/root/pull/1821:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1821
https://github.com/root-project/root/pull/1821:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1821
https://github.com/root-project/root/pull/1821:11,deployability,build,build,11,"@phsft-bot build on slc6/clang39, slc6/gcc48, slc6/gcc48, slc6/gcc49, slc6/gcc52, centos7/gcc62, centos7/gcc7, centos7/gcc7, ubuntu16/native, mac1013/native, windows10/vc15 with flags -Dvc=OFF -Dimt=ON -Dccache=ON",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1821
https://github.com/root-project/root/pull/1821:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1821
https://github.com/root-project/root/pull/1821:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1821
https://github.com/root-project/root/pull/1821:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1821
https://github.com/root-project/root/pull/1821:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1821
https://github.com/root-project/root/pull/1821:41,safety,test,tested,41,"@lmoneta is going to check where this is tested, and then see whether the new code is a viable replacement. A possible issue could be `TMath::Sin(pol0)` or similar nastiness, where the argument (possibly `fun.GetBody()`?) isn't valid C++.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1821
https://github.com/root-project/root/pull/1821:228,safety,valid,valid,228,"@lmoneta is going to check where this is tested, and then see whether the new code is a viable replacement. A possible issue could be `TMath::Sin(pol0)` or similar nastiness, where the argument (possibly `fun.GetBody()`?) isn't valid C++.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1821
https://github.com/root-project/root/pull/1821:41,testability,test,tested,41,"@lmoneta is going to check where this is tested, and then see whether the new code is a viable replacement. A possible issue could be `TMath::Sin(pol0)` or similar nastiness, where the argument (possibly `fun.GetBody()`?) isn't valid C++.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1821
https://github.com/root-project/root/pull/1822:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1822
https://github.com/root-project/root/pull/1822:0,availability,Failur,Failure,0,Failure are unrelated. Merging.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1822
https://github.com/root-project/root/pull/1822:0,deployability,Fail,Failure,0,Failure are unrelated. Merging.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1822
https://github.com/root-project/root/pull/1822:0,performance,Failur,Failure,0,Failure are unrelated. Merging.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1822
https://github.com/root-project/root/pull/1822:0,reliability,Fail,Failure,0,Failure are unrelated. Merging.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1822
https://github.com/root-project/root/pull/1823:126,deployability,build,builds,126,@Axel-Naumann I switched `libstdc++`'s implementation with `libc++`'s. As far as I know the PR is ready to be merged (jenkins builds permitting),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1823
https://github.com/root-project/root/pull/1823:11,energy efficiency,green,green,11,"Hi, all is green and all comments have been addressed, can I merge?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1823
https://github.com/root-project/root/pull/1824:84,deployability,modul,modules,84,This is going in the wrong direction. We should not be fixing the tutorials but the modules problem. There is a lot of code out there which we cannot fix that way.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1824
https://github.com/root-project/root/pull/1824:84,modifiability,modul,modules,84,This is going in the wrong direction. We should not be fixing the tutorials but the modules problem. There is a lot of code out there which we cannot fix that way.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1824
https://github.com/root-project/root/pull/1824:84,safety,modul,modules,84,This is going in the wrong direction. We should not be fixing the tutorials but the modules problem. There is a lot of code out there which we cannot fix that way.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1824
https://github.com/root-project/root/pull/1824:89,energy efficiency,core,core,89,The likely fix should be something like https://github.com/root-project/root/blob/master/core/metacling/src/TCling.cxx#L1272,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1824
https://github.com/root-project/root/pull/1824:52,energy efficiency,Load,LoadModulesVec,52,"For example if we do like this,. ```. if (std::find(LoadModulesVec.begin(), LoadModulesVec.end(), ""R"") != LoadModulesVec.end()). fInterpreter->declare(""#ifdef PI\n #undef PI\n #endif\n"");. ```. will it sounds better for you? In this case we don't process(""#ifdef PI..."") unless -Dr=On.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1824
https://github.com/root-project/root/pull/1824:76,energy efficiency,Load,LoadModulesVec,76,"For example if we do like this,. ```. if (std::find(LoadModulesVec.begin(), LoadModulesVec.end(), ""R"") != LoadModulesVec.end()). fInterpreter->declare(""#ifdef PI\n #undef PI\n #endif\n"");. ```. will it sounds better for you? In this case we don't process(""#ifdef PI..."") unless -Dr=On.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1824
https://github.com/root-project/root/pull/1824:106,energy efficiency,Load,LoadModulesVec,106,"For example if we do like this,. ```. if (std::find(LoadModulesVec.begin(), LoadModulesVec.end(), ""R"") != LoadModulesVec.end()). fInterpreter->declare(""#ifdef PI\n #undef PI\n #endif\n"");. ```. will it sounds better for you? In this case we don't process(""#ifdef PI..."") unless -Dr=On.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1824
https://github.com/root-project/root/pull/1824:52,performance,Load,LoadModulesVec,52,"For example if we do like this,. ```. if (std::find(LoadModulesVec.begin(), LoadModulesVec.end(), ""R"") != LoadModulesVec.end()). fInterpreter->declare(""#ifdef PI\n #undef PI\n #endif\n"");. ```. will it sounds better for you? In this case we don't process(""#ifdef PI..."") unless -Dr=On.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1824
https://github.com/root-project/root/pull/1824:76,performance,Load,LoadModulesVec,76,"For example if we do like this,. ```. if (std::find(LoadModulesVec.begin(), LoadModulesVec.end(), ""R"") != LoadModulesVec.end()). fInterpreter->declare(""#ifdef PI\n #undef PI\n #endif\n"");. ```. will it sounds better for you? In this case we don't process(""#ifdef PI..."") unless -Dr=On.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1824
https://github.com/root-project/root/pull/1824:106,performance,Load,LoadModulesVec,106,"For example if we do like this,. ```. if (std::find(LoadModulesVec.begin(), LoadModulesVec.end(), ""R"") != LoadModulesVec.end()). fInterpreter->declare(""#ifdef PI\n #undef PI\n #endif\n"");. ```. will it sounds better for you? In this case we don't process(""#ifdef PI..."") unless -Dr=On.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1824
https://github.com/root-project/root/pull/1824:2,usability,prefer,prefer,2,"I prefer. ```. #include ""SomethingFromF.h"". #ifdef PI. # undef PI. #endif. ```. in the relevant ROOT headers.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1824
https://github.com/root-project/root/pull/1824:155,availability,state,statement,155,"> PI leaks out even if you're not including any R headers, so I think we can't do that. Just registering my reservation on this - I do not understand this statement, and I am still convinced that we need to `#undef` after including R headers.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1824
https://github.com/root-project/root/pull/1824:155,integrability,state,statement,155,"> PI leaks out even if you're not including any R headers, so I think we can't do that. Just registering my reservation on this - I do not understand this statement, and I am still convinced that we need to `#undef` after including R headers.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1824
https://github.com/root-project/root/pull/1824:139,testability,understand,understand,139,"> PI leaks out even if you're not including any R headers, so I think we can't do that. Just registering my reservation on this - I do not understand this statement, and I am still convinced that we need to `#undef` after including R headers.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1824
https://github.com/root-project/root/pull/1824:58,deployability,modul,modules,58,We don't need this anymore as we decided not to preload R modules.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1824
https://github.com/root-project/root/pull/1824:58,modifiability,modul,modules,58,We don't need this anymore as we decided not to preload R modules.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1824
https://github.com/root-project/root/pull/1824:58,safety,modul,modules,58,We don't need this anymore as we decided not to preload R modules.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1824
https://github.com/root-project/root/pull/1826:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1826
https://github.com/root-project/root/pull/1826:11,deployability,build,build,11,@phsft-bot build with flags -Dimt=OFF,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1826
https://github.com/root-project/root/pull/1826:11,deployability,build,build,11,@phsft-bot build with flags -Dimt=OFF,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1826
https://github.com/root-project/root/pull/1826:11,deployability,build,build,11,@phsft-bot build with flags -Dimt=OFF,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1826
https://github.com/root-project/root/pull/1826:11,deployability,build,build,11,@phsft-bot build with flags -Dimt=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1826
https://github.com/root-project/root/pull/1826:11,deployability,build,build,11,@phsft-bot build with flags -Dimt=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1826
https://github.com/root-project/root/pull/1827:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1827
https://github.com/root-project/root/pull/1827:199,deployability,build,builds,199,"Dear @Axel-Naumann, @bluehood : I addressed the comments which were made. For the moment, I prefer to keep the allocator as an internal tool for TVec and perhaps make it public in the future. If the builds succeed, I'll merge.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1827
https://github.com/root-project/root/pull/1827:111,energy efficiency,alloc,allocator,111,"Dear @Axel-Naumann, @bluehood : I addressed the comments which were made. For the moment, I prefer to keep the allocator as an internal tool for TVec and perhaps make it public in the future. If the builds succeed, I'll merge.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1827
https://github.com/root-project/root/pull/1827:170,integrability,pub,public,170,"Dear @Axel-Naumann, @bluehood : I addressed the comments which were made. For the moment, I prefer to keep the allocator as an internal tool for TVec and perhaps make it public in the future. If the builds succeed, I'll merge.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1827
https://github.com/root-project/root/pull/1827:92,usability,prefer,prefer,92,"Dear @Axel-Naumann, @bluehood : I addressed the comments which were made. For the moment, I prefer to keep the allocator as an internal tool for TVec and perhaps make it public in the future. If the builds succeed, I'll merge.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1827
https://github.com/root-project/root/pull/1827:136,usability,tool,tool,136,"Dear @Axel-Naumann, @bluehood : I addressed the comments which were made. For the moment, I prefer to keep the allocator as an internal tool for TVec and perhaps make it public in the future. If the builds succeed, I'll merge.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1827
https://github.com/root-project/root/pull/1831:79,interoperability,format,format,79,"@dpiparo I took the liberty to fuse my bug fixing & comment addressing & clang format commits into your first one :smiley: , please do a final check but I think this is good to go. After this is merged, it will be the turn of [the roottest](https://github.com/root-project/roottest/pull/166).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1831
https://github.com/root-project/root/pull/1833:5,deployability,fail,failed,5,Only failed to checkout. Merging.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1833
https://github.com/root-project/root/pull/1833:5,reliability,fail,failed,5,Only failed to checkout. Merging.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1833
https://github.com/root-project/root/pull/1834:0,availability,Failur,Failures,0,Failures are not related to this commit. Merging.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1834
https://github.com/root-project/root/pull/1834:0,deployability,Fail,Failures,0,Failures are not related to this commit. Merging.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1834
https://github.com/root-project/root/pull/1834:0,performance,Failur,Failures,0,Failures are not related to this commit. Merging.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1834
https://github.com/root-project/root/pull/1834:0,reliability,Fail,Failures,0,Failures are not related to this commit. Merging.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1834
https://github.com/root-project/root/pull/1835:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1835
https://github.com/root-project/root/pull/1835:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1835
https://github.com/root-project/root/pull/1835:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1835
https://github.com/root-project/root/pull/1835:58,deployability,patch,patch,58,"This should be landed with allmodules and library loading patch, closing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1835
https://github.com/root-project/root/pull/1835:50,energy efficiency,load,loading,50,"This should be landed with allmodules and library loading patch, closing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1835
https://github.com/root-project/root/pull/1835:50,performance,load,loading,50,"This should be landed with allmodules and library loading patch, closing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1835
https://github.com/root-project/root/pull/1835:58,safety,patch,patch,58,"This should be landed with allmodules and library loading patch, closing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1835
https://github.com/root-project/root/pull/1835:58,security,patch,patch,58,"This should be landed with allmodules and library loading patch, closing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1835
https://github.com/root-project/root/pull/1836:142,deployability,depend,dependent,142,"> The problem is that the macro OPENSSL_API_1_1 will only be defined during compilation of civetweb, and not during runtime or compilation of dependent targets. Then if something uses civetweb in interpreted code or other parts of ROOT, it may crash because it will be using the wrong interface. If no external code needs the macro to work properly, then it's fine. I do not see problem here. This flag used only during compilation and does not affect interface of HTTP classes. At the compile time libRHTTP will be linked with OpenSSL library (internal or external). . Later, both in interpreted and compiled mode, always compiled version of civetweb. c code will be used, linked with proper libcrypto.so. Only if OpenSSL library changed, one should rebuild libRHTTP. But I do not have example how this can be done in cmake and if this is controlled properly in other libraries (like RootAuth or GlobusAuth).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1836
https://github.com/root-project/root/pull/1836:632,deployability,version,version,632,"> The problem is that the macro OPENSSL_API_1_1 will only be defined during compilation of civetweb, and not during runtime or compilation of dependent targets. Then if something uses civetweb in interpreted code or other parts of ROOT, it may crash because it will be using the wrong interface. If no external code needs the macro to work properly, then it's fine. I do not see problem here. This flag used only during compilation and does not affect interface of HTTP classes. At the compile time libRHTTP will be linked with OpenSSL library (internal or external). . Later, both in interpreted and compiled mode, always compiled version of civetweb. c code will be used, linked with proper libcrypto.so. Only if OpenSSL library changed, one should rebuild libRHTTP. But I do not have example how this can be done in cmake and if this is controlled properly in other libraries (like RootAuth or GlobusAuth).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1836
https://github.com/root-project/root/pull/1836:142,integrability,depend,dependent,142,"> The problem is that the macro OPENSSL_API_1_1 will only be defined during compilation of civetweb, and not during runtime or compilation of dependent targets. Then if something uses civetweb in interpreted code or other parts of ROOT, it may crash because it will be using the wrong interface. If no external code needs the macro to work properly, then it's fine. I do not see problem here. This flag used only during compilation and does not affect interface of HTTP classes. At the compile time libRHTTP will be linked with OpenSSL library (internal or external). . Later, both in interpreted and compiled mode, always compiled version of civetweb. c code will be used, linked with proper libcrypto.so. Only if OpenSSL library changed, one should rebuild libRHTTP. But I do not have example how this can be done in cmake and if this is controlled properly in other libraries (like RootAuth or GlobusAuth).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1836
https://github.com/root-project/root/pull/1836:285,integrability,interfac,interface,285,"> The problem is that the macro OPENSSL_API_1_1 will only be defined during compilation of civetweb, and not during runtime or compilation of dependent targets. Then if something uses civetweb in interpreted code or other parts of ROOT, it may crash because it will be using the wrong interface. If no external code needs the macro to work properly, then it's fine. I do not see problem here. This flag used only during compilation and does not affect interface of HTTP classes. At the compile time libRHTTP will be linked with OpenSSL library (internal or external). . Later, both in interpreted and compiled mode, always compiled version of civetweb. c code will be used, linked with proper libcrypto.so. Only if OpenSSL library changed, one should rebuild libRHTTP. But I do not have example how this can be done in cmake and if this is controlled properly in other libraries (like RootAuth or GlobusAuth).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1836
https://github.com/root-project/root/pull/1836:452,integrability,interfac,interface,452,"> The problem is that the macro OPENSSL_API_1_1 will only be defined during compilation of civetweb, and not during runtime or compilation of dependent targets. Then if something uses civetweb in interpreted code or other parts of ROOT, it may crash because it will be using the wrong interface. If no external code needs the macro to work properly, then it's fine. I do not see problem here. This flag used only during compilation and does not affect interface of HTTP classes. At the compile time libRHTTP will be linked with OpenSSL library (internal or external). . Later, both in interpreted and compiled mode, always compiled version of civetweb. c code will be used, linked with proper libcrypto.so. Only if OpenSSL library changed, one should rebuild libRHTTP. But I do not have example how this can be done in cmake and if this is controlled properly in other libraries (like RootAuth or GlobusAuth).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1836
https://github.com/root-project/root/pull/1836:632,integrability,version,version,632,"> The problem is that the macro OPENSSL_API_1_1 will only be defined during compilation of civetweb, and not during runtime or compilation of dependent targets. Then if something uses civetweb in interpreted code or other parts of ROOT, it may crash because it will be using the wrong interface. If no external code needs the macro to work properly, then it's fine. I do not see problem here. This flag used only during compilation and does not affect interface of HTTP classes. At the compile time libRHTTP will be linked with OpenSSL library (internal or external). . Later, both in interpreted and compiled mode, always compiled version of civetweb. c code will be used, linked with proper libcrypto.so. Only if OpenSSL library changed, one should rebuild libRHTTP. But I do not have example how this can be done in cmake and if this is controlled properly in other libraries (like RootAuth or GlobusAuth).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1836
https://github.com/root-project/root/pull/1836:285,interoperability,interfac,interface,285,"> The problem is that the macro OPENSSL_API_1_1 will only be defined during compilation of civetweb, and not during runtime or compilation of dependent targets. Then if something uses civetweb in interpreted code or other parts of ROOT, it may crash because it will be using the wrong interface. If no external code needs the macro to work properly, then it's fine. I do not see problem here. This flag used only during compilation and does not affect interface of HTTP classes. At the compile time libRHTTP will be linked with OpenSSL library (internal or external). . Later, both in interpreted and compiled mode, always compiled version of civetweb. c code will be used, linked with proper libcrypto.so. Only if OpenSSL library changed, one should rebuild libRHTTP. But I do not have example how this can be done in cmake and if this is controlled properly in other libraries (like RootAuth or GlobusAuth).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1836
https://github.com/root-project/root/pull/1836:452,interoperability,interfac,interface,452,"> The problem is that the macro OPENSSL_API_1_1 will only be defined during compilation of civetweb, and not during runtime or compilation of dependent targets. Then if something uses civetweb in interpreted code or other parts of ROOT, it may crash because it will be using the wrong interface. If no external code needs the macro to work properly, then it's fine. I do not see problem here. This flag used only during compilation and does not affect interface of HTTP classes. At the compile time libRHTTP will be linked with OpenSSL library (internal or external). . Later, both in interpreted and compiled mode, always compiled version of civetweb. c code will be used, linked with proper libcrypto.so. Only if OpenSSL library changed, one should rebuild libRHTTP. But I do not have example how this can be done in cmake and if this is controlled properly in other libraries (like RootAuth or GlobusAuth).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1836
https://github.com/root-project/root/pull/1836:142,modifiability,depend,dependent,142,"> The problem is that the macro OPENSSL_API_1_1 will only be defined during compilation of civetweb, and not during runtime or compilation of dependent targets. Then if something uses civetweb in interpreted code or other parts of ROOT, it may crash because it will be using the wrong interface. If no external code needs the macro to work properly, then it's fine. I do not see problem here. This flag used only during compilation and does not affect interface of HTTP classes. At the compile time libRHTTP will be linked with OpenSSL library (internal or external). . Later, both in interpreted and compiled mode, always compiled version of civetweb. c code will be used, linked with proper libcrypto.so. Only if OpenSSL library changed, one should rebuild libRHTTP. But I do not have example how this can be done in cmake and if this is controlled properly in other libraries (like RootAuth or GlobusAuth).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1836
https://github.com/root-project/root/pull/1836:285,modifiability,interfac,interface,285,"> The problem is that the macro OPENSSL_API_1_1 will only be defined during compilation of civetweb, and not during runtime or compilation of dependent targets. Then if something uses civetweb in interpreted code or other parts of ROOT, it may crash because it will be using the wrong interface. If no external code needs the macro to work properly, then it's fine. I do not see problem here. This flag used only during compilation and does not affect interface of HTTP classes. At the compile time libRHTTP will be linked with OpenSSL library (internal or external). . Later, both in interpreted and compiled mode, always compiled version of civetweb. c code will be used, linked with proper libcrypto.so. Only if OpenSSL library changed, one should rebuild libRHTTP. But I do not have example how this can be done in cmake and if this is controlled properly in other libraries (like RootAuth or GlobusAuth).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1836
https://github.com/root-project/root/pull/1836:452,modifiability,interfac,interface,452,"> The problem is that the macro OPENSSL_API_1_1 will only be defined during compilation of civetweb, and not during runtime or compilation of dependent targets. Then if something uses civetweb in interpreted code or other parts of ROOT, it may crash because it will be using the wrong interface. If no external code needs the macro to work properly, then it's fine. I do not see problem here. This flag used only during compilation and does not affect interface of HTTP classes. At the compile time libRHTTP will be linked with OpenSSL library (internal or external). . Later, both in interpreted and compiled mode, always compiled version of civetweb. c code will be used, linked with proper libcrypto.so. Only if OpenSSL library changed, one should rebuild libRHTTP. But I do not have example how this can be done in cmake and if this is controlled properly in other libraries (like RootAuth or GlobusAuth).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1836
https://github.com/root-project/root/pull/1836:632,modifiability,version,version,632,"> The problem is that the macro OPENSSL_API_1_1 will only be defined during compilation of civetweb, and not during runtime or compilation of dependent targets. Then if something uses civetweb in interpreted code or other parts of ROOT, it may crash because it will be using the wrong interface. If no external code needs the macro to work properly, then it's fine. I do not see problem here. This flag used only during compilation and does not affect interface of HTTP classes. At the compile time libRHTTP will be linked with OpenSSL library (internal or external). . Later, both in interpreted and compiled mode, always compiled version of civetweb. c code will be used, linked with proper libcrypto.so. Only if OpenSSL library changed, one should rebuild libRHTTP. But I do not have example how this can be done in cmake and if this is controlled properly in other libraries (like RootAuth or GlobusAuth).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1836
https://github.com/root-project/root/pull/1836:494,performance,time,time,494,"> The problem is that the macro OPENSSL_API_1_1 will only be defined during compilation of civetweb, and not during runtime or compilation of dependent targets. Then if something uses civetweb in interpreted code or other parts of ROOT, it may crash because it will be using the wrong interface. If no external code needs the macro to work properly, then it's fine. I do not see problem here. This flag used only during compilation and does not affect interface of HTTP classes. At the compile time libRHTTP will be linked with OpenSSL library (internal or external). . Later, both in interpreted and compiled mode, always compiled version of civetweb. c code will be used, linked with proper libcrypto.so. Only if OpenSSL library changed, one should rebuild libRHTTP. But I do not have example how this can be done in cmake and if this is controlled properly in other libraries (like RootAuth or GlobusAuth).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1836
https://github.com/root-project/root/pull/1836:436,reliability,doe,does,436,"> The problem is that the macro OPENSSL_API_1_1 will only be defined during compilation of civetweb, and not during runtime or compilation of dependent targets. Then if something uses civetweb in interpreted code or other parts of ROOT, it may crash because it will be using the wrong interface. If no external code needs the macro to work properly, then it's fine. I do not see problem here. This flag used only during compilation and does not affect interface of HTTP classes. At the compile time libRHTTP will be linked with OpenSSL library (internal or external). . Later, both in interpreted and compiled mode, always compiled version of civetweb. c code will be used, linked with proper libcrypto.so. Only if OpenSSL library changed, one should rebuild libRHTTP. But I do not have example how this can be done in cmake and if this is controlled properly in other libraries (like RootAuth or GlobusAuth).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1836
https://github.com/root-project/root/pull/1836:142,safety,depend,dependent,142,"> The problem is that the macro OPENSSL_API_1_1 will only be defined during compilation of civetweb, and not during runtime or compilation of dependent targets. Then if something uses civetweb in interpreted code or other parts of ROOT, it may crash because it will be using the wrong interface. If no external code needs the macro to work properly, then it's fine. I do not see problem here. This flag used only during compilation and does not affect interface of HTTP classes. At the compile time libRHTTP will be linked with OpenSSL library (internal or external). . Later, both in interpreted and compiled mode, always compiled version of civetweb. c code will be used, linked with proper libcrypto.so. Only if OpenSSL library changed, one should rebuild libRHTTP. But I do not have example how this can be done in cmake and if this is controlled properly in other libraries (like RootAuth or GlobusAuth).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1836
https://github.com/root-project/root/pull/1836:840,security,control,controlled,840,"> The problem is that the macro OPENSSL_API_1_1 will only be defined during compilation of civetweb, and not during runtime or compilation of dependent targets. Then if something uses civetweb in interpreted code or other parts of ROOT, it may crash because it will be using the wrong interface. If no external code needs the macro to work properly, then it's fine. I do not see problem here. This flag used only during compilation and does not affect interface of HTTP classes. At the compile time libRHTTP will be linked with OpenSSL library (internal or external). . Later, both in interpreted and compiled mode, always compiled version of civetweb. c code will be used, linked with proper libcrypto.so. Only if OpenSSL library changed, one should rebuild libRHTTP. But I do not have example how this can be done in cmake and if this is controlled properly in other libraries (like RootAuth or GlobusAuth).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1836
https://github.com/root-project/root/pull/1836:142,testability,depend,dependent,142,"> The problem is that the macro OPENSSL_API_1_1 will only be defined during compilation of civetweb, and not during runtime or compilation of dependent targets. Then if something uses civetweb in interpreted code or other parts of ROOT, it may crash because it will be using the wrong interface. If no external code needs the macro to work properly, then it's fine. I do not see problem here. This flag used only during compilation and does not affect interface of HTTP classes. At the compile time libRHTTP will be linked with OpenSSL library (internal or external). . Later, both in interpreted and compiled mode, always compiled version of civetweb. c code will be used, linked with proper libcrypto.so. Only if OpenSSL library changed, one should rebuild libRHTTP. But I do not have example how this can be done in cmake and if this is controlled properly in other libraries (like RootAuth or GlobusAuth).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1836
https://github.com/root-project/root/pull/1836:840,testability,control,controlled,840,"> The problem is that the macro OPENSSL_API_1_1 will only be defined during compilation of civetweb, and not during runtime or compilation of dependent targets. Then if something uses civetweb in interpreted code or other parts of ROOT, it may crash because it will be using the wrong interface. If no external code needs the macro to work properly, then it's fine. I do not see problem here. This flag used only during compilation and does not affect interface of HTTP classes. At the compile time libRHTTP will be linked with OpenSSL library (internal or external). . Later, both in interpreted and compiled mode, always compiled version of civetweb. c code will be used, linked with proper libcrypto.so. Only if OpenSSL library changed, one should rebuild libRHTTP. But I do not have example how this can be done in cmake and if this is controlled properly in other libraries (like RootAuth or GlobusAuth).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1836
https://github.com/root-project/root/pull/1836:47,deployability,fail,fails,47,We will immediately see if the `VERSION_EQUAL` fails. Good enough for now!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1836
https://github.com/root-project/root/pull/1836:47,reliability,fail,fails,47,We will immediately see if the `VERSION_EQUAL` fails. Good enough for now!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1836
https://github.com/root-project/root/pull/1836:91,deployability,build,buildid,91,This PR has created new warnings as seen at http://cdash.cern.ch/viewBuildError.php?type=1&buildid=489838. @linev Could you please take a look and fix? Thanks!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1836
https://github.com/root-project/root/pull/1836:29,integrability,messag,message,29,"@amadio . I saw this warning message and partially fix it here: https://github.com/root-project/root/pull/1852. Problem was warning suppression itself, which does not work with gcc 4.x. Warning should disappear once #1852 is merged.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1836
https://github.com/root-project/root/pull/1836:29,interoperability,messag,message,29,"@amadio . I saw this warning message and partially fix it here: https://github.com/root-project/root/pull/1852. Problem was warning suppression itself, which does not work with gcc 4.x. Warning should disappear once #1852 is merged.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1836
https://github.com/root-project/root/pull/1836:158,reliability,doe,does,158,"@amadio . I saw this warning message and partially fix it here: https://github.com/root-project/root/pull/1852. Problem was warning suppression itself, which does not work with gcc 4.x. Warning should disappear once #1852 is merged.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1836
https://github.com/root-project/root/pull/1837:45,security,Hash,Hash,45,"Might work for `Streamer()`, won't work for `Hash()`. Maybe we can sneak this into `GenerateInitInstance` - TBD.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1837
https://github.com/root-project/root/pull/1837:102,modifiability,inherit,inheritance,102,"> Might work for Streamer(). Even for Streamer, the test is looking for a 'local' definition and thus inheritance is not a guaranteed.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1837
https://github.com/root-project/root/pull/1837:52,safety,test,test,52,"> Might work for Streamer(). Even for Streamer, the test is looking for a 'local' definition and thus inheritance is not a guaranteed.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1837
https://github.com/root-project/root/pull/1837:52,testability,test,test,52,"> Might work for Streamer(). Even for Streamer, the test is looking for a 'local' definition and thus inheritance is not a guaranteed.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1837
https://github.com/root-project/root/pull/1839:221,deployability,updat,update,221,Hello Jan. I think what is missing is the motivation/documentation of this new functionally. May be it can go in the THistPainter and TGraphPainter doc ? right now it is not easy to understand how to use it. You can just update the files and push the modified version in the branch PR and it will appear here.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1839
https://github.com/root-project/root/pull/1839:260,deployability,version,version,260,Hello Jan. I think what is missing is the motivation/documentation of this new functionally. May be it can go in the THistPainter and TGraphPainter doc ? right now it is not easy to understand how to use it. You can just update the files and push the modified version in the branch PR and it will appear here.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1839
https://github.com/root-project/root/pull/1839:260,integrability,version,version,260,Hello Jan. I think what is missing is the motivation/documentation of this new functionally. May be it can go in the THistPainter and TGraphPainter doc ? right now it is not easy to understand how to use it. You can just update the files and push the modified version in the branch PR and it will appear here.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1839
https://github.com/root-project/root/pull/1839:260,modifiability,version,version,260,Hello Jan. I think what is missing is the motivation/documentation of this new functionally. May be it can go in the THistPainter and TGraphPainter doc ? right now it is not easy to understand how to use it. You can just update the files and push the modified version in the branch PR and it will appear here.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1839
https://github.com/root-project/root/pull/1839:221,safety,updat,update,221,Hello Jan. I think what is missing is the motivation/documentation of this new functionally. May be it can go in the THistPainter and TGraphPainter doc ? right now it is not easy to understand how to use it. You can just update the files and push the modified version in the branch PR and it will appear here.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1839
https://github.com/root-project/root/pull/1839:221,security,updat,update,221,Hello Jan. I think what is missing is the motivation/documentation of this new functionally. May be it can go in the THistPainter and TGraphPainter doc ? right now it is not easy to understand how to use it. You can just update the files and push the modified version in the branch PR and it will appear here.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1839
https://github.com/root-project/root/pull/1839:251,security,modif,modified,251,Hello Jan. I think what is missing is the motivation/documentation of this new functionally. May be it can go in the THistPainter and TGraphPainter doc ? right now it is not easy to understand how to use it. You can just update the files and push the modified version in the branch PR and it will appear here.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1839
https://github.com/root-project/root/pull/1839:182,testability,understand,understand,182,Hello Jan. I think what is missing is the motivation/documentation of this new functionally. May be it can go in the THistPainter and TGraphPainter doc ? right now it is not easy to understand how to use it. You can just update the files and push the modified version in the branch PR and it will appear here.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1839
https://github.com/root-project/root/pull/1839:53,usability,document,documentation,53,Hello Jan. I think what is missing is the motivation/documentation of this new functionally. May be it can go in the THistPainter and TGraphPainter doc ? right now it is not easy to understand how to use it. You can just update the files and push the modified version in the branch PR and it will appear here.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1839
https://github.com/root-project/root/pull/1839:59,usability,document,documentation,59,"Hello Olivier,. yes, you are right, this commit is without documentation. I will try to prepare documentation from this [README.md](https://github.com/musinsky/ROOTHighlight) to THistPainter/TGraphPainter files.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1839
https://github.com/root-project/root/pull/1839:96,usability,document,documentation,96,"Hello Olivier,. yes, you are right, this commit is without documentation. I will try to prepare documentation from this [README.md](https://github.com/musinsky/ROOTHighlight) to THistPainter/TGraphPainter files.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1839
https://github.com/root-project/root/pull/1839:6,usability,document,documentation,6,Added documentation. Relevant pages:. http://alice.saske.sk/rootdoc/html/classTHistPainter.html. http://alice.saske.sk/rootdoc/html/classTGraphPainter.html.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1839
https://github.com/root-project/root/pull/1839:170,deployability,releas,release,170,Hello Jan. Sounds good and ready to be committed. We are now in the process of making ROOT 6.14. I think it is better if we commit your changes just after we do this new release. That will put less stress on us to polish this new feature.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1839
https://github.com/root-project/root/pull/1839:19,deployability,releas,release,19,"OK, after ROOT new release.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1839
https://github.com/root-project/root/pull/1839:214,integrability,sub,subsequent,214,"The first animated gif you added in http://alice.saske.sk/rootdoc/html/classTHistPainter.html#HP30 is a bit wide which forces the web bowser to adjust the display width, which later may creates weird layout of the subsequent pages one will browse . Would it be possible to have this animation such it does not force the web browser to adjust the display width? may be by putting the two canvas on top of each other and not side by side ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1839
https://github.com/root-project/root/pull/1839:301,reliability,doe,does,301,"The first animated gif you added in http://alice.saske.sk/rootdoc/html/classTHistPainter.html#HP30 is a bit wide which forces the web bowser to adjust the display width, which later may creates weird layout of the subsequent pages one will browse . Would it be possible to have this animation such it does not force the web browser to adjust the display width? may be by putting the two canvas on top of each other and not side by side ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1839
https://github.com/root-project/root/pull/1839:69,energy efficiency,optim,optimal,69,"I can create a new animation (this is not a problem), which width is optimal (maximum) ? [Original gif](https://raw.githubusercontent.com/musinsky/root/5083799f3d89d76a8c4ac42f8bc5ebfcb487d2f6/documentation/doxygen/images/hlHisto3.gif) has size 1200x530, [Half size gif](https://raw.githubusercontent.com/musinsky/ROOTHighlight/master/tmp/hlHisto3_half.gif) has 600x265. Create animated gif with a width of around 800-900 ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1839
https://github.com/root-project/root/pull/1839:193,usability,document,documentation,193,"I can create a new animation (this is not a problem), which width is optimal (maximum) ? [Original gif](https://raw.githubusercontent.com/musinsky/root/5083799f3d89d76a8c4ac42f8bc5ebfcb487d2f6/documentation/doxygen/images/hlHisto3.gif) has size 1200x530, [Half size gif](https://raw.githubusercontent.com/musinsky/ROOTHighlight/master/tmp/hlHisto3_half.gif) has 600x265. Create animated gif with a width of around 800-900 ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1839
https://github.com/root-project/root/pull/1839:56,energy efficiency,draw,drawing,56,I think that keeping the same size for the canvases but drawing them on top of each other should be fine.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1839
https://github.com/root-project/root/pull/1839:69,performance,synch,synchronization,69,"I have tried to make with two canvases (two gifs), but problem with ""synchronization"" in browser (gif1 ""start animating"" in different time as gif2, see on this temporary [site](http://alice.saske.sk/rootdoc2/html/classTHistPainter.html#HP30)), must be as one animated gif. I think there are only two possibilities:. * create a new animation with width for example 900. * or set width in source ```\image html hlHisto3.gif ""Highlight mode"" width=900```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1839
https://github.com/root-project/root/pull/1839:134,performance,time,time,134,"I have tried to make with two canvases (two gifs), but problem with ""synchronization"" in browser (gif1 ""start animating"" in different time as gif2, see on this temporary [site](http://alice.saske.sk/rootdoc2/html/classTHistPainter.html#HP30)), must be as one animated gif. I think there are only two possibilities:. * create a new animation with width for example 900. * or set width in source ```\image html hlHisto3.gif ""Highlight mode"" width=900```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1839
https://github.com/root-project/root/pull/1839:148,reliability,doe,does,148,Why don't you simply make one animated gif with the two canvases on top of each other ? it should be possible ? The tool you are using to make them does not allow this ?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1839
https://github.com/root-project/root/pull/1839:14,testability,simpl,simply,14,Why don't you simply make one animated gif with the two canvases on top of each other ? it should be possible ? The tool you are using to make them does not allow this ?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1839
https://github.com/root-project/root/pull/1839:14,usability,simpl,simply,14,Why don't you simply make one animated gif with the two canvases on top of each other ? it should be possible ? The tool you are using to make them does not allow this ?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1839
https://github.com/root-project/root/pull/1839:116,usability,tool,tool,116,Why don't you simply make one animated gif with the two canvases on top of each other ? it should be possible ? The tool you are using to make them does not allow this ?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1839
https://github.com/root-project/root/pull/1841:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1841
https://github.com/root-project/root/pull/1842:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1842
https://github.com/root-project/root/pull/1843:86,availability,failur,failures,86,@henryiii Have you tried using the code after the patch? I remember seeing extra test failures with this patch compared to what we currently have (https://github.com/root-project/root/pull/1689#issuecomment-380143670).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1843
https://github.com/root-project/root/pull/1843:50,deployability,patch,patch,50,@henryiii Have you tried using the code after the patch? I remember seeing extra test failures with this patch compared to what we currently have (https://github.com/root-project/root/pull/1689#issuecomment-380143670).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1843
https://github.com/root-project/root/pull/1843:86,deployability,fail,failures,86,@henryiii Have you tried using the code after the patch? I remember seeing extra test failures with this patch compared to what we currently have (https://github.com/root-project/root/pull/1689#issuecomment-380143670).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1843
https://github.com/root-project/root/pull/1843:105,deployability,patch,patch,105,@henryiii Have you tried using the code after the patch? I remember seeing extra test failures with this patch compared to what we currently have (https://github.com/root-project/root/pull/1689#issuecomment-380143670).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1843
https://github.com/root-project/root/pull/1843:131,energy efficiency,current,currently,131,@henryiii Have you tried using the code after the patch? I remember seeing extra test failures with this patch compared to what we currently have (https://github.com/root-project/root/pull/1689#issuecomment-380143670).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1843
https://github.com/root-project/root/pull/1843:86,performance,failur,failures,86,@henryiii Have you tried using the code after the patch? I remember seeing extra test failures with this patch compared to what we currently have (https://github.com/root-project/root/pull/1689#issuecomment-380143670).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1843
https://github.com/root-project/root/pull/1843:86,reliability,fail,failures,86,@henryiii Have you tried using the code after the patch? I remember seeing extra test failures with this patch compared to what we currently have (https://github.com/root-project/root/pull/1689#issuecomment-380143670).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1843
https://github.com/root-project/root/pull/1843:50,safety,patch,patch,50,@henryiii Have you tried using the code after the patch? I remember seeing extra test failures with this patch compared to what we currently have (https://github.com/root-project/root/pull/1689#issuecomment-380143670).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1843
https://github.com/root-project/root/pull/1843:59,safety,reme,remember,59,@henryiii Have you tried using the code after the patch? I remember seeing extra test failures with this patch compared to what we currently have (https://github.com/root-project/root/pull/1689#issuecomment-380143670).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1843
https://github.com/root-project/root/pull/1843:81,safety,test,test,81,@henryiii Have you tried using the code after the patch? I remember seeing extra test failures with this patch compared to what we currently have (https://github.com/root-project/root/pull/1689#issuecomment-380143670).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1843
https://github.com/root-project/root/pull/1843:105,safety,patch,patch,105,@henryiii Have you tried using the code after the patch? I remember seeing extra test failures with this patch compared to what we currently have (https://github.com/root-project/root/pull/1689#issuecomment-380143670).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1843
https://github.com/root-project/root/pull/1843:50,security,patch,patch,50,@henryiii Have you tried using the code after the patch? I remember seeing extra test failures with this patch compared to what we currently have (https://github.com/root-project/root/pull/1689#issuecomment-380143670).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1843
https://github.com/root-project/root/pull/1843:105,security,patch,patch,105,@henryiii Have you tried using the code after the patch? I remember seeing extra test failures with this patch compared to what we currently have (https://github.com/root-project/root/pull/1689#issuecomment-380143670).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1843
https://github.com/root-project/root/pull/1843:81,testability,test,test,81,@henryiii Have you tried using the code after the patch? I remember seeing extra test failures with this patch compared to what we currently have (https://github.com/root-project/root/pull/1689#issuecomment-380143670).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1843
https://github.com/root-project/root/pull/1843:51,deployability,patch,patch,51,"Not too much, I was mostly the middle man for this patch. I did try it briefly and saw some issues, but also got issues with master.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1843
https://github.com/root-project/root/pull/1843:51,safety,patch,patch,51,"Not too much, I was mostly the middle man for this patch. I did try it briefly and saw some issues, but also got issues with master.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1843
https://github.com/root-project/root/pull/1843:51,security,patch,patch,51,"Not too much, I was mostly the middle man for this patch. I did try it briefly and saw some issues, but also got issues with master.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1843
https://github.com/root-project/root/pull/1843:36,deployability,patch,patch,36,"Well, I saw *extra* issues with the patch. I'm not sure we should merge this. The current problems with MPI are known (see [ROOT-9293](https://sft.its.cern.ch/jira/browse/ROOT-9293)). Once that's fixed, we can be more confident in merging the move to C bindings, which would be nice, due to the deprecation of the C++ bindings.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1843
https://github.com/root-project/root/pull/1843:82,energy efficiency,current,current,82,"Well, I saw *extra* issues with the patch. I'm not sure we should merge this. The current problems with MPI are known (see [ROOT-9293](https://sft.its.cern.ch/jira/browse/ROOT-9293)). Once that's fixed, we can be more confident in merging the move to C bindings, which would be nice, due to the deprecation of the C++ bindings.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1843
https://github.com/root-project/root/pull/1843:253,interoperability,bind,bindings,253,"Well, I saw *extra* issues with the patch. I'm not sure we should merge this. The current problems with MPI are known (see [ROOT-9293](https://sft.its.cern.ch/jira/browse/ROOT-9293)). Once that's fixed, we can be more confident in merging the move to C bindings, which would be nice, due to the deprecation of the C++ bindings.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1843
https://github.com/root-project/root/pull/1843:318,interoperability,bind,bindings,318,"Well, I saw *extra* issues with the patch. I'm not sure we should merge this. The current problems with MPI are known (see [ROOT-9293](https://sft.its.cern.ch/jira/browse/ROOT-9293)). Once that's fixed, we can be more confident in merging the move to C bindings, which would be nice, due to the deprecation of the C++ bindings.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1843
https://github.com/root-project/root/pull/1843:253,modifiability,bind,bindings,253,"Well, I saw *extra* issues with the patch. I'm not sure we should merge this. The current problems with MPI are known (see [ROOT-9293](https://sft.its.cern.ch/jira/browse/ROOT-9293)). Once that's fixed, we can be more confident in merging the move to C bindings, which would be nice, due to the deprecation of the C++ bindings.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1843
https://github.com/root-project/root/pull/1843:318,modifiability,bind,bindings,318,"Well, I saw *extra* issues with the patch. I'm not sure we should merge this. The current problems with MPI are known (see [ROOT-9293](https://sft.its.cern.ch/jira/browse/ROOT-9293)). Once that's fixed, we can be more confident in merging the move to C bindings, which would be nice, due to the deprecation of the C++ bindings.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1843
https://github.com/root-project/root/pull/1843:36,safety,patch,patch,36,"Well, I saw *extra* issues with the patch. I'm not sure we should merge this. The current problems with MPI are known (see [ROOT-9293](https://sft.its.cern.ch/jira/browse/ROOT-9293)). Once that's fixed, we can be more confident in merging the move to C bindings, which would be nice, due to the deprecation of the C++ bindings.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1843
https://github.com/root-project/root/pull/1843:36,security,patch,patch,36,"Well, I saw *extra* issues with the patch. I'm not sure we should merge this. The current problems with MPI are known (see [ROOT-9293](https://sft.its.cern.ch/jira/browse/ROOT-9293)). Once that's fixed, we can be more confident in merging the move to C bindings, which would be nice, due to the deprecation of the C++ bindings.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1843
https://github.com/root-project/root/pull/1843:119,interoperability,bind,bindings,119,"You are correct, I am pretty sure it is not yet mergeable. It's more of a base for someone to start working on the MPI bindings to get them running. (Such as @gudlaugu?) I might be able to help with this at some point in the future, but not soon. (Hence the WIP in the title)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1843
https://github.com/root-project/root/pull/1843:119,modifiability,bind,bindings,119,"You are correct, I am pretty sure it is not yet mergeable. It's more of a base for someone to start working on the MPI bindings to get them running. (Such as @gudlaugu?) I might be able to help with this at some point in the future, but not soon. (Hence the WIP in the title)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1843
https://github.com/root-project/root/pull/1843:189,usability,help,help,189,"You are correct, I am pretty sure it is not yet mergeable. It's more of a base for someone to start working on the MPI bindings to get them running. (Such as @gudlaugu?) I might be able to help with this at some point in the future, but not soon. (Hence the WIP in the title)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1843
https://github.com/root-project/root/pull/1843:92,interoperability,bind,bindings,92,I agree with @henryiii . We should keep this as a base for start working and fixing the MPI bindings. . Until then I think we should keep this PR open,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1843
https://github.com/root-project/root/pull/1843:92,modifiability,bind,bindings,92,I agree with @henryiii . We should keep this as a base for start working and fixing the MPI bindings. . Until then I think we should keep this PR open,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1843
https://github.com/root-project/root/pull/1843:44,interoperability,bind,bindings,44,"Since no more work has been done on the MPI bindings, I close this PR for the time being",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1843
https://github.com/root-project/root/pull/1843:44,modifiability,bind,bindings,44,"Since no more work has been done on the MPI bindings, I close this PR for the time being",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1843
https://github.com/root-project/root/pull/1843:78,performance,time,time,78,"Since no more work has been done on the MPI bindings, I close this PR for the time being",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1843
https://github.com/root-project/root/pull/1843:56,usability,close,close,56,"Since no more work has been done on the MPI bindings, I close this PR for the time being",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1843
https://github.com/root-project/root/pull/1845:8,availability,error,errors,8,"Ok, the errors above are expected, since Davix is outdated in the externals (0.6.2 vs newly required 0.6.4).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1845
https://github.com/root-project/root/pull/1845:8,performance,error,errors,8,"Ok, the errors above are expected, since Davix is outdated in the externals (0.6.2 vs newly required 0.6.4).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1845
https://github.com/root-project/root/pull/1845:8,safety,error,errors,8,"Ok, the errors above are expected, since Davix is outdated in the externals (0.6.2 vs newly required 0.6.4).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1845
https://github.com/root-project/root/pull/1845:8,usability,error,errors,8,"Ok, the errors above are expected, since Davix is outdated in the externals (0.6.2 vs newly required 0.6.4).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1845
https://github.com/root-project/root/pull/1845:11,deployability,build,build,11,@phsft-bot build with flags -Dbuiltin_davix=ON -Dbuiltin_openssl=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1845
https://github.com/root-project/root/pull/1845:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1845
https://github.com/root-project/root/pull/1845:11,deployability,build,build,11,@phsft-bot build with flags -Dbuiltin_davix=ON -Dbuiltin_openssl=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1845
https://github.com/root-project/root/pull/1845:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1845
https://github.com/root-project/root/pull/1845:11,deployability,build,build,11,@phsft-bot build just on mac1012/native,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1845
https://github.com/root-project/root/pull/1845:26,deployability,build,build,26,"Tests passed, but another build was triggered after the merge, and it cannot find the now deleted branch.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1845
https://github.com/root-project/root/pull/1845:0,safety,Test,Tests,0,"Tests passed, but another build was triggered after the merge, and it cannot find the now deleted branch.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1845
https://github.com/root-project/root/pull/1845:0,testability,Test,Tests,0,"Tests passed, but another build was triggered after the merge, and it cannot find the now deleted branch.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1845
https://github.com/root-project/root/pull/1849:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1849
https://github.com/root-project/root/pull/1850:11,deployability,build,build,11,@phsft-bot build.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1850
https://github.com/root-project/root/pull/1851:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1851
https://github.com/root-project/root/pull/1852:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1852
https://github.com/root-project/root/pull/1852:36,availability,error,errors,36,"@Axel-Naumann . As I could see, all errors has nothing to do with http/webgui classes.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1852
https://github.com/root-project/root/pull/1852:36,performance,error,errors,36,"@Axel-Naumann . As I could see, all errors has nothing to do with http/webgui classes.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1852
https://github.com/root-project/root/pull/1852:36,safety,error,errors,36,"@Axel-Naumann . As I could see, all errors has nothing to do with http/webgui classes.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1852
https://github.com/root-project/root/pull/1852:36,usability,error,errors,36,"@Axel-Naumann . As I could see, all errors has nothing to do with http/webgui classes.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1852
https://github.com/root-project/root/pull/1853:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1853
https://github.com/root-project/root/pull/1855:60,energy efficiency,adapt,adapting,60,"Hi @bluehood, . answers in revrese order. I am not a fan of adapting to old interfaces accepting pointers and a fan of value semantics but I think that adding a method which correspods to *_ptr::get is a good thing. - It would be cheap to add Reset . But for example, TDF is the only entity that should fill these ptrs. What does Reset actually mean? To what TDF is the pointer linked? - Comparison with nullptr (and implicit conversion): it would not be too much used, but cheap to add. Do you have a usecase in mind. - Assignments: I agree.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:60,integrability,adapt,adapting,60,"Hi @bluehood, . answers in revrese order. I am not a fan of adapting to old interfaces accepting pointers and a fan of value semantics but I think that adding a method which correspods to *_ptr::get is a good thing. - It would be cheap to add Reset . But for example, TDF is the only entity that should fill these ptrs. What does Reset actually mean? To what TDF is the pointer linked? - Comparison with nullptr (and implicit conversion): it would not be too much used, but cheap to add. Do you have a usecase in mind. - Assignments: I agree.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:76,integrability,interfac,interfaces,76,"Hi @bluehood, . answers in revrese order. I am not a fan of adapting to old interfaces accepting pointers and a fan of value semantics but I think that adding a method which correspods to *_ptr::get is a good thing. - It would be cheap to add Reset . But for example, TDF is the only entity that should fill these ptrs. What does Reset actually mean? To what TDF is the pointer linked? - Comparison with nullptr (and implicit conversion): it would not be too much used, but cheap to add. Do you have a usecase in mind. - Assignments: I agree.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:60,interoperability,adapt,adapting,60,"Hi @bluehood, . answers in revrese order. I am not a fan of adapting to old interfaces accepting pointers and a fan of value semantics but I think that adding a method which correspods to *_ptr::get is a good thing. - It would be cheap to add Reset . But for example, TDF is the only entity that should fill these ptrs. What does Reset actually mean? To what TDF is the pointer linked? - Comparison with nullptr (and implicit conversion): it would not be too much used, but cheap to add. Do you have a usecase in mind. - Assignments: I agree.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:76,interoperability,interfac,interfaces,76,"Hi @bluehood, . answers in revrese order. I am not a fan of adapting to old interfaces accepting pointers and a fan of value semantics but I think that adding a method which correspods to *_ptr::get is a good thing. - It would be cheap to add Reset . But for example, TDF is the only entity that should fill these ptrs. What does Reset actually mean? To what TDF is the pointer linked? - Comparison with nullptr (and implicit conversion): it would not be too much used, but cheap to add. Do you have a usecase in mind. - Assignments: I agree.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:125,interoperability,semant,semantics,125,"Hi @bluehood, . answers in revrese order. I am not a fan of adapting to old interfaces accepting pointers and a fan of value semantics but I think that adding a method which correspods to *_ptr::get is a good thing. - It would be cheap to add Reset . But for example, TDF is the only entity that should fill these ptrs. What does Reset actually mean? To what TDF is the pointer linked? - Comparison with nullptr (and implicit conversion): it would not be too much used, but cheap to add. Do you have a usecase in mind. - Assignments: I agree.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:426,interoperability,convers,conversion,426,"Hi @bluehood, . answers in revrese order. I am not a fan of adapting to old interfaces accepting pointers and a fan of value semantics but I think that adding a method which correspods to *_ptr::get is a good thing. - It would be cheap to add Reset . But for example, TDF is the only entity that should fill these ptrs. What does Reset actually mean? To what TDF is the pointer linked? - Comparison with nullptr (and implicit conversion): it would not be too much used, but cheap to add. Do you have a usecase in mind. - Assignments: I agree.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:60,modifiability,adapt,adapting,60,"Hi @bluehood, . answers in revrese order. I am not a fan of adapting to old interfaces accepting pointers and a fan of value semantics but I think that adding a method which correspods to *_ptr::get is a good thing. - It would be cheap to add Reset . But for example, TDF is the only entity that should fill these ptrs. What does Reset actually mean? To what TDF is the pointer linked? - Comparison with nullptr (and implicit conversion): it would not be too much used, but cheap to add. Do you have a usecase in mind. - Assignments: I agree.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:76,modifiability,interfac,interfaces,76,"Hi @bluehood, . answers in revrese order. I am not a fan of adapting to old interfaces accepting pointers and a fan of value semantics but I think that adding a method which correspods to *_ptr::get is a good thing. - It would be cheap to add Reset . But for example, TDF is the only entity that should fill these ptrs. What does Reset actually mean? To what TDF is the pointer linked? - Comparison with nullptr (and implicit conversion): it would not be too much used, but cheap to add. Do you have a usecase in mind. - Assignments: I agree.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:325,reliability,doe,does,325,"Hi @bluehood, . answers in revrese order. I am not a fan of adapting to old interfaces accepting pointers and a fan of value semantics but I think that adding a method which correspods to *_ptr::get is a good thing. - It would be cheap to add Reset . But for example, TDF is the only entity that should fill these ptrs. What does Reset actually mean? To what TDF is the pointer linked? - Comparison with nullptr (and implicit conversion): it would not be too much used, but cheap to add. Do you have a usecase in mind. - Assignments: I agree.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:80,interoperability,convers,conversion,80,"* I agree about Reset, not a good idea. * Comparisons with nullptr and implicit conversion to bool become useful now that one can default-construct a TResultPtr, to check whether it has been filled with something yet",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:75,availability,operat,operator,75,I still think that the suffix Ptr is a bit misleading due to the fact that operator-> is/can-be a very heavy operation and as such we may want to consider TResultHandle. > Comparisons with nullptr and implicit conversion to bool ... Would those two operations 'provoke' the execution or looks at the 'current' state?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:109,availability,operat,operation,109,I still think that the suffix Ptr is a bit misleading due to the fact that operator-> is/can-be a very heavy operation and as such we may want to consider TResultHandle. > Comparisons with nullptr and implicit conversion to bool ... Would those two operations 'provoke' the execution or looks at the 'current' state?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:249,availability,operat,operations,249,I still think that the suffix Ptr is a bit misleading due to the fact that operator-> is/can-be a very heavy operation and as such we may want to consider TResultHandle. > Comparisons with nullptr and implicit conversion to bool ... Would those two operations 'provoke' the execution or looks at the 'current' state?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:310,availability,state,state,310,I still think that the suffix Ptr is a bit misleading due to the fact that operator-> is/can-be a very heavy operation and as such we may want to consider TResultHandle. > Comparisons with nullptr and implicit conversion to bool ... Would those two operations 'provoke' the execution or looks at the 'current' state?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:301,energy efficiency,current,current,301,I still think that the suffix Ptr is a bit misleading due to the fact that operator-> is/can-be a very heavy operation and as such we may want to consider TResultHandle. > Comparisons with nullptr and implicit conversion to bool ... Would those two operations 'provoke' the execution or looks at the 'current' state?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:310,integrability,state,state,310,I still think that the suffix Ptr is a bit misleading due to the fact that operator-> is/can-be a very heavy operation and as such we may want to consider TResultHandle. > Comparisons with nullptr and implicit conversion to bool ... Would those two operations 'provoke' the execution or looks at the 'current' state?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:210,interoperability,convers,conversion,210,I still think that the suffix Ptr is a bit misleading due to the fact that operator-> is/can-be a very heavy operation and as such we may want to consider TResultHandle. > Comparisons with nullptr and implicit conversion to bool ... Would those two operations 'provoke' the execution or looks at the 'current' state?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:20,availability,operat,operations,20,". > Would those two operations 'provoke' the execution or looks at the 'current' state? They would refer to the current state. They answer the question ""does this object ~~point to the same value as this other object~~ point to something?"", just as for other smart pointers",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:81,availability,state,state,81,". > Would those two operations 'provoke' the execution or looks at the 'current' state? They would refer to the current state. They answer the question ""does this object ~~point to the same value as this other object~~ point to something?"", just as for other smart pointers",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:120,availability,state,state,120,". > Would those two operations 'provoke' the execution or looks at the 'current' state? They would refer to the current state. They answer the question ""does this object ~~point to the same value as this other object~~ point to something?"", just as for other smart pointers",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:72,energy efficiency,current,current,72,". > Would those two operations 'provoke' the execution or looks at the 'current' state? They would refer to the current state. They answer the question ""does this object ~~point to the same value as this other object~~ point to something?"", just as for other smart pointers",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:112,energy efficiency,current,current,112,". > Would those two operations 'provoke' the execution or looks at the 'current' state? They would refer to the current state. They answer the question ""does this object ~~point to the same value as this other object~~ point to something?"", just as for other smart pointers",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:81,integrability,state,state,81,". > Would those two operations 'provoke' the execution or looks at the 'current' state? They would refer to the current state. They answer the question ""does this object ~~point to the same value as this other object~~ point to something?"", just as for other smart pointers",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:120,integrability,state,state,120,". > Would those two operations 'provoke' the execution or looks at the 'current' state? They would refer to the current state. They answer the question ""does this object ~~point to the same value as this other object~~ point to something?"", just as for other smart pointers",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:153,reliability,doe,does,153,". > Would those two operations 'provoke' the execution or looks at the 'current' state? They would refer to the current state. They answer the question ""does this object ~~point to the same value as this other object~~ point to something?"", just as for other smart pointers",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:77,availability,operat,operator,77,"> I still think that the suffix Ptr is a bit misleading due to the fact that operator-> is/can-be a very heavy operation and as such we may want to consider TResultHandle. I think `TResultHandle` would suffer from the same problems as `TResultProxy`: the name is too generic, the average physicist will not know how to use it, it's not clear if I can make a `std::vector` of those, default construct one, assign one, copy.... `operator->` will be heavy for the first time the first result is accessed, and that is _the one thing_ to know about TDataFrame: event loop runs upon first access to one of the results. Subsequent usages of `operator->` will be fast.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:111,availability,operat,operation,111,"> I still think that the suffix Ptr is a bit misleading due to the fact that operator-> is/can-be a very heavy operation and as such we may want to consider TResultHandle. I think `TResultHandle` would suffer from the same problems as `TResultProxy`: the name is too generic, the average physicist will not know how to use it, it's not clear if I can make a `std::vector` of those, default construct one, assign one, copy.... `operator->` will be heavy for the first time the first result is accessed, and that is _the one thing_ to know about TDataFrame: event loop runs upon first access to one of the results. Subsequent usages of `operator->` will be fast.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:427,availability,operat,operator,427,"> I still think that the suffix Ptr is a bit misleading due to the fact that operator-> is/can-be a very heavy operation and as such we may want to consider TResultHandle. I think `TResultHandle` would suffer from the same problems as `TResultProxy`: the name is too generic, the average physicist will not know how to use it, it's not clear if I can make a `std::vector` of those, default construct one, assign one, copy.... `operator->` will be heavy for the first time the first result is accessed, and that is _the one thing_ to know about TDataFrame: event loop runs upon first access to one of the results. Subsequent usages of `operator->` will be fast.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:635,availability,operat,operator,635,"> I still think that the suffix Ptr is a bit misleading due to the fact that operator-> is/can-be a very heavy operation and as such we may want to consider TResultHandle. I think `TResultHandle` would suffer from the same problems as `TResultProxy`: the name is too generic, the average physicist will not know how to use it, it's not clear if I can make a `std::vector` of those, default construct one, assign one, copy.... `operator->` will be heavy for the first time the first result is accessed, and that is _the one thing_ to know about TDataFrame: event loop runs upon first access to one of the results. Subsequent usages of `operator->` will be fast.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:556,integrability,event,event,556,"> I still think that the suffix Ptr is a bit misleading due to the fact that operator-> is/can-be a very heavy operation and as such we may want to consider TResultHandle. I think `TResultHandle` would suffer from the same problems as `TResultProxy`: the name is too generic, the average physicist will not know how to use it, it's not clear if I can make a `std::vector` of those, default construct one, assign one, copy.... `operator->` will be heavy for the first time the first result is accessed, and that is _the one thing_ to know about TDataFrame: event loop runs upon first access to one of the results. Subsequent usages of `operator->` will be fast.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:613,integrability,Sub,Subsequent,613,"> I still think that the suffix Ptr is a bit misleading due to the fact that operator-> is/can-be a very heavy operation and as such we may want to consider TResultHandle. I think `TResultHandle` would suffer from the same problems as `TResultProxy`: the name is too generic, the average physicist will not know how to use it, it's not clear if I can make a `std::vector` of those, default construct one, assign one, copy.... `operator->` will be heavy for the first time the first result is accessed, and that is _the one thing_ to know about TDataFrame: event loop runs upon first access to one of the results. Subsequent usages of `operator->` will be fast.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:467,performance,time,time,467,"> I still think that the suffix Ptr is a bit misleading due to the fact that operator-> is/can-be a very heavy operation and as such we may want to consider TResultHandle. I think `TResultHandle` would suffer from the same problems as `TResultProxy`: the name is too generic, the average physicist will not know how to use it, it's not clear if I can make a `std::vector` of those, default construct one, assign one, copy.... `operator->` will be heavy for the first time the first result is accessed, and that is _the one thing_ to know about TDataFrame: event loop runs upon first access to one of the results. Subsequent usages of `operator->` will be fast.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:492,security,access,accessed,492,"> I still think that the suffix Ptr is a bit misleading due to the fact that operator-> is/can-be a very heavy operation and as such we may want to consider TResultHandle. I think `TResultHandle` would suffer from the same problems as `TResultProxy`: the name is too generic, the average physicist will not know how to use it, it's not clear if I can make a `std::vector` of those, default construct one, assign one, copy.... `operator->` will be heavy for the first time the first result is accessed, and that is _the one thing_ to know about TDataFrame: event loop runs upon first access to one of the results. Subsequent usages of `operator->` will be fast.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:583,security,access,access,583,"> I still think that the suffix Ptr is a bit misleading due to the fact that operator-> is/can-be a very heavy operation and as such we may want to consider TResultHandle. I think `TResultHandle` would suffer from the same problems as `TResultProxy`: the name is too generic, the average physicist will not know how to use it, it's not clear if I can make a `std::vector` of those, default construct one, assign one, copy.... `operator->` will be heavy for the first time the first result is accessed, and that is _the one thing_ to know about TDataFrame: event loop runs upon first access to one of the results. Subsequent usages of `operator->` will be fast.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:336,usability,clear,clear,336,"> I still think that the suffix Ptr is a bit misleading due to the fact that operator-> is/can-be a very heavy operation and as such we may want to consider TResultHandle. I think `TResultHandle` would suffer from the same problems as `TResultProxy`: the name is too generic, the average physicist will not know how to use it, it's not clear if I can make a `std::vector` of those, default construct one, assign one, copy.... `operator->` will be heavy for the first time the first result is accessed, and that is _the one thing_ to know about TDataFrame: event loop runs upon first access to one of the results. Subsequent usages of `operator->` will be fast.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:34,availability,state,state,34,"> They would refer to the current state. . This is not obvious :) especially for a Ptr. For example, would you expect this to result false (it does in your scenario the first it is run and true the 2nd time ... ):. ```. (bool) resultPtr && resultPtr->IsValid() && (bool) resultPtr. ```. another one :). ```. (bool)resultPtr == resultPtr->IsValid() && (bool) resultPtr. ```. Cheers,. Philippe.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:26,energy efficiency,current,current,26,"> They would refer to the current state. . This is not obvious :) especially for a Ptr. For example, would you expect this to result false (it does in your scenario the first it is run and true the 2nd time ... ):. ```. (bool) resultPtr && resultPtr->IsValid() && (bool) resultPtr. ```. another one :). ```. (bool)resultPtr == resultPtr->IsValid() && (bool) resultPtr. ```. Cheers,. Philippe.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:34,integrability,state,state,34,"> They would refer to the current state. . This is not obvious :) especially for a Ptr. For example, would you expect this to result false (it does in your scenario the first it is run and true the 2nd time ... ):. ```. (bool) resultPtr && resultPtr->IsValid() && (bool) resultPtr. ```. another one :). ```. (bool)resultPtr == resultPtr->IsValid() && (bool) resultPtr. ```. Cheers,. Philippe.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:156,modifiability,scenario,scenario,156,"> They would refer to the current state. . This is not obvious :) especially for a Ptr. For example, would you expect this to result false (it does in your scenario the first it is run and true the 2nd time ... ):. ```. (bool) resultPtr && resultPtr->IsValid() && (bool) resultPtr. ```. another one :). ```. (bool)resultPtr == resultPtr->IsValid() && (bool) resultPtr. ```. Cheers,. Philippe.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:202,performance,time,time,202,"> They would refer to the current state. . This is not obvious :) especially for a Ptr. For example, would you expect this to result false (it does in your scenario the first it is run and true the 2nd time ... ):. ```. (bool) resultPtr && resultPtr->IsValid() && (bool) resultPtr. ```. another one :). ```. (bool)resultPtr == resultPtr->IsValid() && (bool) resultPtr. ```. Cheers,. Philippe.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:143,reliability,doe,does,143,"> They would refer to the current state. . This is not obvious :) especially for a Ptr. For example, would you expect this to result false (it does in your scenario the first it is run and true the 2nd time ... ):. ```. (bool) resultPtr && resultPtr->IsValid() && (bool) resultPtr. ```. another one :). ```. (bool)resultPtr == resultPtr->IsValid() && (bool) resultPtr. ```. Cheers,. Philippe.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:57,availability,operat,operator,57,". > This not obvious. I think you are misunderstanding. `operator bool` will have the exact same semantics as in `shared_ptr` and `unique_ptr`: converts to `true` if I can safely dereference, converts to false otherwise. Dereferencing the `TResultPtr` _does not_ change its `true/false` conversion. `TResultPtr<int> s;` will be falsey, `auto s = tdf.Histo(""x"")` will be truthy",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:97,interoperability,semant,semantics,97,". > This not obvious. I think you are misunderstanding. `operator bool` will have the exact same semantics as in `shared_ptr` and `unique_ptr`: converts to `true` if I can safely dereference, converts to false otherwise. Dereferencing the `TResultPtr` _does not_ change its `true/false` conversion. `TResultPtr<int> s;` will be falsey, `auto s = tdf.Histo(""x"")` will be truthy",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:287,interoperability,convers,conversion,287,". > This not obvious. I think you are misunderstanding. `operator bool` will have the exact same semantics as in `shared_ptr` and `unique_ptr`: converts to `true` if I can safely dereference, converts to false otherwise. Dereferencing the `TResultPtr` _does not_ change its `true/false` conversion. `TResultPtr<int> s;` will be falsey, `auto s = tdf.Histo(""x"")` will be truthy",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:172,safety,safe,safely,172,". > This not obvious. I think you are misunderstanding. `operator bool` will have the exact same semantics as in `shared_ptr` and `unique_ptr`: converts to `true` if I can safely dereference, converts to false otherwise. Dereferencing the `TResultPtr` _does not_ change its `true/false` conversion. `TResultPtr<int> s;` will be falsey, `auto s = tdf.Histo(""x"")` will be truthy",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:525,energy efficiency,load,loaded,525,"> I think TResultHandle would suffer from the same problems as TResultProxy: the name is too generic, the average physicist will not know how to use it, it's not clear if I can make a std::vector of those, default construct one, assign one, copy.... One could give the exact same argument against TResultPtr ;) .... One difference with a pointer is the life-time of the pointee. > the average physicist will not know how to use it,. A lot of the frameworks have the concept of 'Handle' already to indicate this kind of delay-loaded accessor.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:358,performance,time,time,358,"> I think TResultHandle would suffer from the same problems as TResultProxy: the name is too generic, the average physicist will not know how to use it, it's not clear if I can make a std::vector of those, default construct one, assign one, copy.... One could give the exact same argument against TResultPtr ;) .... One difference with a pointer is the life-time of the pointee. > the average physicist will not know how to use it,. A lot of the frameworks have the concept of 'Handle' already to indicate this kind of delay-loaded accessor.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:525,performance,load,loaded,525,"> I think TResultHandle would suffer from the same problems as TResultProxy: the name is too generic, the average physicist will not know how to use it, it's not clear if I can make a std::vector of those, default construct one, assign one, copy.... One could give the exact same argument against TResultPtr ;) .... One difference with a pointer is the life-time of the pointee. > the average physicist will not know how to use it,. A lot of the frameworks have the concept of 'Handle' already to indicate this kind of delay-loaded accessor.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:532,security,access,accessor,532,"> I think TResultHandle would suffer from the same problems as TResultProxy: the name is too generic, the average physicist will not know how to use it, it's not clear if I can make a std::vector of those, default construct one, assign one, copy.... One could give the exact same argument against TResultPtr ;) .... One difference with a pointer is the life-time of the pointee. > the average physicist will not know how to use it,. A lot of the frameworks have the concept of 'Handle' already to indicate this kind of delay-loaded accessor.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:162,usability,clear,clear,162,"> I think TResultHandle would suffer from the same problems as TResultProxy: the name is too generic, the average physicist will not know how to use it, it's not clear if I can make a std::vector of those, default construct one, assign one, copy.... One could give the exact same argument against TResultPtr ;) .... One difference with a pointer is the life-time of the pointee. > the average physicist will not know how to use it,. A lot of the frameworks have the concept of 'Handle' already to indicate this kind of delay-loaded accessor.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:497,usability,indicat,indicate,497,"> I think TResultHandle would suffer from the same problems as TResultProxy: the name is too generic, the average physicist will not know how to use it, it's not clear if I can make a std::vector of those, default construct one, assign one, copy.... One could give the exact same argument against TResultPtr ;) .... One difference with a pointer is the life-time of the pointee. > the average physicist will not know how to use it,. A lot of the frameworks have the concept of 'Handle' already to indicate this kind of delay-loaded accessor.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:563,availability,state,stated,563,"> One could give the exact same argument against TResultPtr. I don't get it: all ROOT users are familiar with the concept of a pointer, while not every PhD student is familiar with the concept of a Handle. If it's a pointer, I know that I can access the contents with `*p` or `->`, and I know what happens when I copy it, assign one thing to the other, etc.... If it's a Handle I know none of these things. We might as well stick with `TResultProxy`. [The idea](https://sft.its.cern.ch/jira/browse/ROOT-9350) was to convey _how to use it_, not _how it works_. As stated in the jira issue the problem we are trying to solve is that users do not know what to do with a ""proxy"" -- but they do know what to do with a pointer.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:563,integrability,state,stated,563,"> One could give the exact same argument against TResultPtr. I don't get it: all ROOT users are familiar with the concept of a pointer, while not every PhD student is familiar with the concept of a Handle. If it's a pointer, I know that I can access the contents with `*p` or `->`, and I know what happens when I copy it, assign one thing to the other, etc.... If it's a Handle I know none of these things. We might as well stick with `TResultProxy`. [The idea](https://sft.its.cern.ch/jira/browse/ROOT-9350) was to convey _how to use it_, not _how it works_. As stated in the jira issue the problem we are trying to solve is that users do not know what to do with a ""proxy"" -- but they do know what to do with a pointer.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:668,interoperability,prox,proxy,668,"> One could give the exact same argument against TResultPtr. I don't get it: all ROOT users are familiar with the concept of a pointer, while not every PhD student is familiar with the concept of a Handle. If it's a pointer, I know that I can access the contents with `*p` or `->`, and I know what happens when I copy it, assign one thing to the other, etc.... If it's a Handle I know none of these things. We might as well stick with `TResultProxy`. [The idea](https://sft.its.cern.ch/jira/browse/ROOT-9350) was to convey _how to use it_, not _how it works_. As stated in the jira issue the problem we are trying to solve is that users do not know what to do with a ""proxy"" -- but they do know what to do with a pointer.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:254,performance,content,contents,254,"> One could give the exact same argument against TResultPtr. I don't get it: all ROOT users are familiar with the concept of a pointer, while not every PhD student is familiar with the concept of a Handle. If it's a pointer, I know that I can access the contents with `*p` or `->`, and I know what happens when I copy it, assign one thing to the other, etc.... If it's a Handle I know none of these things. We might as well stick with `TResultProxy`. [The idea](https://sft.its.cern.ch/jira/browse/ROOT-9350) was to convey _how to use it_, not _how it works_. As stated in the jira issue the problem we are trying to solve is that users do not know what to do with a ""proxy"" -- but they do know what to do with a pointer.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:243,security,access,access,243,"> One could give the exact same argument against TResultPtr. I don't get it: all ROOT users are familiar with the concept of a pointer, while not every PhD student is familiar with the concept of a Handle. If it's a pointer, I know that I can access the contents with `*p` or `->`, and I know what happens when I copy it, assign one thing to the other, etc.... If it's a Handle I know none of these things. We might as well stick with `TResultProxy`. [The idea](https://sft.its.cern.ch/jira/browse/ROOT-9350) was to convey _how to use it_, not _how it works_. As stated in the jira issue the problem we are trying to solve is that users do not know what to do with a ""proxy"" -- but they do know what to do with a pointer.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:86,usability,user,users,86,"> One could give the exact same argument against TResultPtr. I don't get it: all ROOT users are familiar with the concept of a pointer, while not every PhD student is familiar with the concept of a Handle. If it's a pointer, I know that I can access the contents with `*p` or `->`, and I know what happens when I copy it, assign one thing to the other, etc.... If it's a Handle I know none of these things. We might as well stick with `TResultProxy`. [The idea](https://sft.its.cern.ch/jira/browse/ROOT-9350) was to convey _how to use it_, not _how it works_. As stated in the jira issue the problem we are trying to solve is that users do not know what to do with a ""proxy"" -- but they do know what to do with a pointer.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:631,usability,user,users,631,"> One could give the exact same argument against TResultPtr. I don't get it: all ROOT users are familiar with the concept of a pointer, while not every PhD student is familiar with the concept of a Handle. If it's a pointer, I know that I can access the contents with `*p` or `->`, and I know what happens when I copy it, assign one thing to the other, etc.... If it's a Handle I know none of these things. We might as well stick with `TResultProxy`. [The idea](https://sft.its.cern.ch/jira/browse/ROOT-9350) was to convey _how to use it_, not _how it works_. As stated in the jira issue the problem we are trying to solve is that users do not know what to do with a ""proxy"" -- but they do know what to do with a pointer.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:224,usability,close,close,224,"> The idea was to convey how to use it, not how it works. . And I claimed that because of other uses of the suffix Handle you can actually do both :) [C++ wise, I would also argue that rather than a smart_ptr this entity is close to an std::future ....]",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:390,availability,sli,slice,390,"_One_ of the results will do something similar to a future (but not quite, because futures in C++ are associated with asynchronous execution). I still think that the average physicist will get as little insight in the semantics of the type from the denomination ""Handle"" as they get from ""Proxy"". Even ROOT has a `TFileOpenHandle` which does not have the semantics you describe. There is a slice of our users which are not familiar with the experiment frameworks and/or do not use one. If you feel strongly that this is not the way to go and we need a name that clearly conveys both pointer semantics and the fact that the first access triggers the event loop, I think we'll need a discussion outside of this PR :smile:.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:118,integrability,asynchron,asynchronous,118,"_One_ of the results will do something similar to a future (but not quite, because futures in C++ are associated with asynchronous execution). I still think that the average physicist will get as little insight in the semantics of the type from the denomination ""Handle"" as they get from ""Proxy"". Even ROOT has a `TFileOpenHandle` which does not have the semantics you describe. There is a slice of our users which are not familiar with the experiment frameworks and/or do not use one. If you feel strongly that this is not the way to go and we need a name that clearly conveys both pointer semantics and the fact that the first access triggers the event loop, I think we'll need a discussion outside of this PR :smile:.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:649,integrability,event,event,649,"_One_ of the results will do something similar to a future (but not quite, because futures in C++ are associated with asynchronous execution). I still think that the average physicist will get as little insight in the semantics of the type from the denomination ""Handle"" as they get from ""Proxy"". Even ROOT has a `TFileOpenHandle` which does not have the semantics you describe. There is a slice of our users which are not familiar with the experiment frameworks and/or do not use one. If you feel strongly that this is not the way to go and we need a name that clearly conveys both pointer semantics and the fact that the first access triggers the event loop, I think we'll need a discussion outside of this PR :smile:.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:218,interoperability,semant,semantics,218,"_One_ of the results will do something similar to a future (but not quite, because futures in C++ are associated with asynchronous execution). I still think that the average physicist will get as little insight in the semantics of the type from the denomination ""Handle"" as they get from ""Proxy"". Even ROOT has a `TFileOpenHandle` which does not have the semantics you describe. There is a slice of our users which are not familiar with the experiment frameworks and/or do not use one. If you feel strongly that this is not the way to go and we need a name that clearly conveys both pointer semantics and the fact that the first access triggers the event loop, I think we'll need a discussion outside of this PR :smile:.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:289,interoperability,Prox,Proxy,289,"_One_ of the results will do something similar to a future (but not quite, because futures in C++ are associated with asynchronous execution). I still think that the average physicist will get as little insight in the semantics of the type from the denomination ""Handle"" as they get from ""Proxy"". Even ROOT has a `TFileOpenHandle` which does not have the semantics you describe. There is a slice of our users which are not familiar with the experiment frameworks and/or do not use one. If you feel strongly that this is not the way to go and we need a name that clearly conveys both pointer semantics and the fact that the first access triggers the event loop, I think we'll need a discussion outside of this PR :smile:.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:355,interoperability,semant,semantics,355,"_One_ of the results will do something similar to a future (but not quite, because futures in C++ are associated with asynchronous execution). I still think that the average physicist will get as little insight in the semantics of the type from the denomination ""Handle"" as they get from ""Proxy"". Even ROOT has a `TFileOpenHandle` which does not have the semantics you describe. There is a slice of our users which are not familiar with the experiment frameworks and/or do not use one. If you feel strongly that this is not the way to go and we need a name that clearly conveys both pointer semantics and the fact that the first access triggers the event loop, I think we'll need a discussion outside of this PR :smile:.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:591,interoperability,semant,semantics,591,"_One_ of the results will do something similar to a future (but not quite, because futures in C++ are associated with asynchronous execution). I still think that the average physicist will get as little insight in the semantics of the type from the denomination ""Handle"" as they get from ""Proxy"". Even ROOT has a `TFileOpenHandle` which does not have the semantics you describe. There is a slice of our users which are not familiar with the experiment frameworks and/or do not use one. If you feel strongly that this is not the way to go and we need a name that clearly conveys both pointer semantics and the fact that the first access triggers the event loop, I think we'll need a discussion outside of this PR :smile:.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:118,performance,asynch,asynchronous,118,"_One_ of the results will do something similar to a future (but not quite, because futures in C++ are associated with asynchronous execution). I still think that the average physicist will get as little insight in the semantics of the type from the denomination ""Handle"" as they get from ""Proxy"". Even ROOT has a `TFileOpenHandle` which does not have the semantics you describe. There is a slice of our users which are not familiar with the experiment frameworks and/or do not use one. If you feel strongly that this is not the way to go and we need a name that clearly conveys both pointer semantics and the fact that the first access triggers the event loop, I think we'll need a discussion outside of this PR :smile:.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:337,reliability,doe,does,337,"_One_ of the results will do something similar to a future (but not quite, because futures in C++ are associated with asynchronous execution). I still think that the average physicist will get as little insight in the semantics of the type from the denomination ""Handle"" as they get from ""Proxy"". Even ROOT has a `TFileOpenHandle` which does not have the semantics you describe. There is a slice of our users which are not familiar with the experiment frameworks and/or do not use one. If you feel strongly that this is not the way to go and we need a name that clearly conveys both pointer semantics and the fact that the first access triggers the event loop, I think we'll need a discussion outside of this PR :smile:.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:390,reliability,sli,slice,390,"_One_ of the results will do something similar to a future (but not quite, because futures in C++ are associated with asynchronous execution). I still think that the average physicist will get as little insight in the semantics of the type from the denomination ""Handle"" as they get from ""Proxy"". Even ROOT has a `TFileOpenHandle` which does not have the semantics you describe. There is a slice of our users which are not familiar with the experiment frameworks and/or do not use one. If you feel strongly that this is not the way to go and we need a name that clearly conveys both pointer semantics and the fact that the first access triggers the event loop, I think we'll need a discussion outside of this PR :smile:.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:629,security,access,access,629,"_One_ of the results will do something similar to a future (but not quite, because futures in C++ are associated with asynchronous execution). I still think that the average physicist will get as little insight in the semantics of the type from the denomination ""Handle"" as they get from ""Proxy"". Even ROOT has a `TFileOpenHandle` which does not have the semantics you describe. There is a slice of our users which are not familiar with the experiment frameworks and/or do not use one. If you feel strongly that this is not the way to go and we need a name that clearly conveys both pointer semantics and the fact that the first access triggers the event loop, I think we'll need a discussion outside of this PR :smile:.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:403,usability,user,users,403,"_One_ of the results will do something similar to a future (but not quite, because futures in C++ are associated with asynchronous execution). I still think that the average physicist will get as little insight in the semantics of the type from the denomination ""Handle"" as they get from ""Proxy"". Even ROOT has a `TFileOpenHandle` which does not have the semantics you describe. There is a slice of our users which are not familiar with the experiment frameworks and/or do not use one. If you feel strongly that this is not the way to go and we need a name that clearly conveys both pointer semantics and the fact that the first access triggers the event loop, I think we'll need a discussion outside of this PR :smile:.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:562,usability,clear,clearly,562,"_One_ of the results will do something similar to a future (but not quite, because futures in C++ are associated with asynchronous execution). I still think that the average physicist will get as little insight in the semantics of the type from the denomination ""Handle"" as they get from ""Proxy"". Even ROOT has a `TFileOpenHandle` which does not have the semantics you describe. There is a slice of our users which are not familiar with the experiment frameworks and/or do not use one. If you feel strongly that this is not the way to go and we need a name that clearly conveys both pointer semantics and the fact that the first access triggers the event loop, I think we'll need a discussion outside of this PR :smile:.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:46,usability,close,close,46,> that rather than a smart_ptr this entity is close to an std::future .... Actually this brings me to another question to answer before a final decision. What are the advantage and disadvantage of splitting TResultProxy into distinct entity: a future and a (more regular) smart ptr?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:45,integrability,asynchron,asynchronous,45,> because futures in C++ are associated with asynchronous execution. Yes technically it is not a future but (beside the threading implementation details) behaves very much like it.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:45,performance,asynch,asynchronous,45,> because futures in C++ are associated with asynchronous execution. Yes technically it is not a future but (beside the threading implementation details) behaves very much like it.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:243,integrability,asynchron,asynchronous,243,> What are the advantage and disadvantage of splitting TResultProxy into distinct entity: a future and a (more regular) smart ptr? Can you give an example of how that would look from the user perspective? (again note that future usually means asynchronous execution in c++..),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:243,performance,asynch,asynchronous,243,> What are the advantage and disadvantage of splitting TResultProxy into distinct entity: a future and a (more regular) smart ptr? Can you give an example of how that would look from the user perspective? (again note that future usually means asynchronous execution in c++..),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:187,usability,user,user,187,> What are the advantage and disadvantage of splitting TResultProxy into distinct entity: a future and a (more regular) smart ptr? Can you give an example of how that would look from the user perspective? (again note that future usually means asynchronous execution in c++..),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:40,integrability,asynchron,asynchronous,40,"> (again note that future usually means asynchronous execution in c++. Right .... this is a major difference. > Can you give an example of how that would look from the user perspective? Did not really think about it in details. I suppose. ```. Auto filter = tdf.something( filter_lamba, branches ); // Guarantee 'fast'. auto histo = filter.GetResult(); // access the disk ... ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:249,integrability,filter,filter,249,"> (again note that future usually means asynchronous execution in c++. Right .... this is a major difference. > Can you give an example of how that would look from the user perspective? Did not really think about it in details. I suppose. ```. Auto filter = tdf.something( filter_lamba, branches ); // Guarantee 'fast'. auto histo = filter.GetResult(); // access the disk ... ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:333,integrability,filter,filter,333,"> (again note that future usually means asynchronous execution in c++. Right .... this is a major difference. > Can you give an example of how that would look from the user perspective? Did not really think about it in details. I suppose. ```. Auto filter = tdf.something( filter_lamba, branches ); // Guarantee 'fast'. auto histo = filter.GetResult(); // access the disk ... ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:40,performance,asynch,asynchronous,40,"> (again note that future usually means asynchronous execution in c++. Right .... this is a major difference. > Can you give an example of how that would look from the user perspective? Did not really think about it in details. I suppose. ```. Auto filter = tdf.something( filter_lamba, branches ); // Guarantee 'fast'. auto histo = filter.GetResult(); // access the disk ... ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:367,performance,disk,disk,367,"> (again note that future usually means asynchronous execution in c++. Right .... this is a major difference. > Can you give an example of how that would look from the user perspective? Did not really think about it in details. I suppose. ```. Auto filter = tdf.something( filter_lamba, branches ); // Guarantee 'fast'. auto histo = filter.GetResult(); // access the disk ... ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:356,security,access,access,356,"> (again note that future usually means asynchronous execution in c++. Right .... this is a major difference. > Can you give an example of how that would look from the user perspective? Did not really think about it in details. I suppose. ```. Auto filter = tdf.something( filter_lamba, branches ); // Guarantee 'fast'. auto histo = filter.GetResult(); // access the disk ... ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:168,usability,user,user,168,"> (again note that future usually means asynchronous execution in c++. Right .... this is a major difference. > Can you give an example of how that would look from the user perspective? Did not really think about it in details. I suppose. ```. Auto filter = tdf.something( filter_lamba, branches ); // Guarantee 'fast'. auto histo = filter.GetResult(); // access the disk ... ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:296,performance,time,times,296,"I see. `TResultProxy` already has a `GetValue` helper method that returns a reference to the stored value (and triggers its computation if need be). It's meant to be used mostly from python, where there is no `->`. It's more awkward than `->` because for N histograms I have to call `GetValue` N times.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:47,usability,help,helper,47,"I see. `TResultProxy` already has a `GetValue` helper method that returns a reference to the stored value (and triggers its computation if need be). It's meant to be used mostly from python, where there is no `->`. It's more awkward than `->` because for N histograms I have to call `GetValue` N times.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:490,reliability,pra,pragmatic,490,"One of the main difficulties to start developing in CMSSW (and this is common to other fwks) is the jeargon permeating all corners of the software, for example ""Handle"" means really little while ""pointer"" is something which can be accessed with ""->"". . We have signs on the forum of user not even noticing/caring enough what type the return value of action was (this is a success) *and* have a huge amount of code still to develop to implement our long term vision of ROOT. I support being pragmatic before anything else :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:231,security,access,accessed,231,"One of the main difficulties to start developing in CMSSW (and this is common to other fwks) is the jeargon permeating all corners of the software, for example ""Handle"" means really little while ""pointer"" is something which can be accessed with ""->"". . We have signs on the forum of user not even noticing/caring enough what type the return value of action was (this is a success) *and* have a huge amount of code still to develop to implement our long term vision of ROOT. I support being pragmatic before anything else :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:261,security,sign,signs,261,"One of the main difficulties to start developing in CMSSW (and this is common to other fwks) is the jeargon permeating all corners of the software, for example ""Handle"" means really little while ""pointer"" is something which can be accessed with ""->"". . We have signs on the forum of user not even noticing/caring enough what type the return value of action was (this is a success) *and* have a huge amount of code still to develop to implement our long term vision of ROOT. I support being pragmatic before anything else :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:283,usability,user,user,283,"One of the main difficulties to start developing in CMSSW (and this is common to other fwks) is the jeargon permeating all corners of the software, for example ""Handle"" means really little while ""pointer"" is something which can be accessed with ""->"". . We have signs on the forum of user not even noticing/caring enough what type the return value of action was (this is a success) *and* have a huge amount of code still to develop to implement our long term vision of ROOT. I support being pragmatic before anything else :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:476,usability,support,support,476,"One of the main difficulties to start developing in CMSSW (and this is common to other fwks) is the jeargon permeating all corners of the software, for example ""Handle"" means really little while ""pointer"" is something which can be accessed with ""->"". . We have signs on the forum of user not even noticing/caring enough what type the return value of action was (this is a success) *and* have a huge amount of code still to develop to implement our long term vision of ROOT. I support being pragmatic before anything else :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:254,energy efficiency,Draw,Draw,254,"Apologies for joining the party only after it's over. My opinion:. `ptr` is fine because I don't see how (regular) people would notice / care *when* the cost occurs, this should be opaque to them. If they ever notice, they can be told and learn. `TTree::Draw()` sort of suffers from a similar mismatch of interface announcement (""register in the pad"") and runtime cost that `ptr` has in this case. And we survived. I find the argument convincing that `ptr`, unlike `handle`, conveys the usage: `handle` often means ""opaque thing that you don't know what to do with but someone else will"" and is thus not very helpful for interfaces. I find the usage cost for separating trigger and value access too high.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:305,integrability,interfac,interface,305,"Apologies for joining the party only after it's over. My opinion:. `ptr` is fine because I don't see how (regular) people would notice / care *when* the cost occurs, this should be opaque to them. If they ever notice, they can be told and learn. `TTree::Draw()` sort of suffers from a similar mismatch of interface announcement (""register in the pad"") and runtime cost that `ptr` has in this case. And we survived. I find the argument convincing that `ptr`, unlike `handle`, conveys the usage: `handle` often means ""opaque thing that you don't know what to do with but someone else will"" and is thus not very helpful for interfaces. I find the usage cost for separating trigger and value access too high.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:621,integrability,interfac,interfaces,621,"Apologies for joining the party only after it's over. My opinion:. `ptr` is fine because I don't see how (regular) people would notice / care *when* the cost occurs, this should be opaque to them. If they ever notice, they can be told and learn. `TTree::Draw()` sort of suffers from a similar mismatch of interface announcement (""register in the pad"") and runtime cost that `ptr` has in this case. And we survived. I find the argument convincing that `ptr`, unlike `handle`, conveys the usage: `handle` often means ""opaque thing that you don't know what to do with but someone else will"" and is thus not very helpful for interfaces. I find the usage cost for separating trigger and value access too high.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:293,interoperability,mismatch,mismatch,293,"Apologies for joining the party only after it's over. My opinion:. `ptr` is fine because I don't see how (regular) people would notice / care *when* the cost occurs, this should be opaque to them. If they ever notice, they can be told and learn. `TTree::Draw()` sort of suffers from a similar mismatch of interface announcement (""register in the pad"") and runtime cost that `ptr` has in this case. And we survived. I find the argument convincing that `ptr`, unlike `handle`, conveys the usage: `handle` often means ""opaque thing that you don't know what to do with but someone else will"" and is thus not very helpful for interfaces. I find the usage cost for separating trigger and value access too high.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:305,interoperability,interfac,interface,305,"Apologies for joining the party only after it's over. My opinion:. `ptr` is fine because I don't see how (regular) people would notice / care *when* the cost occurs, this should be opaque to them. If they ever notice, they can be told and learn. `TTree::Draw()` sort of suffers from a similar mismatch of interface announcement (""register in the pad"") and runtime cost that `ptr` has in this case. And we survived. I find the argument convincing that `ptr`, unlike `handle`, conveys the usage: `handle` often means ""opaque thing that you don't know what to do with but someone else will"" and is thus not very helpful for interfaces. I find the usage cost for separating trigger and value access too high.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:621,interoperability,interfac,interfaces,621,"Apologies for joining the party only after it's over. My opinion:. `ptr` is fine because I don't see how (regular) people would notice / care *when* the cost occurs, this should be opaque to them. If they ever notice, they can be told and learn. `TTree::Draw()` sort of suffers from a similar mismatch of interface announcement (""register in the pad"") and runtime cost that `ptr` has in this case. And we survived. I find the argument convincing that `ptr`, unlike `handle`, conveys the usage: `handle` often means ""opaque thing that you don't know what to do with but someone else will"" and is thus not very helpful for interfaces. I find the usage cost for separating trigger and value access too high.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:305,modifiability,interfac,interface,305,"Apologies for joining the party only after it's over. My opinion:. `ptr` is fine because I don't see how (regular) people would notice / care *when* the cost occurs, this should be opaque to them. If they ever notice, they can be told and learn. `TTree::Draw()` sort of suffers from a similar mismatch of interface announcement (""register in the pad"") and runtime cost that `ptr` has in this case. And we survived. I find the argument convincing that `ptr`, unlike `handle`, conveys the usage: `handle` often means ""opaque thing that you don't know what to do with but someone else will"" and is thus not very helpful for interfaces. I find the usage cost for separating trigger and value access too high.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:621,modifiability,interfac,interfaces,621,"Apologies for joining the party only after it's over. My opinion:. `ptr` is fine because I don't see how (regular) people would notice / care *when* the cost occurs, this should be opaque to them. If they ever notice, they can be told and learn. `TTree::Draw()` sort of suffers from a similar mismatch of interface announcement (""register in the pad"") and runtime cost that `ptr` has in this case. And we survived. I find the argument convincing that `ptr`, unlike `handle`, conveys the usage: `handle` often means ""opaque thing that you don't know what to do with but someone else will"" and is thus not very helpful for interfaces. I find the usage cost for separating trigger and value access too high.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:688,security,access,access,688,"Apologies for joining the party only after it's over. My opinion:. `ptr` is fine because I don't see how (regular) people would notice / care *when* the cost occurs, this should be opaque to them. If they ever notice, they can be told and learn. `TTree::Draw()` sort of suffers from a similar mismatch of interface announcement (""register in the pad"") and runtime cost that `ptr` has in this case. And we survived. I find the argument convincing that `ptr`, unlike `handle`, conveys the usage: `handle` often means ""opaque thing that you don't know what to do with but someone else will"" and is thus not very helpful for interfaces. I find the usage cost for separating trigger and value access too high.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:239,usability,learn,learn,239,"Apologies for joining the party only after it's over. My opinion:. `ptr` is fine because I don't see how (regular) people would notice / care *when* the cost occurs, this should be opaque to them. If they ever notice, they can be told and learn. `TTree::Draw()` sort of suffers from a similar mismatch of interface announcement (""register in the pad"") and runtime cost that `ptr` has in this case. And we survived. I find the argument convincing that `ptr`, unlike `handle`, conveys the usage: `handle` often means ""opaque thing that you don't know what to do with but someone else will"" and is thus not very helpful for interfaces. I find the usage cost for separating trigger and value access too high.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:609,usability,help,helpful,609,"Apologies for joining the party only after it's over. My opinion:. `ptr` is fine because I don't see how (regular) people would notice / care *when* the cost occurs, this should be opaque to them. If they ever notice, they can be told and learn. `TTree::Draw()` sort of suffers from a similar mismatch of interface announcement (""register in the pad"") and runtime cost that `ptr` has in this case. And we survived. I find the argument convincing that `ptr`, unlike `handle`, conveys the usage: `handle` often means ""opaque thing that you don't know what to do with but someone else will"" and is thus not very helpful for interfaces. I find the usage cost for separating trigger and value access too high.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1855:52,usability,progress,progress,52,"Sure. For now. We still have 1 month: I really want progress, we can refine these things later.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1855
https://github.com/root-project/root/pull/1856:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1856:264,availability,error,error,264,"Hi @stwunsch , congrats! Very nice - and delivered extremely quickly: it was not obvious. Let's start from the points you mention as ""todos"" - I would order them as follows in terms of priority:. - More tests? Corner-cases missed? - These tests could also foresee error cases. - More error-handling? - What about not supported datatypes? Currently implemented for float, double, int, unsigned int, long, unsigned long. This is dependent on the memory adption feature of #1777 for std.vector. - Infere the final datatype of the numpy array in a clever way (currently double is the default). Implicit type conversion is done by the lambda passed to TDataFrame in the backend. - Apply clang-format. For the non supported data types, I think we should error out gracefully, but I let @etejedor comment. For the common type: can we use http://en.cppreference.com/w/cpp/types/common_type ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1856:284,availability,error,error-handling,284,"Hi @stwunsch , congrats! Very nice - and delivered extremely quickly: it was not obvious. Let's start from the points you mention as ""todos"" - I would order them as follows in terms of priority:. - More tests? Corner-cases missed? - These tests could also foresee error cases. - More error-handling? - What about not supported datatypes? Currently implemented for float, double, int, unsigned int, long, unsigned long. This is dependent on the memory adption feature of #1777 for std.vector. - Infere the final datatype of the numpy array in a clever way (currently double is the default). Implicit type conversion is done by the lambda passed to TDataFrame in the backend. - Apply clang-format. For the non supported data types, I think we should error out gracefully, but I let @etejedor comment. For the common type: can we use http://en.cppreference.com/w/cpp/types/common_type ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1856:748,availability,error,error,748,"Hi @stwunsch , congrats! Very nice - and delivered extremely quickly: it was not obvious. Let's start from the points you mention as ""todos"" - I would order them as follows in terms of priority:. - More tests? Corner-cases missed? - These tests could also foresee error cases. - More error-handling? - What about not supported datatypes? Currently implemented for float, double, int, unsigned int, long, unsigned long. This is dependent on the memory adption feature of #1777 for std.vector. - Infere the final datatype of the numpy array in a clever way (currently double is the default). Implicit type conversion is done by the lambda passed to TDataFrame in the backend. - Apply clang-format. For the non supported data types, I think we should error out gracefully, but I let @etejedor comment. For the common type: can we use http://en.cppreference.com/w/cpp/types/common_type ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1856:427,deployability,depend,dependent,427,"Hi @stwunsch , congrats! Very nice - and delivered extremely quickly: it was not obvious. Let's start from the points you mention as ""todos"" - I would order them as follows in terms of priority:. - More tests? Corner-cases missed? - These tests could also foresee error cases. - More error-handling? - What about not supported datatypes? Currently implemented for float, double, int, unsigned int, long, unsigned long. This is dependent on the memory adption feature of #1777 for std.vector. - Infere the final datatype of the numpy array in a clever way (currently double is the default). Implicit type conversion is done by the lambda passed to TDataFrame in the backend. - Apply clang-format. For the non supported data types, I think we should error out gracefully, but I let @etejedor comment. For the common type: can we use http://en.cppreference.com/w/cpp/types/common_type ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1856:338,energy efficiency,Current,Currently,338,"Hi @stwunsch , congrats! Very nice - and delivered extremely quickly: it was not obvious. Let's start from the points you mention as ""todos"" - I would order them as follows in terms of priority:. - More tests? Corner-cases missed? - These tests could also foresee error cases. - More error-handling? - What about not supported datatypes? Currently implemented for float, double, int, unsigned int, long, unsigned long. This is dependent on the memory adption feature of #1777 for std.vector. - Infere the final datatype of the numpy array in a clever way (currently double is the default). Implicit type conversion is done by the lambda passed to TDataFrame in the backend. - Apply clang-format. For the non supported data types, I think we should error out gracefully, but I let @etejedor comment. For the common type: can we use http://en.cppreference.com/w/cpp/types/common_type ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1856:556,energy efficiency,current,currently,556,"Hi @stwunsch , congrats! Very nice - and delivered extremely quickly: it was not obvious. Let's start from the points you mention as ""todos"" - I would order them as follows in terms of priority:. - More tests? Corner-cases missed? - These tests could also foresee error cases. - More error-handling? - What about not supported datatypes? Currently implemented for float, double, int, unsigned int, long, unsigned long. This is dependent on the memory adption feature of #1777 for std.vector. - Infere the final datatype of the numpy array in a clever way (currently double is the default). Implicit type conversion is done by the lambda passed to TDataFrame in the backend. - Apply clang-format. For the non supported data types, I think we should error out gracefully, but I let @etejedor comment. For the common type: can we use http://en.cppreference.com/w/cpp/types/common_type ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1856:427,integrability,depend,dependent,427,"Hi @stwunsch , congrats! Very nice - and delivered extremely quickly: it was not obvious. Let's start from the points you mention as ""todos"" - I would order them as follows in terms of priority:. - More tests? Corner-cases missed? - These tests could also foresee error cases. - More error-handling? - What about not supported datatypes? Currently implemented for float, double, int, unsigned int, long, unsigned long. This is dependent on the memory adption feature of #1777 for std.vector. - Infere the final datatype of the numpy array in a clever way (currently double is the default). Implicit type conversion is done by the lambda passed to TDataFrame in the backend. - Apply clang-format. For the non supported data types, I think we should error out gracefully, but I let @etejedor comment. For the common type: can we use http://en.cppreference.com/w/cpp/types/common_type ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1856:604,interoperability,convers,conversion,604,"Hi @stwunsch , congrats! Very nice - and delivered extremely quickly: it was not obvious. Let's start from the points you mention as ""todos"" - I would order them as follows in terms of priority:. - More tests? Corner-cases missed? - These tests could also foresee error cases. - More error-handling? - What about not supported datatypes? Currently implemented for float, double, int, unsigned int, long, unsigned long. This is dependent on the memory adption feature of #1777 for std.vector. - Infere the final datatype of the numpy array in a clever way (currently double is the default). Implicit type conversion is done by the lambda passed to TDataFrame in the backend. - Apply clang-format. For the non supported data types, I think we should error out gracefully, but I let @etejedor comment. For the common type: can we use http://en.cppreference.com/w/cpp/types/common_type ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1856:688,interoperability,format,format,688,"Hi @stwunsch , congrats! Very nice - and delivered extremely quickly: it was not obvious. Let's start from the points you mention as ""todos"" - I would order them as follows in terms of priority:. - More tests? Corner-cases missed? - These tests could also foresee error cases. - More error-handling? - What about not supported datatypes? Currently implemented for float, double, int, unsigned int, long, unsigned long. This is dependent on the memory adption feature of #1777 for std.vector. - Infere the final datatype of the numpy array in a clever way (currently double is the default). Implicit type conversion is done by the lambda passed to TDataFrame in the backend. - Apply clang-format. For the non supported data types, I think we should error out gracefully, but I let @etejedor comment. For the common type: can we use http://en.cppreference.com/w/cpp/types/common_type ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1856:427,modifiability,depend,dependent,427,"Hi @stwunsch , congrats! Very nice - and delivered extremely quickly: it was not obvious. Let's start from the points you mention as ""todos"" - I would order them as follows in terms of priority:. - More tests? Corner-cases missed? - These tests could also foresee error cases. - More error-handling? - What about not supported datatypes? Currently implemented for float, double, int, unsigned int, long, unsigned long. This is dependent on the memory adption feature of #1777 for std.vector. - Infere the final datatype of the numpy array in a clever way (currently double is the default). Implicit type conversion is done by the lambda passed to TDataFrame in the backend. - Apply clang-format. For the non supported data types, I think we should error out gracefully, but I let @etejedor comment. For the common type: can we use http://en.cppreference.com/w/cpp/types/common_type ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1856:264,performance,error,error,264,"Hi @stwunsch , congrats! Very nice - and delivered extremely quickly: it was not obvious. Let's start from the points you mention as ""todos"" - I would order them as follows in terms of priority:. - More tests? Corner-cases missed? - These tests could also foresee error cases. - More error-handling? - What about not supported datatypes? Currently implemented for float, double, int, unsigned int, long, unsigned long. This is dependent on the memory adption feature of #1777 for std.vector. - Infere the final datatype of the numpy array in a clever way (currently double is the default). Implicit type conversion is done by the lambda passed to TDataFrame in the backend. - Apply clang-format. For the non supported data types, I think we should error out gracefully, but I let @etejedor comment. For the common type: can we use http://en.cppreference.com/w/cpp/types/common_type ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1856:284,performance,error,error-handling,284,"Hi @stwunsch , congrats! Very nice - and delivered extremely quickly: it was not obvious. Let's start from the points you mention as ""todos"" - I would order them as follows in terms of priority:. - More tests? Corner-cases missed? - These tests could also foresee error cases. - More error-handling? - What about not supported datatypes? Currently implemented for float, double, int, unsigned int, long, unsigned long. This is dependent on the memory adption feature of #1777 for std.vector. - Infere the final datatype of the numpy array in a clever way (currently double is the default). Implicit type conversion is done by the lambda passed to TDataFrame in the backend. - Apply clang-format. For the non supported data types, I think we should error out gracefully, but I let @etejedor comment. For the common type: can we use http://en.cppreference.com/w/cpp/types/common_type ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1856:444,performance,memor,memory,444,"Hi @stwunsch , congrats! Very nice - and delivered extremely quickly: it was not obvious. Let's start from the points you mention as ""todos"" - I would order them as follows in terms of priority:. - More tests? Corner-cases missed? - These tests could also foresee error cases. - More error-handling? - What about not supported datatypes? Currently implemented for float, double, int, unsigned int, long, unsigned long. This is dependent on the memory adption feature of #1777 for std.vector. - Infere the final datatype of the numpy array in a clever way (currently double is the default). Implicit type conversion is done by the lambda passed to TDataFrame in the backend. - Apply clang-format. For the non supported data types, I think we should error out gracefully, but I let @etejedor comment. For the common type: can we use http://en.cppreference.com/w/cpp/types/common_type ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1856:748,performance,error,error,748,"Hi @stwunsch , congrats! Very nice - and delivered extremely quickly: it was not obvious. Let's start from the points you mention as ""todos"" - I would order them as follows in terms of priority:. - More tests? Corner-cases missed? - These tests could also foresee error cases. - More error-handling? - What about not supported datatypes? Currently implemented for float, double, int, unsigned int, long, unsigned long. This is dependent on the memory adption feature of #1777 for std.vector. - Infere the final datatype of the numpy array in a clever way (currently double is the default). Implicit type conversion is done by the lambda passed to TDataFrame in the backend. - Apply clang-format. For the non supported data types, I think we should error out gracefully, but I let @etejedor comment. For the common type: can we use http://en.cppreference.com/w/cpp/types/common_type ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1856:203,safety,test,tests,203,"Hi @stwunsch , congrats! Very nice - and delivered extremely quickly: it was not obvious. Let's start from the points you mention as ""todos"" - I would order them as follows in terms of priority:. - More tests? Corner-cases missed? - These tests could also foresee error cases. - More error-handling? - What about not supported datatypes? Currently implemented for float, double, int, unsigned int, long, unsigned long. This is dependent on the memory adption feature of #1777 for std.vector. - Infere the final datatype of the numpy array in a clever way (currently double is the default). Implicit type conversion is done by the lambda passed to TDataFrame in the backend. - Apply clang-format. For the non supported data types, I think we should error out gracefully, but I let @etejedor comment. For the common type: can we use http://en.cppreference.com/w/cpp/types/common_type ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1856:239,safety,test,tests,239,"Hi @stwunsch , congrats! Very nice - and delivered extremely quickly: it was not obvious. Let's start from the points you mention as ""todos"" - I would order them as follows in terms of priority:. - More tests? Corner-cases missed? - These tests could also foresee error cases. - More error-handling? - What about not supported datatypes? Currently implemented for float, double, int, unsigned int, long, unsigned long. This is dependent on the memory adption feature of #1777 for std.vector. - Infere the final datatype of the numpy array in a clever way (currently double is the default). Implicit type conversion is done by the lambda passed to TDataFrame in the backend. - Apply clang-format. For the non supported data types, I think we should error out gracefully, but I let @etejedor comment. For the common type: can we use http://en.cppreference.com/w/cpp/types/common_type ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1856:264,safety,error,error,264,"Hi @stwunsch , congrats! Very nice - and delivered extremely quickly: it was not obvious. Let's start from the points you mention as ""todos"" - I would order them as follows in terms of priority:. - More tests? Corner-cases missed? - These tests could also foresee error cases. - More error-handling? - What about not supported datatypes? Currently implemented for float, double, int, unsigned int, long, unsigned long. This is dependent on the memory adption feature of #1777 for std.vector. - Infere the final datatype of the numpy array in a clever way (currently double is the default). Implicit type conversion is done by the lambda passed to TDataFrame in the backend. - Apply clang-format. For the non supported data types, I think we should error out gracefully, but I let @etejedor comment. For the common type: can we use http://en.cppreference.com/w/cpp/types/common_type ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1856:284,safety,error,error-handling,284,"Hi @stwunsch , congrats! Very nice - and delivered extremely quickly: it was not obvious. Let's start from the points you mention as ""todos"" - I would order them as follows in terms of priority:. - More tests? Corner-cases missed? - These tests could also foresee error cases. - More error-handling? - What about not supported datatypes? Currently implemented for float, double, int, unsigned int, long, unsigned long. This is dependent on the memory adption feature of #1777 for std.vector. - Infere the final datatype of the numpy array in a clever way (currently double is the default). Implicit type conversion is done by the lambda passed to TDataFrame in the backend. - Apply clang-format. For the non supported data types, I think we should error out gracefully, but I let @etejedor comment. For the common type: can we use http://en.cppreference.com/w/cpp/types/common_type ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1856:427,safety,depend,dependent,427,"Hi @stwunsch , congrats! Very nice - and delivered extremely quickly: it was not obvious. Let's start from the points you mention as ""todos"" - I would order them as follows in terms of priority:. - More tests? Corner-cases missed? - These tests could also foresee error cases. - More error-handling? - What about not supported datatypes? Currently implemented for float, double, int, unsigned int, long, unsigned long. This is dependent on the memory adption feature of #1777 for std.vector. - Infere the final datatype of the numpy array in a clever way (currently double is the default). Implicit type conversion is done by the lambda passed to TDataFrame in the backend. - Apply clang-format. For the non supported data types, I think we should error out gracefully, but I let @etejedor comment. For the common type: can we use http://en.cppreference.com/w/cpp/types/common_type ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1856:748,safety,error,error,748,"Hi @stwunsch , congrats! Very nice - and delivered extremely quickly: it was not obvious. Let's start from the points you mention as ""todos"" - I would order them as follows in terms of priority:. - More tests? Corner-cases missed? - These tests could also foresee error cases. - More error-handling? - What about not supported datatypes? Currently implemented for float, double, int, unsigned int, long, unsigned long. This is dependent on the memory adption feature of #1777 for std.vector. - Infere the final datatype of the numpy array in a clever way (currently double is the default). Implicit type conversion is done by the lambda passed to TDataFrame in the backend. - Apply clang-format. For the non supported data types, I think we should error out gracefully, but I let @etejedor comment. For the common type: can we use http://en.cppreference.com/w/cpp/types/common_type ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1856:203,testability,test,tests,203,"Hi @stwunsch , congrats! Very nice - and delivered extremely quickly: it was not obvious. Let's start from the points you mention as ""todos"" - I would order them as follows in terms of priority:. - More tests? Corner-cases missed? - These tests could also foresee error cases. - More error-handling? - What about not supported datatypes? Currently implemented for float, double, int, unsigned int, long, unsigned long. This is dependent on the memory adption feature of #1777 for std.vector. - Infere the final datatype of the numpy array in a clever way (currently double is the default). Implicit type conversion is done by the lambda passed to TDataFrame in the backend. - Apply clang-format. For the non supported data types, I think we should error out gracefully, but I let @etejedor comment. For the common type: can we use http://en.cppreference.com/w/cpp/types/common_type ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1856:239,testability,test,tests,239,"Hi @stwunsch , congrats! Very nice - and delivered extremely quickly: it was not obvious. Let's start from the points you mention as ""todos"" - I would order them as follows in terms of priority:. - More tests? Corner-cases missed? - These tests could also foresee error cases. - More error-handling? - What about not supported datatypes? Currently implemented for float, double, int, unsigned int, long, unsigned long. This is dependent on the memory adption feature of #1777 for std.vector. - Infere the final datatype of the numpy array in a clever way (currently double is the default). Implicit type conversion is done by the lambda passed to TDataFrame in the backend. - Apply clang-format. For the non supported data types, I think we should error out gracefully, but I let @etejedor comment. For the common type: can we use http://en.cppreference.com/w/cpp/types/common_type ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1856:427,testability,depend,dependent,427,"Hi @stwunsch , congrats! Very nice - and delivered extremely quickly: it was not obvious. Let's start from the points you mention as ""todos"" - I would order them as follows in terms of priority:. - More tests? Corner-cases missed? - These tests could also foresee error cases. - More error-handling? - What about not supported datatypes? Currently implemented for float, double, int, unsigned int, long, unsigned long. This is dependent on the memory adption feature of #1777 for std.vector. - Infere the final datatype of the numpy array in a clever way (currently double is the default). Implicit type conversion is done by the lambda passed to TDataFrame in the backend. - Apply clang-format. For the non supported data types, I think we should error out gracefully, but I let @etejedor comment. For the common type: can we use http://en.cppreference.com/w/cpp/types/common_type ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1856:264,usability,error,error,264,"Hi @stwunsch , congrats! Very nice - and delivered extremely quickly: it was not obvious. Let's start from the points you mention as ""todos"" - I would order them as follows in terms of priority:. - More tests? Corner-cases missed? - These tests could also foresee error cases. - More error-handling? - What about not supported datatypes? Currently implemented for float, double, int, unsigned int, long, unsigned long. This is dependent on the memory adption feature of #1777 for std.vector. - Infere the final datatype of the numpy array in a clever way (currently double is the default). Implicit type conversion is done by the lambda passed to TDataFrame in the backend. - Apply clang-format. For the non supported data types, I think we should error out gracefully, but I let @etejedor comment. For the common type: can we use http://en.cppreference.com/w/cpp/types/common_type ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1856:284,usability,error,error-handling,284,"Hi @stwunsch , congrats! Very nice - and delivered extremely quickly: it was not obvious. Let's start from the points you mention as ""todos"" - I would order them as follows in terms of priority:. - More tests? Corner-cases missed? - These tests could also foresee error cases. - More error-handling? - What about not supported datatypes? Currently implemented for float, double, int, unsigned int, long, unsigned long. This is dependent on the memory adption feature of #1777 for std.vector. - Infere the final datatype of the numpy array in a clever way (currently double is the default). Implicit type conversion is done by the lambda passed to TDataFrame in the backend. - Apply clang-format. For the non supported data types, I think we should error out gracefully, but I let @etejedor comment. For the common type: can we use http://en.cppreference.com/w/cpp/types/common_type ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1856:317,usability,support,supported,317,"Hi @stwunsch , congrats! Very nice - and delivered extremely quickly: it was not obvious. Let's start from the points you mention as ""todos"" - I would order them as follows in terms of priority:. - More tests? Corner-cases missed? - These tests could also foresee error cases. - More error-handling? - What about not supported datatypes? Currently implemented for float, double, int, unsigned int, long, unsigned long. This is dependent on the memory adption feature of #1777 for std.vector. - Infere the final datatype of the numpy array in a clever way (currently double is the default). Implicit type conversion is done by the lambda passed to TDataFrame in the backend. - Apply clang-format. For the non supported data types, I think we should error out gracefully, but I let @etejedor comment. For the common type: can we use http://en.cppreference.com/w/cpp/types/common_type ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1856:444,usability,memor,memory,444,"Hi @stwunsch , congrats! Very nice - and delivered extremely quickly: it was not obvious. Let's start from the points you mention as ""todos"" - I would order them as follows in terms of priority:. - More tests? Corner-cases missed? - These tests could also foresee error cases. - More error-handling? - What about not supported datatypes? Currently implemented for float, double, int, unsigned int, long, unsigned long. This is dependent on the memory adption feature of #1777 for std.vector. - Infere the final datatype of the numpy array in a clever way (currently double is the default). Implicit type conversion is done by the lambda passed to TDataFrame in the backend. - Apply clang-format. For the non supported data types, I think we should error out gracefully, but I let @etejedor comment. For the common type: can we use http://en.cppreference.com/w/cpp/types/common_type ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1856:708,usability,support,supported,708,"Hi @stwunsch , congrats! Very nice - and delivered extremely quickly: it was not obvious. Let's start from the points you mention as ""todos"" - I would order them as follows in terms of priority:. - More tests? Corner-cases missed? - These tests could also foresee error cases. - More error-handling? - What about not supported datatypes? Currently implemented for float, double, int, unsigned int, long, unsigned long. This is dependent on the memory adption feature of #1777 for std.vector. - Infere the final datatype of the numpy array in a clever way (currently double is the default). Implicit type conversion is done by the lambda passed to TDataFrame in the backend. - Apply clang-format. For the non supported data types, I think we should error out gracefully, but I let @etejedor comment. For the common type: can we use http://en.cppreference.com/w/cpp/types/common_type ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1856:748,usability,error,error,748,"Hi @stwunsch , congrats! Very nice - and delivered extremely quickly: it was not obvious. Let's start from the points you mention as ""todos"" - I would order them as follows in terms of priority:. - More tests? Corner-cases missed? - These tests could also foresee error cases. - More error-handling? - What about not supported datatypes? Currently implemented for float, double, int, unsigned int, long, unsigned long. This is dependent on the memory adption feature of #1777 for std.vector. - Infere the final datatype of the numpy array in a clever way (currently double is the default). Implicit type conversion is done by the lambda passed to TDataFrame in the backend. - Apply clang-format. For the non supported data types, I think we should error out gracefully, but I let @etejedor comment. For the common type: can we use http://en.cppreference.com/w/cpp/types/common_type ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1856:134,testability,simpl,simple,134,"Just to summarise @stwunsch , I think the only action remaining is to iron out the type of the return vector, either in C++ or with a simple promotion mechanism implemented in python.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1856:134,usability,simpl,simple,134,"Just to summarise @stwunsch , I think the only action remaining is to iron out the type of the return vector, either in C++ or with a simple promotion mechanism implemented in python.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1856:85,availability,down,down-side,85,@etejedor @dpiparo I think that I've addressed all the point in the newest commit. A down-side is the quite lengthy implementation for finding the common data-type of the output array. Any opinions on that?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1856:16,interoperability,convers,conversion,16,"Fixed data-type conversion for corner-case `int, unsigned long -> long`. Check the test case `test_dtype_conversion`!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1856:83,safety,test,test,83,"Fixed data-type conversion for corner-case `int, unsigned long -> long`. Check the test case `test_dtype_conversion`!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1856:83,testability,test,test,83,"Fixed data-type conversion for corner-case `int, unsigned long -> long`. Check the test case `test_dtype_conversion`!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1856
https://github.com/root-project/root/pull/1857:433,availability,error,error,433,"Hi @bluehood , `v` should not be added to the list, only `v.a` and `v.b`. I just tried myself with master and indeed the list does not contain `v`. This works:. ```cpp. auto count = tdf.Define(""a"", ""v.a"").Filter(""a > 0.5"").Count();. std::cout << *count << std::endl;. ```. and the branch is generated with:. ```cpp. struct TwoInts {. int a, b;. };. ... TwoInts ti{1, 2};. t.Branch(""v"", &ti, ""a/I:b/I"");. ```. How did you get to this error?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1857
https://github.com/root-project/root/pull/1857:135,deployability,contain,contain,135,"Hi @bluehood , `v` should not be added to the list, only `v.a` and `v.b`. I just tried myself with master and indeed the list does not contain `v`. This works:. ```cpp. auto count = tdf.Define(""a"", ""v.a"").Filter(""a > 0.5"").Count();. std::cout << *count << std::endl;. ```. and the branch is generated with:. ```cpp. struct TwoInts {. int a, b;. };. ... TwoInts ti{1, 2};. t.Branch(""v"", &ti, ""a/I:b/I"");. ```. How did you get to this error?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1857
https://github.com/root-project/root/pull/1857:205,integrability,Filter,Filter,205,"Hi @bluehood , `v` should not be added to the list, only `v.a` and `v.b`. I just tried myself with master and indeed the list does not contain `v`. This works:. ```cpp. auto count = tdf.Define(""a"", ""v.a"").Filter(""a > 0.5"").Count();. std::cout << *count << std::endl;. ```. and the branch is generated with:. ```cpp. struct TwoInts {. int a, b;. };. ... TwoInts ti{1, 2};. t.Branch(""v"", &ti, ""a/I:b/I"");. ```. How did you get to this error?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1857
https://github.com/root-project/root/pull/1857:433,performance,error,error,433,"Hi @bluehood , `v` should not be added to the list, only `v.a` and `v.b`. I just tried myself with master and indeed the list does not contain `v`. This works:. ```cpp. auto count = tdf.Define(""a"", ""v.a"").Filter(""a > 0.5"").Count();. std::cout << *count << std::endl;. ```. and the branch is generated with:. ```cpp. struct TwoInts {. int a, b;. };. ... TwoInts ti{1, 2};. t.Branch(""v"", &ti, ""a/I:b/I"");. ```. How did you get to this error?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1857
https://github.com/root-project/root/pull/1857:126,reliability,doe,does,126,"Hi @bluehood , `v` should not be added to the list, only `v.a` and `v.b`. I just tried myself with master and indeed the list does not contain `v`. This works:. ```cpp. auto count = tdf.Define(""a"", ""v.a"").Filter(""a > 0.5"").Count();. std::cout << *count << std::endl;. ```. and the branch is generated with:. ```cpp. struct TwoInts {. int a, b;. };. ... TwoInts ti{1, 2};. t.Branch(""v"", &ti, ""a/I:b/I"");. ```. How did you get to this error?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1857
https://github.com/root-project/root/pull/1857:433,safety,error,error,433,"Hi @bluehood , `v` should not be added to the list, only `v.a` and `v.b`. I just tried myself with master and indeed the list does not contain `v`. This works:. ```cpp. auto count = tdf.Define(""a"", ""v.a"").Filter(""a > 0.5"").Count();. std::cout << *count << std::endl;. ```. and the branch is generated with:. ```cpp. struct TwoInts {. int a, b;. };. ... TwoInts ti{1, 2};. t.Branch(""v"", &ti, ""a/I:b/I"");. ```. How did you get to this error?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1857
https://github.com/root-project/root/pull/1857:433,usability,error,error,433,"Hi @bluehood , `v` should not be added to the list, only `v.a` and `v.b`. I just tried myself with master and indeed the list does not contain `v`. This works:. ```cpp. auto count = tdf.Define(""a"", ""v.a"").Filter(""a > 0.5"").Count();. std::cout << *count << std::endl;. ```. and the branch is generated with:. ```cpp. struct TwoInts {. int a, b;. };. ... TwoInts ti{1, 2};. t.Branch(""v"", &ti, ""a/I:b/I"");. ```. How did you get to this error?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1857
https://github.com/root-project/root/pull/1857:601,security,sign,signal,601,"@etejedor sorry, mine was not a good example. apparently this only happens when the struct has a single data member:. ```c++. #include <ROOT/TDataFrame.hxx>. struct S {. int a;. };. int main(). {. TTree t(""t"", ""t"");. S s{42};. t.Branch(""s"", &s, ""a/I"");. t.Fill();. t.ResetBranchAddresses();. ROOT::Experimental::TDataFrame d(t);. auto dot = d.Define(""res1"", ""s.a"").Min<int>(""res1"");. R__ASSERT(*dot == 42);. return 0;. }. ```. yields. ```. terminate called after throwing an instance of 'std::runtime_error'. what(): Column ""s"" is not in a file and has not been defined. fish: ./repro terminated by signal SIGABRT (Abort). ```. because `s` is matched instead of `s.a`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1857
https://github.com/root-project/root/pull/1857:135,energy efficiency,green,green,135,"Alright, issue was cleared by @etejedor and I was able to put in a test that works around it. I think this can be merged if jenkins is green.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1857
https://github.com/root-project/root/pull/1857:67,safety,test,test,67,"Alright, issue was cleared by @etejedor and I was able to put in a test that works around it. I think this can be merged if jenkins is green.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1857
https://github.com/root-project/root/pull/1857:67,testability,test,test,67,"Alright, issue was cleared by @etejedor and I was able to put in a test that works around it. I think this can be merged if jenkins is green.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1857
https://github.com/root-project/root/pull/1857:19,usability,clear,cleared,19,"Alright, issue was cleared by @etejedor and I was able to put in a test that works around it. I think this can be merged if jenkins is green.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1857
https://github.com/root-project/root/pull/1858:61,deployability,build,builds,61,"Let's merge this as soon as we get the confirmation from the builds, @dpiparo anything to add?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1858
https://github.com/root-project/root/pull/1858:39,usability,confirm,confirmation,39,"Let's merge this as soon as we get the confirmation from the builds, @dpiparo anything to add?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1858
https://github.com/root-project/root/pull/1861:11,deployability,build,build,11,@phsft-bot build just on slc6/clang_gcc62 with flags -Dcxxmodules=On -Druntime_cxxmodules=On -Dctest_test_exclude_none=on,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1861
https://github.com/root-project/root/pull/1861:117,availability,failur,failures,117,Thanks you for providing the patch. The proposed change looks OK to me (removal of those two header files). The test failures do not seem related to this patch. I'll make a few additional cross checks and then I'll merge.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1861
https://github.com/root-project/root/pull/1861:29,deployability,patch,patch,29,Thanks you for providing the patch. The proposed change looks OK to me (removal of those two header files). The test failures do not seem related to this patch. I'll make a few additional cross checks and then I'll merge.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1861
https://github.com/root-project/root/pull/1861:117,deployability,fail,failures,117,Thanks you for providing the patch. The proposed change looks OK to me (removal of those two header files). The test failures do not seem related to this patch. I'll make a few additional cross checks and then I'll merge.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1861
https://github.com/root-project/root/pull/1861:154,deployability,patch,patch,154,Thanks you for providing the patch. The proposed change looks OK to me (removal of those two header files). The test failures do not seem related to this patch. I'll make a few additional cross checks and then I'll merge.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1861
https://github.com/root-project/root/pull/1861:117,performance,failur,failures,117,Thanks you for providing the patch. The proposed change looks OK to me (removal of those two header files). The test failures do not seem related to this patch. I'll make a few additional cross checks and then I'll merge.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1861
https://github.com/root-project/root/pull/1861:117,reliability,fail,failures,117,Thanks you for providing the patch. The proposed change looks OK to me (removal of those two header files). The test failures do not seem related to this patch. I'll make a few additional cross checks and then I'll merge.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1861
https://github.com/root-project/root/pull/1861:29,safety,patch,patch,29,Thanks you for providing the patch. The proposed change looks OK to me (removal of those two header files). The test failures do not seem related to this patch. I'll make a few additional cross checks and then I'll merge.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1861
https://github.com/root-project/root/pull/1861:112,safety,test,test,112,Thanks you for providing the patch. The proposed change looks OK to me (removal of those two header files). The test failures do not seem related to this patch. I'll make a few additional cross checks and then I'll merge.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1861
https://github.com/root-project/root/pull/1861:154,safety,patch,patch,154,Thanks you for providing the patch. The proposed change looks OK to me (removal of those two header files). The test failures do not seem related to this patch. I'll make a few additional cross checks and then I'll merge.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1861
https://github.com/root-project/root/pull/1861:29,security,patch,patch,29,Thanks you for providing the patch. The proposed change looks OK to me (removal of those two header files). The test failures do not seem related to this patch. I'll make a few additional cross checks and then I'll merge.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1861
https://github.com/root-project/root/pull/1861:154,security,patch,patch,154,Thanks you for providing the patch. The proposed change looks OK to me (removal of those two header files). The test failures do not seem related to this patch. I'll make a few additional cross checks and then I'll merge.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1861
https://github.com/root-project/root/pull/1861:112,testability,test,test,112,Thanks you for providing the patch. The proposed change looks OK to me (removal of those two header files). The test failures do not seem related to this patch. I'll make a few additional cross checks and then I'll merge.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1861
https://github.com/root-project/root/pull/1861:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1861
https://github.com/root-project/root/pull/1863:42,deployability,build,builds,42,"@bluehood test added , let's wait for the builds and merge",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1863
https://github.com/root-project/root/pull/1863:10,safety,test,test,10,"@bluehood test added , let's wait for the builds and merge",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1863
https://github.com/root-project/root/pull/1863:10,testability,test,test,10,"@bluehood test added , let's wait for the builds and merge",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1863
https://github.com/root-project/root/pull/1865:11,deployability,build,build,11,@phsft-bot build with flags -Dcxx14=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1865
https://github.com/root-project/root/pull/1865:11,deployability,build,build,11,@phsft-bot build with flags -Dcxx14=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1865
https://github.com/root-project/root/pull/1865:153,safety,avoid,avoid,153,@couet It looks like you are using `git merge` rather than `git rebase`. Could you please try `git rebase origin/master array_view-to-span`? That should avoid the merging issues.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1865
https://github.com/root-project/root/pull/1866:0,deployability,Fail,Failed,0,Failed to post tests to CDash only.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:0,reliability,Fail,Failed,0,Failed to post tests to CDash only.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:15,safety,test,tests,15,Failed to post tests to CDash only.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:15,testability,test,tests,15,Failed to post tests to CDash only.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:80,availability,operat,operation,80,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:361,availability,operat,operation,361,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:518,availability,operat,operation,518,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:640,availability,operat,operation,640,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:796,availability,operat,operation,796,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:876,availability,unavail,unavailable,876,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:996,availability,operat,operations,996,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:1170,availability,operat,operations,1170,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:61,deployability,Updat,Update,61,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:737,deployability,updat,updated,737,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:860,deployability,modul,module,860,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:897,deployability,modul,modules,897,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:950,deployability,modul,modules,950,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:1425,deployability,API,API,1425,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:983,integrability,queue,queued,983,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:1357,integrability,interfac,interface,1357,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:1425,integrability,API,API,1425,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:1357,interoperability,interfac,interface,1357,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:1425,interoperability,API,API,1425,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:860,modifiability,modul,module,860,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:897,modifiability,modul,modules,897,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:950,modifiability,modul,modules,950,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:1357,modifiability,interfac,interface,1357,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:983,performance,queue,queued,983,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:1228,performance,lock,lock,1228,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:1345,performance,Concurren,Concurrency,1345,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:61,safety,Updat,Update,61,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:204,safety,avoid,avoid,204,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:339,safety,detect,detect,339,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:653,safety,compl,completed,653,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:737,safety,updat,updated,737,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:860,safety,modul,module,860,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:897,safety,modul,modules,897,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:950,safety,modul,modules,950,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:61,security,Updat,Update,61,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:339,security,detect,detect,339,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:653,security,compl,completed,653,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:737,security,updat,updated,737,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:1228,security,lock,lock,1228,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1866:1433,usability,close,close-out,1433,"For the record, one such discussion yield the following:. a) Update the merging operation (if not already done) to make sure that the output file is kept open during the length of the process (this is to avoid re-reading the output TTree from the output file) and the TTree is written to the output file only once at the end. b) CMSSW can detect when a 'merge' operation was requested by checking the return value of Fill and the number of entry: if Fill succeed and the TTree has zero entries afterwards then a merge operation was requested (the TTree was reset). c) We need to call a callback (std::function) provided at CMS when a merge operation is completed (i.e all its baskets are on the output file and the output TTree has been updated accordingly). d) When CMSSW noticed that a 'merge' operation has been requested, it will shutdown the CMSSW output module (make it unavailable to other modules). This guarantees that if CMSSW has N output modules, there will be at most N queued merge operations and while the merge are going on only 1 thread is used for it (and the other N-1 can be used for other CMSSW work). e) We need to implement a queuing of the merge operations tasks without relying on the ROOT global write lock. See for example the way something similar is done in CSMSW: https://github.com/cms-sw/cmssw/blob/master/FWCore/Concurrency/interface/SerialTaskQueue.h. f) CMSSW need to call a 'finalization' API to 'close-out' the output file (without this call the output file is useless).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1866
https://github.com/root-project/root/pull/1869:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1869
https://github.com/root-project/root/pull/1869:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1869
https://github.com/root-project/root/pull/1870:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1870
https://github.com/root-project/root/pull/1871:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1871
https://github.com/root-project/root/pull/1871:43,deployability,build,builds,43,"I believe this one can be merged after the builds. The only pending change would be to move the logic for the array interface configuration to C++, if possible. A source to check is [this](https://stackoverflow.com/questions/10161609/class-property-using-python-c-api).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1871
https://github.com/root-project/root/pull/1871:96,deployability,log,logic,96,"I believe this one can be merged after the builds. The only pending change would be to move the logic for the array interface configuration to C++, if possible. A source to check is [this](https://stackoverflow.com/questions/10161609/class-property-using-python-c-api).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1871
https://github.com/root-project/root/pull/1871:126,deployability,configurat,configuration,126,"I believe this one can be merged after the builds. The only pending change would be to move the logic for the array interface configuration to C++, if possible. A source to check is [this](https://stackoverflow.com/questions/10161609/class-property-using-python-c-api).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1871
https://github.com/root-project/root/pull/1871:197,deployability,stack,stackoverflow,197,"I believe this one can be merged after the builds. The only pending change would be to move the logic for the array interface configuration to C++, if possible. A source to check is [this](https://stackoverflow.com/questions/10161609/class-property-using-python-c-api).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1871
https://github.com/root-project/root/pull/1871:264,deployability,api,api,264,"I believe this one can be merged after the builds. The only pending change would be to move the logic for the array interface configuration to C++, if possible. A source to check is [this](https://stackoverflow.com/questions/10161609/class-property-using-python-c-api).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1871
https://github.com/root-project/root/pull/1871:116,integrability,interfac,interface,116,"I believe this one can be merged after the builds. The only pending change would be to move the logic for the array interface configuration to C++, if possible. A source to check is [this](https://stackoverflow.com/questions/10161609/class-property-using-python-c-api).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1871
https://github.com/root-project/root/pull/1871:126,integrability,configur,configuration,126,"I believe this one can be merged after the builds. The only pending change would be to move the logic for the array interface configuration to C++, if possible. A source to check is [this](https://stackoverflow.com/questions/10161609/class-property-using-python-c-api).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1871
https://github.com/root-project/root/pull/1871:264,integrability,api,api,264,"I believe this one can be merged after the builds. The only pending change would be to move the logic for the array interface configuration to C++, if possible. A source to check is [this](https://stackoverflow.com/questions/10161609/class-property-using-python-c-api).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1871
https://github.com/root-project/root/pull/1871:116,interoperability,interfac,interface,116,"I believe this one can be merged after the builds. The only pending change would be to move the logic for the array interface configuration to C++, if possible. A source to check is [this](https://stackoverflow.com/questions/10161609/class-property-using-python-c-api).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1871
https://github.com/root-project/root/pull/1871:264,interoperability,api,api,264,"I believe this one can be merged after the builds. The only pending change would be to move the logic for the array interface configuration to C++, if possible. A source to check is [this](https://stackoverflow.com/questions/10161609/class-property-using-python-c-api).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1871
https://github.com/root-project/root/pull/1871:116,modifiability,interfac,interface,116,"I believe this one can be merged after the builds. The only pending change would be to move the logic for the array interface configuration to C++, if possible. A source to check is [this](https://stackoverflow.com/questions/10161609/class-property-using-python-c-api).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1871
https://github.com/root-project/root/pull/1871:126,modifiability,configur,configuration,126,"I believe this one can be merged after the builds. The only pending change would be to move the logic for the array interface configuration to C++, if possible. A source to check is [this](https://stackoverflow.com/questions/10161609/class-property-using-python-c-api).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1871
https://github.com/root-project/root/pull/1871:96,safety,log,logic,96,"I believe this one can be merged after the builds. The only pending change would be to move the logic for the array interface configuration to C++, if possible. A source to check is [this](https://stackoverflow.com/questions/10161609/class-property-using-python-c-api).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1871
https://github.com/root-project/root/pull/1871:96,security,log,logic,96,"I believe this one can be merged after the builds. The only pending change would be to move the logic for the array interface configuration to C++, if possible. A source to check is [this](https://stackoverflow.com/questions/10161609/class-property-using-python-c-api).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1871
https://github.com/root-project/root/pull/1871:126,security,configur,configuration,126,"I believe this one can be merged after the builds. The only pending change would be to move the logic for the array interface configuration to C++, if possible. A source to check is [this](https://stackoverflow.com/questions/10161609/class-property-using-python-c-api).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1871
https://github.com/root-project/root/pull/1871:96,testability,log,logic,96,"I believe this one can be merged after the builds. The only pending change would be to move the logic for the array interface configuration to C++, if possible. A source to check is [this](https://stackoverflow.com/questions/10161609/class-property-using-python-c-api).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1871
https://github.com/root-project/root/pull/1872:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:29,security,sign,signature,29,"The method has now following signature: `TTree.AsMatrix(columns=None, exclude=None, return_labels=False)`. `columns`: Can be a list with branch names, for `None` is `tree.GetListOfBranches()` taken. `exclude` Can be a list with branch names, simply removed from `columns`. `return_labels`: If true a tuple with `(column_names, numpy_array)` is returned, otherwise only the array. The `return_labels` feature is to be discussed.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:242,testability,simpl,simply,242,"The method has now following signature: `TTree.AsMatrix(columns=None, exclude=None, return_labels=False)`. `columns`: Can be a list with branch names, for `None` is `tree.GetListOfBranches()` taken. `exclude` Can be a list with branch names, simply removed from `columns`. `return_labels`: If true a tuple with `(column_names, numpy_array)` is returned, otherwise only the array. The `return_labels` feature is to be discussed.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:242,usability,simpl,simply,242,"The method has now following signature: `TTree.AsMatrix(columns=None, exclude=None, return_labels=False)`. `columns`: Can be a list with branch names, for `None` is `tree.GetListOfBranches()` taken. `exclude` Can be a list with branch names, simply removed from `columns`. `return_labels`: If true a tuple with `(column_names, numpy_array)` is returned, otherwise only the array. The `return_labels` feature is to be discussed.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:0,usability,Person,Personally,0,"Personally I like `return_labels`, very numpy-like :smiley:",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:24,usability,user,users,24,It's true that it keeps users away from getting the list of branches...,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:502,integrability,wrap,wrap,502,"Ah, too late I was just looking at this request and wanted to comment on the `return_labels`. If you want the output Numpy array to carry labels, you could make it a [record array](https://docs.scipy.org/doc/numpy-1.14.0/user/basics.rec.html). That way, the user wouldn't have to be involved in asking for labels, unpacking a tuple, or matching labels in a list with arrays in another list. Also, the `pandas.DataFrame` constructor can take a record array as a single argument, making it very easy to wrap the AsMatrix output, with column labels, in Pandas.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:222,usability,user,user,222,"Ah, too late I was just looking at this request and wanted to comment on the `return_labels`. If you want the output Numpy array to carry labels, you could make it a [record array](https://docs.scipy.org/doc/numpy-1.14.0/user/basics.rec.html). That way, the user wouldn't have to be involved in asking for labels, unpacking a tuple, or matching labels in a list with arrays in another list. Also, the `pandas.DataFrame` constructor can take a record array as a single argument, making it very easy to wrap the AsMatrix output, with column labels, in Pandas.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:259,usability,user,user,259,"Ah, too late I was just looking at this request and wanted to comment on the `return_labels`. If you want the output Numpy array to carry labels, you could make it a [record array](https://docs.scipy.org/doc/numpy-1.14.0/user/basics.rec.html). That way, the user wouldn't have to be involved in asking for labels, unpacking a tuple, or matching labels in a list with arrays in another list. Also, the `pandas.DataFrame` constructor can take a record array as a single argument, making it very easy to wrap the AsMatrix output, with column labels, in Pandas.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:72,performance,memor,memory,72,"hi @jpivarski , would the whole matrix of values still be contiguous in memory in a record array? if yes this is indeed interesting :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:72,usability,memor,memory,72,"hi @jpivarski , would the whole matrix of values still be contiguous in memory in a record array? if yes this is indeed interesting :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:44,deployability,API,API,44,"Here's the code to do this with the current API:. ```python. data, columns = tree.AsMatrix(return_labels=True). df = pandas.DataFrame(data=data, columns=columns). ```. You barely can do this more convenient! The print output is this (see `root/tutorials/pyroot/pyroot002_TTreeAsMatrix.py`):. ```. >>> print(df). x y. 0 0.0 0.0. 1 1.0 -1.0. 2 2.0 -2.0. 3 3.0 -3.0. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:36,energy efficiency,current,current,36,"Here's the code to do this with the current API:. ```python. data, columns = tree.AsMatrix(return_labels=True). df = pandas.DataFrame(data=data, columns=columns). ```. You barely can do this more convenient! The print output is this (see `root/tutorials/pyroot/pyroot002_TTreeAsMatrix.py`):. ```. >>> print(df). x y. 0 0.0 0.0. 1 1.0 -1.0. 2 2.0 -2.0. 3 3.0 -3.0. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:44,integrability,API,API,44,"Here's the code to do this with the current API:. ```python. data, columns = tree.AsMatrix(return_labels=True). df = pandas.DataFrame(data=data, columns=columns). ```. You barely can do this more convenient! The print output is this (see `root/tutorials/pyroot/pyroot002_TTreeAsMatrix.py`):. ```. >>> print(df). x y. 0 0.0 0.0. 1 1.0 -1.0. 2 2.0 -2.0. 3 3.0 -3.0. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:44,interoperability,API,API,44,"Here's the code to do this with the current API:. ```python. data, columns = tree.AsMatrix(return_labels=True). df = pandas.DataFrame(data=data, columns=columns). ```. You barely can do this more convenient! The print output is this (see `root/tutorials/pyroot/pyroot002_TTreeAsMatrix.py`):. ```. >>> print(df). x y. 0 0.0 0.0. 1 1.0 -1.0. 2 2.0 -2.0. 3 3.0 -3.0. ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:212,availability,operat,operating,212,"Yes. The link goes into detail, but record arrays are essentially arrays of structs contiguous in memory, rowwise across named, differently typed members. You can also specify per-member alignment, in case your operating system has weird alignment rules. The user can then refer to rows of the record array with integer slices and columns with strings in square brackets. Since the data are rectangular, these slices are accomplished through constant strides. I've often wondered what the big deal about Pandas was, since these are the features people describe as the benefits of Pandas, but they've been available in Numpy for years. I've since learned that Pandas additionally has smarter indexing than Numpy's position-based indexing, but that's not needed for something that's essentially a set, like a set of events. (Not needed until we aggregate somehow.)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:321,availability,sli,slices,321,"Yes. The link goes into detail, but record arrays are essentially arrays of structs contiguous in memory, rowwise across named, differently typed members. You can also specify per-member alignment, in case your operating system has weird alignment rules. The user can then refer to rows of the record array with integer slices and columns with strings in square brackets. Since the data are rectangular, these slices are accomplished through constant strides. I've often wondered what the big deal about Pandas was, since these are the features people describe as the benefits of Pandas, but they've been available in Numpy for years. I've since learned that Pandas additionally has smarter indexing than Numpy's position-based indexing, but that's not needed for something that's essentially a set, like a set of events. (Not needed until we aggregate somehow.)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:411,availability,sli,slices,411,"Yes. The link goes into detail, but record arrays are essentially arrays of structs contiguous in memory, rowwise across named, differently typed members. You can also specify per-member alignment, in case your operating system has weird alignment rules. The user can then refer to rows of the record array with integer slices and columns with strings in square brackets. Since the data are rectangular, these slices are accomplished through constant strides. I've often wondered what the big deal about Pandas was, since these are the features people describe as the benefits of Pandas, but they've been available in Numpy for years. I've since learned that Pandas additionally has smarter indexing than Numpy's position-based indexing, but that's not needed for something that's essentially a set, like a set of events. (Not needed until we aggregate somehow.)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:606,availability,avail,available,606,"Yes. The link goes into detail, but record arrays are essentially arrays of structs contiguous in memory, rowwise across named, differently typed members. You can also specify per-member alignment, in case your operating system has weird alignment rules. The user can then refer to rows of the record array with integer slices and columns with strings in square brackets. Since the data are rectangular, these slices are accomplished through constant strides. I've often wondered what the big deal about Pandas was, since these are the features people describe as the benefits of Pandas, but they've been available in Numpy for years. I've since learned that Pandas additionally has smarter indexing than Numpy's position-based indexing, but that's not needed for something that's essentially a set, like a set of events. (Not needed until we aggregate somehow.)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:815,integrability,event,events,815,"Yes. The link goes into detail, but record arrays are essentially arrays of structs contiguous in memory, rowwise across named, differently typed members. You can also specify per-member alignment, in case your operating system has weird alignment rules. The user can then refer to rows of the record array with integer slices and columns with strings in square brackets. Since the data are rectangular, these slices are accomplished through constant strides. I've often wondered what the big deal about Pandas was, since these are the features people describe as the benefits of Pandas, but they've been available in Numpy for years. I've since learned that Pandas additionally has smarter indexing than Numpy's position-based indexing, but that's not needed for something that's essentially a set, like a set of events. (Not needed until we aggregate somehow.)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:169,interoperability,specif,specify,169,"Yes. The link goes into detail, but record arrays are essentially arrays of structs contiguous in memory, rowwise across named, differently typed members. You can also specify per-member alignment, in case your operating system has weird alignment rules. The user can then refer to rows of the record array with integer slices and columns with strings in square brackets. Since the data are rectangular, these slices are accomplished through constant strides. I've often wondered what the big deal about Pandas was, since these are the features people describe as the benefits of Pandas, but they've been available in Numpy for years. I've since learned that Pandas additionally has smarter indexing than Numpy's position-based indexing, but that's not needed for something that's essentially a set, like a set of events. (Not needed until we aggregate somehow.)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:99,performance,memor,memory,99,"Yes. The link goes into detail, but record arrays are essentially arrays of structs contiguous in memory, rowwise across named, differently typed members. You can also specify per-member alignment, in case your operating system has weird alignment rules. The user can then refer to rows of the record array with integer slices and columns with strings in square brackets. Since the data are rectangular, these slices are accomplished through constant strides. I've often wondered what the big deal about Pandas was, since these are the features people describe as the benefits of Pandas, but they've been available in Numpy for years. I've since learned that Pandas additionally has smarter indexing than Numpy's position-based indexing, but that's not needed for something that's essentially a set, like a set of events. (Not needed until we aggregate somehow.)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:321,reliability,sli,slices,321,"Yes. The link goes into detail, but record arrays are essentially arrays of structs contiguous in memory, rowwise across named, differently typed members. You can also specify per-member alignment, in case your operating system has weird alignment rules. The user can then refer to rows of the record array with integer slices and columns with strings in square brackets. Since the data are rectangular, these slices are accomplished through constant strides. I've often wondered what the big deal about Pandas was, since these are the features people describe as the benefits of Pandas, but they've been available in Numpy for years. I've since learned that Pandas additionally has smarter indexing than Numpy's position-based indexing, but that's not needed for something that's essentially a set, like a set of events. (Not needed until we aggregate somehow.)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:411,reliability,sli,slices,411,"Yes. The link goes into detail, but record arrays are essentially arrays of structs contiguous in memory, rowwise across named, differently typed members. You can also specify per-member alignment, in case your operating system has weird alignment rules. The user can then refer to rows of the record array with integer slices and columns with strings in square brackets. Since the data are rectangular, these slices are accomplished through constant strides. I've often wondered what the big deal about Pandas was, since these are the features people describe as the benefits of Pandas, but they've been available in Numpy for years. I've since learned that Pandas additionally has smarter indexing than Numpy's position-based indexing, but that's not needed for something that's essentially a set, like a set of events. (Not needed until we aggregate somehow.)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:606,reliability,availab,available,606,"Yes. The link goes into detail, but record arrays are essentially arrays of structs contiguous in memory, rowwise across named, differently typed members. You can also specify per-member alignment, in case your operating system has weird alignment rules. The user can then refer to rows of the record array with integer slices and columns with strings in square brackets. Since the data are rectangular, these slices are accomplished through constant strides. I've often wondered what the big deal about Pandas was, since these are the features people describe as the benefits of Pandas, but they've been available in Numpy for years. I've since learned that Pandas additionally has smarter indexing than Numpy's position-based indexing, but that's not needed for something that's essentially a set, like a set of events. (Not needed until we aggregate somehow.)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:606,safety,avail,available,606,"Yes. The link goes into detail, but record arrays are essentially arrays of structs contiguous in memory, rowwise across named, differently typed members. You can also specify per-member alignment, in case your operating system has weird alignment rules. The user can then refer to rows of the record array with integer slices and columns with strings in square brackets. Since the data are rectangular, these slices are accomplished through constant strides. I've often wondered what the big deal about Pandas was, since these are the features people describe as the benefits of Pandas, but they've been available in Numpy for years. I've since learned that Pandas additionally has smarter indexing than Numpy's position-based indexing, but that's not needed for something that's essentially a set, like a set of events. (Not needed until we aggregate somehow.)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:452,security,stride,strides,452,"Yes. The link goes into detail, but record arrays are essentially arrays of structs contiguous in memory, rowwise across named, differently typed members. You can also specify per-member alignment, in case your operating system has weird alignment rules. The user can then refer to rows of the record array with integer slices and columns with strings in square brackets. Since the data are rectangular, these slices are accomplished through constant strides. I've often wondered what the big deal about Pandas was, since these are the features people describe as the benefits of Pandas, but they've been available in Numpy for years. I've since learned that Pandas additionally has smarter indexing than Numpy's position-based indexing, but that's not needed for something that's essentially a set, like a set of events. (Not needed until we aggregate somehow.)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:606,security,availab,available,606,"Yes. The link goes into detail, but record arrays are essentially arrays of structs contiguous in memory, rowwise across named, differently typed members. You can also specify per-member alignment, in case your operating system has weird alignment rules. The user can then refer to rows of the record array with integer slices and columns with strings in square brackets. Since the data are rectangular, these slices are accomplished through constant strides. I've often wondered what the big deal about Pandas was, since these are the features people describe as the benefits of Pandas, but they've been available in Numpy for years. I've since learned that Pandas additionally has smarter indexing than Numpy's position-based indexing, but that's not needed for something that's essentially a set, like a set of events. (Not needed until we aggregate somehow.)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:99,usability,memor,memory,99,"Yes. The link goes into detail, but record arrays are essentially arrays of structs contiguous in memory, rowwise across named, differently typed members. You can also specify per-member alignment, in case your operating system has weird alignment rules. The user can then refer to rows of the record array with integer slices and columns with strings in square brackets. Since the data are rectangular, these slices are accomplished through constant strides. I've often wondered what the big deal about Pandas was, since these are the features people describe as the benefits of Pandas, but they've been available in Numpy for years. I've since learned that Pandas additionally has smarter indexing than Numpy's position-based indexing, but that's not needed for something that's essentially a set, like a set of events. (Not needed until we aggregate somehow.)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:260,usability,user,user,260,"Yes. The link goes into detail, but record arrays are essentially arrays of structs contiguous in memory, rowwise across named, differently typed members. You can also specify per-member alignment, in case your operating system has weird alignment rules. The user can then refer to rows of the record array with integer slices and columns with strings in square brackets. Since the data are rectangular, these slices are accomplished through constant strides. I've often wondered what the big deal about Pandas was, since these are the features people describe as the benefits of Pandas, but they've been available in Numpy for years. I've since learned that Pandas additionally has smarter indexing than Numpy's position-based indexing, but that's not needed for something that's essentially a set, like a set of events. (Not needed until we aggregate somehow.)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:647,usability,learn,learned,647,"Yes. The link goes into detail, but record arrays are essentially arrays of structs contiguous in memory, rowwise across named, differently typed members. You can also specify per-member alignment, in case your operating system has weird alignment rules. The user can then refer to rows of the record array with integer slices and columns with strings in square brackets. Since the data are rectangular, these slices are accomplished through constant strides. I've often wondered what the big deal about Pandas was, since these are the features people describe as the benefits of Pandas, but they've been available in Numpy for years. I've since learned that Pandas additionally has smarter indexing than Numpy's position-based indexing, but that's not needed for something that's essentially a set, like a set of events. (Not needed until we aggregate somehow.)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:731,performance,memor,memory,731,"```python. >>> import numpy. >>> import pandas. >>> array = numpy.array([(1, 1.1, ""one""), (2, 2.2, ""two""), (3, 3.3, ""three"")],. ... dtype=[(""x"", ""int32""), (""y"", ""float64""), (""z"", ""|S5"")]). >>> array. array([(1, 1.1, 'one'), (2, 2.2, 'two'), (3, 3.3, 'three')],. dtype=[('x', '<i4'), ('y', '<f8'), ('z', 'S5')]). >>> pandas.DataFrame(array). x y z. 0 1 1.1 one. 1 2 2.2 two. 2 3 3.3 three. >>> array[""x""]. array([1, 2, 3], dtype=int32). >>> array[""y""]. array([1.1, 2.2, 3.3]). >>> array[""z""]. array(['one', 'two', 'three'], dtype='|S5'). >>> array[0]. (1, 1.1, 'one'). >>> array[1]. (2, 2.2, 'two'). >>> array[2]. (3, 3.3, 'three'). ```. Addressing the question of contiguity, see where the `one`, `two`, `three` strings are in the memory dump:. ```python. >>> array.tostring(). '\x01\x00\x00\x00\x9a\x99\x99\x99\x99\x99\xf1?one\x00\x00\x02\x00\x00\x00\x9a\x99\x99\x99\x99\x99\x01@two\x00\x00\x03\x00\x00\x00ffffff\n@three'. ```. It's a row-wise block. If you don't want it to be row-wise, that's an argument against record arrays. The ""fortran order"" flag doesn't apply here: it sets the order of row vs. column for dimensions of a single-type array.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:1056,reliability,doe,doesn,1056,"```python. >>> import numpy. >>> import pandas. >>> array = numpy.array([(1, 1.1, ""one""), (2, 2.2, ""two""), (3, 3.3, ""three"")],. ... dtype=[(""x"", ""int32""), (""y"", ""float64""), (""z"", ""|S5"")]). >>> array. array([(1, 1.1, 'one'), (2, 2.2, 'two'), (3, 3.3, 'three')],. dtype=[('x', '<i4'), ('y', '<f8'), ('z', 'S5')]). >>> pandas.DataFrame(array). x y z. 0 1 1.1 one. 1 2 2.2 two. 2 3 3.3 three. >>> array[""x""]. array([1, 2, 3], dtype=int32). >>> array[""y""]. array([1.1, 2.2, 3.3]). >>> array[""z""]. array(['one', 'two', 'three'], dtype='|S5'). >>> array[0]. (1, 1.1, 'one'). >>> array[1]. (2, 2.2, 'two'). >>> array[2]. (3, 3.3, 'three'). ```. Addressing the question of contiguity, see where the `one`, `two`, `three` strings are in the memory dump:. ```python. >>> array.tostring(). '\x01\x00\x00\x00\x9a\x99\x99\x99\x99\x99\xf1?one\x00\x00\x02\x00\x00\x00\x9a\x99\x99\x99\x99\x99\x01@two\x00\x00\x03\x00\x00\x00ffffff\n@three'. ```. It's a row-wise block. If you don't want it to be row-wise, that's an argument against record arrays. The ""fortran order"" flag doesn't apply here: it sets the order of row vs. column for dimensions of a single-type array.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:731,usability,memor,memory,731,"```python. >>> import numpy. >>> import pandas. >>> array = numpy.array([(1, 1.1, ""one""), (2, 2.2, ""two""), (3, 3.3, ""three"")],. ... dtype=[(""x"", ""int32""), (""y"", ""float64""), (""z"", ""|S5"")]). >>> array. array([(1, 1.1, 'one'), (2, 2.2, 'two'), (3, 3.3, 'three')],. dtype=[('x', '<i4'), ('y', '<f8'), ('z', 'S5')]). >>> pandas.DataFrame(array). x y z. 0 1 1.1 one. 1 2 2.2 two. 2 3 3.3 three. >>> array[""x""]. array([1, 2, 3], dtype=int32). >>> array[""y""]. array([1.1, 2.2, 3.3]). >>> array[""z""]. array(['one', 'two', 'three'], dtype='|S5'). >>> array[0]. (1, 1.1, 'one'). >>> array[1]. (2, 2.2, 'two'). >>> array[2]. (3, 3.3, 'three'). ```. Addressing the question of contiguity, see where the `one`, `two`, `three` strings are in the memory dump:. ```python. >>> array.tostring(). '\x01\x00\x00\x00\x9a\x99\x99\x99\x99\x99\xf1?one\x00\x00\x02\x00\x00\x00\x9a\x99\x99\x99\x99\x99\x01@two\x00\x00\x03\x00\x00\x00ffffff\n@three'. ```. It's a row-wise block. If you don't want it to be row-wise, that's an argument against record arrays. The ""fortran order"" flag doesn't apply here: it sets the order of row vs. column for dimensions of a single-type array.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:64,deployability,observ,observation,64,"On the one hand, nice feature of numpy! You are right with your observation about numpy vs pandas ;) On the other hand, the ""normal"" user would be quite confused by the magic we would do in the back. They know what a list is and what a numpy array is, which is a happy marriage in `pandas.DataFrame(data=data, columns=columns)`. However, you are completely right that we could do this in the back without them having to notice and without breaking to ""easy to understand"" approach we implemented now. So thanks! We will have a look at this.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:346,safety,compl,completely,346,"On the one hand, nice feature of numpy! You are right with your observation about numpy vs pandas ;) On the other hand, the ""normal"" user would be quite confused by the magic we would do in the back. They know what a list is and what a numpy array is, which is a happy marriage in `pandas.DataFrame(data=data, columns=columns)`. However, you are completely right that we could do this in the back without them having to notice and without breaking to ""easy to understand"" approach we implemented now. So thanks! We will have a look at this.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:346,security,compl,completely,346,"On the one hand, nice feature of numpy! You are right with your observation about numpy vs pandas ;) On the other hand, the ""normal"" user would be quite confused by the magic we would do in the back. They know what a list is and what a numpy array is, which is a happy marriage in `pandas.DataFrame(data=data, columns=columns)`. However, you are completely right that we could do this in the back without them having to notice and without breaking to ""easy to understand"" approach we implemented now. So thanks! We will have a look at this.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:64,testability,observ,observation,64,"On the one hand, nice feature of numpy! You are right with your observation about numpy vs pandas ;) On the other hand, the ""normal"" user would be quite confused by the magic we would do in the back. They know what a list is and what a numpy array is, which is a happy marriage in `pandas.DataFrame(data=data, columns=columns)`. However, you are completely right that we could do this in the back without them having to notice and without breaking to ""easy to understand"" approach we implemented now. So thanks! We will have a look at this.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:460,testability,understand,understand,460,"On the one hand, nice feature of numpy! You are right with your observation about numpy vs pandas ;) On the other hand, the ""normal"" user would be quite confused by the magic we would do in the back. They know what a list is and what a numpy array is, which is a happy marriage in `pandas.DataFrame(data=data, columns=columns)`. However, you are completely right that we could do this in the back without them having to notice and without breaking to ""easy to understand"" approach we implemented now. So thanks! We will have a look at this.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1872:133,usability,user,user,133,"On the one hand, nice feature of numpy! You are right with your observation about numpy vs pandas ;) On the other hand, the ""normal"" user would be quite confused by the magic we would do in the back. They know what a list is and what a numpy array is, which is a happy marriage in `pandas.DataFrame(data=data, columns=columns)`. However, you are completely right that we could do this in the back without them having to notice and without breaking to ""easy to understand"" approach we implemented now. So thanks! We will have a look at this.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1872
https://github.com/root-project/root/pull/1878:11,deployability,build,build,11,@phsft-bot build with -Dveccore=ON .,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1878
https://github.com/root-project/root/pull/1878:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1878
https://github.com/root-project/root/pull/1880:33,testability,simpl,simplistic,33,Need a more involved fix than my simplistic attempt.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1880
https://github.com/root-project/root/pull/1880:33,usability,simpl,simplistic,33,Need a more involved fix than my simplistic attempt.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1880
https://github.com/root-project/root/pull/1881:63,interoperability,compatib,compatibility,63,We should keep a forwarding 'ROOT/RArrayView.hxx' for backward compatibility.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1881
https://github.com/root-project/root/pull/1881:85,deployability,updat,updated,85,projectroot.roottest.root.collection.roottest_root_collection_arrayViewBasic will be updated in a next commit,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1881
https://github.com/root-project/root/pull/1881:85,safety,updat,updated,85,projectroot.roottest.root.collection.roottest_root_collection_arrayViewBasic will be updated in a next commit,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1881
https://github.com/root-project/root/pull/1881:85,security,updat,updated,85,projectroot.roottest.root.collection.roottest_root_collection_arrayViewBasic will be updated in a next commit,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1881
https://github.com/root-project/root/pull/1882:26,safety,review,review,26,Please open a [clang phab review](https://reviews.llvm.org/) for the clang related change.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1882
https://github.com/root-project/root/pull/1882:42,safety,review,reviews,42,Please open a [clang phab review](https://reviews.llvm.org/) for the clang related change.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1882
https://github.com/root-project/root/pull/1882:26,testability,review,review,26,Please open a [clang phab review](https://reviews.llvm.org/) for the clang related change.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1882
https://github.com/root-project/root/pull/1882:42,testability,review,reviews,42,Please open a [clang phab review](https://reviews.llvm.org/) for the clang related change.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1882
https://github.com/root-project/root/pull/1882:85,safety,review,reviews,85,"Hi, thanks for comments. I changed diff a lot in the new commit but tried to address reviews.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1882
https://github.com/root-project/root/pull/1882:85,testability,review,reviews,85,"Hi, thanks for comments. I changed diff a lot in the new commit but tried to address reviews.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1882
https://github.com/root-project/root/pull/1882:58,deployability,patch,patch,58,"This should be landed with allmodules and library loading patch, closing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1882
https://github.com/root-project/root/pull/1882:50,energy efficiency,load,loading,50,"This should be landed with allmodules and library loading patch, closing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1882
https://github.com/root-project/root/pull/1882:50,performance,load,loading,50,"This should be landed with allmodules and library loading patch, closing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1882
https://github.com/root-project/root/pull/1882:58,safety,patch,patch,58,"This should be landed with allmodules and library loading patch, closing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1882
https://github.com/root-project/root/pull/1882:58,security,patch,patch,58,"This should be landed with allmodules and library loading patch, closing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1882
https://github.com/root-project/root/pull/1883:11,deployability,build,build,11,@phsft-bot build! @jasondet thanks for your fix!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1883
https://github.com/root-project/root/pull/1886:45,safety,test,tests,45,looks fine to me .. let see if it passes the tests.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1886
https://github.com/root-project/root/pull/1886:45,testability,test,tests,45,looks fine to me .. let see if it passes the tests.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1886
https://github.com/root-project/root/pull/1886:307,availability,Error,Error,307,"Master is broken after this merge. There is a header missing in git. ```. [ 65%] Built target XMLIO. gmake[2]: *** No rule to make target '/home/amadio/src/root/net/http/inc/TCivetweb.h', needed by 'net/http/G__RHTTP.cxx'. Stop. gmake[1]: *** [CMakeFiles/Makefile2:16748: net/http/CMakeFiles/RHTTP.dir/all] Error 2. gmake[1]: *** Waiting for unfinished jobs.... ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1886
https://github.com/root-project/root/pull/1886:94,interoperability,XML,XMLIO,94,"Master is broken after this merge. There is a header missing in git. ```. [ 65%] Built target XMLIO. gmake[2]: *** No rule to make target '/home/amadio/src/root/net/http/inc/TCivetweb.h', needed by 'net/http/G__RHTTP.cxx'. Stop. gmake[1]: *** [CMakeFiles/Makefile2:16748: net/http/CMakeFiles/RHTTP.dir/all] Error 2. gmake[1]: *** Waiting for unfinished jobs.... ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1886
https://github.com/root-project/root/pull/1886:307,performance,Error,Error,307,"Master is broken after this merge. There is a header missing in git. ```. [ 65%] Built target XMLIO. gmake[2]: *** No rule to make target '/home/amadio/src/root/net/http/inc/TCivetweb.h', needed by 'net/http/G__RHTTP.cxx'. Stop. gmake[1]: *** [CMakeFiles/Makefile2:16748: net/http/CMakeFiles/RHTTP.dir/all] Error 2. gmake[1]: *** Waiting for unfinished jobs.... ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1886
https://github.com/root-project/root/pull/1886:307,safety,Error,Error,307,"Master is broken after this merge. There is a header missing in git. ```. [ 65%] Built target XMLIO. gmake[2]: *** No rule to make target '/home/amadio/src/root/net/http/inc/TCivetweb.h', needed by 'net/http/G__RHTTP.cxx'. Stop. gmake[1]: *** [CMakeFiles/Makefile2:16748: net/http/CMakeFiles/RHTTP.dir/all] Error 2. gmake[1]: *** Waiting for unfinished jobs.... ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1886
https://github.com/root-project/root/pull/1886:223,usability,Stop,Stop,223,"Master is broken after this merge. There is a header missing in git. ```. [ 65%] Built target XMLIO. gmake[2]: *** No rule to make target '/home/amadio/src/root/net/http/inc/TCivetweb.h', needed by 'net/http/G__RHTTP.cxx'. Stop. gmake[1]: *** [CMakeFiles/Makefile2:16748: net/http/CMakeFiles/RHTTP.dir/all] Error 2. gmake[1]: *** Waiting for unfinished jobs.... ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1886
https://github.com/root-project/root/pull/1886:307,usability,Error,Error,307,"Master is broken after this merge. There is a header missing in git. ```. [ 65%] Built target XMLIO. gmake[2]: *** No rule to make target '/home/amadio/src/root/net/http/inc/TCivetweb.h', needed by 'net/http/G__RHTTP.cxx'. Stop. gmake[1]: *** [CMakeFiles/Makefile2:16748: net/http/CMakeFiles/RHTTP.dir/all] Error 2. gmake[1]: *** Waiting for unfinished jobs.... ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1886
https://github.com/root-project/root/pull/1886:87,deployability,build,build,87,"> Master is broken after this merge. There is a header missing in git. No, you need to build from scratch or just delete:. [shell] rm -rf net/http",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1886
https://github.com/root-project/root/pull/1886:137,deployability,build,build,137,"Ah, I re-ran CMake, but did not remove the directory... Thanks! This sort of problem will go away when we start listing all files in the build system. It's a really annoying problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1886
https://github.com/root-project/root/pull/1888:11,deployability,build,build,11,@phsft-bot build please.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1888
https://github.com/root-project/root/pull/1888:54,availability,failur,failures,54,I am rerunning the test since I do not understand the failures.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1888
https://github.com/root-project/root/pull/1888:54,deployability,fail,failures,54,I am rerunning the test since I do not understand the failures.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1888
https://github.com/root-project/root/pull/1888:54,performance,failur,failures,54,I am rerunning the test since I do not understand the failures.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1888
https://github.com/root-project/root/pull/1888:54,reliability,fail,failures,54,I am rerunning the test since I do not understand the failures.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1888
https://github.com/root-project/root/pull/1888:19,safety,test,test,19,I am rerunning the test since I do not understand the failures.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1888
https://github.com/root-project/root/pull/1888:19,testability,test,test,19,I am rerunning the test since I do not understand the failures.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1888
https://github.com/root-project/root/pull/1888:39,testability,understand,understand,39,I am rerunning the test since I do not understand the failures.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1888
https://github.com/root-project/root/pull/1888:167,deployability,build,build,167,"@dpiparo this is cling messing something up, e.g. due to recursive parsing of the same thing twice. @Axel-Naumann is looking into it and can reproduce it with a debug build of cling",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1888
https://github.com/root-project/root/pull/1888:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1888
https://github.com/root-project/root/pull/1889:34,performance,time,time,34,"@stwunsch, @etejedor perhaps it's time to merge?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1889
https://github.com/root-project/root/pull/1889:84,deployability,depend,depends,84,@dpiparo I think @stwunsch still needs some time to address our comments. Also this depends on #1872,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1889
https://github.com/root-project/root/pull/1889:84,integrability,depend,depends,84,@dpiparo I think @stwunsch still needs some time to address our comments. Also this depends on #1872,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1889
https://github.com/root-project/root/pull/1889:84,modifiability,depend,depends,84,@dpiparo I think @stwunsch still needs some time to address our comments. Also this depends on #1872,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1889
https://github.com/root-project/root/pull/1889:44,performance,time,time,44,@dpiparo I think @stwunsch still needs some time to address our comments. Also this depends on #1872,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1889
https://github.com/root-project/root/pull/1889:84,safety,depend,depends,84,@dpiparo I think @stwunsch still needs some time to address our comments. Also this depends on #1872,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1889
https://github.com/root-project/root/pull/1889:84,testability,depend,depends,84,@dpiparo I think @stwunsch still needs some time to address our comments. Also this depends on #1872,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1889
https://github.com/root-project/root/pull/1889:60,safety,Test,Tested,60,Rebased to master with PR #1872 and addressed the comments. Tested locally with py2 and py3.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1889
https://github.com/root-project/root/pull/1889:60,testability,Test,Tested,60,Rebased to master with PR #1872 and addressed the comments. Tested locally with py2 and py3.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1889
https://github.com/root-project/root/pull/1889:25,deployability,build,builds,25,"Good, let's wait for the builds, thanks!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1889
https://github.com/root-project/root/pull/1889:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1889
https://github.com/root-project/root/pull/1889:198,deployability,updat,updated,198,"Sry, I've done confusing stuff. The return values of `TTree.AsMatrix(return_lables=True)` are inconsistent in the docs and the implementation (screwed this up...). PR #1909 fixes this. I've already updated the tutorials here to the proper return struct.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1889
https://github.com/root-project/root/pull/1889:198,safety,updat,updated,198,"Sry, I've done confusing stuff. The return values of `TTree.AsMatrix(return_lables=True)` are inconsistent in the docs and the implementation (screwed this up...). PR #1909 fixes this. I've already updated the tutorials here to the proper return struct.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1889
https://github.com/root-project/root/pull/1889:198,security,updat,updated,198,"Sry, I've done confusing stuff. The return values of `TTree.AsMatrix(return_lables=True)` are inconsistent in the docs and the implementation (screwed this up...). PR #1909 fixes this. I've already updated the tutorials here to the proper return struct.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1889
https://github.com/root-project/root/pull/1890:11,deployability,build,build,11,@phsft-bot build with flags -Dssl=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1890
https://github.com/root-project/root/pull/1892:10,deployability,build,build,10,phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1892
https://github.com/root-project/root/pull/1892:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1892
https://github.com/root-project/root/pull/1893:19,safety,test,tests,19,here the PR to fix tests: https://github.com/root-project/roottest/pull/160,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1893
https://github.com/root-project/root/pull/1893:19,testability,test,tests,19,here the PR to fix tests: https://github.com/root-project/roottest/pull/160,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1893
https://github.com/root-project/root/pull/1894:16,safety,test,test,16,cannot push the test too as the fcc file I am considering is far too big :),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1894
https://github.com/root-project/root/pull/1894:16,testability,test,test,16,cannot push the test too as the fcc file I am considering is far too big :),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1894
https://github.com/root-project/root/pull/1894:37,reliability,doe,does,37,@dpiparo if `df.Range(1).Snapshot()` does not work we have homework :sweat_smile:,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1894
https://github.com/root-project/root/pull/1895:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1895
https://github.com/root-project/root/pull/1896:11,deployability,build,build,11,@phsft-bot build please,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:120,interoperability,standard,standard,120,"Hi, I think it would be good, if possible, to amend the description of commit ""Use extern templates for TVecs of common standard types"" with the motivation behind their introduction. I can see them being accidentally removed and never put back...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:204,safety,accid,accidentally,204,"Hi, I think it would be good, if possible, to amend the description of commit ""Use extern templates for TVecs of common standard types"" with the motivation behind their introduction. I can see them being accidentally removed and never put back...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:50,integrability,messag,message,50,"@bluehood Ok, good point. I will amend the commit message.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:50,interoperability,messag,message,50,"@bluehood Ok, good point. I will amend the commit message.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:57,availability,error,errors,57,"@amadio @bluehood I do not get all these missing symbols errors and retriggered the build. If the PR builds pass, I am in favour to quickly merge so to proceed with the second part of the plan, i.e.:. - Add extern specialisation for all TVec operations. - Compile libVecOps with Ofast. - VDT On by default. - If VDT available, use VDT functions instead of standard ones. all this will be transparent for the user who will just see things boosted...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:242,availability,operat,operations,242,"@amadio @bluehood I do not get all these missing symbols errors and retriggered the build. If the PR builds pass, I am in favour to quickly merge so to proceed with the second part of the plan, i.e.:. - Add extern specialisation for all TVec operations. - Compile libVecOps with Ofast. - VDT On by default. - If VDT available, use VDT functions instead of standard ones. all this will be transparent for the user who will just see things boosted...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:316,availability,avail,available,316,"@amadio @bluehood I do not get all these missing symbols errors and retriggered the build. If the PR builds pass, I am in favour to quickly merge so to proceed with the second part of the plan, i.e.:. - Add extern specialisation for all TVec operations. - Compile libVecOps with Ofast. - VDT On by default. - If VDT available, use VDT functions instead of standard ones. all this will be transparent for the user who will just see things boosted...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:84,deployability,build,build,84,"@amadio @bluehood I do not get all these missing symbols errors and retriggered the build. If the PR builds pass, I am in favour to quickly merge so to proceed with the second part of the plan, i.e.:. - Add extern specialisation for all TVec operations. - Compile libVecOps with Ofast. - VDT On by default. - If VDT available, use VDT functions instead of standard ones. all this will be transparent for the user who will just see things boosted...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:101,deployability,build,builds,101,"@amadio @bluehood I do not get all these missing symbols errors and retriggered the build. If the PR builds pass, I am in favour to quickly merge so to proceed with the second part of the plan, i.e.:. - Add extern specialisation for all TVec operations. - Compile libVecOps with Ofast. - VDT On by default. - If VDT available, use VDT functions instead of standard ones. all this will be transparent for the user who will just see things boosted...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:356,interoperability,standard,standard,356,"@amadio @bluehood I do not get all these missing symbols errors and retriggered the build. If the PR builds pass, I am in favour to quickly merge so to proceed with the second part of the plan, i.e.:. - Add extern specialisation for all TVec operations. - Compile libVecOps with Ofast. - VDT On by default. - If VDT available, use VDT functions instead of standard ones. all this will be transparent for the user who will just see things boosted...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:57,performance,error,errors,57,"@amadio @bluehood I do not get all these missing symbols errors and retriggered the build. If the PR builds pass, I am in favour to quickly merge so to proceed with the second part of the plan, i.e.:. - Add extern specialisation for all TVec operations. - Compile libVecOps with Ofast. - VDT On by default. - If VDT available, use VDT functions instead of standard ones. all this will be transparent for the user who will just see things boosted...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:316,reliability,availab,available,316,"@amadio @bluehood I do not get all these missing symbols errors and retriggered the build. If the PR builds pass, I am in favour to quickly merge so to proceed with the second part of the plan, i.e.:. - Add extern specialisation for all TVec operations. - Compile libVecOps with Ofast. - VDT On by default. - If VDT available, use VDT functions instead of standard ones. all this will be transparent for the user who will just see things boosted...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:57,safety,error,errors,57,"@amadio @bluehood I do not get all these missing symbols errors and retriggered the build. If the PR builds pass, I am in favour to quickly merge so to proceed with the second part of the plan, i.e.:. - Add extern specialisation for all TVec operations. - Compile libVecOps with Ofast. - VDT On by default. - If VDT available, use VDT functions instead of standard ones. all this will be transparent for the user who will just see things boosted...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:316,safety,avail,available,316,"@amadio @bluehood I do not get all these missing symbols errors and retriggered the build. If the PR builds pass, I am in favour to quickly merge so to proceed with the second part of the plan, i.e.:. - Add extern specialisation for all TVec operations. - Compile libVecOps with Ofast. - VDT On by default. - If VDT available, use VDT functions instead of standard ones. all this will be transparent for the user who will just see things boosted...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:316,security,availab,available,316,"@amadio @bluehood I do not get all these missing symbols errors and retriggered the build. If the PR builds pass, I am in favour to quickly merge so to proceed with the second part of the plan, i.e.:. - Add extern specialisation for all TVec operations. - Compile libVecOps with Ofast. - VDT On by default. - If VDT available, use VDT functions instead of standard ones. all this will be transparent for the user who will just see things boosted...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:188,testability,plan,plan,188,"@amadio @bluehood I do not get all these missing symbols errors and retriggered the build. If the PR builds pass, I am in favour to quickly merge so to proceed with the second part of the plan, i.e.:. - Add extern specialisation for all TVec operations. - Compile libVecOps with Ofast. - VDT On by default. - If VDT available, use VDT functions instead of standard ones. all this will be transparent for the user who will just see things boosted...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:57,usability,error,errors,57,"@amadio @bluehood I do not get all these missing symbols errors and retriggered the build. If the PR builds pass, I am in favour to quickly merge so to proceed with the second part of the plan, i.e.:. - Add extern specialisation for all TVec operations. - Compile libVecOps with Ofast. - VDT On by default. - If VDT available, use VDT functions instead of standard ones. all this will be transparent for the user who will just see things boosted...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:408,usability,user,user,408,"@amadio @bluehood I do not get all these missing symbols errors and retriggered the build. If the PR builds pass, I am in favour to quickly merge so to proceed with the second part of the plan, i.e.:. - Add extern specialisation for all TVec operations. - Compile libVecOps with Ofast. - VDT On by default. - If VDT available, use VDT functions instead of standard ones. all this will be transparent for the user who will just see things boosted...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:239,deployability,build,builds,239,"Hi @dpiparo , I agree with the remainder of the plan, but I'd prefer to merge at the end, once the problem of missing symbols is resolved for all platforms. We can merge the first two commits anytime, though, as they do not affect current builds.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:231,energy efficiency,current,current,231,"Hi @dpiparo , I agree with the remainder of the plan, but I'd prefer to merge at the end, once the problem of missing symbols is resolved for all platforms. We can merge the first two commits anytime, though, as they do not affect current builds.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:146,interoperability,platform,platforms,146,"Hi @dpiparo , I agree with the remainder of the plan, but I'd prefer to merge at the end, once the problem of missing symbols is resolved for all platforms. We can merge the first two commits anytime, though, as they do not affect current builds.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:48,testability,plan,plan,48,"Hi @dpiparo , I agree with the remainder of the plan, but I'd prefer to merge at the end, once the problem of missing symbols is resolved for all platforms. We can merge the first two commits anytime, though, as they do not affect current builds.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:62,usability,prefer,prefer,62,"Hi @dpiparo , I agree with the remainder of the plan, but I'd prefer to merge at the end, once the problem of missing symbols is resolved for all platforms. We can merge the first two commits anytime, though, as they do not affect current builds.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:63,deployability,depend,dependencies,63,"Hi @amadio, I think I found the problem. We simply need to add dependencies on libVecOps.so. For the dependency of PyROOT on VecOps, we can discuss a solution together with @etejedor. I have an idea on how to solve this relying on the fact that a TVec has the same layout of a vector with a custom allocator.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:101,deployability,depend,dependency,101,"Hi @amadio, I think I found the problem. We simply need to add dependencies on libVecOps.so. For the dependency of PyROOT on VecOps, we can discuss a solution together with @etejedor. I have an idea on how to solve this relying on the fact that a TVec has the same layout of a vector with a custom allocator.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:298,energy efficiency,alloc,allocator,298,"Hi @amadio, I think I found the problem. We simply need to add dependencies on libVecOps.so. For the dependency of PyROOT on VecOps, we can discuss a solution together with @etejedor. I have an idea on how to solve this relying on the fact that a TVec has the same layout of a vector with a custom allocator.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:63,integrability,depend,dependencies,63,"Hi @amadio, I think I found the problem. We simply need to add dependencies on libVecOps.so. For the dependency of PyROOT on VecOps, we can discuss a solution together with @etejedor. I have an idea on how to solve this relying on the fact that a TVec has the same layout of a vector with a custom allocator.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:101,integrability,depend,dependency,101,"Hi @amadio, I think I found the problem. We simply need to add dependencies on libVecOps.so. For the dependency of PyROOT on VecOps, we can discuss a solution together with @etejedor. I have an idea on how to solve this relying on the fact that a TVec has the same layout of a vector with a custom allocator.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:63,modifiability,depend,dependencies,63,"Hi @amadio, I think I found the problem. We simply need to add dependencies on libVecOps.so. For the dependency of PyROOT on VecOps, we can discuss a solution together with @etejedor. I have an idea on how to solve this relying on the fact that a TVec has the same layout of a vector with a custom allocator.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:101,modifiability,depend,dependency,101,"Hi @amadio, I think I found the problem. We simply need to add dependencies on libVecOps.so. For the dependency of PyROOT on VecOps, we can discuss a solution together with @etejedor. I have an idea on how to solve this relying on the fact that a TVec has the same layout of a vector with a custom allocator.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:63,safety,depend,dependencies,63,"Hi @amadio, I think I found the problem. We simply need to add dependencies on libVecOps.so. For the dependency of PyROOT on VecOps, we can discuss a solution together with @etejedor. I have an idea on how to solve this relying on the fact that a TVec has the same layout of a vector with a custom allocator.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:101,safety,depend,dependency,101,"Hi @amadio, I think I found the problem. We simply need to add dependencies on libVecOps.so. For the dependency of PyROOT on VecOps, we can discuss a solution together with @etejedor. I have an idea on how to solve this relying on the fact that a TVec has the same layout of a vector with a custom allocator.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:44,testability,simpl,simply,44,"Hi @amadio, I think I found the problem. We simply need to add dependencies on libVecOps.so. For the dependency of PyROOT on VecOps, we can discuss a solution together with @etejedor. I have an idea on how to solve this relying on the fact that a TVec has the same layout of a vector with a custom allocator.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:63,testability,depend,dependencies,63,"Hi @amadio, I think I found the problem. We simply need to add dependencies on libVecOps.so. For the dependency of PyROOT on VecOps, we can discuss a solution together with @etejedor. I have an idea on how to solve this relying on the fact that a TVec has the same layout of a vector with a custom allocator.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:101,testability,depend,dependency,101,"Hi @amadio, I think I found the problem. We simply need to add dependencies on libVecOps.so. For the dependency of PyROOT on VecOps, we can discuss a solution together with @etejedor. I have an idea on how to solve this relying on the fact that a TVec has the same layout of a vector with a custom allocator.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:44,usability,simpl,simply,44,"Hi @amadio, I think I found the problem. We simply need to add dependencies on libVecOps.so. For the dependency of PyROOT on VecOps, we can discuss a solution together with @etejedor. I have an idea on how to solve this relying on the fact that a TVec has the same layout of a vector with a custom allocator.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:291,usability,custom,custom,291,"Hi @amadio, I think I found the problem. We simply need to add dependencies on libVecOps.so. For the dependency of PyROOT on VecOps, we can discuss a solution together with @etejedor. I have an idea on how to solve this relying on the fact that a TVec has the same layout of a vector with a custom allocator.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:87,availability,failur,failures,87,"Hi @dpiparo , on this topic #1888 adds libVecOps as a dependency of libTreePlayer. The failures in that PR should have been fixed by commit 62fca2cbef, so I just restarted the tests to check it's now green.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:54,deployability,depend,dependency,54,"Hi @dpiparo , on this topic #1888 adds libVecOps as a dependency of libTreePlayer. The failures in that PR should have been fixed by commit 62fca2cbef, so I just restarted the tests to check it's now green.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:87,deployability,fail,failures,87,"Hi @dpiparo , on this topic #1888 adds libVecOps as a dependency of libTreePlayer. The failures in that PR should have been fixed by commit 62fca2cbef, so I just restarted the tests to check it's now green.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:200,energy efficiency,green,green,200,"Hi @dpiparo , on this topic #1888 adds libVecOps as a dependency of libTreePlayer. The failures in that PR should have been fixed by commit 62fca2cbef, so I just restarted the tests to check it's now green.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:22,integrability,topic,topic,22,"Hi @dpiparo , on this topic #1888 adds libVecOps as a dependency of libTreePlayer. The failures in that PR should have been fixed by commit 62fca2cbef, so I just restarted the tests to check it's now green.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:54,integrability,depend,dependency,54,"Hi @dpiparo , on this topic #1888 adds libVecOps as a dependency of libTreePlayer. The failures in that PR should have been fixed by commit 62fca2cbef, so I just restarted the tests to check it's now green.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:54,modifiability,depend,dependency,54,"Hi @dpiparo , on this topic #1888 adds libVecOps as a dependency of libTreePlayer. The failures in that PR should have been fixed by commit 62fca2cbef, so I just restarted the tests to check it's now green.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:87,performance,failur,failures,87,"Hi @dpiparo , on this topic #1888 adds libVecOps as a dependency of libTreePlayer. The failures in that PR should have been fixed by commit 62fca2cbef, so I just restarted the tests to check it's now green.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:87,reliability,fail,failures,87,"Hi @dpiparo , on this topic #1888 adds libVecOps as a dependency of libTreePlayer. The failures in that PR should have been fixed by commit 62fca2cbef, so I just restarted the tests to check it's now green.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:54,safety,depend,dependency,54,"Hi @dpiparo , on this topic #1888 adds libVecOps as a dependency of libTreePlayer. The failures in that PR should have been fixed by commit 62fca2cbef, so I just restarted the tests to check it's now green.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:176,safety,test,tests,176,"Hi @dpiparo , on this topic #1888 adds libVecOps as a dependency of libTreePlayer. The failures in that PR should have been fixed by commit 62fca2cbef, so I just restarted the tests to check it's now green.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:54,testability,depend,dependency,54,"Hi @dpiparo , on this topic #1888 adds libVecOps as a dependency of libTreePlayer. The failures in that PR should have been fixed by commit 62fca2cbef, so I just restarted the tests to check it's now green.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:176,testability,test,tests,176,"Hi @dpiparo , on this topic #1888 adds libVecOps as a dependency of libTreePlayer. The failures in that PR should have been fixed by commit 62fca2cbef, so I just restarted the tests to check it's now green.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:140,usability,indicat,indicated,140,"Ok, I just merged PR #1888 and will rebase this PR on master. Then I will try to get the constructor problem worked out with Axel, since he indicated that the problem might be with rootcling.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:25,testability,simpl,simple,25,Merged as #1945 adding 2 simple workarounds.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1896:25,usability,simpl,simple,25,Merged as #1945 adding 2 simple workarounds.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1896
https://github.com/root-project/root/pull/1898:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1898
https://github.com/root-project/root/pull/1899:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1899
https://github.com/root-project/root/pull/1899:11,deployability,build,build,11,@phsft-bot build only on mac1013/native,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1899
https://github.com/root-project/root/pull/1901:106,availability,state,state,106,"So writing (and reading) hex floats `0x0.123p-1` is not an option? This is an exact, platform independent state dump of an fp value - the best you can get...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1901
https://github.com/root-project/root/pull/1901:106,integrability,state,state,106,"So writing (and reading) hex floats `0x0.123p-1` is not an option? This is an exact, platform independent state dump of an fp value - the best you can get...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1901
https://github.com/root-project/root/pull/1901:85,interoperability,platform,platform,85,"So writing (and reading) hex floats `0x0.123p-1` is not an option? This is an exact, platform independent state dump of an fp value - the best you can get...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1901
https://github.com/root-project/root/pull/1901:211,availability,error,error,211,"One of the features of these exports is that they are supposed to be humanly readable, in contrast with binary formats. Don't ask me why, but there are people looking in the GDML after discovering some geometry error...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1901
https://github.com/root-project/root/pull/1901:185,integrability,discover,discovering,185,"One of the features of these exports is that they are supposed to be humanly readable, in contrast with binary formats. Don't ask me why, but there are people looking in the GDML after discovering some geometry error...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1901
https://github.com/root-project/root/pull/1901:111,interoperability,format,formats,111,"One of the features of these exports is that they are supposed to be humanly readable, in contrast with binary formats. Don't ask me why, but there are people looking in the GDML after discovering some geometry error...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1901
https://github.com/root-project/root/pull/1901:185,interoperability,discover,discovering,185,"One of the features of these exports is that they are supposed to be humanly readable, in contrast with binary formats. Don't ask me why, but there are people looking in the GDML after discovering some geometry error...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1901
https://github.com/root-project/root/pull/1901:211,performance,error,error,211,"One of the features of these exports is that they are supposed to be humanly readable, in contrast with binary formats. Don't ask me why, but there are people looking in the GDML after discovering some geometry error...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1901
https://github.com/root-project/root/pull/1901:211,safety,error,error,211,"One of the features of these exports is that they are supposed to be humanly readable, in contrast with binary formats. Don't ask me why, but there are people looking in the GDML after discovering some geometry error...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1901
https://github.com/root-project/root/pull/1901:185,usability,discov,discovering,185,"One of the features of these exports is that they are supposed to be humanly readable, in contrast with binary formats. Don't ask me why, but there are people looking in the GDML after discovering some geometry error...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1901
https://github.com/root-project/root/pull/1901:211,usability,error,error,211,"One of the features of these exports is that they are supposed to be humanly readable, in contrast with binary formats. Don't ask me why, but there are people looking in the GDML after discovering some geometry error...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1901
https://github.com/root-project/root/pull/1901:19,integrability,interfac,interface,19,"Changed TGDMLWrite interface to take UInt_t. The export precision is now handled by GDML and partially .C export (just matrices for now), but not by xml export. @pcanal, @linev what is your take? Could we do the same for the xml exporter?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1901
https://github.com/root-project/root/pull/1901:19,interoperability,interfac,interface,19,"Changed TGDMLWrite interface to take UInt_t. The export precision is now handled by GDML and partially .C export (just matrices for now), but not by xml export. @pcanal, @linev what is your take? Could we do the same for the xml exporter?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1901
https://github.com/root-project/root/pull/1901:149,interoperability,xml,xml,149,"Changed TGDMLWrite interface to take UInt_t. The export precision is now handled by GDML and partially .C export (just matrices for now), but not by xml export. @pcanal, @linev what is your take? Could we do the same for the xml exporter?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1901
https://github.com/root-project/root/pull/1901:225,interoperability,xml,xml,225,"Changed TGDMLWrite interface to take UInt_t. The export precision is now handled by GDML and partially .C export (just matrices for now), but not by xml export. @pcanal, @linev what is your take? Could we do the same for the xml exporter?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1901
https://github.com/root-project/root/pull/1901:19,modifiability,interfac,interface,19,"Changed TGDMLWrite interface to take UInt_t. The export precision is now handled by GDML and partially .C export (just matrices for now), but not by xml export. @pcanal, @linev what is your take? Could we do the same for the xml exporter?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1901
https://github.com/root-project/root/pull/1901:62,interoperability,XML,XML,62,"When you are using large precision number, you blow up output XML files. One can use compression method from TBufferText. I use it to control size of output JSON/XML files and avoids output like `17.000000000000000`. Instead `17` will be produced. I can provide code for that.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1901
https://github.com/root-project/root/pull/1901:162,interoperability,XML,XML,162,"When you are using large precision number, you blow up output XML files. One can use compression method from TBufferText. I use it to control size of output JSON/XML files and avoids output like `17.000000000000000`. Instead `17` will be produced. I can provide code for that.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1901
https://github.com/root-project/root/pull/1901:176,safety,avoid,avoids,176,"When you are using large precision number, you blow up output XML files. One can use compression method from TBufferText. I use it to control size of output JSON/XML files and avoids output like `17.000000000000000`. Instead `17` will be produced. I can provide code for that.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1901
https://github.com/root-project/root/pull/1901:134,security,control,control,134,"When you are using large precision number, you blow up output XML files. One can use compression method from TBufferText. I use it to control size of output JSON/XML files and avoids output like `17.000000000000000`. Instead `17` will be produced. I can provide code for that.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1901
https://github.com/root-project/root/pull/1901:134,testability,control,control,134,"When you are using large precision number, you blow up output XML files. One can use compression method from TBufferText. I use it to control size of output JSON/XML files and avoids output like `17.000000000000000`. Instead `17` will be produced. I can provide code for that.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1901
https://github.com/root-project/root/pull/1901:201,modifiability,responsibil,responsibility,201,"Thanks @linev, I know that there is an issue with very large precision for the file size. I use %.[prec]g which does the expected cutting zeros if not putting too big precision there. It is the user's responsibility to control the precision and implicitly the file size.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1901
https://github.com/root-project/root/pull/1901:112,reliability,doe,does,112,"Thanks @linev, I know that there is an issue with very large precision for the file size. I use %.[prec]g which does the expected cutting zeros if not putting too big precision there. It is the user's responsibility to control the precision and implicitly the file size.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1901
https://github.com/root-project/root/pull/1901:219,security,control,control,219,"Thanks @linev, I know that there is an issue with very large precision for the file size. I use %.[prec]g which does the expected cutting zeros if not putting too big precision there. It is the user's responsibility to control the precision and implicitly the file size.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1901
https://github.com/root-project/root/pull/1901:219,testability,control,control,219,"Thanks @linev, I know that there is an issue with very large precision for the file size. I use %.[prec]g which does the expected cutting zeros if not putting too big precision there. It is the user's responsibility to control the precision and implicitly the file size.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1901
https://github.com/root-project/root/pull/1901:194,usability,user,user,194,"Thanks @linev, I know that there is an issue with very large precision for the file size. I use %.[prec]g which does the expected cutting zeros if not putting too big precision there. It is the user's responsibility to control the precision and implicitly the file size.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1901
https://github.com/root-project/root/pull/1901:22,deployability,fail,failing,22,Merging since what is failing is just un-related tests,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1901
https://github.com/root-project/root/pull/1901:22,reliability,fail,failing,22,Merging since what is failing is just un-related tests,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1901
https://github.com/root-project/root/pull/1901:49,safety,test,tests,49,Merging since what is failing is just un-related tests,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1901
https://github.com/root-project/root/pull/1901:49,testability,test,tests,49,Merging since what is failing is just un-related tests,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1901
https://github.com/root-project/root/pull/1903:122,availability,failur,failures,122,"Looks good, I do not see either how this can be implemented without the extra regex search. Let's put it in? Are the test failures related to these changes?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1903
https://github.com/root-project/root/pull/1903:122,deployability,fail,failures,122,"Looks good, I do not see either how this can be implemented without the extra regex search. Let's put it in? Are the test failures related to these changes?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1903
https://github.com/root-project/root/pull/1903:122,performance,failur,failures,122,"Looks good, I do not see either how this can be implemented without the extra regex search. Let's put it in? Are the test failures related to these changes?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1903
https://github.com/root-project/root/pull/1903:122,reliability,fail,failures,122,"Looks good, I do not see either how this can be implemented without the extra regex search. Let's put it in? Are the test failures related to these changes?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1903
https://github.com/root-project/root/pull/1903:117,safety,test,test,117,"Looks good, I do not see either how this can be implemented without the extra regex search. Let's put it in? Are the test failures related to these changes?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1903
https://github.com/root-project/root/pull/1903:117,testability,test,test,117,"Looks good, I do not see either how this can be implemented without the extra regex search. Let's put it in? Are the test failures related to these changes?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1903
https://github.com/root-project/root/pull/1903:33,availability,failur,failures,33,"Hi @etejedor , perfect. The test failures are unrelated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1903
https://github.com/root-project/root/pull/1903:33,deployability,fail,failures,33,"Hi @etejedor , perfect. The test failures are unrelated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1903
https://github.com/root-project/root/pull/1903:33,performance,failur,failures,33,"Hi @etejedor , perfect. The test failures are unrelated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1903
https://github.com/root-project/root/pull/1903:33,reliability,fail,failures,33,"Hi @etejedor , perfect. The test failures are unrelated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1903
https://github.com/root-project/root/pull/1903:28,safety,test,test,28,"Hi @etejedor , perfect. The test failures are unrelated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1903
https://github.com/root-project/root/pull/1903:28,testability,test,test,28,"Hi @etejedor , perfect. The test failures are unrelated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1903
https://github.com/root-project/root/pull/1905:563,deployability,log,logic,563,"Hi @dpiparo ,. you are right, `Exec` and `Finalize` could also be no-op. I explicitly specified that `Initialize` and `InitTask` can be no-op in the doc because those two ""feel"" like they should be doing something important, given their name. I thought users would know what they want to put in `Exec` and `Finalize`, but they might be confused by `Initialize` and `InitTask`. I can reword it if you think it's unclear. The only method that doesn't have to be present is `PartialResult`. The others are required, at least for now. In the future we could add some logic to `TActionImpl<T>` that implements `Initialize`, `InitTask`, `Exec` and `Finalize` as no-op if they are not implemented in `T`. It doesn't even look [that ugly](https://godbolt.org/g/RZHkAy). A humble suggestion for the tutorial (thanks!): wrapping THn in a custom TDF action :grin:",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1905
https://github.com/root-project/root/pull/1905:810,integrability,wrap,wrapping,810,"Hi @dpiparo ,. you are right, `Exec` and `Finalize` could also be no-op. I explicitly specified that `Initialize` and `InitTask` can be no-op in the doc because those two ""feel"" like they should be doing something important, given their name. I thought users would know what they want to put in `Exec` and `Finalize`, but they might be confused by `Initialize` and `InitTask`. I can reword it if you think it's unclear. The only method that doesn't have to be present is `PartialResult`. The others are required, at least for now. In the future we could add some logic to `TActionImpl<T>` that implements `Initialize`, `InitTask`, `Exec` and `Finalize` as no-op if they are not implemented in `T`. It doesn't even look [that ugly](https://godbolt.org/g/RZHkAy). A humble suggestion for the tutorial (thanks!): wrapping THn in a custom TDF action :grin:",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1905
https://github.com/root-project/root/pull/1905:86,interoperability,specif,specified,86,"Hi @dpiparo ,. you are right, `Exec` and `Finalize` could also be no-op. I explicitly specified that `Initialize` and `InitTask` can be no-op in the doc because those two ""feel"" like they should be doing something important, given their name. I thought users would know what they want to put in `Exec` and `Finalize`, but they might be confused by `Initialize` and `InitTask`. I can reword it if you think it's unclear. The only method that doesn't have to be present is `PartialResult`. The others are required, at least for now. In the future we could add some logic to `TActionImpl<T>` that implements `Initialize`, `InitTask`, `Exec` and `Finalize` as no-op if they are not implemented in `T`. It doesn't even look [that ugly](https://godbolt.org/g/RZHkAy). A humble suggestion for the tutorial (thanks!): wrapping THn in a custom TDF action :grin:",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1905
https://github.com/root-project/root/pull/1905:441,reliability,doe,doesn,441,"Hi @dpiparo ,. you are right, `Exec` and `Finalize` could also be no-op. I explicitly specified that `Initialize` and `InitTask` can be no-op in the doc because those two ""feel"" like they should be doing something important, given their name. I thought users would know what they want to put in `Exec` and `Finalize`, but they might be confused by `Initialize` and `InitTask`. I can reword it if you think it's unclear. The only method that doesn't have to be present is `PartialResult`. The others are required, at least for now. In the future we could add some logic to `TActionImpl<T>` that implements `Initialize`, `InitTask`, `Exec` and `Finalize` as no-op if they are not implemented in `T`. It doesn't even look [that ugly](https://godbolt.org/g/RZHkAy). A humble suggestion for the tutorial (thanks!): wrapping THn in a custom TDF action :grin:",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1905
https://github.com/root-project/root/pull/1905:701,reliability,doe,doesn,701,"Hi @dpiparo ,. you are right, `Exec` and `Finalize` could also be no-op. I explicitly specified that `Initialize` and `InitTask` can be no-op in the doc because those two ""feel"" like they should be doing something important, given their name. I thought users would know what they want to put in `Exec` and `Finalize`, but they might be confused by `Initialize` and `InitTask`. I can reword it if you think it's unclear. The only method that doesn't have to be present is `PartialResult`. The others are required, at least for now. In the future we could add some logic to `TActionImpl<T>` that implements `Initialize`, `InitTask`, `Exec` and `Finalize` as no-op if they are not implemented in `T`. It doesn't even look [that ugly](https://godbolt.org/g/RZHkAy). A humble suggestion for the tutorial (thanks!): wrapping THn in a custom TDF action :grin:",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1905
https://github.com/root-project/root/pull/1905:563,safety,log,logic,563,"Hi @dpiparo ,. you are right, `Exec` and `Finalize` could also be no-op. I explicitly specified that `Initialize` and `InitTask` can be no-op in the doc because those two ""feel"" like they should be doing something important, given their name. I thought users would know what they want to put in `Exec` and `Finalize`, but they might be confused by `Initialize` and `InitTask`. I can reword it if you think it's unclear. The only method that doesn't have to be present is `PartialResult`. The others are required, at least for now. In the future we could add some logic to `TActionImpl<T>` that implements `Initialize`, `InitTask`, `Exec` and `Finalize` as no-op if they are not implemented in `T`. It doesn't even look [that ugly](https://godbolt.org/g/RZHkAy). A humble suggestion for the tutorial (thanks!): wrapping THn in a custom TDF action :grin:",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1905
https://github.com/root-project/root/pull/1905:563,security,log,logic,563,"Hi @dpiparo ,. you are right, `Exec` and `Finalize` could also be no-op. I explicitly specified that `Initialize` and `InitTask` can be no-op in the doc because those two ""feel"" like they should be doing something important, given their name. I thought users would know what they want to put in `Exec` and `Finalize`, but they might be confused by `Initialize` and `InitTask`. I can reword it if you think it's unclear. The only method that doesn't have to be present is `PartialResult`. The others are required, at least for now. In the future we could add some logic to `TActionImpl<T>` that implements `Initialize`, `InitTask`, `Exec` and `Finalize` as no-op if they are not implemented in `T`. It doesn't even look [that ugly](https://godbolt.org/g/RZHkAy). A humble suggestion for the tutorial (thanks!): wrapping THn in a custom TDF action :grin:",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1905
https://github.com/root-project/root/pull/1905:563,testability,log,logic,563,"Hi @dpiparo ,. you are right, `Exec` and `Finalize` could also be no-op. I explicitly specified that `Initialize` and `InitTask` can be no-op in the doc because those two ""feel"" like they should be doing something important, given their name. I thought users would know what they want to put in `Exec` and `Finalize`, but they might be confused by `Initialize` and `InitTask`. I can reword it if you think it's unclear. The only method that doesn't have to be present is `PartialResult`. The others are required, at least for now. In the future we could add some logic to `TActionImpl<T>` that implements `Initialize`, `InitTask`, `Exec` and `Finalize` as no-op if they are not implemented in `T`. It doesn't even look [that ugly](https://godbolt.org/g/RZHkAy). A humble suggestion for the tutorial (thanks!): wrapping THn in a custom TDF action :grin:",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1905
https://github.com/root-project/root/pull/1905:253,usability,user,users,253,"Hi @dpiparo ,. you are right, `Exec` and `Finalize` could also be no-op. I explicitly specified that `Initialize` and `InitTask` can be no-op in the doc because those two ""feel"" like they should be doing something important, given their name. I thought users would know what they want to put in `Exec` and `Finalize`, but they might be confused by `Initialize` and `InitTask`. I can reword it if you think it's unclear. The only method that doesn't have to be present is `PartialResult`. The others are required, at least for now. In the future we could add some logic to `TActionImpl<T>` that implements `Initialize`, `InitTask`, `Exec` and `Finalize` as no-op if they are not implemented in `T`. It doesn't even look [that ugly](https://godbolt.org/g/RZHkAy). A humble suggestion for the tutorial (thanks!): wrapping THn in a custom TDF action :grin:",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1905
https://github.com/root-project/root/pull/1905:828,usability,custom,custom,828,"Hi @dpiparo ,. you are right, `Exec` and `Finalize` could also be no-op. I explicitly specified that `Initialize` and `InitTask` can be no-op in the doc because those two ""feel"" like they should be doing something important, given their name. I thought users would know what they want to put in `Exec` and `Finalize`, but they might be confused by `Initialize` and `InitTask`. I can reword it if you think it's unclear. The only method that doesn't have to be present is `PartialResult`. The others are required, at least for now. In the future we could add some logic to `TActionImpl<T>` that implements `Initialize`, `InitTask`, `Exec` and `Finalize` as no-op if they are not implemented in `T`. It doesn't even look [that ugly](https://godbolt.org/g/RZHkAy). A humble suggestion for the tutorial (thanks!): wrapping THn in a custom TDF action :grin:",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1905
https://github.com/root-project/root/pull/1909:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1909
https://github.com/root-project/root/pull/1911:11,deployability,build,build,11,@phsft-bot build just on slc6/gcc49,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1911
https://github.com/root-project/root/pull/1912:11,deployability,build,build,11,@phsft-bot build just on windows10/vc15,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1912
https://github.com/root-project/root/pull/1914:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1914
https://github.com/root-project/root/pull/1914:4,usability,document,documentation,4,"The documentation from [here](http://en.cppreference.com/w/cpp/utility/integer_sequence). ```. template<class... T>. using index_sequence_for = std::make_index_sequence<sizeof...(T)>;. template<std::size_t N>. using make_index_sequence = make_integer_sequence<std::size_t, N>;. ````",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1914
https://github.com/root-project/root/pull/1914:45,deployability,build,builds,45,"HI @stwunsch, I tried your fix on one of the builds where it failed last night (lcgapp-slc6-i386-3, master-i686-slc6-gcc49-dbg) and both `tutorial-pyroot-pyroot002_TTreeAsMatrix-py` and `pyunittests-pyroot-ttree-asmatrix` are now fine. I think this can go in.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1914
https://github.com/root-project/root/pull/1914:61,deployability,fail,failed,61,"HI @stwunsch, I tried your fix on one of the builds where it failed last night (lcgapp-slc6-i386-3, master-i686-slc6-gcc49-dbg) and both `tutorial-pyroot-pyroot002_TTreeAsMatrix-py` and `pyunittests-pyroot-ttree-asmatrix` are now fine. I think this can go in.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1914
https://github.com/root-project/root/pull/1914:61,reliability,fail,failed,61,"HI @stwunsch, I tried your fix on one of the builds where it failed last night (lcgapp-slc6-i386-3, master-i686-slc6-gcc49-dbg) and both `tutorial-pyroot-pyroot002_TTreeAsMatrix-py` and `pyunittests-pyroot-ttree-asmatrix` are now fine. I think this can go in.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1914
https://github.com/root-project/root/pull/1916:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:55,availability,error,error,55,@Axel-Naumann @lmoneta that looks like a transitionary error to me. care to restart jenkins for slc6/gcc62?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:55,performance,error,error,55,@Axel-Naumann @lmoneta that looks like a transitionary error to me. care to restart jenkins for slc6/gcc62?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:55,safety,error,error,55,@Axel-Naumann @lmoneta that looks like a transitionary error to me. care to restart jenkins for slc6/gcc62?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:55,usability,error,error,55,@Axel-Naumann @lmoneta that looks like a transitionary error to me. care to restart jenkins for slc6/gcc62?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:47,availability,failur,failures,47,"I agree with the fix. I will merge it now, the failures have nothing to do with it. . Thank you for submitting this PR",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:47,deployability,fail,failures,47,"I agree with the fix. I will merge it now, the failures have nothing to do with it. . Thank you for submitting this PR",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:100,integrability,sub,submitting,100,"I agree with the fix. I will merge it now, the failures have nothing to do with it. . Thank you for submitting this PR",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:47,performance,failur,failures,47,"I agree with the fix. I will merge it now, the failures have nothing to do with it. . Thank you for submitting this PR",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1916:47,reliability,fail,failures,47,"I agree with the fix. I will merge it now, the failures have nothing to do with it. . Thank you for submitting this PR",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1916
https://github.com/root-project/root/pull/1917:9,modifiability,concern,concern,9,My basic concern: Too much stuff/features in a single tutorial?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1917
https://github.com/root-project/root/pull/1917:9,testability,concern,concern,9,My basic concern: Too much stuff/features in a single tutorial?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1917
https://github.com/root-project/root/pull/1919:11,deployability,build,build,11,@phsft-bot build just on slc6/gcc62,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1919
https://github.com/root-project/root/pull/1921:57,modifiability,paramet,parameter,57,"In the helper's ctor it seems there is an extra `nSlots` parameter to `make_shared`, and the loop variable `i` will cause ""unused variable"" warnings. Besides these it looks good to me.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1921
https://github.com/root-project/root/pull/1921:98,modifiability,variab,variable,98,"In the helper's ctor it seems there is an extra `nSlots` parameter to `make_shared`, and the loop variable `i` will cause ""unused variable"" warnings. Besides these it looks good to me.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1921
https://github.com/root-project/root/pull/1921:130,modifiability,variab,variable,130,"In the helper's ctor it seems there is an extra `nSlots` parameter to `make_shared`, and the loop variable `i` will cause ""unused variable"" warnings. Besides these it looks good to me.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1921
https://github.com/root-project/root/pull/1921:7,usability,help,helper,7,"In the helper's ctor it seems there is an extra `nSlots` parameter to `make_shared`, and the loop variable `i` will cause ""unused variable"" warnings. Besides these it looks good to me.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1921
https://github.com/root-project/root/pull/1922:11,deployability,build,build,11,@phsft-bot build just on slc6/gcc62 with flags -DLLVM_BUILD_TYPE=Debug -Droofit=Off -Druntime_cxxmodules=On -Dctest_test_exclude_none=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1922
https://github.com/root-project/root/pull/1923:11,deployability,build,build,11,@phsft-bot build just on ubuntu16/native with flags -Dclingtest=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1923
https://github.com/root-project/root/pull/1925:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1925
https://github.com/root-project/root/pull/1925:45,deployability,build,build,45,Tested on the 32bit node. Let's check the PR build for the 64bit architecture.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1925
https://github.com/root-project/root/pull/1925:65,interoperability,architectur,architecture,65,Tested on the 32bit node. Let's check the PR build for the 64bit architecture.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1925
https://github.com/root-project/root/pull/1925:0,safety,Test,Tested,0,Tested on the 32bit node. Let's check the PR build for the 64bit architecture.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1925
https://github.com/root-project/root/pull/1925:0,testability,Test,Tested,0,Tested on the 32bit node. Let's check the PR build for the 64bit architecture.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1925
https://github.com/root-project/root/pull/1925:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1925
https://github.com/root-project/root/pull/1925:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1925
https://github.com/root-project/root/pull/1927:75,safety,test,test,75,@Axel-Naumann . Can you merge it before branching for 6.14. It passes root-test now,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1927
https://github.com/root-project/root/pull/1927:75,testability,test,test,75,@Axel-Naumann . Can you merge it before branching for 6.14. It passes root-test now,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1927
https://github.com/root-project/root/pull/1934:25,usability,confirm,confirmation,25,Merging separately after confirmation of @amadio,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1934
https://github.com/root-project/root/pull/1936:138,interoperability,Format,Format,138,"TRandomGen is a class template. Other engine are likely still returning an std::string. In TRandomGen you could do. ```. SetName(TString::Format(""Random_%s"",std::string(fEngine.Name()).c_str() );. ```. or (maybe). ```. SetName(TString::Format(""Random_%s"",std::string_view(fEngine.Name()).data()) );. ```. Cheers,. Philippe.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1936
https://github.com/root-project/root/pull/1936:236,interoperability,Format,Format,236,"TRandomGen is a class template. Other engine are likely still returning an std::string. In TRandomGen you could do. ```. SetName(TString::Format(""Random_%s"",std::string(fEngine.Name()).c_str() );. ```. or (maybe). ```. SetName(TString::Format(""Random_%s"",std::string_view(fEngine.Name()).data()) );. ```. Cheers,. Philippe.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1936
https://github.com/root-project/root/pull/1936:116,deployability,updat,update,116,"I would do as Axel suggest, use std::string(fEngine.Name()).c_str() instead of string_view. . Can you please Enrico update and then for me it is fine for me to merge. Lorenzo",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1936
https://github.com/root-project/root/pull/1936:116,safety,updat,update,116,"I would do as Axel suggest, use std::string(fEngine.Name()).c_str() instead of string_view. . Can you please Enrico update and then for me it is fine for me to merge. Lorenzo",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1936
https://github.com/root-project/root/pull/1936:116,security,updat,update,116,"I would do as Axel suggest, use std::string(fEngine.Name()).c_str() instead of string_view. . Can you please Enrico update and then for me it is fine for me to merge. Lorenzo",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1936
https://github.com/root-project/root/pull/1939:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1939
https://github.com/root-project/root/pull/1943:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1943
https://github.com/root-project/root/pull/1945:352,availability,consist,consists,352,"This PR is a reload of #1896 . All the work of @amadio is there + 2 workarounds for 2 problems:. 1) On Ubuntu 16, gcc 54, interpreted macros and prompt cannot autoload TVec<(unsigned) long long>. The autoload key is there, the autoload can be triggered e.g. with TClass::GetClass but somehow through interpreted code this does not work. The workaround consists in not declaring the TVec<long long> extern, therewith leaving it in the pch and have it working (the library by definition is not needed at the price of using that class w/o the optimisations of the compiled library in interpreted code). 2) Windows. MVCC has issues digesting all the templates. Since 6.14 is the first ROOT6 version working with Windows and performance through data paralellism made accessible by VecOps is not a top priority, the extern templates have been removed alltogether with a preprocessor statement.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1945
https://github.com/root-project/root/pull/1945:877,availability,state,statement,877,"This PR is a reload of #1896 . All the work of @amadio is there + 2 workarounds for 2 problems:. 1) On Ubuntu 16, gcc 54, interpreted macros and prompt cannot autoload TVec<(unsigned) long long>. The autoload key is there, the autoload can be triggered e.g. with TClass::GetClass but somehow through interpreted code this does not work. The workaround consists in not declaring the TVec<long long> extern, therewith leaving it in the pch and have it working (the library by definition is not needed at the price of using that class w/o the optimisations of the compiled library in interpreted code). 2) Windows. MVCC has issues digesting all the templates. Since 6.14 is the first ROOT6 version working with Windows and performance through data paralellism made accessible by VecOps is not a top priority, the extern templates have been removed alltogether with a preprocessor statement.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1945
https://github.com/root-project/root/pull/1945:687,deployability,version,version,687,"This PR is a reload of #1896 . All the work of @amadio is there + 2 workarounds for 2 problems:. 1) On Ubuntu 16, gcc 54, interpreted macros and prompt cannot autoload TVec<(unsigned) long long>. The autoload key is there, the autoload can be triggered e.g. with TClass::GetClass but somehow through interpreted code this does not work. The workaround consists in not declaring the TVec<long long> extern, therewith leaving it in the pch and have it working (the library by definition is not needed at the price of using that class w/o the optimisations of the compiled library in interpreted code). 2) Windows. MVCC has issues digesting all the templates. Since 6.14 is the first ROOT6 version working with Windows and performance through data paralellism made accessible by VecOps is not a top priority, the extern templates have been removed alltogether with a preprocessor statement.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1945
https://github.com/root-project/root/pull/1945:540,energy efficiency,optim,optimisations,540,"This PR is a reload of #1896 . All the work of @amadio is there + 2 workarounds for 2 problems:. 1) On Ubuntu 16, gcc 54, interpreted macros and prompt cannot autoload TVec<(unsigned) long long>. The autoload key is there, the autoload can be triggered e.g. with TClass::GetClass but somehow through interpreted code this does not work. The workaround consists in not declaring the TVec<long long> extern, therewith leaving it in the pch and have it working (the library by definition is not needed at the price of using that class w/o the optimisations of the compiled library in interpreted code). 2) Windows. MVCC has issues digesting all the templates. Since 6.14 is the first ROOT6 version working with Windows and performance through data paralellism made accessible by VecOps is not a top priority, the extern templates have been removed alltogether with a preprocessor statement.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1945
https://github.com/root-project/root/pull/1945:687,integrability,version,version,687,"This PR is a reload of #1896 . All the work of @amadio is there + 2 workarounds for 2 problems:. 1) On Ubuntu 16, gcc 54, interpreted macros and prompt cannot autoload TVec<(unsigned) long long>. The autoload key is there, the autoload can be triggered e.g. with TClass::GetClass but somehow through interpreted code this does not work. The workaround consists in not declaring the TVec<long long> extern, therewith leaving it in the pch and have it working (the library by definition is not needed at the price of using that class w/o the optimisations of the compiled library in interpreted code). 2) Windows. MVCC has issues digesting all the templates. Since 6.14 is the first ROOT6 version working with Windows and performance through data paralellism made accessible by VecOps is not a top priority, the extern templates have been removed alltogether with a preprocessor statement.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1945
https://github.com/root-project/root/pull/1945:877,integrability,state,statement,877,"This PR is a reload of #1896 . All the work of @amadio is there + 2 workarounds for 2 problems:. 1) On Ubuntu 16, gcc 54, interpreted macros and prompt cannot autoload TVec<(unsigned) long long>. The autoload key is there, the autoload can be triggered e.g. with TClass::GetClass but somehow through interpreted code this does not work. The workaround consists in not declaring the TVec<long long> extern, therewith leaving it in the pch and have it working (the library by definition is not needed at the price of using that class w/o the optimisations of the compiled library in interpreted code). 2) Windows. MVCC has issues digesting all the templates. Since 6.14 is the first ROOT6 version working with Windows and performance through data paralellism made accessible by VecOps is not a top priority, the extern templates have been removed alltogether with a preprocessor statement.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1945
https://github.com/root-project/root/pull/1945:612,modifiability,MVC,MVCC,612,"This PR is a reload of #1896 . All the work of @amadio is there + 2 workarounds for 2 problems:. 1) On Ubuntu 16, gcc 54, interpreted macros and prompt cannot autoload TVec<(unsigned) long long>. The autoload key is there, the autoload can be triggered e.g. with TClass::GetClass but somehow through interpreted code this does not work. The workaround consists in not declaring the TVec<long long> extern, therewith leaving it in the pch and have it working (the library by definition is not needed at the price of using that class w/o the optimisations of the compiled library in interpreted code). 2) Windows. MVCC has issues digesting all the templates. Since 6.14 is the first ROOT6 version working with Windows and performance through data paralellism made accessible by VecOps is not a top priority, the extern templates have been removed alltogether with a preprocessor statement.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1945
https://github.com/root-project/root/pull/1945:687,modifiability,version,version,687,"This PR is a reload of #1896 . All the work of @amadio is there + 2 workarounds for 2 problems:. 1) On Ubuntu 16, gcc 54, interpreted macros and prompt cannot autoload TVec<(unsigned) long long>. The autoload key is there, the autoload can be triggered e.g. with TClass::GetClass but somehow through interpreted code this does not work. The workaround consists in not declaring the TVec<long long> extern, therewith leaving it in the pch and have it working (the library by definition is not needed at the price of using that class w/o the optimisations of the compiled library in interpreted code). 2) Windows. MVCC has issues digesting all the templates. Since 6.14 is the first ROOT6 version working with Windows and performance through data paralellism made accessible by VecOps is not a top priority, the extern templates have been removed alltogether with a preprocessor statement.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1945
https://github.com/root-project/root/pull/1945:720,performance,perform,performance,720,"This PR is a reload of #1896 . All the work of @amadio is there + 2 workarounds for 2 problems:. 1) On Ubuntu 16, gcc 54, interpreted macros and prompt cannot autoload TVec<(unsigned) long long>. The autoload key is there, the autoload can be triggered e.g. with TClass::GetClass but somehow through interpreted code this does not work. The workaround consists in not declaring the TVec<long long> extern, therewith leaving it in the pch and have it working (the library by definition is not needed at the price of using that class w/o the optimisations of the compiled library in interpreted code). 2) Windows. MVCC has issues digesting all the templates. Since 6.14 is the first ROOT6 version working with Windows and performance through data paralellism made accessible by VecOps is not a top priority, the extern templates have been removed alltogether with a preprocessor statement.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1945
https://github.com/root-project/root/pull/1945:322,reliability,doe,does,322,"This PR is a reload of #1896 . All the work of @amadio is there + 2 workarounds for 2 problems:. 1) On Ubuntu 16, gcc 54, interpreted macros and prompt cannot autoload TVec<(unsigned) long long>. The autoload key is there, the autoload can be triggered e.g. with TClass::GetClass but somehow through interpreted code this does not work. The workaround consists in not declaring the TVec<long long> extern, therewith leaving it in the pch and have it working (the library by definition is not needed at the price of using that class w/o the optimisations of the compiled library in interpreted code). 2) Windows. MVCC has issues digesting all the templates. Since 6.14 is the first ROOT6 version working with Windows and performance through data paralellism made accessible by VecOps is not a top priority, the extern templates have been removed alltogether with a preprocessor statement.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1945
https://github.com/root-project/root/pull/1945:762,security,access,accessible,762,"This PR is a reload of #1896 . All the work of @amadio is there + 2 workarounds for 2 problems:. 1) On Ubuntu 16, gcc 54, interpreted macros and prompt cannot autoload TVec<(unsigned) long long>. The autoload key is there, the autoload can be triggered e.g. with TClass::GetClass but somehow through interpreted code this does not work. The workaround consists in not declaring the TVec<long long> extern, therewith leaving it in the pch and have it working (the library by definition is not needed at the price of using that class w/o the optimisations of the compiled library in interpreted code). 2) Windows. MVCC has issues digesting all the templates. Since 6.14 is the first ROOT6 version working with Windows and performance through data paralellism made accessible by VecOps is not a top priority, the extern templates have been removed alltogether with a preprocessor statement.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1945
https://github.com/root-project/root/pull/1945:352,usability,consist,consists,352,"This PR is a reload of #1896 . All the work of @amadio is there + 2 workarounds for 2 problems:. 1) On Ubuntu 16, gcc 54, interpreted macros and prompt cannot autoload TVec<(unsigned) long long>. The autoload key is there, the autoload can be triggered e.g. with TClass::GetClass but somehow through interpreted code this does not work. The workaround consists in not declaring the TVec<long long> extern, therewith leaving it in the pch and have it working (the library by definition is not needed at the price of using that class w/o the optimisations of the compiled library in interpreted code). 2) Windows. MVCC has issues digesting all the templates. Since 6.14 is the first ROOT6 version working with Windows and performance through data paralellism made accessible by VecOps is not a top priority, the extern templates have been removed alltogether with a preprocessor statement.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1945
https://github.com/root-project/root/pull/1945:720,usability,perform,performance,720,"This PR is a reload of #1896 . All the work of @amadio is there + 2 workarounds for 2 problems:. 1) On Ubuntu 16, gcc 54, interpreted macros and prompt cannot autoload TVec<(unsigned) long long>. The autoload key is there, the autoload can be triggered e.g. with TClass::GetClass but somehow through interpreted code this does not work. The workaround consists in not declaring the TVec<long long> extern, therewith leaving it in the pch and have it working (the library by definition is not needed at the price of using that class w/o the optimisations of the compiled library in interpreted code). 2) Windows. MVCC has issues digesting all the templates. Since 6.14 is the first ROOT6 version working with Windows and performance through data paralellism made accessible by VecOps is not a top priority, the extern templates have been removed alltogether with a preprocessor statement.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1945
https://github.com/root-project/root/pull/1945:11,deployability,build,build,11,@phsft-bot build since you seem to be quite free at the moment.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1945
https://github.com/root-project/root/pull/1946:4,deployability,patch,patch,4,"The patch is straight-forward, but it is a shame that this requires new overloads in all inherited classes. I don't have a less intrusive alternative, but... Ideally, `MnApplication` should hold a smart pointer to `ModularFunctionMinimizer`, which is initialized with a concrete instance by each derived class. The method `Minimizer()` wouldn't be virtual and overloaded in each derived class. There could just be two normal methods in `MnApplication` for const and non-const access to the internal smart pointer. The `MnApplication` would get a modified constructor that accepts the raw pointer of `ModularFunctionMinimizer` created in each derived class. This would rid us of superfluous overloads, but would require even more line changes, because all constructors in all derived classes would have to be modified. So after all, the straight-forward solution is better.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1946
https://github.com/root-project/root/pull/1946:215,deployability,Modul,ModularFunctionMinimizer,215,"The patch is straight-forward, but it is a shame that this requires new overloads in all inherited classes. I don't have a less intrusive alternative, but... Ideally, `MnApplication` should hold a smart pointer to `ModularFunctionMinimizer`, which is initialized with a concrete instance by each derived class. The method `Minimizer()` wouldn't be virtual and overloaded in each derived class. There could just be two normal methods in `MnApplication` for const and non-const access to the internal smart pointer. The `MnApplication` would get a modified constructor that accepts the raw pointer of `ModularFunctionMinimizer` created in each derived class. This would rid us of superfluous overloads, but would require even more line changes, because all constructors in all derived classes would have to be modified. So after all, the straight-forward solution is better.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1946
https://github.com/root-project/root/pull/1946:600,deployability,Modul,ModularFunctionMinimizer,600,"The patch is straight-forward, but it is a shame that this requires new overloads in all inherited classes. I don't have a less intrusive alternative, but... Ideally, `MnApplication` should hold a smart pointer to `ModularFunctionMinimizer`, which is initialized with a concrete instance by each derived class. The method `Minimizer()` wouldn't be virtual and overloaded in each derived class. There could just be two normal methods in `MnApplication` for const and non-const access to the internal smart pointer. The `MnApplication` would get a modified constructor that accepts the raw pointer of `ModularFunctionMinimizer` created in each derived class. This would rid us of superfluous overloads, but would require even more line changes, because all constructors in all derived classes would have to be modified. So after all, the straight-forward solution is better.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1946
https://github.com/root-project/root/pull/1946:215,integrability,Modular,ModularFunctionMinimizer,215,"The patch is straight-forward, but it is a shame that this requires new overloads in all inherited classes. I don't have a less intrusive alternative, but... Ideally, `MnApplication` should hold a smart pointer to `ModularFunctionMinimizer`, which is initialized with a concrete instance by each derived class. The method `Minimizer()` wouldn't be virtual and overloaded in each derived class. There could just be two normal methods in `MnApplication` for const and non-const access to the internal smart pointer. The `MnApplication` would get a modified constructor that accepts the raw pointer of `ModularFunctionMinimizer` created in each derived class. This would rid us of superfluous overloads, but would require even more line changes, because all constructors in all derived classes would have to be modified. So after all, the straight-forward solution is better.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1946
https://github.com/root-project/root/pull/1946:600,integrability,Modular,ModularFunctionMinimizer,600,"The patch is straight-forward, but it is a shame that this requires new overloads in all inherited classes. I don't have a less intrusive alternative, but... Ideally, `MnApplication` should hold a smart pointer to `ModularFunctionMinimizer`, which is initialized with a concrete instance by each derived class. The method `Minimizer()` wouldn't be virtual and overloaded in each derived class. There could just be two normal methods in `MnApplication` for const and non-const access to the internal smart pointer. The `MnApplication` would get a modified constructor that accepts the raw pointer of `ModularFunctionMinimizer` created in each derived class. This would rid us of superfluous overloads, but would require even more line changes, because all constructors in all derived classes would have to be modified. So after all, the straight-forward solution is better.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1946
https://github.com/root-project/root/pull/1946:89,modifiability,inherit,inherited,89,"The patch is straight-forward, but it is a shame that this requires new overloads in all inherited classes. I don't have a less intrusive alternative, but... Ideally, `MnApplication` should hold a smart pointer to `ModularFunctionMinimizer`, which is initialized with a concrete instance by each derived class. The method `Minimizer()` wouldn't be virtual and overloaded in each derived class. There could just be two normal methods in `MnApplication` for const and non-const access to the internal smart pointer. The `MnApplication` would get a modified constructor that accepts the raw pointer of `ModularFunctionMinimizer` created in each derived class. This would rid us of superfluous overloads, but would require even more line changes, because all constructors in all derived classes would have to be modified. So after all, the straight-forward solution is better.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1946
https://github.com/root-project/root/pull/1946:215,modifiability,Modul,ModularFunctionMinimizer,215,"The patch is straight-forward, but it is a shame that this requires new overloads in all inherited classes. I don't have a less intrusive alternative, but... Ideally, `MnApplication` should hold a smart pointer to `ModularFunctionMinimizer`, which is initialized with a concrete instance by each derived class. The method `Minimizer()` wouldn't be virtual and overloaded in each derived class. There could just be two normal methods in `MnApplication` for const and non-const access to the internal smart pointer. The `MnApplication` would get a modified constructor that accepts the raw pointer of `ModularFunctionMinimizer` created in each derived class. This would rid us of superfluous overloads, but would require even more line changes, because all constructors in all derived classes would have to be modified. So after all, the straight-forward solution is better.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1946
https://github.com/root-project/root/pull/1946:600,modifiability,Modul,ModularFunctionMinimizer,600,"The patch is straight-forward, but it is a shame that this requires new overloads in all inherited classes. I don't have a less intrusive alternative, but... Ideally, `MnApplication` should hold a smart pointer to `ModularFunctionMinimizer`, which is initialized with a concrete instance by each derived class. The method `Minimizer()` wouldn't be virtual and overloaded in each derived class. There could just be two normal methods in `MnApplication` for const and non-const access to the internal smart pointer. The `MnApplication` would get a modified constructor that accepts the raw pointer of `ModularFunctionMinimizer` created in each derived class. This would rid us of superfluous overloads, but would require even more line changes, because all constructors in all derived classes would have to be modified. So after all, the straight-forward solution is better.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/1946
