id,quality_attribute,keyword,matched_word,match_idx,sentence,source,author,repo,version,wiki,url
https://github.com/root-project/root/pull/4583:32,usability,Error,Error,32,"The failure is unrelated:. ```. Error in <DavixOpen>: can not open file ""https://root.cern/files/tmva101.root"" with davix: Failure (Neon): Server certificate verification failed: issuer is not trusted after 3 attempts (6). ```",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4583
https://github.com/root-project/root/pull/4585:37,availability,error,error,37,"@Axel-Naumann . Actually, you create error. But let see if error will be seen on any platform.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4585
https://github.com/root-project/root/pull/4585:59,availability,error,error,59,"@Axel-Naumann . Actually, you create error. But let see if error will be seen on any platform.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4585
https://github.com/root-project/root/pull/4585:85,interoperability,platform,platform,85,"@Axel-Naumann . Actually, you create error. But let see if error will be seen on any platform.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4585
https://github.com/root-project/root/pull/4585:37,performance,error,error,37,"@Axel-Naumann . Actually, you create error. But let see if error will be seen on any platform.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4585
https://github.com/root-project/root/pull/4585:59,performance,error,error,59,"@Axel-Naumann . Actually, you create error. But let see if error will be seen on any platform.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4585
https://github.com/root-project/root/pull/4585:37,safety,error,error,37,"@Axel-Naumann . Actually, you create error. But let see if error will be seen on any platform.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4585
https://github.com/root-project/root/pull/4585:59,safety,error,error,59,"@Axel-Naumann . Actually, you create error. But let see if error will be seen on any platform.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4585
https://github.com/root-project/root/pull/4585:37,usability,error,error,37,"@Axel-Naumann . Actually, you create error. But let see if error will be seen on any platform.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4585
https://github.com/root-project/root/pull/4585:59,usability,error,error,59,"@Axel-Naumann . Actually, you create error. But let see if error will be seen on any platform.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4585
https://github.com/root-project/root/pull/4585:0,deployability,Build,Build,0,Build on Mac is green!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4585
https://github.com/root-project/root/pull/4585:16,energy efficiency,green,green,16,Build on Mac is green!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4585
https://github.com/root-project/root/pull/4585:49,availability,error,error,49,"Fedora30 failed due to stupid Jenkins connection error. OTOH, Mac has:. ```. 14:54:13 [7604/10184] Building CXX object gui/webdisplay/CMakeFiles/G__ROOTWebDisplay.dir/G__ROOTWebDisplay.cxx.o. 14:54:13 In file included from gui/webdisplay/G__ROOTWebDisplay.cxx:42:. 14:54:13 /build/jenkins/workspace/root-pullrequests-build/root/gui/webdisplay/inc/ROOT/RWebDisplayHandle.hxx:88:27: warning: unused parameter 'UNUSED' [-Wunused-parameter]. 14:54:13 std::string GetUrl(int UNUSED) const { return fUrl; }. 14:54:13 ^. 14:54:13 1 warning generated. ```. I need to fix the log parser.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4585
https://github.com/root-project/root/pull/4585:9,deployability,fail,failed,9,"Fedora30 failed due to stupid Jenkins connection error. OTOH, Mac has:. ```. 14:54:13 [7604/10184] Building CXX object gui/webdisplay/CMakeFiles/G__ROOTWebDisplay.dir/G__ROOTWebDisplay.cxx.o. 14:54:13 In file included from gui/webdisplay/G__ROOTWebDisplay.cxx:42:. 14:54:13 /build/jenkins/workspace/root-pullrequests-build/root/gui/webdisplay/inc/ROOT/RWebDisplayHandle.hxx:88:27: warning: unused parameter 'UNUSED' [-Wunused-parameter]. 14:54:13 std::string GetUrl(int UNUSED) const { return fUrl; }. 14:54:13 ^. 14:54:13 1 warning generated. ```. I need to fix the log parser.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4585
https://github.com/root-project/root/pull/4585:99,deployability,Build,Building,99,"Fedora30 failed due to stupid Jenkins connection error. OTOH, Mac has:. ```. 14:54:13 [7604/10184] Building CXX object gui/webdisplay/CMakeFiles/G__ROOTWebDisplay.dir/G__ROOTWebDisplay.cxx.o. 14:54:13 In file included from gui/webdisplay/G__ROOTWebDisplay.cxx:42:. 14:54:13 /build/jenkins/workspace/root-pullrequests-build/root/gui/webdisplay/inc/ROOT/RWebDisplayHandle.hxx:88:27: warning: unused parameter 'UNUSED' [-Wunused-parameter]. 14:54:13 std::string GetUrl(int UNUSED) const { return fUrl; }. 14:54:13 ^. 14:54:13 1 warning generated. ```. I need to fix the log parser.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4585
https://github.com/root-project/root/pull/4585:275,deployability,build,build,275,"Fedora30 failed due to stupid Jenkins connection error. OTOH, Mac has:. ```. 14:54:13 [7604/10184] Building CXX object gui/webdisplay/CMakeFiles/G__ROOTWebDisplay.dir/G__ROOTWebDisplay.cxx.o. 14:54:13 In file included from gui/webdisplay/G__ROOTWebDisplay.cxx:42:. 14:54:13 /build/jenkins/workspace/root-pullrequests-build/root/gui/webdisplay/inc/ROOT/RWebDisplayHandle.hxx:88:27: warning: unused parameter 'UNUSED' [-Wunused-parameter]. 14:54:13 std::string GetUrl(int UNUSED) const { return fUrl; }. 14:54:13 ^. 14:54:13 1 warning generated. ```. I need to fix the log parser.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4585
https://github.com/root-project/root/pull/4585:317,deployability,build,build,317,"Fedora30 failed due to stupid Jenkins connection error. OTOH, Mac has:. ```. 14:54:13 [7604/10184] Building CXX object gui/webdisplay/CMakeFiles/G__ROOTWebDisplay.dir/G__ROOTWebDisplay.cxx.o. 14:54:13 In file included from gui/webdisplay/G__ROOTWebDisplay.cxx:42:. 14:54:13 /build/jenkins/workspace/root-pullrequests-build/root/gui/webdisplay/inc/ROOT/RWebDisplayHandle.hxx:88:27: warning: unused parameter 'UNUSED' [-Wunused-parameter]. 14:54:13 std::string GetUrl(int UNUSED) const { return fUrl; }. 14:54:13 ^. 14:54:13 1 warning generated. ```. I need to fix the log parser.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4585
https://github.com/root-project/root/pull/4585:567,deployability,log,log,567,"Fedora30 failed due to stupid Jenkins connection error. OTOH, Mac has:. ```. 14:54:13 [7604/10184] Building CXX object gui/webdisplay/CMakeFiles/G__ROOTWebDisplay.dir/G__ROOTWebDisplay.cxx.o. 14:54:13 In file included from gui/webdisplay/G__ROOTWebDisplay.cxx:42:. 14:54:13 /build/jenkins/workspace/root-pullrequests-build/root/gui/webdisplay/inc/ROOT/RWebDisplayHandle.hxx:88:27: warning: unused parameter 'UNUSED' [-Wunused-parameter]. 14:54:13 std::string GetUrl(int UNUSED) const { return fUrl; }. 14:54:13 ^. 14:54:13 1 warning generated. ```. I need to fix the log parser.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4585
https://github.com/root-project/root/pull/4585:397,modifiability,paramet,parameter,397,"Fedora30 failed due to stupid Jenkins connection error. OTOH, Mac has:. ```. 14:54:13 [7604/10184] Building CXX object gui/webdisplay/CMakeFiles/G__ROOTWebDisplay.dir/G__ROOTWebDisplay.cxx.o. 14:54:13 In file included from gui/webdisplay/G__ROOTWebDisplay.cxx:42:. 14:54:13 /build/jenkins/workspace/root-pullrequests-build/root/gui/webdisplay/inc/ROOT/RWebDisplayHandle.hxx:88:27: warning: unused parameter 'UNUSED' [-Wunused-parameter]. 14:54:13 std::string GetUrl(int UNUSED) const { return fUrl; }. 14:54:13 ^. 14:54:13 1 warning generated. ```. I need to fix the log parser.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4585
https://github.com/root-project/root/pull/4585:426,modifiability,paramet,parameter,426,"Fedora30 failed due to stupid Jenkins connection error. OTOH, Mac has:. ```. 14:54:13 [7604/10184] Building CXX object gui/webdisplay/CMakeFiles/G__ROOTWebDisplay.dir/G__ROOTWebDisplay.cxx.o. 14:54:13 In file included from gui/webdisplay/G__ROOTWebDisplay.cxx:42:. 14:54:13 /build/jenkins/workspace/root-pullrequests-build/root/gui/webdisplay/inc/ROOT/RWebDisplayHandle.hxx:88:27: warning: unused parameter 'UNUSED' [-Wunused-parameter]. 14:54:13 std::string GetUrl(int UNUSED) const { return fUrl; }. 14:54:13 ^. 14:54:13 1 warning generated. ```. I need to fix the log parser.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4585
https://github.com/root-project/root/pull/4585:49,performance,error,error,49,"Fedora30 failed due to stupid Jenkins connection error. OTOH, Mac has:. ```. 14:54:13 [7604/10184] Building CXX object gui/webdisplay/CMakeFiles/G__ROOTWebDisplay.dir/G__ROOTWebDisplay.cxx.o. 14:54:13 In file included from gui/webdisplay/G__ROOTWebDisplay.cxx:42:. 14:54:13 /build/jenkins/workspace/root-pullrequests-build/root/gui/webdisplay/inc/ROOT/RWebDisplayHandle.hxx:88:27: warning: unused parameter 'UNUSED' [-Wunused-parameter]. 14:54:13 std::string GetUrl(int UNUSED) const { return fUrl; }. 14:54:13 ^. 14:54:13 1 warning generated. ```. I need to fix the log parser.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4585
https://github.com/root-project/root/pull/4585:9,reliability,fail,failed,9,"Fedora30 failed due to stupid Jenkins connection error. OTOH, Mac has:. ```. 14:54:13 [7604/10184] Building CXX object gui/webdisplay/CMakeFiles/G__ROOTWebDisplay.dir/G__ROOTWebDisplay.cxx.o. 14:54:13 In file included from gui/webdisplay/G__ROOTWebDisplay.cxx:42:. 14:54:13 /build/jenkins/workspace/root-pullrequests-build/root/gui/webdisplay/inc/ROOT/RWebDisplayHandle.hxx:88:27: warning: unused parameter 'UNUSED' [-Wunused-parameter]. 14:54:13 std::string GetUrl(int UNUSED) const { return fUrl; }. 14:54:13 ^. 14:54:13 1 warning generated. ```. I need to fix the log parser.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4585
https://github.com/root-project/root/pull/4585:49,safety,error,error,49,"Fedora30 failed due to stupid Jenkins connection error. OTOH, Mac has:. ```. 14:54:13 [7604/10184] Building CXX object gui/webdisplay/CMakeFiles/G__ROOTWebDisplay.dir/G__ROOTWebDisplay.cxx.o. 14:54:13 In file included from gui/webdisplay/G__ROOTWebDisplay.cxx:42:. 14:54:13 /build/jenkins/workspace/root-pullrequests-build/root/gui/webdisplay/inc/ROOT/RWebDisplayHandle.hxx:88:27: warning: unused parameter 'UNUSED' [-Wunused-parameter]. 14:54:13 std::string GetUrl(int UNUSED) const { return fUrl; }. 14:54:13 ^. 14:54:13 1 warning generated. ```. I need to fix the log parser.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4585
https://github.com/root-project/root/pull/4585:567,safety,log,log,567,"Fedora30 failed due to stupid Jenkins connection error. OTOH, Mac has:. ```. 14:54:13 [7604/10184] Building CXX object gui/webdisplay/CMakeFiles/G__ROOTWebDisplay.dir/G__ROOTWebDisplay.cxx.o. 14:54:13 In file included from gui/webdisplay/G__ROOTWebDisplay.cxx:42:. 14:54:13 /build/jenkins/workspace/root-pullrequests-build/root/gui/webdisplay/inc/ROOT/RWebDisplayHandle.hxx:88:27: warning: unused parameter 'UNUSED' [-Wunused-parameter]. 14:54:13 std::string GetUrl(int UNUSED) const { return fUrl; }. 14:54:13 ^. 14:54:13 1 warning generated. ```. I need to fix the log parser.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4585
https://github.com/root-project/root/pull/4585:567,security,log,log,567,"Fedora30 failed due to stupid Jenkins connection error. OTOH, Mac has:. ```. 14:54:13 [7604/10184] Building CXX object gui/webdisplay/CMakeFiles/G__ROOTWebDisplay.dir/G__ROOTWebDisplay.cxx.o. 14:54:13 In file included from gui/webdisplay/G__ROOTWebDisplay.cxx:42:. 14:54:13 /build/jenkins/workspace/root-pullrequests-build/root/gui/webdisplay/inc/ROOT/RWebDisplayHandle.hxx:88:27: warning: unused parameter 'UNUSED' [-Wunused-parameter]. 14:54:13 std::string GetUrl(int UNUSED) const { return fUrl; }. 14:54:13 ^. 14:54:13 1 warning generated. ```. I need to fix the log parser.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4585
https://github.com/root-project/root/pull/4585:567,testability,log,log,567,"Fedora30 failed due to stupid Jenkins connection error. OTOH, Mac has:. ```. 14:54:13 [7604/10184] Building CXX object gui/webdisplay/CMakeFiles/G__ROOTWebDisplay.dir/G__ROOTWebDisplay.cxx.o. 14:54:13 In file included from gui/webdisplay/G__ROOTWebDisplay.cxx:42:. 14:54:13 /build/jenkins/workspace/root-pullrequests-build/root/gui/webdisplay/inc/ROOT/RWebDisplayHandle.hxx:88:27: warning: unused parameter 'UNUSED' [-Wunused-parameter]. 14:54:13 std::string GetUrl(int UNUSED) const { return fUrl; }. 14:54:13 ^. 14:54:13 1 warning generated. ```. I need to fix the log parser.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4585
https://github.com/root-project/root/pull/4585:49,usability,error,error,49,"Fedora30 failed due to stupid Jenkins connection error. OTOH, Mac has:. ```. 14:54:13 [7604/10184] Building CXX object gui/webdisplay/CMakeFiles/G__ROOTWebDisplay.dir/G__ROOTWebDisplay.cxx.o. 14:54:13 In file included from gui/webdisplay/G__ROOTWebDisplay.cxx:42:. 14:54:13 /build/jenkins/workspace/root-pullrequests-build/root/gui/webdisplay/inc/ROOT/RWebDisplayHandle.hxx:88:27: warning: unused parameter 'UNUSED' [-Wunused-parameter]. 14:54:13 std::string GetUrl(int UNUSED) const { return fUrl; }. 14:54:13 ^. 14:54:13 1 warning generated. ```. I need to fix the log parser.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4585
https://github.com/root-project/root/pull/4585:43,interoperability,platform,platform,43,"We need one Mac, one Linux and one Windows platform where root7 always on.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4585
https://github.com/root-project/root/pull/4585:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4585
https://github.com/root-project/root/pull/4585:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4585
https://github.com/root-project/root/pull/4585:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4585
https://github.com/root-project/root/pull/4585:45,interoperability,platform,platform,45,"> We need one Mac, one Linux and one Windows platform where root7 always on. That's what we now have.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4585
https://github.com/root-project/root/pull/4585:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4585
https://github.com/root-project/root/pull/4586:17,usability,confirm,confirm,17,@lmoneta Can you confirm that this is actually not a bug?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4586
https://github.com/root-project/root/pull/4586:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4586
https://github.com/root-project/root/pull/4587:17,usability,confirm,confirm,17,@lmoneta Can you confirm that this is actually not a bug?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4587
https://github.com/root-project/root/pull/4588:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4588
https://github.com/root-project/root/pull/4588:50,availability,failur,failures,50,"The 32 bit build seems stall. I do not expect any failures as there is no cuda there, too.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4588
https://github.com/root-project/root/pull/4588:11,deployability,build,build,11,"The 32 bit build seems stall. I do not expect any failures as there is no cuda there, too.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4588
https://github.com/root-project/root/pull/4588:50,deployability,fail,failures,50,"The 32 bit build seems stall. I do not expect any failures as there is no cuda there, too.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4588
https://github.com/root-project/root/pull/4588:50,performance,failur,failures,50,"The 32 bit build seems stall. I do not expect any failures as there is no cuda there, too.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4588
https://github.com/root-project/root/pull/4588:50,reliability,fail,failures,50,"The 32 bit build seems stall. I do not expect any failures as there is no cuda there, too.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4588
https://github.com/root-project/root/pull/4591:300,safety,review,review,300,"I really want to use SplittApp. And with GeometryViewer it works in most cases ok. https://linev.github.io/geomCMS/. There is difference with RBrowser, where SplitApp make double scrollbars? Now also we have too much PRs around. We need to merge them together. Bertrand, can you ask @Axel-Naumann to review #4555 .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:300,testability,review,review,300,"I really want to use SplittApp. And with GeometryViewer it works in most cases ok. https://linev.github.io/geomCMS/. There is difference with RBrowser, where SplitApp make double scrollbars? Now also we have too much PRs around. We need to merge them together. Bertrand, can you ask @Axel-Naumann to review #4555 .",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:125,availability,Sla,Slack,125,"I want too, but actually it make the TreeTable one row more than it should, and break the breadcrumbs. I sended a message on Slack to have help from SAP, but i still have no answer. As soon as i have free time, or an answer i will try to find a solution, and apply it back. But i believe that for the user experience, it is better to have the Splitter, more than the two scrollbars, and the nor usable breadcrumbs. This is a temporary fix until we can debug the SplitApp",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:114,integrability,messag,message,114,"I want too, but actually it make the TreeTable one row more than it should, and break the breadcrumbs. I sended a message on Slack to have help from SAP, but i still have no answer. As soon as i have free time, or an answer i will try to find a solution, and apply it back. But i believe that for the user experience, it is better to have the Splitter, more than the two scrollbars, and the nor usable breadcrumbs. This is a temporary fix until we can debug the SplitApp",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:114,interoperability,messag,message,114,"I want too, but actually it make the TreeTable one row more than it should, and break the breadcrumbs. I sended a message on Slack to have help from SAP, but i still have no answer. As soon as i have free time, or an answer i will try to find a solution, and apply it back. But i believe that for the user experience, it is better to have the Splitter, more than the two scrollbars, and the nor usable breadcrumbs. This is a temporary fix until we can debug the SplitApp",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:205,performance,time,time,205,"I want too, but actually it make the TreeTable one row more than it should, and break the breadcrumbs. I sended a message on Slack to have help from SAP, but i still have no answer. As soon as i have free time, or an answer i will try to find a solution, and apply it back. But i believe that for the user experience, it is better to have the Splitter, more than the two scrollbars, and the nor usable breadcrumbs. This is a temporary fix until we can debug the SplitApp",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:125,reliability,Sla,Slack,125,"I want too, but actually it make the TreeTable one row more than it should, and break the breadcrumbs. I sended a message on Slack to have help from SAP, but i still have no answer. As soon as i have free time, or an answer i will try to find a solution, and apply it back. But i believe that for the user experience, it is better to have the Splitter, more than the two scrollbars, and the nor usable breadcrumbs. This is a temporary fix until we can debug the SplitApp",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:139,usability,help,help,139,"I want too, but actually it make the TreeTable one row more than it should, and break the breadcrumbs. I sended a message on Slack to have help from SAP, but i still have no answer. As soon as i have free time, or an answer i will try to find a solution, and apply it back. But i believe that for the user experience, it is better to have the Splitter, more than the two scrollbars, and the nor usable breadcrumbs. This is a temporary fix until we can debug the SplitApp",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:301,usability,user,user,301,"I want too, but actually it make the TreeTable one row more than it should, and break the breadcrumbs. I sended a message on Slack to have help from SAP, but i still have no answer. As soon as i have free time, or an answer i will try to find a solution, and apply it back. But i believe that for the user experience, it is better to have the Splitter, more than the two scrollbars, and the nor usable breadcrumbs. This is a temporary fix until we can debug the SplitApp",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:306,usability,experien,experience,306,"I want too, but actually it make the TreeTable one row more than it should, and break the breadcrumbs. I sended a message on Slack to have help from SAP, but i still have no answer. As soon as i have free time, or an answer i will try to find a solution, and apply it back. But i believe that for the user experience, it is better to have the Splitter, more than the two scrollbars, and the nor usable breadcrumbs. This is a temporary fix until we can debug the SplitApp",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:395,usability,usab,usable,395,"I want too, but actually it make the TreeTable one row more than it should, and break the breadcrumbs. I sended a message on Slack to have help from SAP, but i still have no answer. As soon as i have free time, or an answer i will try to find a solution, and apply it back. But i believe that for the user experience, it is better to have the Splitter, more than the two scrollbars, and the nor usable breadcrumbs. This is a temporary fix until we can debug the SplitApp",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:413,availability,sla,slack,413,"> I want too, but actually it make the TreeTable one row more than it should, and break the breadcrumbs. You say that Breadcrumbs and TreeTable cannot be combined correctly? Can you create standalone example on jsbin.com demonstrating effect? It does not need to be fully functional - just SplitApp, Breadcrumbs, TreeTable to see effect. I guess, it is the only proper way to get help from openui5 developers. On slack.com chat you will find several examples how openui5-based design can be created",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:246,reliability,doe,does,246,"> I want too, but actually it make the TreeTable one row more than it should, and break the breadcrumbs. You say that Breadcrumbs and TreeTable cannot be combined correctly? Can you create standalone example on jsbin.com demonstrating effect? It does not need to be fully functional - just SplitApp, Breadcrumbs, TreeTable to see effect. I guess, it is the only proper way to get help from openui5 developers. On slack.com chat you will find several examples how openui5-based design can be created",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:413,reliability,sla,slack,413,"> I want too, but actually it make the TreeTable one row more than it should, and break the breadcrumbs. You say that Breadcrumbs and TreeTable cannot be combined correctly? Can you create standalone example on jsbin.com demonstrating effect? It does not need to be fully functional - just SplitApp, Breadcrumbs, TreeTable to see effect. I guess, it is the only proper way to get help from openui5 developers. On slack.com chat you will find several examples how openui5-based design can be created",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:380,usability,help,help,380,"> I want too, but actually it make the TreeTable one row more than it should, and break the breadcrumbs. You say that Breadcrumbs and TreeTable cannot be combined correctly? Can you create standalone example on jsbin.com demonstrating effect? It does not need to be fully functional - just SplitApp, Breadcrumbs, TreeTable to see effect. I guess, it is the only proper way to get help from openui5 developers. On slack.com chat you will find several examples how openui5-based design can be created",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:87,usability,behavi,behaviour,87,"No, they ca be combined correctly, but the master page of the SplitApp has a different behaviour than the normal splitter. And so i make the breadcrumbs and the option visibleRowCountMode=""Auto"" of the TreeTable not working correctly. I will try to make a JSFiddle then",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:159,usability,experien,experience,159,"I would add that if the issue with SplitApp & TreeTable & Breadcrumb cannot be fixed before CHEP, better switch back to Split View, in order to offer a better experience to the users, otherwise we shoot ourselves in the foot...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:177,usability,user,users,177,"I would add that if the issue with SplitApp & TreeTable & Breadcrumb cannot be fixed before CHEP, better switch back to Split View, in order to offer a better experience to the users, otherwise we shoot ourselves in the foot...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:31,interoperability,Specif,Specify,31,"There is very simple solution. Specify for master page:. ```. enableScrolling=""false"". ```. Scrolling should be ok then",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:14,testability,simpl,simple,14,"There is very simple solution. Specify for master page:. ```. enableScrolling=""false"". ```. Scrolling should be ok then",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:14,usability,simpl,simple,14,"There is very simple solution. Specify for master page:. ```. enableScrolling=""false"". ```. Scrolling should be ok then",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:54,reliability,doe,does,54,> Scrolling should be ok then. Mostly ok... TreeTable does not correctly calculate number of visible lines. This should be reported to openui5 forums to get help - for that we need jsbin.com example.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:157,usability,help,help,157,> Scrolling should be ok then. Mostly ok... TreeTable does not correctly calculate number of visible lines. This should be reported to openui5 forums to get help - for that we need jsbin.com example.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:688,deployability,contain,container,688,"Just tried the enable scrolling, and at first try :. `<masterPages id=""myMaster"" enableScrolling=""false"">`. it is not working unfortunately. Event if it was it will cut a row in half like on this screenshot. ![Capture d’écran 2019-10-29 à 13 16 49](https://user-images.githubusercontent.com/16002227/67766412-aab6a380-fa4e-11e9-9757-252cf8062ee4.png). I believe that the problems is because the UI5 Table visibleRowCountMode option auto has on the documentation the following limitations: . > **Limitations**. > * All rows need to have the same height. > * The table must be rendered without siblings in its parent DOM element. The only exception is if the parent element is a CSS flex container, and the table is a CSS flex item allowed to grow and shrink. And that the SplitApp broke something about the parent container. But adding a flex container on top of it did no solve the problem when i tried last time",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:815,deployability,contain,container,815,"Just tried the enable scrolling, and at first try :. `<masterPages id=""myMaster"" enableScrolling=""false"">`. it is not working unfortunately. Event if it was it will cut a row in half like on this screenshot. ![Capture d’écran 2019-10-29 à 13 16 49](https://user-images.githubusercontent.com/16002227/67766412-aab6a380-fa4e-11e9-9757-252cf8062ee4.png). I believe that the problems is because the UI5 Table visibleRowCountMode option auto has on the documentation the following limitations: . > **Limitations**. > * All rows need to have the same height. > * The table must be rendered without siblings in its parent DOM element. The only exception is if the parent element is a CSS flex container, and the table is a CSS flex item allowed to grow and shrink. And that the SplitApp broke something about the parent container. But adding a flex container on top of it did no solve the problem when i tried last time",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:844,deployability,contain,container,844,"Just tried the enable scrolling, and at first try :. `<masterPages id=""myMaster"" enableScrolling=""false"">`. it is not working unfortunately. Event if it was it will cut a row in half like on this screenshot. ![Capture d’écran 2019-10-29 à 13 16 49](https://user-images.githubusercontent.com/16002227/67766412-aab6a380-fa4e-11e9-9757-252cf8062ee4.png). I believe that the problems is because the UI5 Table visibleRowCountMode option auto has on the documentation the following limitations: . > **Limitations**. > * All rows need to have the same height. > * The table must be rendered without siblings in its parent DOM element. The only exception is if the parent element is a CSS flex container, and the table is a CSS flex item allowed to grow and shrink. And that the SplitApp broke something about the parent container. But adding a flex container on top of it did no solve the problem when i tried last time",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:141,integrability,Event,Event,141,"Just tried the enable scrolling, and at first try :. `<masterPages id=""myMaster"" enableScrolling=""false"">`. it is not working unfortunately. Event if it was it will cut a row in half like on this screenshot. ![Capture d’écran 2019-10-29 à 13 16 49](https://user-images.githubusercontent.com/16002227/67766412-aab6a380-fa4e-11e9-9757-252cf8062ee4.png). I believe that the problems is because the UI5 Table visibleRowCountMode option auto has on the documentation the following limitations: . > **Limitations**. > * All rows need to have the same height. > * The table must be rendered without siblings in its parent DOM element. The only exception is if the parent element is a CSS flex container, and the table is a CSS flex item allowed to grow and shrink. And that the SplitApp broke something about the parent container. But adding a flex container on top of it did no solve the problem when i tried last time",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:910,performance,time,time,910,"Just tried the enable scrolling, and at first try :. `<masterPages id=""myMaster"" enableScrolling=""false"">`. it is not working unfortunately. Event if it was it will cut a row in half like on this screenshot. ![Capture d’écran 2019-10-29 à 13 16 49](https://user-images.githubusercontent.com/16002227/67766412-aab6a380-fa4e-11e9-9757-252cf8062ee4.png). I believe that the problems is because the UI5 Table visibleRowCountMode option auto has on the documentation the following limitations: . > **Limitations**. > * All rows need to have the same height. > * The table must be rendered without siblings in its parent DOM element. The only exception is if the parent element is a CSS flex container, and the table is a CSS flex item allowed to grow and shrink. And that the SplitApp broke something about the parent container. But adding a flex container on top of it did no solve the problem when i tried last time",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:639,safety,except,exception,639,"Just tried the enable scrolling, and at first try :. `<masterPages id=""myMaster"" enableScrolling=""false"">`. it is not working unfortunately. Event if it was it will cut a row in half like on this screenshot. ![Capture d’écran 2019-10-29 à 13 16 49](https://user-images.githubusercontent.com/16002227/67766412-aab6a380-fa4e-11e9-9757-252cf8062ee4.png). I believe that the problems is because the UI5 Table visibleRowCountMode option auto has on the documentation the following limitations: . > **Limitations**. > * All rows need to have the same height. > * The table must be rendered without siblings in its parent DOM element. The only exception is if the parent element is a CSS flex container, and the table is a CSS flex item allowed to grow and shrink. And that the SplitApp broke something about the parent container. But adding a flex container on top of it did no solve the problem when i tried last time",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:259,usability,user,user-images,259,"Just tried the enable scrolling, and at first try :. `<masterPages id=""myMaster"" enableScrolling=""false"">`. it is not working unfortunately. Event if it was it will cut a row in half like on this screenshot. ![Capture d’écran 2019-10-29 à 13 16 49](https://user-images.githubusercontent.com/16002227/67766412-aab6a380-fa4e-11e9-9757-252cf8062ee4.png). I believe that the problems is because the UI5 Table visibleRowCountMode option auto has on the documentation the following limitations: . > **Limitations**. > * All rows need to have the same height. > * The table must be rendered without siblings in its parent DOM element. The only exception is if the parent element is a CSS flex container, and the table is a CSS flex item allowed to grow and shrink. And that the SplitApp broke something about the parent container. But adding a flex container on top of it did no solve the problem when i tried last time",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:450,usability,document,documentation,450,"Just tried the enable scrolling, and at first try :. `<masterPages id=""myMaster"" enableScrolling=""false"">`. it is not working unfortunately. Event if it was it will cut a row in half like on this screenshot. ![Capture d’écran 2019-10-29 à 13 16 49](https://user-images.githubusercontent.com/16002227/67766412-aab6a380-fa4e-11e9-9757-252cf8062ee4.png). I believe that the problems is because the UI5 Table visibleRowCountMode option auto has on the documentation the following limitations: . > **Limitations**. > * All rows need to have the same height. > * The table must be rendered without siblings in its parent DOM element. The only exception is if the parent element is a CSS flex container, and the table is a CSS flex item allowed to grow and shrink. And that the SplitApp broke something about the parent container. But adding a flex container on top of it did no solve the problem when i tried last time",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:190,deployability,contain,container,190,"enableScrolling=""false"" just solves double scrolling bars. > The table must be rendered without siblings in its parent DOM element. The only exception is if the parent element is a CSS flex container, and the table is a CSS flex item allowed to grow and shrink. This should be possible to solve. Now TreeTable just included as item in the content list of the Page (not allowed according docu). One should place container (like VBox or Panel) and find proper setting for container first",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:411,deployability,contain,container,411,"enableScrolling=""false"" just solves double scrolling bars. > The table must be rendered without siblings in its parent DOM element. The only exception is if the parent element is a CSS flex container, and the table is a CSS flex item allowed to grow and shrink. This should be possible to solve. Now TreeTable just included as item in the content list of the Page (not allowed according docu). One should place container (like VBox or Panel) and find proper setting for container first",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:470,deployability,contain,container,470,"enableScrolling=""false"" just solves double scrolling bars. > The table must be rendered without siblings in its parent DOM element. The only exception is if the parent element is a CSS flex container, and the table is a CSS flex item allowed to grow and shrink. This should be possible to solve. Now TreeTable just included as item in the content list of the Page (not allowed according docu). One should place container (like VBox or Panel) and find proper setting for container first",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:339,performance,content,content,339,"enableScrolling=""false"" just solves double scrolling bars. > The table must be rendered without siblings in its parent DOM element. The only exception is if the parent element is a CSS flex container, and the table is a CSS flex item allowed to grow and shrink. This should be possible to solve. Now TreeTable just included as item in the content list of the Page (not allowed according docu). One should place container (like VBox or Panel) and find proper setting for container first",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:141,safety,except,exception,141,"enableScrolling=""false"" just solves double scrolling bars. > The table must be rendered without siblings in its parent DOM element. The only exception is if the parent element is a CSS flex container, and the table is a CSS flex item allowed to grow and shrink. This should be possible to solve. Now TreeTable just included as item in the content list of the Page (not allowed according docu). One should place container (like VBox or Panel) and find proper setting for container first",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4591:23,usability,user,user-images,23,![browser_now](https://user-images.githubusercontent.com/4936580/67773304-ca07fd80-fa5b-11e9-9246-1655b3a75465.png). Here how browser looks now,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4591
https://github.com/root-project/root/pull/4592:5,availability,error,errors,5,Same errors observed in dummy 6.14-based PR: https://github.com/root-project/root/pull/4595. Concluding they are unrelated with the changes of this PR. Merging.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4592
https://github.com/root-project/root/pull/4592:12,deployability,observ,observed,12,Same errors observed in dummy 6.14-based PR: https://github.com/root-project/root/pull/4595. Concluding they are unrelated with the changes of this PR. Merging.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4592
https://github.com/root-project/root/pull/4592:5,performance,error,errors,5,Same errors observed in dummy 6.14-based PR: https://github.com/root-project/root/pull/4595. Concluding they are unrelated with the changes of this PR. Merging.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4592
https://github.com/root-project/root/pull/4592:5,safety,error,errors,5,Same errors observed in dummy 6.14-based PR: https://github.com/root-project/root/pull/4595. Concluding they are unrelated with the changes of this PR. Merging.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4592
https://github.com/root-project/root/pull/4592:12,testability,observ,observed,12,Same errors observed in dummy 6.14-based PR: https://github.com/root-project/root/pull/4595. Concluding they are unrelated with the changes of this PR. Merging.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4592
https://github.com/root-project/root/pull/4592:5,usability,error,errors,5,Same errors observed in dummy 6.14-based PR: https://github.com/root-project/root/pull/4595. Concluding they are unrelated with the changes of this PR. Merging.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4592
https://github.com/root-project/root/pull/4593:11,deployability,build,build,11,@phsft-bot build just on mac1014/cxx17,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4593
https://github.com/root-project/root/pull/4596:11,deployability,build,build,11,@phsft-bot build with `-Dpyroot_experimental=ON`,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4596
https://github.com/root-project/root/pull/4596:11,deployability,build,build,11,@phsft-bot build with -Dpyroot_experimental=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4596
https://github.com/root-project/root/pull/4596:56,deployability,modul,modularization,56,I'll write later a Jira ticket so that we follow up the modularization going towards 6.22.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4596
https://github.com/root-project/root/pull/4596:56,integrability,modular,modularization,56,I'll write later a Jira ticket so that we follow up the modularization going towards 6.22.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4596
https://github.com/root-project/root/pull/4596:56,modifiability,modul,modularization,56,I'll write later a Jira ticket so that we follow up the modularization going towards 6.22.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4596
https://github.com/root-project/root/pull/4596:56,safety,modul,modularization,56,I'll write later a Jira ticket so that we follow up the modularization going towards 6.22.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4596
https://github.com/root-project/root/pull/4596:56,testability,modula,modularization,56,I'll write later a Jira ticket so that we follow up the modularization going towards 6.22.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4596
https://github.com/root-project/root/pull/4596:11,deployability,build,build,11,@phsft-bot build with `-Dpyroot_experimental=ON -Ddataframe=OFF`,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4596
https://github.com/root-project/root/pull/4596:11,deployability,build,build,11,@phsft-bot build with -Dpyroot_experimental=ON -Ddataframe=OFF,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4596
https://github.com/root-project/root/pull/4596:11,deployability,build,build,11,@phsft-bot build with `-Dpyroot_experimental=ON -Ddataframe=OFF`,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4596
https://github.com/root-project/root/pull/4597:98,availability,error,error,98,"This solves problem on my desktop, where config like:. ```. c.NotebookApp.ip = '*'. ```. Leads to error when starting notebook.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4597
https://github.com/root-project/root/pull/4597:98,performance,error,error,98,"This solves problem on my desktop, where config like:. ```. c.NotebookApp.ip = '*'. ```. Leads to error when starting notebook.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4597
https://github.com/root-project/root/pull/4597:98,safety,error,error,98,"This solves problem on my desktop, where config like:. ```. c.NotebookApp.ip = '*'. ```. Leads to error when starting notebook.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4597
https://github.com/root-project/root/pull/4597:98,usability,error,error,98,"This solves problem on my desktop, where config like:. ```. c.NotebookApp.ip = '*'. ```. Leads to error when starting notebook.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4597
https://github.com/root-project/root/pull/4597:312,deployability,configurat,configuration,312,"Thanks for the PR, I believe it would be better to make this more generic and just forward any argument after `root --notebook` to jupyter, not only `--ip` or `localhost`. I guess that if we just forward the arguments to Jupyter, then it will take into account our argument over what is specified in the Jupyter configuration file (although I am not 100% sure).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4597
https://github.com/root-project/root/pull/4597:312,integrability,configur,configuration,312,"Thanks for the PR, I believe it would be better to make this more generic and just forward any argument after `root --notebook` to jupyter, not only `--ip` or `localhost`. I guess that if we just forward the arguments to Jupyter, then it will take into account our argument over what is specified in the Jupyter configuration file (although I am not 100% sure).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4597
https://github.com/root-project/root/pull/4597:287,interoperability,specif,specified,287,"Thanks for the PR, I believe it would be better to make this more generic and just forward any argument after `root --notebook` to jupyter, not only `--ip` or `localhost`. I guess that if we just forward the arguments to Jupyter, then it will take into account our argument over what is specified in the Jupyter configuration file (although I am not 100% sure).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4597
https://github.com/root-project/root/pull/4597:312,modifiability,configur,configuration,312,"Thanks for the PR, I believe it would be better to make this more generic and just forward any argument after `root --notebook` to jupyter, not only `--ip` or `localhost`. I guess that if we just forward the arguments to Jupyter, then it will take into account our argument over what is specified in the Jupyter configuration file (although I am not 100% sure).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4597
https://github.com/root-project/root/pull/4597:312,security,configur,configuration,312,"Thanks for the PR, I believe it would be better to make this more generic and just forward any argument after `root --notebook` to jupyter, not only `--ip` or `localhost`. I guess that if we just forward the arguments to Jupyter, then it will take into account our argument over what is specified in the Jupyter configuration file (although I am not 100% sure).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4597
https://github.com/root-project/root/pull/4597:145,deployability,configurat,configuration,145,"> I guess that if we just forward the arguments to Jupyter, then it will take into account our argument. > over what is specified in the Jupyter configuration file (although I am not 100% sure). Yes, this also works. Now I just forward all args to jupyter executable. For me it still works when starting:. ```. root --notebook --ip=hostname. ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4597
https://github.com/root-project/root/pull/4597:145,integrability,configur,configuration,145,"> I guess that if we just forward the arguments to Jupyter, then it will take into account our argument. > over what is specified in the Jupyter configuration file (although I am not 100% sure). Yes, this also works. Now I just forward all args to jupyter executable. For me it still works when starting:. ```. root --notebook --ip=hostname. ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4597
https://github.com/root-project/root/pull/4597:120,interoperability,specif,specified,120,"> I guess that if we just forward the arguments to Jupyter, then it will take into account our argument. > over what is specified in the Jupyter configuration file (although I am not 100% sure). Yes, this also works. Now I just forward all args to jupyter executable. For me it still works when starting:. ```. root --notebook --ip=hostname. ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4597
https://github.com/root-project/root/pull/4597:145,modifiability,configur,configuration,145,"> I guess that if we just forward the arguments to Jupyter, then it will take into account our argument. > over what is specified in the Jupyter configuration file (although I am not 100% sure). Yes, this also works. Now I just forward all args to jupyter executable. For me it still works when starting:. ```. root --notebook --ip=hostname. ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4597
https://github.com/root-project/root/pull/4597:145,security,configur,configuration,145,"> I guess that if we just forward the arguments to Jupyter, then it will take into account our argument. > over what is specified in the Jupyter configuration file (although I am not 100% sure). Yes, this also works. Now I just forward all args to jupyter executable. For me it still works when starting:. ```. root --notebook --ip=hostname. ```.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4597
https://github.com/root-project/root/pull/4597:70,deployability,version,version,70,"@etejedor . As I see, `c.NotebookApp.ip = '*'` was introduced in 6.16 version for those who wants have external access to the notebook. Maybe, it is not a good idea to have it by default. This that PR one could just do it explicitly. . I rather prefer to remove such option from default settings.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4597
https://github.com/root-project/root/pull/4597:70,integrability,version,version,70,"@etejedor . As I see, `c.NotebookApp.ip = '*'` was introduced in 6.16 version for those who wants have external access to the notebook. Maybe, it is not a good idea to have it by default. This that PR one could just do it explicitly. . I rather prefer to remove such option from default settings.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4597
https://github.com/root-project/root/pull/4597:70,modifiability,version,version,70,"@etejedor . As I see, `c.NotebookApp.ip = '*'` was introduced in 6.16 version for those who wants have external access to the notebook. Maybe, it is not a good idea to have it by default. This that PR one could just do it explicitly. . I rather prefer to remove such option from default settings.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4597
https://github.com/root-project/root/pull/4597:112,security,access,access,112,"@etejedor . As I see, `c.NotebookApp.ip = '*'` was introduced in 6.16 version for those who wants have external access to the notebook. Maybe, it is not a good idea to have it by default. This that PR one could just do it explicitly. . I rather prefer to remove such option from default settings.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4597
https://github.com/root-project/root/pull/4597:245,usability,prefer,prefer,245,"@etejedor . As I see, `c.NotebookApp.ip = '*'` was introduced in 6.16 version for those who wants have external access to the notebook. Maybe, it is not a good idea to have it by default. This that PR one could just do it explicitly. . I rather prefer to remove such option from default settings.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4597
https://github.com/root-project/root/pull/4597:178,deployability,version,versions,178,"I agree, since this PR makes it possible to override options, the user has the possibility to set the ip themselves. That would also alleviate issues of people using the Jupyter versions with the bug that prevents parsing the option.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4597
https://github.com/root-project/root/pull/4597:178,integrability,version,versions,178,"I agree, since this PR makes it possible to override options, the user has the possibility to set the ip themselves. That would also alleviate issues of people using the Jupyter versions with the bug that prevents parsing the option.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4597
https://github.com/root-project/root/pull/4597:178,modifiability,version,versions,178,"I agree, since this PR makes it possible to override options, the user has the possibility to set the ip themselves. That would also alleviate issues of people using the Jupyter versions with the bug that prevents parsing the option.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4597
https://github.com/root-project/root/pull/4597:205,safety,prevent,prevents,205,"I agree, since this PR makes it possible to override options, the user has the possibility to set the ip themselves. That would also alleviate issues of people using the Jupyter versions with the bug that prevents parsing the option.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4597
https://github.com/root-project/root/pull/4597:205,security,preven,prevents,205,"I agree, since this PR makes it possible to override options, the user has the possibility to set the ip themselves. That would also alleviate issues of people using the Jupyter versions with the bug that prevents parsing the option.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4597
https://github.com/root-project/root/pull/4597:66,usability,user,user,66,"I agree, since this PR makes it possible to override options, the user has the possibility to set the ip themselves. That would also alleviate issues of people using the Jupyter versions with the bug that prevents parsing the option.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4597
https://github.com/root-project/root/pull/4597:68,deployability,releas,release,68,"Ok, I remove it from default options and add few more comments into release notes",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4597
https://github.com/root-project/root/pull/4597:43,availability,failur,failures,43,@etejedor Can we merge it now? All Jenkins failures has nothing to do with the PR,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4597
https://github.com/root-project/root/pull/4597:43,deployability,fail,failures,43,@etejedor Can we merge it now? All Jenkins failures has nothing to do with the PR,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4597
https://github.com/root-project/root/pull/4597:43,performance,failur,failures,43,@etejedor Can we merge it now? All Jenkins failures has nothing to do with the PR,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4597
https://github.com/root-project/root/pull/4597:43,reliability,fail,failures,43,@etejedor Can we merge it now? All Jenkins failures has nothing to do with the PR,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4597
https://github.com/root-project/root/pull/4598:72,deployability,build,builds,72,@Falcort Now it is really working as designed. I will merge it once all builds are completed. There are many items to improve - I will send you list via email,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4598
https://github.com/root-project/root/pull/4598:83,safety,compl,completed,83,@Falcort Now it is really working as designed. I will merge it once all builds are completed. There are many items to improve - I will send you list via email,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4598
https://github.com/root-project/root/pull/4598:83,security,compl,completed,83,@Falcort Now it is really working as designed. I will merge it once all builds are completed. There are many items to improve - I will send you list via email,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4598
https://github.com/root-project/root/pull/4598:21,deployability,log,log,21,Finally less console.log output !,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4598
https://github.com/root-project/root/pull/4598:21,safety,log,log,21,Finally less console.log output !,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4598
https://github.com/root-project/root/pull/4598:21,security,log,log,21,Finally less console.log output !,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4598
https://github.com/root-project/root/pull/4598:21,testability,log,log,21,Finally less console.log output !,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4598
https://github.com/root-project/root/pull/4600:40,safety,test,tested,40,"I merge it, while ui5/js code cannot be tested through Jenkins",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4600
https://github.com/root-project/root/pull/4600:40,testability,test,tested,40,"I merge it, while ui5/js code cannot be tested through Jenkins",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4600
https://github.com/root-project/root/pull/4603:11,deployability,build,build,11,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4603
https://github.com/root-project/root/pull/4603:12,availability,error,error,12,"The mac1014 error on macphsft17 is due the difference of opinion between XCode 11, MacOS 10.14 and CMake on which version and what part of python to use ....",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4603
https://github.com/root-project/root/pull/4603:114,deployability,version,version,114,"The mac1014 error on macphsft17 is due the difference of opinion between XCode 11, MacOS 10.14 and CMake on which version and what part of python to use ....",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4603
https://github.com/root-project/root/pull/4603:114,integrability,version,version,114,"The mac1014 error on macphsft17 is due the difference of opinion between XCode 11, MacOS 10.14 and CMake on which version and what part of python to use ....",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4603
https://github.com/root-project/root/pull/4603:114,modifiability,version,version,114,"The mac1014 error on macphsft17 is due the difference of opinion between XCode 11, MacOS 10.14 and CMake on which version and what part of python to use ....",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4603
https://github.com/root-project/root/pull/4603:12,performance,error,error,12,"The mac1014 error on macphsft17 is due the difference of opinion between XCode 11, MacOS 10.14 and CMake on which version and what part of python to use ....",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4603
https://github.com/root-project/root/pull/4603:12,safety,error,error,12,"The mac1014 error on macphsft17 is due the difference of opinion between XCode 11, MacOS 10.14 and CMake on which version and what part of python to use ....",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4603
https://github.com/root-project/root/pull/4603:12,usability,error,error,12,"The mac1014 error on macphsft17 is due the difference of opinion between XCode 11, MacOS 10.14 and CMake on which version and what part of python to use ....",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4603
https://github.com/root-project/root/pull/4605:11,deployability,build,build,11,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4605
https://github.com/root-project/root/pull/4605:4,availability,failur,failure,4,the failure on macos is the python/cmake/xcode11,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4605
https://github.com/root-project/root/pull/4605:4,deployability,fail,failure,4,the failure on macos is the python/cmake/xcode11,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4605
https://github.com/root-project/root/pull/4605:4,performance,failur,failure,4,the failure on macos is the python/cmake/xcode11,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4605
https://github.com/root-project/root/pull/4605:4,reliability,fail,failure,4,the failure on macos is the python/cmake/xcode11,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4605
https://github.com/root-project/root/pull/4606:0,availability,Error,Error,0,Error in python executable setup. It seems irrelevant for this pr.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4606
https://github.com/root-project/root/pull/4606:0,performance,Error,Error,0,Error in python executable setup. It seems irrelevant for this pr.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4606
https://github.com/root-project/root/pull/4606:0,safety,Error,Error,0,Error in python executable setup. It seems irrelevant for this pr.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4606
https://github.com/root-project/root/pull/4606:0,usability,Error,Error,0,Error in python executable setup. It seems irrelevant for this pr.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4606
https://github.com/root-project/root/pull/4609:0,availability,Error,Errors,0,Errors are unrelated. Merging...,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4609
https://github.com/root-project/root/pull/4609:0,performance,Error,Errors,0,Errors are unrelated. Merging...,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4609
https://github.com/root-project/root/pull/4609:0,safety,Error,Errors,0,Errors are unrelated. Merging...,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4609
https://github.com/root-project/root/pull/4609:0,usability,Error,Errors,0,Errors are unrelated. Merging...,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4609
https://github.com/root-project/root/pull/4612:0,availability,Failur,Failure,0,Failure on Ubuntu is caused by unrelated warning.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4612
https://github.com/root-project/root/pull/4612:0,deployability,Fail,Failure,0,Failure on Ubuntu is caused by unrelated warning.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4612
https://github.com/root-project/root/pull/4612:0,performance,Failur,Failure,0,Failure on Ubuntu is caused by unrelated warning.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4612
https://github.com/root-project/root/pull/4612:0,reliability,Fail,Failure,0,Failure on Ubuntu is caused by unrelated warning.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4612
https://github.com/root-project/root/pull/4613:86,integrability,event,event,86,"This is still in prototype phase, i have troubles with attributing functions to press event of buttons. But this is a proof of concept",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4613
https://github.com/root-project/root/pull/4613:17,usability,prototyp,prototype,17,"This is still in prototype phase, i have troubles with attributing functions to press event of buttons. But this is a proof of concept",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4613
https://github.com/root-project/root/pull/4613:61,deployability,stack,stackoverflow,61,"@Falcort . Please check information from this link:. https://stackoverflow.com/questions/39660161/how-to-access-elements-from-xml-fragment-by-id. Seems to be, one can use IDs in the fragment without bit limitations. Regards,. Sergey",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4613
https://github.com/root-project/root/pull/4613:126,interoperability,xml,xml-fragment-by-id,126,"@Falcort . Please check information from this link:. https://stackoverflow.com/questions/39660161/how-to-access-elements-from-xml-fragment-by-id. Seems to be, one can use IDs in the fragment without bit limitations. Regards,. Sergey",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4613
https://github.com/root-project/root/pull/4613:105,security,access,access-elements-from-xml-fragment-by-id,105,"@Falcort . Please check information from this link:. https://stackoverflow.com/questions/39660161/how-to-access-elements-from-xml-fragment-by-id. Seems to be, one can use IDs in the fragment without bit limitations. Regards,. Sergey",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4613
https://github.com/root-project/root/pull/4613:624,deployability,updat,update,624,"This tell you how you can select an ID which is inside a fragment, as it is not as doing something is the main page. But this does not help you to duplicate ID, or select sub element in a fragment. This also tell you that you can use prefix for fragment, but it is not recommended to uses that. And almost everything in the post is depreciated. it is also saied : . - Avoid concatenating ID parts or relying on the syntax of the global ID, as mentioned in the comment as well as in the documentation . . Which is in favor of my solution, not relying on UI5 gobalID but on custom generated ones that will never change in any update",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4613
https://github.com/root-project/root/pull/4613:171,integrability,sub,sub,171,"This tell you how you can select an ID which is inside a fragment, as it is not as doing something is the main page. But this does not help you to duplicate ID, or select sub element in a fragment. This also tell you that you can use prefix for fragment, but it is not recommended to uses that. And almost everything in the post is depreciated. it is also saied : . - Avoid concatenating ID parts or relying on the syntax of the global ID, as mentioned in the comment as well as in the documentation . . Which is in favor of my solution, not relying on UI5 gobalID but on custom generated ones that will never change in any update",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4613
https://github.com/root-project/root/pull/4613:126,reliability,doe,does,126,"This tell you how you can select an ID which is inside a fragment, as it is not as doing something is the main page. But this does not help you to duplicate ID, or select sub element in a fragment. This also tell you that you can use prefix for fragment, but it is not recommended to uses that. And almost everything in the post is depreciated. it is also saied : . - Avoid concatenating ID parts or relying on the syntax of the global ID, as mentioned in the comment as well as in the documentation . . Which is in favor of my solution, not relying on UI5 gobalID but on custom generated ones that will never change in any update",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4613
https://github.com/root-project/root/pull/4613:368,safety,Avoid,Avoid,368,"This tell you how you can select an ID which is inside a fragment, as it is not as doing something is the main page. But this does not help you to duplicate ID, or select sub element in a fragment. This also tell you that you can use prefix for fragment, but it is not recommended to uses that. And almost everything in the post is depreciated. it is also saied : . - Avoid concatenating ID parts or relying on the syntax of the global ID, as mentioned in the comment as well as in the documentation . . Which is in favor of my solution, not relying on UI5 gobalID but on custom generated ones that will never change in any update",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4613
https://github.com/root-project/root/pull/4613:624,safety,updat,update,624,"This tell you how you can select an ID which is inside a fragment, as it is not as doing something is the main page. But this does not help you to duplicate ID, or select sub element in a fragment. This also tell you that you can use prefix for fragment, but it is not recommended to uses that. And almost everything in the post is depreciated. it is also saied : . - Avoid concatenating ID parts or relying on the syntax of the global ID, as mentioned in the comment as well as in the documentation . . Which is in favor of my solution, not relying on UI5 gobalID but on custom generated ones that will never change in any update",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4613
https://github.com/root-project/root/pull/4613:624,security,updat,update,624,"This tell you how you can select an ID which is inside a fragment, as it is not as doing something is the main page. But this does not help you to duplicate ID, or select sub element in a fragment. This also tell you that you can use prefix for fragment, but it is not recommended to uses that. And almost everything in the post is depreciated. it is also saied : . - Avoid concatenating ID parts or relying on the syntax of the global ID, as mentioned in the comment as well as in the documentation . . Which is in favor of my solution, not relying on UI5 gobalID but on custom generated ones that will never change in any update",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4613
https://github.com/root-project/root/pull/4613:135,usability,help,help,135,"This tell you how you can select an ID which is inside a fragment, as it is not as doing something is the main page. But this does not help you to duplicate ID, or select sub element in a fragment. This also tell you that you can use prefix for fragment, but it is not recommended to uses that. And almost everything in the post is depreciated. it is also saied : . - Avoid concatenating ID parts or relying on the syntax of the global ID, as mentioned in the comment as well as in the documentation . . Which is in favor of my solution, not relying on UI5 gobalID but on custom generated ones that will never change in any update",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4613
https://github.com/root-project/root/pull/4613:486,usability,document,documentation,486,"This tell you how you can select an ID which is inside a fragment, as it is not as doing something is the main page. But this does not help you to duplicate ID, or select sub element in a fragment. This also tell you that you can use prefix for fragment, but it is not recommended to uses that. And almost everything in the post is depreciated. it is also saied : . - Avoid concatenating ID parts or relying on the syntax of the global ID, as mentioned in the comment as well as in the documentation . . Which is in favor of my solution, not relying on UI5 gobalID but on custom generated ones that will never change in any update",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4613
https://github.com/root-project/root/pull/4613:572,usability,custom,custom,572,"This tell you how you can select an ID which is inside a fragment, as it is not as doing something is the main page. But this does not help you to duplicate ID, or select sub element in a fragment. This also tell you that you can use prefix for fragment, but it is not recommended to uses that. And almost everything in the post is depreciated. it is also saied : . - Avoid concatenating ID parts or relying on the syntax of the global ID, as mentioned in the comment as well as in the documentation . . Which is in favor of my solution, not relying on UI5 gobalID but on custom generated ones that will never change in any update",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4613
https://github.com/root-project/root/pull/4613:358,availability,repair,repair,358,"@linev my last commit is the code editor fully completed with my solution. On the diff i think you should be able to see all the improvements it does. It also a lot of abstraction to the code, creating possibilities for function that can be used across all element created by my function, like the function getElementFromCurrentTab(). I have also started to repair the indentations of the different functions, and cleaned the imports. Could you please have a new look ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4613
https://github.com/root-project/root/pull/4613:168,integrability,abstract,abstraction,168,"@linev my last commit is the code editor fully completed with my solution. On the diff i think you should be able to see all the improvements it does. It also a lot of abstraction to the code, creating possibilities for function that can be used across all element created by my function, like the function getElementFromCurrentTab(). I have also started to repair the indentations of the different functions, and cleaned the imports. Could you please have a new look ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4613
https://github.com/root-project/root/pull/4613:168,modifiability,abstract,abstraction,168,"@linev my last commit is the code editor fully completed with my solution. On the diff i think you should be able to see all the improvements it does. It also a lot of abstraction to the code, creating possibilities for function that can be used across all element created by my function, like the function getElementFromCurrentTab(). I have also started to repair the indentations of the different functions, and cleaned the imports. Could you please have a new look ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4613
https://github.com/root-project/root/pull/4613:145,reliability,doe,does,145,"@linev my last commit is the code editor fully completed with my solution. On the diff i think you should be able to see all the improvements it does. It also a lot of abstraction to the code, creating possibilities for function that can be used across all element created by my function, like the function getElementFromCurrentTab(). I have also started to repair the indentations of the different functions, and cleaned the imports. Could you please have a new look ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4613
https://github.com/root-project/root/pull/4613:358,reliability,repair,repair,358,"@linev my last commit is the code editor fully completed with my solution. On the diff i think you should be able to see all the improvements it does. It also a lot of abstraction to the code, creating possibilities for function that can be used across all element created by my function, like the function getElementFromCurrentTab(). I have also started to repair the indentations of the different functions, and cleaned the imports. Could you please have a new look ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4613
https://github.com/root-project/root/pull/4613:47,safety,compl,completed,47,"@linev my last commit is the code editor fully completed with my solution. On the diff i think you should be able to see all the improvements it does. It also a lot of abstraction to the code, creating possibilities for function that can be used across all element created by my function, like the function getElementFromCurrentTab(). I have also started to repair the indentations of the different functions, and cleaned the imports. Could you please have a new look ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4613
https://github.com/root-project/root/pull/4613:47,security,compl,completed,47,"@linev my last commit is the code editor fully completed with my solution. On the diff i think you should be able to see all the improvements it does. It also a lot of abstraction to the code, creating possibilities for function that can be used across all element created by my function, like the function getElementFromCurrentTab(). I have also started to repair the indentations of the different functions, and cleaned the imports. Could you please have a new look ?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4613
https://github.com/root-project/root/pull/4613:49,safety,compl,complete,49,"@linev I have rebased with master and this PR is complete. I still need to remove the bad selectors for the TreeTable, but this is an other story, and i can do it in an other PR. So if you want to merge, you can !",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4613
https://github.com/root-project/root/pull/4613:49,security,compl,complete,49,"@linev I have rebased with master and this PR is complete. I still need to remove the bad selectors for the TreeTable, but this is an other story, and i can do it in an other PR. So if you want to merge, you can !",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4613
https://github.com/root-project/root/pull/4613:57,security,access,access,57,"I merge your PR, next two days I will be out of Internet access",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4613
https://github.com/root-project/root/pull/4614:71,integrability,coupl,couple,71,"Could you add some documentation on the algorithms being used (there a couple of ""same as ABC"" that could at least use some references)? In particular without reading carefully the code, I am not sure how the case with (min, max, number of bits) is handled. Thanks.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4614
https://github.com/root-project/root/pull/4614:71,modifiability,coupl,couple,71,"Could you add some documentation on the algorithms being used (there a couple of ""same as ABC"" that could at least use some references)? In particular without reading carefully the code, I am not sure how the case with (min, max, number of bits) is handled. Thanks.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4614
https://github.com/root-project/root/pull/4614:71,testability,coupl,couple,71,"Could you add some documentation on the algorithms being used (there a couple of ""same as ABC"" that could at least use some references)? In particular without reading carefully the code, I am not sure how the case with (min, max, number of bits) is handled. Thanks.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4614
https://github.com/root-project/root/pull/4614:19,usability,document,documentation,19,"Could you add some documentation on the algorithms being used (there a couple of ""same as ABC"" that could at least use some references)? In particular without reading carefully the code, I am not sure how the case with (min, max, number of bits) is handled. Thanks.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4614
https://github.com/root-project/root/pull/4614:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4614
https://github.com/root-project/root/pull/4615:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4615
https://github.com/root-project/root/pull/4615:47,safety,test,tests,47,Thanks for this contribution. Can you also add tests for this (new) feature? Thanks.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4615
https://github.com/root-project/root/pull/4615:47,testability,test,tests,47,Thanks for this contribution. Can you also add tests for this (new) feature? Thanks.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4615
https://github.com/root-project/root/pull/4615:519,interoperability,specif,specific,519,"Thanks for looking at my pull request. I initially only tested a few root files that all had the same histograms. Now, when I try to hadd files with histograms with different names, it crashes with:. `Fatal in <TFileMerger::RecursiveRemove>: Output file of the TFile Merger (targeting bla3.root) has been deleted (likely due to a TTree larger than 100Gb)`. I will return when I have fiddled some more with it. Unfortunately for this request, I have solved the issue that prompted this work by chaining `rootcp` for the specific folders to temp. files and `hadd`ing them.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4615
https://github.com/root-project/root/pull/4615:56,safety,test,tested,56,"Thanks for looking at my pull request. I initially only tested a few root files that all had the same histograms. Now, when I try to hadd files with histograms with different names, it crashes with:. `Fatal in <TFileMerger::RecursiveRemove>: Output file of the TFile Merger (targeting bla3.root) has been deleted (likely due to a TTree larger than 100Gb)`. I will return when I have fiddled some more with it. Unfortunately for this request, I have solved the issue that prompted this work by chaining `rootcp` for the specific folders to temp. files and `hadd`ing them.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4615
https://github.com/root-project/root/pull/4615:56,testability,test,tested,56,"Thanks for looking at my pull request. I initially only tested a few root files that all had the same histograms. Now, when I try to hadd files with histograms with different names, it crashes with:. `Fatal in <TFileMerger::RecursiveRemove>: Output file of the TFile Merger (targeting bla3.root) has been deleted (likely due to a TTree larger than 100Gb)`. I will return when I have fiddled some more with it. Unfortunately for this request, I have solved the issue that prompted this work by chaining `rootcp` for the specific folders to temp. files and `hadd`ing them.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4615
https://github.com/root-project/root/pull/4616:186,availability,error,errors,186,@SimeonEhrig you said (in https://github.com/root-project/cling/pull/284#issuecomment-545871201 ). > I have removed the part of the code that requires changes to the clang base. Yet the errors above seem to come from a missing llvm patch. Could you clarify?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4616
https://github.com/root-project/root/pull/4616:232,deployability,patch,patch,232,@SimeonEhrig you said (in https://github.com/root-project/cling/pull/284#issuecomment-545871201 ). > I have removed the part of the code that requires changes to the clang base. Yet the errors above seem to come from a missing llvm patch. Could you clarify?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4616
https://github.com/root-project/root/pull/4616:142,modifiability,requires chang,requires changes,142,@SimeonEhrig you said (in https://github.com/root-project/cling/pull/284#issuecomment-545871201 ). > I have removed the part of the code that requires changes to the clang base. Yet the errors above seem to come from a missing llvm patch. Could you clarify?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4616
https://github.com/root-project/root/pull/4616:186,performance,error,errors,186,@SimeonEhrig you said (in https://github.com/root-project/cling/pull/284#issuecomment-545871201 ). > I have removed the part of the code that requires changes to the clang base. Yet the errors above seem to come from a missing llvm patch. Could you clarify?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4616
https://github.com/root-project/root/pull/4616:186,safety,error,errors,186,@SimeonEhrig you said (in https://github.com/root-project/cling/pull/284#issuecomment-545871201 ). > I have removed the part of the code that requires changes to the clang base. Yet the errors above seem to come from a missing llvm patch. Could you clarify?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4616
https://github.com/root-project/root/pull/4616:232,safety,patch,patch,232,@SimeonEhrig you said (in https://github.com/root-project/cling/pull/284#issuecomment-545871201 ). > I have removed the part of the code that requires changes to the clang base. Yet the errors above seem to come from a missing llvm patch. Could you clarify?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4616
https://github.com/root-project/root/pull/4616:232,security,patch,patch,232,@SimeonEhrig you said (in https://github.com/root-project/cling/pull/284#issuecomment-545871201 ). > I have removed the part of the code that requires changes to the clang base. Yet the errors above seem to come from a missing llvm patch. Could you clarify?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4616
https://github.com/root-project/root/pull/4616:186,usability,error,errors,186,@SimeonEhrig you said (in https://github.com/root-project/cling/pull/284#issuecomment-545871201 ). > I have removed the part of the code that requires changes to the clang base. Yet the errors above seem to come from a missing llvm patch. Could you clarify?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4616
https://github.com/root-project/root/pull/4616:236,availability,error,errors,236,"> @SimeonEhrig you said (in [root-project/cling#284 (comment)](https://github.com/root-project/cling/pull/284#issuecomment-545871201) ). > . > > I have removed the part of the code that requires changes to the clang base. > . > Yet the errors above seem to come from a missing llvm patch. Could you clarify? I've removed any part that requires changes to the Clang base. The error occurs because the nvptx is not enabled. I'm not familiar with the root build process, so I need a little time to check it.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4616
https://github.com/root-project/root/pull/4616:375,availability,error,error,375,"> @SimeonEhrig you said (in [root-project/cling#284 (comment)](https://github.com/root-project/cling/pull/284#issuecomment-545871201) ). > . > > I have removed the part of the code that requires changes to the clang base. > . > Yet the errors above seem to come from a missing llvm patch. Could you clarify? I've removed any part that requires changes to the Clang base. The error occurs because the nvptx is not enabled. I'm not familiar with the root build process, so I need a little time to check it.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4616
https://github.com/root-project/root/pull/4616:282,deployability,patch,patch,282,"> @SimeonEhrig you said (in [root-project/cling#284 (comment)](https://github.com/root-project/cling/pull/284#issuecomment-545871201) ). > . > > I have removed the part of the code that requires changes to the clang base. > . > Yet the errors above seem to come from a missing llvm patch. Could you clarify? I've removed any part that requires changes to the Clang base. The error occurs because the nvptx is not enabled. I'm not familiar with the root build process, so I need a little time to check it.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4616
https://github.com/root-project/root/pull/4616:453,deployability,build,build,453,"> @SimeonEhrig you said (in [root-project/cling#284 (comment)](https://github.com/root-project/cling/pull/284#issuecomment-545871201) ). > . > > I have removed the part of the code that requires changes to the clang base. > . > Yet the errors above seem to come from a missing llvm patch. Could you clarify? I've removed any part that requires changes to the Clang base. The error occurs because the nvptx is not enabled. I'm not familiar with the root build process, so I need a little time to check it.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4616
https://github.com/root-project/root/pull/4616:186,modifiability,requires chang,requires changes,186,"> @SimeonEhrig you said (in [root-project/cling#284 (comment)](https://github.com/root-project/cling/pull/284#issuecomment-545871201) ). > . > > I have removed the part of the code that requires changes to the clang base. > . > Yet the errors above seem to come from a missing llvm patch. Could you clarify? I've removed any part that requires changes to the Clang base. The error occurs because the nvptx is not enabled. I'm not familiar with the root build process, so I need a little time to check it.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4616
https://github.com/root-project/root/pull/4616:335,modifiability,requires chang,requires changes,335,"> @SimeonEhrig you said (in [root-project/cling#284 (comment)](https://github.com/root-project/cling/pull/284#issuecomment-545871201) ). > . > > I have removed the part of the code that requires changes to the clang base. > . > Yet the errors above seem to come from a missing llvm patch. Could you clarify? I've removed any part that requires changes to the Clang base. The error occurs because the nvptx is not enabled. I'm not familiar with the root build process, so I need a little time to check it.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4616
https://github.com/root-project/root/pull/4616:236,performance,error,errors,236,"> @SimeonEhrig you said (in [root-project/cling#284 (comment)](https://github.com/root-project/cling/pull/284#issuecomment-545871201) ). > . > > I have removed the part of the code that requires changes to the clang base. > . > Yet the errors above seem to come from a missing llvm patch. Could you clarify? I've removed any part that requires changes to the Clang base. The error occurs because the nvptx is not enabled. I'm not familiar with the root build process, so I need a little time to check it.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4616
https://github.com/root-project/root/pull/4616:375,performance,error,error,375,"> @SimeonEhrig you said (in [root-project/cling#284 (comment)](https://github.com/root-project/cling/pull/284#issuecomment-545871201) ). > . > > I have removed the part of the code that requires changes to the clang base. > . > Yet the errors above seem to come from a missing llvm patch. Could you clarify? I've removed any part that requires changes to the Clang base. The error occurs because the nvptx is not enabled. I'm not familiar with the root build process, so I need a little time to check it.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4616
https://github.com/root-project/root/pull/4616:487,performance,time,time,487,"> @SimeonEhrig you said (in [root-project/cling#284 (comment)](https://github.com/root-project/cling/pull/284#issuecomment-545871201) ). > . > > I have removed the part of the code that requires changes to the clang base. > . > Yet the errors above seem to come from a missing llvm patch. Could you clarify? I've removed any part that requires changes to the Clang base. The error occurs because the nvptx is not enabled. I'm not familiar with the root build process, so I need a little time to check it.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4616
https://github.com/root-project/root/pull/4616:236,safety,error,errors,236,"> @SimeonEhrig you said (in [root-project/cling#284 (comment)](https://github.com/root-project/cling/pull/284#issuecomment-545871201) ). > . > > I have removed the part of the code that requires changes to the clang base. > . > Yet the errors above seem to come from a missing llvm patch. Could you clarify? I've removed any part that requires changes to the Clang base. The error occurs because the nvptx is not enabled. I'm not familiar with the root build process, so I need a little time to check it.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4616
https://github.com/root-project/root/pull/4616:282,safety,patch,patch,282,"> @SimeonEhrig you said (in [root-project/cling#284 (comment)](https://github.com/root-project/cling/pull/284#issuecomment-545871201) ). > . > > I have removed the part of the code that requires changes to the clang base. > . > Yet the errors above seem to come from a missing llvm patch. Could you clarify? I've removed any part that requires changes to the Clang base. The error occurs because the nvptx is not enabled. I'm not familiar with the root build process, so I need a little time to check it.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4616
https://github.com/root-project/root/pull/4616:375,safety,error,error,375,"> @SimeonEhrig you said (in [root-project/cling#284 (comment)](https://github.com/root-project/cling/pull/284#issuecomment-545871201) ). > . > > I have removed the part of the code that requires changes to the clang base. > . > Yet the errors above seem to come from a missing llvm patch. Could you clarify? I've removed any part that requires changes to the Clang base. The error occurs because the nvptx is not enabled. I'm not familiar with the root build process, so I need a little time to check it.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4616
https://github.com/root-project/root/pull/4616:282,security,patch,patch,282,"> @SimeonEhrig you said (in [root-project/cling#284 (comment)](https://github.com/root-project/cling/pull/284#issuecomment-545871201) ). > . > > I have removed the part of the code that requires changes to the clang base. > . > Yet the errors above seem to come from a missing llvm patch. Could you clarify? I've removed any part that requires changes to the Clang base. The error occurs because the nvptx is not enabled. I'm not familiar with the root build process, so I need a little time to check it.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4616
https://github.com/root-project/root/pull/4616:236,usability,error,errors,236,"> @SimeonEhrig you said (in [root-project/cling#284 (comment)](https://github.com/root-project/cling/pull/284#issuecomment-545871201) ). > . > > I have removed the part of the code that requires changes to the clang base. > . > Yet the errors above seem to come from a missing llvm patch. Could you clarify? I've removed any part that requires changes to the Clang base. The error occurs because the nvptx is not enabled. I'm not familiar with the root build process, so I need a little time to check it.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4616
https://github.com/root-project/root/pull/4616:375,usability,error,error,375,"> @SimeonEhrig you said (in [root-project/cling#284 (comment)](https://github.com/root-project/cling/pull/284#issuecomment-545871201) ). > . > > I have removed the part of the code that requires changes to the clang base. > . > Yet the errors above seem to come from a missing llvm patch. Could you clarify? I've removed any part that requires changes to the Clang base. The error occurs because the nvptx is not enabled. I'm not familiar with the root build process, so I need a little time to check it.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4616
https://github.com/root-project/root/pull/4616:153,availability,error,error,153,"I have developed a solution to enable the NVPTX backend in Root by default. I have also implemented a check in the CMakeLists.txt of Cling that throw an error if the NVPTX backend is not enabled. Unfortunately, I don't know how to push commits to this PR, so I forked your repo and modified the PR-284 branch: https://github.com/SimeonEhrig/root/tree/PR-284. **Attention:** I have removed the last commit of your branch.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4616
https://github.com/root-project/root/pull/4616:153,performance,error,error,153,"I have developed a solution to enable the NVPTX backend in Root by default. I have also implemented a check in the CMakeLists.txt of Cling that throw an error if the NVPTX backend is not enabled. Unfortunately, I don't know how to push commits to this PR, so I forked your repo and modified the PR-284 branch: https://github.com/SimeonEhrig/root/tree/PR-284. **Attention:** I have removed the last commit of your branch.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4616
https://github.com/root-project/root/pull/4616:153,safety,error,error,153,"I have developed a solution to enable the NVPTX backend in Root by default. I have also implemented a check in the CMakeLists.txt of Cling that throw an error if the NVPTX backend is not enabled. Unfortunately, I don't know how to push commits to this PR, so I forked your repo and modified the PR-284 branch: https://github.com/SimeonEhrig/root/tree/PR-284. **Attention:** I have removed the last commit of your branch.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4616
https://github.com/root-project/root/pull/4616:282,security,modif,modified,282,"I have developed a solution to enable the NVPTX backend in Root by default. I have also implemented a check in the CMakeLists.txt of Cling that throw an error if the NVPTX backend is not enabled. Unfortunately, I don't know how to push commits to this PR, so I forked your repo and modified the PR-284 branch: https://github.com/SimeonEhrig/root/tree/PR-284. **Attention:** I have removed the last commit of your branch.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4616
https://github.com/root-project/root/pull/4616:153,usability,error,error,153,"I have developed a solution to enable the NVPTX backend in Root by default. I have also implemented a check in the CMakeLists.txt of Cling that throw an error if the NVPTX backend is not enabled. Unfortunately, I don't know how to push commits to this PR, so I forked your repo and modified the PR-284 branch: https://github.com/SimeonEhrig/root/tree/PR-284. **Attention:** I have removed the last commit of your branch.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4616
https://github.com/root-project/root/pull/4616:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4616
https://github.com/root-project/root/pull/4617:19,integrability,sub,submit,19,"Hi @alja,. Can you submit PR with alja/clientResolve-1 branch? It would be more informative to have separate commits in the repository.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4617
https://github.com/root-project/root/pull/4617:124,integrability,repositor,repository,124,"Hi @alja,. Can you submit PR with alja/clientResolve-1 branch? It would be more informative to have separate commits in the repository.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4617
https://github.com/root-project/root/pull/4617:124,interoperability,repositor,repository,124,"Hi @alja,. Can you submit PR with alja/clientResolve-1 branch? It would be more informative to have separate commits in the repository.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4617
https://github.com/root-project/root/pull/4617:88,modifiability,interm,intermediate,88,Can we please just merge this rebase? There really isn't much use for the development / intermediate commits.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4617
https://github.com/root-project/root/pull/4618:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:29,deployability,build,build,29,"@Axel-Naumann Now, it should build it.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:68,deployability,build,build,68,@SimeonEhrig please fork also roottest to fix the `windows10/cxx14` build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:34,integrability,repositor,repository,34,@bellenot I forked the `roottest` repository. Is that enough or do I have to do additional things?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:34,interoperability,repositor,repository,34,@bellenot I forked the `roottest` repository. Is that enough or do I have to do additional things?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:36,integrability,repositor,repository,36,"> @bellenot I forked the `roottest` repository. Is that enough or do I have to do additional things? @SimeonEhrig That should be enough, thanks!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:36,interoperability,repositor,repository,36,"> @bellenot I forked the `roottest` repository. Is that enough or do I have to do additional things? @SimeonEhrig That should be enough, thanks!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:180,availability,Error,Error,180,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:356,availability,error,errors,356,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:664,availability,Error,Error,664,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:156,deployability,fail,fails,156,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:465,deployability,build,build,465,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:494,deployability,log,log,494,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:592,deployability,build,build,592,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:620,deployability,log,log,620,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:227,integrability,messag,message,227,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:332,integrability,Configur,Configuring,332,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:227,interoperability,messag,message,227,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:332,modifiability,Configur,Configuring,332,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:99,performance,perform,performance-,99,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:180,performance,Error,Error,180,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:356,performance,error,errors,356,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:422,performance,perform,performance-,422,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:549,performance,perform,performance-,549,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:664,performance,Error,Error,664,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:156,reliability,fail,fails,156,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:180,safety,Error,Error,180,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:356,safety,error,errors,356,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:494,safety,log,log,494,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:620,safety,log,log,620,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:664,safety,Error,Error,664,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:332,security,Configur,Configuring,332,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:494,security,log,log,494,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:620,security,log,log,620,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:494,testability,log,log,494,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:620,testability,log,log,620,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:99,usability,perform,performance-,99,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:180,usability,Error,Error,180,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:356,usability,error,errors,356,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:422,usability,perform,performance-,422,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:549,usability,perform,performance-,549,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:664,usability,Error,Error,664,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4618:673,usability,Command,Command,673,"The incremental, for example: https://epsft-jenkins.cern.ch/job/root-incremental-master/LABEL=ROOT-performance-centos7-multicore,SPEC=default/8204/console. fails with:. ```. CMake Error at interpreter/cling/CMakeLists.txt:178 (message):. NVPTX backend is not activated. Please enable it via -DLLVM_TARGETS_TO_BUILD=""host;NVPTX"". -- Configuring incomplete, errors occurred! See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeOutput.log"". See also ""/data/sftnight/wsincrmaster/LABEL/ROOT-performance-centos7-multicore/SPEC/default/build/CMakeFiles/CMakeError.log"". gmake: *** [cmake_check_build_system] Error 1. Command exited with the value: 2. ```. What is the best solution?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4618
https://github.com/root-project/root/pull/4620:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4620
https://github.com/root-project/root/pull/4620:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4620
https://github.com/root-project/root/pull/4624:11,deployability,build,build,11,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4624
https://github.com/root-project/root/pull/4624:11,deployability,build,build,11,@phsft-bot build just on mac1014/cxx17 with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4624
https://github.com/root-project/root/pull/4627:11,deployability,build,build,11,@phsft-bot build just on ROOT-fedora30/cxx14,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4627
https://github.com/root-project/root/pull/4627:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4627
https://github.com/root-project/root/pull/4628:17,testability,simpl,simple,17,"@Falcort This is simple solution for row._bHasChildren, also for layout",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4628
https://github.com/root-project/root/pull/4628:17,usability,simpl,simple,17,"@Falcort This is simple solution for row._bHasChildren, also for layout",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4628
https://github.com/root-project/root/pull/4629:52,deployability,build,builds,52,@maxgalli it will fix your problem with muti-python builds?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4629
https://github.com/root-project/root/pull/4629:54,deployability,build,builds,54,"> @maxgalli it will fix your problem with muti-python builds? yes, Axel figured it out",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4629
https://github.com/root-project/root/pull/4629:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4629
https://github.com/root-project/root/pull/4629:33,safety,review,review,33,Can you @oshadura or @vgvassilev review or merge?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4629
https://github.com/root-project/root/pull/4629:33,testability,review,review,33,Can you @oshadura or @vgvassilev review or merge?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4629
https://github.com/root-project/root/pull/4631:0,usability,Close,Close,0,Close in favor of #4645,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4631
https://github.com/root-project/root/pull/4635:23,deployability,continu,continue,23,@Falcort @bellenot . I continue my changes in browser. Now main difference - path defined as array of sub-folders names. And there is always top browse element - not necessary top file folder. I also include openui5 with fiori_3 theme,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4635
https://github.com/root-project/root/pull/4635:102,integrability,sub,sub-folders,102,@Falcort @bellenot . I continue my changes in browser. Now main difference - path defined as array of sub-folders names. And there is always top browse element - not necessary top file folder. I also include openui5 with fiori_3 theme,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4635
https://github.com/root-project/root/pull/4637:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4637
https://github.com/root-project/root/pull/4637:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4637
https://github.com/root-project/root/pull/4637:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4637
https://github.com/root-project/root/pull/4637:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4637
https://github.com/root-project/root/pull/4637:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4637
https://github.com/root-project/root/pull/4637:11,deployability,build,build,11,@phsft-bot build just on ROOT-fedora29/python3,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4637
https://github.com/root-project/root/pull/4638:302,availability,avail,available,302,"This is how browser looks for me:. ![browser](https://user-images.githubusercontent.com/4936580/69444646-0f64d580-0d51-11ea-8ba5-d49112563036.png). Still missing icons, but this can be improved. On windows instead of ""fs"" should letter ""c:"" appears (or that is in current path). And later full list of available drivers",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4638
https://github.com/root-project/root/pull/4638:264,energy efficiency,current,current,264,"This is how browser looks for me:. ![browser](https://user-images.githubusercontent.com/4936580/69444646-0f64d580-0d51-11ea-8ba5-d49112563036.png). Still missing icons, but this can be improved. On windows instead of ""fs"" should letter ""c:"" appears (or that is in current path). And later full list of available drivers",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4638
https://github.com/root-project/root/pull/4638:302,reliability,availab,available,302,"This is how browser looks for me:. ![browser](https://user-images.githubusercontent.com/4936580/69444646-0f64d580-0d51-11ea-8ba5-d49112563036.png). Still missing icons, but this can be improved. On windows instead of ""fs"" should letter ""c:"" appears (or that is in current path). And later full list of available drivers",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4638
https://github.com/root-project/root/pull/4638:302,safety,avail,available,302,"This is how browser looks for me:. ![browser](https://user-images.githubusercontent.com/4936580/69444646-0f64d580-0d51-11ea-8ba5-d49112563036.png). Still missing icons, but this can be improved. On windows instead of ""fs"" should letter ""c:"" appears (or that is in current path). And later full list of available drivers",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4638
https://github.com/root-project/root/pull/4638:302,security,availab,available,302,"This is how browser looks for me:. ![browser](https://user-images.githubusercontent.com/4936580/69444646-0f64d580-0d51-11ea-8ba5-d49112563036.png). Still missing icons, but this can be improved. On windows instead of ""fs"" should letter ""c:"" appears (or that is in current path). And later full list of available drivers",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4638
https://github.com/root-project/root/pull/4638:54,usability,user,user-images,54,"This is how browser looks for me:. ![browser](https://user-images.githubusercontent.com/4936580/69444646-0f64d580-0d51-11ea-8ba5-d49112563036.png). Still missing icons, but this can be improved. On windows instead of ""fs"" should letter ""c:"" appears (or that is in current path). And later full list of available drivers",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4638
https://github.com/root-project/root/pull/4640:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4640
https://github.com/root-project/root/pull/4640:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4640
https://github.com/root-project/root/pull/4640:301,interoperability,specif,specific,301,"Dear all, I just pushed the discussed performance improvements for the asymptotic method. The main improvement is to only create one RooDerivative object for each varied parameter. The changes lead to a significant speedup, for the rf611_weightedfits.C example, the speedup for the calculation of the specific matrix corresponds to a factor of ~4. Numerically, the results are identical. The full tutorial is sped up by a factor of ~2. The speed improvement will be larger for a larger number of free parameters (the tutorial only fits 2).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4640
https://github.com/root-project/root/pull/4640:170,modifiability,paramet,parameter,170,"Dear all, I just pushed the discussed performance improvements for the asymptotic method. The main improvement is to only create one RooDerivative object for each varied parameter. The changes lead to a significant speedup, for the rf611_weightedfits.C example, the speedup for the calculation of the specific matrix corresponds to a factor of ~4. Numerically, the results are identical. The full tutorial is sped up by a factor of ~2. The speed improvement will be larger for a larger number of free parameters (the tutorial only fits 2).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4640
https://github.com/root-project/root/pull/4640:501,modifiability,paramet,parameters,501,"Dear all, I just pushed the discussed performance improvements for the asymptotic method. The main improvement is to only create one RooDerivative object for each varied parameter. The changes lead to a significant speedup, for the rf611_weightedfits.C example, the speedup for the calculation of the specific matrix corresponds to a factor of ~4. Numerically, the results are identical. The full tutorial is sped up by a factor of ~2. The speed improvement will be larger for a larger number of free parameters (the tutorial only fits 2).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4640
https://github.com/root-project/root/pull/4640:38,performance,perform,performance,38,"Dear all, I just pushed the discussed performance improvements for the asymptotic method. The main improvement is to only create one RooDerivative object for each varied parameter. The changes lead to a significant speedup, for the rf611_weightedfits.C example, the speedup for the calculation of the specific matrix corresponds to a factor of ~4. Numerically, the results are identical. The full tutorial is sped up by a factor of ~2. The speed improvement will be larger for a larger number of free parameters (the tutorial only fits 2).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4640
https://github.com/root-project/root/pull/4640:203,security,sign,significant,203,"Dear all, I just pushed the discussed performance improvements for the asymptotic method. The main improvement is to only create one RooDerivative object for each varied parameter. The changes lead to a significant speedup, for the rf611_weightedfits.C example, the speedup for the calculation of the specific matrix corresponds to a factor of ~4. Numerically, the results are identical. The full tutorial is sped up by a factor of ~2. The speed improvement will be larger for a larger number of free parameters (the tutorial only fits 2).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4640
https://github.com/root-project/root/pull/4640:377,security,ident,identical,377,"Dear all, I just pushed the discussed performance improvements for the asymptotic method. The main improvement is to only create one RooDerivative object for each varied parameter. The changes lead to a significant speedup, for the rf611_weightedfits.C example, the speedup for the calculation of the specific matrix corresponds to a factor of ~4. Numerically, the results are identical. The full tutorial is sped up by a factor of ~2. The speed improvement will be larger for a larger number of free parameters (the tutorial only fits 2).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4640
https://github.com/root-project/root/pull/4640:38,usability,perform,performance,38,"Dear all, I just pushed the discussed performance improvements for the asymptotic method. The main improvement is to only create one RooDerivative object for each varied parameter. The changes lead to a significant speedup, for the rf611_weightedfits.C example, the speedup for the calculation of the specific matrix corresponds to a factor of ~4. Numerically, the results are identical. The full tutorial is sped up by a factor of ~2. The speed improvement will be larger for a larger number of free parameters (the tutorial only fits 2).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4640
https://github.com/root-project/root/pull/4640:37,deployability,build,build,37,"Hello,. that's excellent! @phsft-bot build",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4640
https://github.com/root-project/root/pull/4640:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4640
https://github.com/root-project/root/pull/4640:14,availability,failur,failures,14,The two build failures were unrelated to the work discussed here. Let's wait for tomorrow to check the nightlies.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4640
https://github.com/root-project/root/pull/4640:8,deployability,build,build,8,The two build failures were unrelated to the work discussed here. Let's wait for tomorrow to check the nightlies.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4640
https://github.com/root-project/root/pull/4640:14,deployability,fail,failures,14,The two build failures were unrelated to the work discussed here. Let's wait for tomorrow to check the nightlies.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4640
https://github.com/root-project/root/pull/4640:14,performance,failur,failures,14,The two build failures were unrelated to the work discussed here. Let's wait for tomorrow to check the nightlies.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4640
https://github.com/root-project/root/pull/4640:14,reliability,fail,failures,14,The two build failures were unrelated to the work discussed here. Let's wait for tomorrow to check the nightlies.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4640
https://github.com/root-project/root/pull/4642:11,deployability,build,build,11,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4642
https://github.com/root-project/root/pull/4642:11,deployability,build,build,11,@phsft-bot build just on ROOT-performance-centos7-multicore/default with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4642
https://github.com/root-project/root/pull/4642:30,performance,perform,performance-,30,@phsft-bot build just on ROOT-performance-centos7-multicore/default with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4642
https://github.com/root-project/root/pull/4642:30,usability,perform,performance-,30,@phsft-bot build just on ROOT-performance-centos7-multicore/default with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4642
https://github.com/root-project/root/pull/4645:40,reliability,doe,does,40,"@alja Unfortunately, event_demo.C still does not work",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4645
https://github.com/root-project/root/pull/4646:110,usability,Tool,ToolHeader,110,Maybe it is better for merge it after i found a solution for the SplitApp resize and move some stuff into the ToolHeader ?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:112,usability,Tool,ToolHeader,112,"> Maybe it is better for merge it after i found a solution for the SplitApp resize and move some stuff into the ToolHeader ? Yes, let's try to fix it first (if it can be done quickly enough)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:55,safety,review,reviewed,55,@linev This PR for the new GUI is rebase an can now be reviewed,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:55,testability,review,reviewed,55,@linev This PR for the new GUI is rebase an can now be reviewed,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:76,energy efficiency,load,load,76,"I looked into the PR. There are two point. 1. You add ""Browse..."" button to load files using default file open dialog from the web browser. Does it make sense? We already have file browsing on left side. It can fully confuse users when they work with remote system. I propose to ""hide"" this functionality for now and provide in ""Expert"" mode. And one has to implement correspondent ""Save as ..."" button which allows to save text editor content into browser host system. As it done in JSROOT with saving png files:. https://github.com/root-project/jsroot/blob/master/scripts/JSRootPainter.v6.js#L3982-L3998. 2. You are using ToolHeader from **tnt** library. This library is not included into ROOT openui5 package, therefore does not work properly in ""offline"" mode. Are there any other alternatives in libraries like **m** or **ui**? If not, I have to include **tnt** - it seems to be not that big.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:704,modifiability,pac,package,704,"I looked into the PR. There are two point. 1. You add ""Browse..."" button to load files using default file open dialog from the web browser. Does it make sense? We already have file browsing on left side. It can fully confuse users when they work with remote system. I propose to ""hide"" this functionality for now and provide in ""Expert"" mode. And one has to implement correspondent ""Save as ..."" button which allows to save text editor content into browser host system. As it done in JSROOT with saving png files:. https://github.com/root-project/jsroot/blob/master/scripts/JSRootPainter.v6.js#L3982-L3998. 2. You are using ToolHeader from **tnt** library. This library is not included into ROOT openui5 package, therefore does not work properly in ""offline"" mode. Are there any other alternatives in libraries like **m** or **ui**? If not, I have to include **tnt** - it seems to be not that big.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:76,performance,load,load,76,"I looked into the PR. There are two point. 1. You add ""Browse..."" button to load files using default file open dialog from the web browser. Does it make sense? We already have file browsing on left side. It can fully confuse users when they work with remote system. I propose to ""hide"" this functionality for now and provide in ""Expert"" mode. And one has to implement correspondent ""Save as ..."" button which allows to save text editor content into browser host system. As it done in JSROOT with saving png files:. https://github.com/root-project/jsroot/blob/master/scripts/JSRootPainter.v6.js#L3982-L3998. 2. You are using ToolHeader from **tnt** library. This library is not included into ROOT openui5 package, therefore does not work properly in ""offline"" mode. Are there any other alternatives in libraries like **m** or **ui**? If not, I have to include **tnt** - it seems to be not that big.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:436,performance,content,content,436,"I looked into the PR. There are two point. 1. You add ""Browse..."" button to load files using default file open dialog from the web browser. Does it make sense? We already have file browsing on left side. It can fully confuse users when they work with remote system. I propose to ""hide"" this functionality for now and provide in ""Expert"" mode. And one has to implement correspondent ""Save as ..."" button which allows to save text editor content into browser host system. As it done in JSROOT with saving png files:. https://github.com/root-project/jsroot/blob/master/scripts/JSRootPainter.v6.js#L3982-L3998. 2. You are using ToolHeader from **tnt** library. This library is not included into ROOT openui5 package, therefore does not work properly in ""offline"" mode. Are there any other alternatives in libraries like **m** or **ui**? If not, I have to include **tnt** - it seems to be not that big.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:140,reliability,Doe,Does,140,"I looked into the PR. There are two point. 1. You add ""Browse..."" button to load files using default file open dialog from the web browser. Does it make sense? We already have file browsing on left side. It can fully confuse users when they work with remote system. I propose to ""hide"" this functionality for now and provide in ""Expert"" mode. And one has to implement correspondent ""Save as ..."" button which allows to save text editor content into browser host system. As it done in JSROOT with saving png files:. https://github.com/root-project/jsroot/blob/master/scripts/JSRootPainter.v6.js#L3982-L3998. 2. You are using ToolHeader from **tnt** library. This library is not included into ROOT openui5 package, therefore does not work properly in ""offline"" mode. Are there any other alternatives in libraries like **m** or **ui**? If not, I have to include **tnt** - it seems to be not that big.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:723,reliability,doe,does,723,"I looked into the PR. There are two point. 1. You add ""Browse..."" button to load files using default file open dialog from the web browser. Does it make sense? We already have file browsing on left side. It can fully confuse users when they work with remote system. I propose to ""hide"" this functionality for now and provide in ""Expert"" mode. And one has to implement correspondent ""Save as ..."" button which allows to save text editor content into browser host system. As it done in JSROOT with saving png files:. https://github.com/root-project/jsroot/blob/master/scripts/JSRootPainter.v6.js#L3982-L3998. 2. You are using ToolHeader from **tnt** library. This library is not included into ROOT openui5 package, therefore does not work properly in ""offline"" mode. Are there any other alternatives in libraries like **m** or **ui**? If not, I have to include **tnt** - it seems to be not that big.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:111,usability,dialog,dialog,111,"I looked into the PR. There are two point. 1. You add ""Browse..."" button to load files using default file open dialog from the web browser. Does it make sense? We already have file browsing on left side. It can fully confuse users when they work with remote system. I propose to ""hide"" this functionality for now and provide in ""Expert"" mode. And one has to implement correspondent ""Save as ..."" button which allows to save text editor content into browser host system. As it done in JSROOT with saving png files:. https://github.com/root-project/jsroot/blob/master/scripts/JSRootPainter.v6.js#L3982-L3998. 2. You are using ToolHeader from **tnt** library. This library is not included into ROOT openui5 package, therefore does not work properly in ""offline"" mode. Are there any other alternatives in libraries like **m** or **ui**? If not, I have to include **tnt** - it seems to be not that big.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:225,usability,user,users,225,"I looked into the PR. There are two point. 1. You add ""Browse..."" button to load files using default file open dialog from the web browser. Does it make sense? We already have file browsing on left side. It can fully confuse users when they work with remote system. I propose to ""hide"" this functionality for now and provide in ""Expert"" mode. And one has to implement correspondent ""Save as ..."" button which allows to save text editor content into browser host system. As it done in JSROOT with saving png files:. https://github.com/root-project/jsroot/blob/master/scripts/JSRootPainter.v6.js#L3982-L3998. 2. You are using ToolHeader from **tnt** library. This library is not included into ROOT openui5 package, therefore does not work properly in ""offline"" mode. Are there any other alternatives in libraries like **m** or **ui**? If not, I have to include **tnt** - it seems to be not that big.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:624,usability,Tool,ToolHeader,624,"I looked into the PR. There are two point. 1. You add ""Browse..."" button to load files using default file open dialog from the web browser. Does it make sense? We already have file browsing on left side. It can fully confuse users when they work with remote system. I propose to ""hide"" this functionality for now and provide in ""Expert"" mode. And one has to implement correspondent ""Save as ..."" button which allows to save text editor content into browser host system. As it done in JSROOT with saving png files:. https://github.com/root-project/jsroot/blob/master/scripts/JSRootPainter.v6.js#L3982-L3998. 2. You are using ToolHeader from **tnt** library. This library is not included into ROOT openui5 package, therefore does not work properly in ""offline"" mode. Are there any other alternatives in libraries like **m** or **ui**? If not, I have to include **tnt** - it seems to be not that big.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:827,usability,ui,ui,827,"I looked into the PR. There are two point. 1. You add ""Browse..."" button to load files using default file open dialog from the web browser. Does it make sense? We already have file browsing on left side. It can fully confuse users when they work with remote system. I propose to ""hide"" this functionality for now and provide in ""Expert"" mode. And one has to implement correspondent ""Save as ..."" button which allows to save text editor content into browser host system. As it done in JSROOT with saving png files:. https://github.com/root-project/jsroot/blob/master/scripts/JSRootPainter.v6.js#L3982-L3998. 2. You are using ToolHeader from **tnt** library. This library is not included into ROOT openui5 package, therefore does not work properly in ""offline"" mode. Are there any other alternatives in libraries like **m** or **ui**? If not, I have to include **tnt** - it seems to be not that big.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:137,integrability,compon,components,137,Also some time ago we discuss functionality to resize left area in the SplitApp (where files list is shown). Did you found correspondent components?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:137,interoperability,compon,components,137,Also some time ago we discuss functionality to resize left area in the SplitApp (where files list is shown). Did you found correspondent components?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:137,modifiability,compon,components,137,Also some time ago we discuss functionality to resize left area in the SplitApp (where files list is shown). Did you found correspondent components?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:10,performance,time,time,10,Also some time ago we discuss functionality to resize left area in the SplitApp (where files list is shown). Did you found correspondent components?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:62,safety,test,test,62,"1. This button was not added by me, it was meant to be use ro test the code editor before the fileDialog was created. But i can remove it if you want. 2. I will look into that but i don't think **m** or **ui** have such things, if i remember well, all the others solutions where depreciated",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:233,safety,reme,remember,233,"1. This button was not added by me, it was meant to be use ro test the code editor before the fileDialog was created. But i can remove it if you want. 2. I will look into that but i don't think **m** or **ui** have such things, if i remember well, all the others solutions where depreciated",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:62,testability,test,test,62,"1. This button was not added by me, it was meant to be use ro test the code editor before the fileDialog was created. But i can remove it if you want. 2. I will look into that but i don't think **m** or **ui** have such things, if i remember well, all the others solutions where depreciated",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:205,usability,ui,ui,205,"1. This button was not added by me, it was meant to be use ro test the code editor before the fileDialog was created. But i can remove it if you want. 2. I will look into that but i don't think **m** or **ui** have such things, if i remember well, all the others solutions where depreciated",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:375,modifiability,pac,package,375,"> This button was not added by me, it was meant to be use ro test the code editor before the fileDialog was created. But i can remove it if you want. Just ""hide"" this button for the moment - it will be confusing to the people. > I will look into that but i don't think m or ui have such things. Please check. If there are no alternatives - I will add tnt lib to ROOT openui5 package",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:61,safety,test,test,61,"> This button was not added by me, it was meant to be use ro test the code editor before the fileDialog was created. But i can remove it if you want. Just ""hide"" this button for the moment - it will be confusing to the people. > I will look into that but i don't think m or ui have such things. Please check. If there are no alternatives - I will add tnt lib to ROOT openui5 package",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:61,testability,test,test,61,"> This button was not added by me, it was meant to be use ro test the code editor before the fileDialog was created. But i can remove it if you want. Just ""hide"" this button for the moment - it will be confusing to the people. > I will look into that but i don't think m or ui have such things. Please check. If there are no alternatives - I will add tnt lib to ROOT openui5 package",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:274,usability,ui,ui,274,"> This button was not added by me, it was meant to be use ro test the code editor before the fileDialog was created. But i can remove it if you want. Just ""hide"" this button for the moment - it will be confusing to the people. > I will look into that but i don't think m or ui have such things. Please check. If there are no alternatives - I will add tnt lib to ROOT openui5 package",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:139,integrability,compon,components,139,"> Also some time ago we discuss functionality to resize left area in the SplitApp (where files list is shown). Did you found correspondent components? Yes and no, the component that you showed me on the demo was a very big and complex component that would have need a complete refactor of a lot of things. https://openui5.hana.ondemand.com/entity/sap.f.tutorial.fiori2/sample/sap.f.tutorial.fiori2.12 . The other solution that i found that would have been custom resize will not fit also because of the Tree table :. https://openui5.hana.ondemand.com/entity/sap.tnt.ToolPage/sample/sap.tnt.sample.ToolPage. So for now i don't think this is possible with a UI5 component, i thinks that we can recode the functionality of the SplitApp using just a Splitter, but it will be complexe for the Responsive",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:167,integrability,compon,component,167,"> Also some time ago we discuss functionality to resize left area in the SplitApp (where files list is shown). Did you found correspondent components? Yes and no, the component that you showed me on the demo was a very big and complex component that would have need a complete refactor of a lot of things. https://openui5.hana.ondemand.com/entity/sap.f.tutorial.fiori2/sample/sap.f.tutorial.fiori2.12 . The other solution that i found that would have been custom resize will not fit also because of the Tree table :. https://openui5.hana.ondemand.com/entity/sap.tnt.ToolPage/sample/sap.tnt.sample.ToolPage. So for now i don't think this is possible with a UI5 component, i thinks that we can recode the functionality of the SplitApp using just a Splitter, but it will be complexe for the Responsive",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:235,integrability,compon,component,235,"> Also some time ago we discuss functionality to resize left area in the SplitApp (where files list is shown). Did you found correspondent components? Yes and no, the component that you showed me on the demo was a very big and complex component that would have need a complete refactor of a lot of things. https://openui5.hana.ondemand.com/entity/sap.f.tutorial.fiori2/sample/sap.f.tutorial.fiori2.12 . The other solution that i found that would have been custom resize will not fit also because of the Tree table :. https://openui5.hana.ondemand.com/entity/sap.tnt.ToolPage/sample/sap.tnt.sample.ToolPage. So for now i don't think this is possible with a UI5 component, i thinks that we can recode the functionality of the SplitApp using just a Splitter, but it will be complexe for the Responsive",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:660,integrability,compon,component,660,"> Also some time ago we discuss functionality to resize left area in the SplitApp (where files list is shown). Did you found correspondent components? Yes and no, the component that you showed me on the demo was a very big and complex component that would have need a complete refactor of a lot of things. https://openui5.hana.ondemand.com/entity/sap.f.tutorial.fiori2/sample/sap.f.tutorial.fiori2.12 . The other solution that i found that would have been custom resize will not fit also because of the Tree table :. https://openui5.hana.ondemand.com/entity/sap.tnt.ToolPage/sample/sap.tnt.sample.ToolPage. So for now i don't think this is possible with a UI5 component, i thinks that we can recode the functionality of the SplitApp using just a Splitter, but it will be complexe for the Responsive",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:139,interoperability,compon,components,139,"> Also some time ago we discuss functionality to resize left area in the SplitApp (where files list is shown). Did you found correspondent components? Yes and no, the component that you showed me on the demo was a very big and complex component that would have need a complete refactor of a lot of things. https://openui5.hana.ondemand.com/entity/sap.f.tutorial.fiori2/sample/sap.f.tutorial.fiori2.12 . The other solution that i found that would have been custom resize will not fit also because of the Tree table :. https://openui5.hana.ondemand.com/entity/sap.tnt.ToolPage/sample/sap.tnt.sample.ToolPage. So for now i don't think this is possible with a UI5 component, i thinks that we can recode the functionality of the SplitApp using just a Splitter, but it will be complexe for the Responsive",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:167,interoperability,compon,component,167,"> Also some time ago we discuss functionality to resize left area in the SplitApp (where files list is shown). Did you found correspondent components? Yes and no, the component that you showed me on the demo was a very big and complex component that would have need a complete refactor of a lot of things. https://openui5.hana.ondemand.com/entity/sap.f.tutorial.fiori2/sample/sap.f.tutorial.fiori2.12 . The other solution that i found that would have been custom resize will not fit also because of the Tree table :. https://openui5.hana.ondemand.com/entity/sap.tnt.ToolPage/sample/sap.tnt.sample.ToolPage. So for now i don't think this is possible with a UI5 component, i thinks that we can recode the functionality of the SplitApp using just a Splitter, but it will be complexe for the Responsive",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:235,interoperability,compon,component,235,"> Also some time ago we discuss functionality to resize left area in the SplitApp (where files list is shown). Did you found correspondent components? Yes and no, the component that you showed me on the demo was a very big and complex component that would have need a complete refactor of a lot of things. https://openui5.hana.ondemand.com/entity/sap.f.tutorial.fiori2/sample/sap.f.tutorial.fiori2.12 . The other solution that i found that would have been custom resize will not fit also because of the Tree table :. https://openui5.hana.ondemand.com/entity/sap.tnt.ToolPage/sample/sap.tnt.sample.ToolPage. So for now i don't think this is possible with a UI5 component, i thinks that we can recode the functionality of the SplitApp using just a Splitter, but it will be complexe for the Responsive",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:660,interoperability,compon,component,660,"> Also some time ago we discuss functionality to resize left area in the SplitApp (where files list is shown). Did you found correspondent components? Yes and no, the component that you showed me on the demo was a very big and complex component that would have need a complete refactor of a lot of things. https://openui5.hana.ondemand.com/entity/sap.f.tutorial.fiori2/sample/sap.f.tutorial.fiori2.12 . The other solution that i found that would have been custom resize will not fit also because of the Tree table :. https://openui5.hana.ondemand.com/entity/sap.tnt.ToolPage/sample/sap.tnt.sample.ToolPage. So for now i don't think this is possible with a UI5 component, i thinks that we can recode the functionality of the SplitApp using just a Splitter, but it will be complexe for the Responsive",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:139,modifiability,compon,components,139,"> Also some time ago we discuss functionality to resize left area in the SplitApp (where files list is shown). Did you found correspondent components? Yes and no, the component that you showed me on the demo was a very big and complex component that would have need a complete refactor of a lot of things. https://openui5.hana.ondemand.com/entity/sap.f.tutorial.fiori2/sample/sap.f.tutorial.fiori2.12 . The other solution that i found that would have been custom resize will not fit also because of the Tree table :. https://openui5.hana.ondemand.com/entity/sap.tnt.ToolPage/sample/sap.tnt.sample.ToolPage. So for now i don't think this is possible with a UI5 component, i thinks that we can recode the functionality of the SplitApp using just a Splitter, but it will be complexe for the Responsive",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:167,modifiability,compon,component,167,"> Also some time ago we discuss functionality to resize left area in the SplitApp (where files list is shown). Did you found correspondent components? Yes and no, the component that you showed me on the demo was a very big and complex component that would have need a complete refactor of a lot of things. https://openui5.hana.ondemand.com/entity/sap.f.tutorial.fiori2/sample/sap.f.tutorial.fiori2.12 . The other solution that i found that would have been custom resize will not fit also because of the Tree table :. https://openui5.hana.ondemand.com/entity/sap.tnt.ToolPage/sample/sap.tnt.sample.ToolPage. So for now i don't think this is possible with a UI5 component, i thinks that we can recode the functionality of the SplitApp using just a Splitter, but it will be complexe for the Responsive",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:235,modifiability,compon,component,235,"> Also some time ago we discuss functionality to resize left area in the SplitApp (where files list is shown). Did you found correspondent components? Yes and no, the component that you showed me on the demo was a very big and complex component that would have need a complete refactor of a lot of things. https://openui5.hana.ondemand.com/entity/sap.f.tutorial.fiori2/sample/sap.f.tutorial.fiori2.12 . The other solution that i found that would have been custom resize will not fit also because of the Tree table :. https://openui5.hana.ondemand.com/entity/sap.tnt.ToolPage/sample/sap.tnt.sample.ToolPage. So for now i don't think this is possible with a UI5 component, i thinks that we can recode the functionality of the SplitApp using just a Splitter, but it will be complexe for the Responsive",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:277,modifiability,refact,refactor,277,"> Also some time ago we discuss functionality to resize left area in the SplitApp (where files list is shown). Did you found correspondent components? Yes and no, the component that you showed me on the demo was a very big and complex component that would have need a complete refactor of a lot of things. https://openui5.hana.ondemand.com/entity/sap.f.tutorial.fiori2/sample/sap.f.tutorial.fiori2.12 . The other solution that i found that would have been custom resize will not fit also because of the Tree table :. https://openui5.hana.ondemand.com/entity/sap.tnt.ToolPage/sample/sap.tnt.sample.ToolPage. So for now i don't think this is possible with a UI5 component, i thinks that we can recode the functionality of the SplitApp using just a Splitter, but it will be complexe for the Responsive",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:660,modifiability,compon,component,660,"> Also some time ago we discuss functionality to resize left area in the SplitApp (where files list is shown). Did you found correspondent components? Yes and no, the component that you showed me on the demo was a very big and complex component that would have need a complete refactor of a lot of things. https://openui5.hana.ondemand.com/entity/sap.f.tutorial.fiori2/sample/sap.f.tutorial.fiori2.12 . The other solution that i found that would have been custom resize will not fit also because of the Tree table :. https://openui5.hana.ondemand.com/entity/sap.tnt.ToolPage/sample/sap.tnt.sample.ToolPage. So for now i don't think this is possible with a UI5 component, i thinks that we can recode the functionality of the SplitApp using just a Splitter, but it will be complexe for the Responsive",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:12,performance,time,time,12,"> Also some time ago we discuss functionality to resize left area in the SplitApp (where files list is shown). Did you found correspondent components? Yes and no, the component that you showed me on the demo was a very big and complex component that would have need a complete refactor of a lot of things. https://openui5.hana.ondemand.com/entity/sap.f.tutorial.fiori2/sample/sap.f.tutorial.fiori2.12 . The other solution that i found that would have been custom resize will not fit also because of the Tree table :. https://openui5.hana.ondemand.com/entity/sap.tnt.ToolPage/sample/sap.tnt.sample.ToolPage. So for now i don't think this is possible with a UI5 component, i thinks that we can recode the functionality of the SplitApp using just a Splitter, but it will be complexe for the Responsive",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:277,performance,refactor,refactor,277,"> Also some time ago we discuss functionality to resize left area in the SplitApp (where files list is shown). Did you found correspondent components? Yes and no, the component that you showed me on the demo was a very big and complex component that would have need a complete refactor of a lot of things. https://openui5.hana.ondemand.com/entity/sap.f.tutorial.fiori2/sample/sap.f.tutorial.fiori2.12 . The other solution that i found that would have been custom resize will not fit also because of the Tree table :. https://openui5.hana.ondemand.com/entity/sap.tnt.ToolPage/sample/sap.tnt.sample.ToolPage. So for now i don't think this is possible with a UI5 component, i thinks that we can recode the functionality of the SplitApp using just a Splitter, but it will be complexe for the Responsive",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:227,safety,compl,complex,227,"> Also some time ago we discuss functionality to resize left area in the SplitApp (where files list is shown). Did you found correspondent components? Yes and no, the component that you showed me on the demo was a very big and complex component that would have need a complete refactor of a lot of things. https://openui5.hana.ondemand.com/entity/sap.f.tutorial.fiori2/sample/sap.f.tutorial.fiori2.12 . The other solution that i found that would have been custom resize will not fit also because of the Tree table :. https://openui5.hana.ondemand.com/entity/sap.tnt.ToolPage/sample/sap.tnt.sample.ToolPage. So for now i don't think this is possible with a UI5 component, i thinks that we can recode the functionality of the SplitApp using just a Splitter, but it will be complexe for the Responsive",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:268,safety,compl,complete,268,"> Also some time ago we discuss functionality to resize left area in the SplitApp (where files list is shown). Did you found correspondent components? Yes and no, the component that you showed me on the demo was a very big and complex component that would have need a complete refactor of a lot of things. https://openui5.hana.ondemand.com/entity/sap.f.tutorial.fiori2/sample/sap.f.tutorial.fiori2.12 . The other solution that i found that would have been custom resize will not fit also because of the Tree table :. https://openui5.hana.ondemand.com/entity/sap.tnt.ToolPage/sample/sap.tnt.sample.ToolPage. So for now i don't think this is possible with a UI5 component, i thinks that we can recode the functionality of the SplitApp using just a Splitter, but it will be complexe for the Responsive",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:771,safety,compl,complexe,771,"> Also some time ago we discuss functionality to resize left area in the SplitApp (where files list is shown). Did you found correspondent components? Yes and no, the component that you showed me on the demo was a very big and complex component that would have need a complete refactor of a lot of things. https://openui5.hana.ondemand.com/entity/sap.f.tutorial.fiori2/sample/sap.f.tutorial.fiori2.12 . The other solution that i found that would have been custom resize will not fit also because of the Tree table :. https://openui5.hana.ondemand.com/entity/sap.tnt.ToolPage/sample/sap.tnt.sample.ToolPage. So for now i don't think this is possible with a UI5 component, i thinks that we can recode the functionality of the SplitApp using just a Splitter, but it will be complexe for the Responsive",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:227,security,compl,complex,227,"> Also some time ago we discuss functionality to resize left area in the SplitApp (where files list is shown). Did you found correspondent components? Yes and no, the component that you showed me on the demo was a very big and complex component that would have need a complete refactor of a lot of things. https://openui5.hana.ondemand.com/entity/sap.f.tutorial.fiori2/sample/sap.f.tutorial.fiori2.12 . The other solution that i found that would have been custom resize will not fit also because of the Tree table :. https://openui5.hana.ondemand.com/entity/sap.tnt.ToolPage/sample/sap.tnt.sample.ToolPage. So for now i don't think this is possible with a UI5 component, i thinks that we can recode the functionality of the SplitApp using just a Splitter, but it will be complexe for the Responsive",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:268,security,compl,complete,268,"> Also some time ago we discuss functionality to resize left area in the SplitApp (where files list is shown). Did you found correspondent components? Yes and no, the component that you showed me on the demo was a very big and complex component that would have need a complete refactor of a lot of things. https://openui5.hana.ondemand.com/entity/sap.f.tutorial.fiori2/sample/sap.f.tutorial.fiori2.12 . The other solution that i found that would have been custom resize will not fit also because of the Tree table :. https://openui5.hana.ondemand.com/entity/sap.tnt.ToolPage/sample/sap.tnt.sample.ToolPage. So for now i don't think this is possible with a UI5 component, i thinks that we can recode the functionality of the SplitApp using just a Splitter, but it will be complexe for the Responsive",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:771,security,compl,complexe,771,"> Also some time ago we discuss functionality to resize left area in the SplitApp (where files list is shown). Did you found correspondent components? Yes and no, the component that you showed me on the demo was a very big and complex component that would have need a complete refactor of a lot of things. https://openui5.hana.ondemand.com/entity/sap.f.tutorial.fiori2/sample/sap.f.tutorial.fiori2.12 . The other solution that i found that would have been custom resize will not fit also because of the Tree table :. https://openui5.hana.ondemand.com/entity/sap.tnt.ToolPage/sample/sap.tnt.sample.ToolPage. So for now i don't think this is possible with a UI5 component, i thinks that we can recode the functionality of the SplitApp using just a Splitter, but it will be complexe for the Responsive",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:456,usability,custom,custom,456,"> Also some time ago we discuss functionality to resize left area in the SplitApp (where files list is shown). Did you found correspondent components? Yes and no, the component that you showed me on the demo was a very big and complex component that would have need a complete refactor of a lot of things. https://openui5.hana.ondemand.com/entity/sap.f.tutorial.fiori2/sample/sap.f.tutorial.fiori2.12 . The other solution that i found that would have been custom resize will not fit also because of the Tree table :. https://openui5.hana.ondemand.com/entity/sap.tnt.ToolPage/sample/sap.tnt.sample.ToolPage. So for now i don't think this is possible with a UI5 component, i thinks that we can recode the functionality of the SplitApp using just a Splitter, but it will be complexe for the Responsive",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:566,usability,Tool,ToolPage,566,"> Also some time ago we discuss functionality to resize left area in the SplitApp (where files list is shown). Did you found correspondent components? Yes and no, the component that you showed me on the demo was a very big and complex component that would have need a complete refactor of a lot of things. https://openui5.hana.ondemand.com/entity/sap.f.tutorial.fiori2/sample/sap.f.tutorial.fiori2.12 . The other solution that i found that would have been custom resize will not fit also because of the Tree table :. https://openui5.hana.ondemand.com/entity/sap.tnt.ToolPage/sample/sap.tnt.sample.ToolPage. So for now i don't think this is possible with a UI5 component, i thinks that we can recode the functionality of the SplitApp using just a Splitter, but it will be complexe for the Responsive",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:597,usability,Tool,ToolPage,597,"> Also some time ago we discuss functionality to resize left area in the SplitApp (where files list is shown). Did you found correspondent components? Yes and no, the component that you showed me on the demo was a very big and complex component that would have need a complete refactor of a lot of things. https://openui5.hana.ondemand.com/entity/sap.f.tutorial.fiori2/sample/sap.f.tutorial.fiori2.12 . The other solution that i found that would have been custom resize will not fit also because of the Tree table :. https://openui5.hana.ondemand.com/entity/sap.tnt.ToolPage/sample/sap.tnt.sample.ToolPage. So for now i don't think this is possible with a UI5 component, i thinks that we can recode the functionality of the SplitApp using just a Splitter, but it will be complexe for the Responsive",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:788,usability,Responsiv,Responsive,788,"> Also some time ago we discuss functionality to resize left area in the SplitApp (where files list is shown). Did you found correspondent components? Yes and no, the component that you showed me on the demo was a very big and complex component that would have need a complete refactor of a lot of things. https://openui5.hana.ondemand.com/entity/sap.f.tutorial.fiori2/sample/sap.f.tutorial.fiori2.12 . The other solution that i found that would have been custom resize will not fit also because of the Tree table :. https://openui5.hana.ondemand.com/entity/sap.tnt.ToolPage/sample/sap.tnt.sample.ToolPage. So for now i don't think this is possible with a UI5 component, i thinks that we can recode the functionality of the SplitApp using just a Splitter, but it will be complexe for the Responsive",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:179,modifiability,paramet,parameter,179,I saw much simpler example how MasterPage can be resized. https://answers.sap.com/questions/12009929/is-it-possible-to-expand-the-width-of-master-page-.html. It is just an single parameter which set width of master page - one can add button in the ToolHeader to switch between default and wide mode.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:11,testability,simpl,simpler,11,I saw much simpler example how MasterPage can be resized. https://answers.sap.com/questions/12009929/is-it-possible-to-expand-the-width-of-master-page-.html. It is just an single parameter which set width of master page - one can add button in the ToolHeader to switch between default and wide mode.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:11,usability,simpl,simpler,11,I saw much simpler example how MasterPage can be resized. https://answers.sap.com/questions/12009929/is-it-possible-to-expand-the-width-of-master-page-.html. It is just an single parameter which set width of master page - one can add button in the ToolHeader to switch between default and wide mode.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:248,usability,Tool,ToolHeader,248,I saw much simpler example how MasterPage can be resized. https://answers.sap.com/questions/12009929/is-it-possible-to-expand-the-width-of-master-page-.html. It is just an single parameter which set width of master page - one can add button in the ToolHeader to switch between default and wide mode.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:59,testability,simpl,simplest,59,"> But yes i can implement those button if you want ! It is simplest solution for now, later you can try do it better",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:59,usability,simpl,simplest,59,"> But yes i can implement those button if you want ! It is simplest solution for now, later you can try do it better",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:35,energy efficiency,load,load,35,"> 1. You add ""Browse..."" button to load files using default file open dialog from the web browser. FYI, this button is there since day one...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:35,performance,load,load,35,"> 1. You add ""Browse..."" button to load files using default file open dialog from the web browser. FYI, this button is there since day one...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:70,usability,dialog,dialog,70,"> 1. You add ""Browse..."" button to load files using default file open dialog from the web browser. FYI, this button is there since day one...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:71,performance,time,time,71,"> FYI, this button is there since day one... I was ignoring it all the time :(. But one should disable it",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:158,deployability,toggl,toggle,158,"There is side effect when resizing web browser. I saw situation when both buttons - ""Enter full screen"" and ""Exit full screen"" appears at the same time. Just toggle ""full screen"", then made web browser smaller (main page hides) and then again web browser bigger. Please check logic here. And also name ""full screen"" is misleading. Wider or thinner",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:276,deployability,log,logic,276,"There is side effect when resizing web browser. I saw situation when both buttons - ""Enter full screen"" and ""Exit full screen"" appears at the same time. Just toggle ""full screen"", then made web browser smaller (main page hides) and then again web browser bigger. Please check logic here. And also name ""full screen"" is misleading. Wider or thinner",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:147,performance,time,time,147,"There is side effect when resizing web browser. I saw situation when both buttons - ""Enter full screen"" and ""Exit full screen"" appears at the same time. Just toggle ""full screen"", then made web browser smaller (main page hides) and then again web browser bigger. Please check logic here. And also name ""full screen"" is misleading. Wider or thinner",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:276,safety,log,logic,276,"There is side effect when resizing web browser. I saw situation when both buttons - ""Enter full screen"" and ""Exit full screen"" appears at the same time. Just toggle ""full screen"", then made web browser smaller (main page hides) and then again web browser bigger. Please check logic here. And also name ""full screen"" is misleading. Wider or thinner",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:276,security,log,logic,276,"There is side effect when resizing web browser. I saw situation when both buttons - ""Enter full screen"" and ""Exit full screen"" appears at the same time. Just toggle ""full screen"", then made web browser smaller (main page hides) and then again web browser bigger. Please check logic here. And also name ""full screen"" is misleading. Wider or thinner",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:276,testability,log,logic,276,"There is side effect when resizing web browser. I saw situation when both buttons - ""Enter full screen"" and ""Exit full screen"" appears at the same time. Just toggle ""full screen"", then made web browser smaller (main page hides) and then again web browser bigger. Please check logic here. And also name ""full screen"" is misleading. Wider or thinner",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:79,usability,behavi,behavior,79,"@linev i will debug that as soon as position, but this was part of an intended behavior. As in portait mode the master take 80% of the screen making it bigger is not useful. So the goad was to hide those button and revert to normal the master when entering portrait move, but this is not behaving correctly",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4646:288,usability,behavi,behaving,288,"@linev i will debug that as soon as position, but this was part of an intended behavior. As in portait mode the master take 80% of the screen making it bigger is not useful. So the goad was to hide those button and revert to normal the master when entering portrait move, but this is not behaving correctly",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4646
https://github.com/root-project/root/pull/4647:11,deployability,build,build,11,@phsft-bot build with flags -Dpyroot_experimental=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4647
https://github.com/root-project/root/pull/4647:11,deployability,build,build,11,@phsft-bot build with flags -Dpyroot_experimental=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4647
https://github.com/root-project/root/pull/4647:11,deployability,build,build,11,@phsft-bot build with flags -Dpyroot_experimental=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4647
https://github.com/root-project/root/pull/4647:151,availability,Error,Errors,151,> Build failed on ROOT-ubuntu16/nortcxxmod. > [See console output](https://epsft-jenkins.cern.ch/job/root-pullrequests-build/72624/console). > . > ### Errors:. > * FAILED: cd /mnt/build/workspace/root-pullrequests-build/build && /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/build/unix/makepchinput.py /mnt/build/workspace/root-pullrequests-build/root . ON etc/cling/Interpreter/DynamicExprInfo.h etc/cling/Interpreter/DynamicLookupRuntimeUniverse.h etc/cling/Interpreter/DynamicLookupLifetimeHandler.h etc/cling/Interpreter/Exception.h etc/cling/Interpreter/RuntimePrintValue.h etc/cling/Interpreter/RuntimeUniverse.h etc/cling/Interpreter/Value.h && /usr/local/bin/cmake -E env ROOTIGNOREPREFIX=1 /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/etc/dictpch/makepch.py etc/allDict.cxx.pch -I/mnt/build/workspace/root-pullrequests-build/build/include. Build and tests were tried separately in this machine. Everything is fine. The build directory is:. /home/sftnight/gallim_multipython/build. Don't know why it does not work with Jenkins.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4647
https://github.com/root-project/root/pull/4647:2,deployability,Build,Build,2,> Build failed on ROOT-ubuntu16/nortcxxmod. > [See console output](https://epsft-jenkins.cern.ch/job/root-pullrequests-build/72624/console). > . > ### Errors:. > * FAILED: cd /mnt/build/workspace/root-pullrequests-build/build && /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/build/unix/makepchinput.py /mnt/build/workspace/root-pullrequests-build/root . ON etc/cling/Interpreter/DynamicExprInfo.h etc/cling/Interpreter/DynamicLookupRuntimeUniverse.h etc/cling/Interpreter/DynamicLookupLifetimeHandler.h etc/cling/Interpreter/Exception.h etc/cling/Interpreter/RuntimePrintValue.h etc/cling/Interpreter/RuntimeUniverse.h etc/cling/Interpreter/Value.h && /usr/local/bin/cmake -E env ROOTIGNOREPREFIX=1 /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/etc/dictpch/makepch.py etc/allDict.cxx.pch -I/mnt/build/workspace/root-pullrequests-build/build/include. Build and tests were tried separately in this machine. Everything is fine. The build directory is:. /home/sftnight/gallim_multipython/build. Don't know why it does not work with Jenkins.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4647
https://github.com/root-project/root/pull/4647:8,deployability,fail,failed,8,> Build failed on ROOT-ubuntu16/nortcxxmod. > [See console output](https://epsft-jenkins.cern.ch/job/root-pullrequests-build/72624/console). > . > ### Errors:. > * FAILED: cd /mnt/build/workspace/root-pullrequests-build/build && /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/build/unix/makepchinput.py /mnt/build/workspace/root-pullrequests-build/root . ON etc/cling/Interpreter/DynamicExprInfo.h etc/cling/Interpreter/DynamicLookupRuntimeUniverse.h etc/cling/Interpreter/DynamicLookupLifetimeHandler.h etc/cling/Interpreter/Exception.h etc/cling/Interpreter/RuntimePrintValue.h etc/cling/Interpreter/RuntimeUniverse.h etc/cling/Interpreter/Value.h && /usr/local/bin/cmake -E env ROOTIGNOREPREFIX=1 /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/etc/dictpch/makepch.py etc/allDict.cxx.pch -I/mnt/build/workspace/root-pullrequests-build/build/include. Build and tests were tried separately in this machine. Everything is fine. The build directory is:. /home/sftnight/gallim_multipython/build. Don't know why it does not work with Jenkins.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4647
https://github.com/root-project/root/pull/4647:119,deployability,build,build,119,> Build failed on ROOT-ubuntu16/nortcxxmod. > [See console output](https://epsft-jenkins.cern.ch/job/root-pullrequests-build/72624/console). > . > ### Errors:. > * FAILED: cd /mnt/build/workspace/root-pullrequests-build/build && /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/build/unix/makepchinput.py /mnt/build/workspace/root-pullrequests-build/root . ON etc/cling/Interpreter/DynamicExprInfo.h etc/cling/Interpreter/DynamicLookupRuntimeUniverse.h etc/cling/Interpreter/DynamicLookupLifetimeHandler.h etc/cling/Interpreter/Exception.h etc/cling/Interpreter/RuntimePrintValue.h etc/cling/Interpreter/RuntimeUniverse.h etc/cling/Interpreter/Value.h && /usr/local/bin/cmake -E env ROOTIGNOREPREFIX=1 /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/etc/dictpch/makepch.py etc/allDict.cxx.pch -I/mnt/build/workspace/root-pullrequests-build/build/include. Build and tests were tried separately in this machine. Everything is fine. The build directory is:. /home/sftnight/gallim_multipython/build. Don't know why it does not work with Jenkins.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4647
https://github.com/root-project/root/pull/4647:164,deployability,FAIL,FAILED,164,> Build failed on ROOT-ubuntu16/nortcxxmod. > [See console output](https://epsft-jenkins.cern.ch/job/root-pullrequests-build/72624/console). > . > ### Errors:. > * FAILED: cd /mnt/build/workspace/root-pullrequests-build/build && /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/build/unix/makepchinput.py /mnt/build/workspace/root-pullrequests-build/root . ON etc/cling/Interpreter/DynamicExprInfo.h etc/cling/Interpreter/DynamicLookupRuntimeUniverse.h etc/cling/Interpreter/DynamicLookupLifetimeHandler.h etc/cling/Interpreter/Exception.h etc/cling/Interpreter/RuntimePrintValue.h etc/cling/Interpreter/RuntimeUniverse.h etc/cling/Interpreter/Value.h && /usr/local/bin/cmake -E env ROOTIGNOREPREFIX=1 /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/etc/dictpch/makepch.py etc/allDict.cxx.pch -I/mnt/build/workspace/root-pullrequests-build/build/include. Build and tests were tried separately in this machine. Everything is fine. The build directory is:. /home/sftnight/gallim_multipython/build. Don't know why it does not work with Jenkins.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4647
https://github.com/root-project/root/pull/4647:180,deployability,build,build,180,> Build failed on ROOT-ubuntu16/nortcxxmod. > [See console output](https://epsft-jenkins.cern.ch/job/root-pullrequests-build/72624/console). > . > ### Errors:. > * FAILED: cd /mnt/build/workspace/root-pullrequests-build/build && /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/build/unix/makepchinput.py /mnt/build/workspace/root-pullrequests-build/root . ON etc/cling/Interpreter/DynamicExprInfo.h etc/cling/Interpreter/DynamicLookupRuntimeUniverse.h etc/cling/Interpreter/DynamicLookupLifetimeHandler.h etc/cling/Interpreter/Exception.h etc/cling/Interpreter/RuntimePrintValue.h etc/cling/Interpreter/RuntimeUniverse.h etc/cling/Interpreter/Value.h && /usr/local/bin/cmake -E env ROOTIGNOREPREFIX=1 /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/etc/dictpch/makepch.py etc/allDict.cxx.pch -I/mnt/build/workspace/root-pullrequests-build/build/include. Build and tests were tried separately in this machine. Everything is fine. The build directory is:. /home/sftnight/gallim_multipython/build. Don't know why it does not work with Jenkins.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4647
https://github.com/root-project/root/pull/4647:214,deployability,build,build,214,> Build failed on ROOT-ubuntu16/nortcxxmod. > [See console output](https://epsft-jenkins.cern.ch/job/root-pullrequests-build/72624/console). > . > ### Errors:. > * FAILED: cd /mnt/build/workspace/root-pullrequests-build/build && /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/build/unix/makepchinput.py /mnt/build/workspace/root-pullrequests-build/root . ON etc/cling/Interpreter/DynamicExprInfo.h etc/cling/Interpreter/DynamicLookupRuntimeUniverse.h etc/cling/Interpreter/DynamicLookupLifetimeHandler.h etc/cling/Interpreter/Exception.h etc/cling/Interpreter/RuntimePrintValue.h etc/cling/Interpreter/RuntimeUniverse.h etc/cling/Interpreter/Value.h && /usr/local/bin/cmake -E env ROOTIGNOREPREFIX=1 /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/etc/dictpch/makepch.py etc/allDict.cxx.pch -I/mnt/build/workspace/root-pullrequests-build/build/include. Build and tests were tried separately in this machine. Everything is fine. The build directory is:. /home/sftnight/gallim_multipython/build. Don't know why it does not work with Jenkins.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4647
https://github.com/root-project/root/pull/4647:220,deployability,build,build,220,> Build failed on ROOT-ubuntu16/nortcxxmod. > [See console output](https://epsft-jenkins.cern.ch/job/root-pullrequests-build/72624/console). > . > ### Errors:. > * FAILED: cd /mnt/build/workspace/root-pullrequests-build/build && /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/build/unix/makepchinput.py /mnt/build/workspace/root-pullrequests-build/root . ON etc/cling/Interpreter/DynamicExprInfo.h etc/cling/Interpreter/DynamicLookupRuntimeUniverse.h etc/cling/Interpreter/DynamicLookupLifetimeHandler.h etc/cling/Interpreter/Exception.h etc/cling/Interpreter/RuntimePrintValue.h etc/cling/Interpreter/RuntimeUniverse.h etc/cling/Interpreter/Value.h && /usr/local/bin/cmake -E env ROOTIGNOREPREFIX=1 /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/etc/dictpch/makepch.py etc/allDict.cxx.pch -I/mnt/build/workspace/root-pullrequests-build/build/include. Build and tests were tried separately in this machine. Everything is fine. The build directory is:. /home/sftnight/gallim_multipython/build. Don't know why it does not work with Jenkins.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4647
https://github.com/root-project/root/pull/4647:250,deployability,build,build,250,> Build failed on ROOT-ubuntu16/nortcxxmod. > [See console output](https://epsft-jenkins.cern.ch/job/root-pullrequests-build/72624/console). > . > ### Errors:. > * FAILED: cd /mnt/build/workspace/root-pullrequests-build/build && /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/build/unix/makepchinput.py /mnt/build/workspace/root-pullrequests-build/root . ON etc/cling/Interpreter/DynamicExprInfo.h etc/cling/Interpreter/DynamicLookupRuntimeUniverse.h etc/cling/Interpreter/DynamicLookupLifetimeHandler.h etc/cling/Interpreter/Exception.h etc/cling/Interpreter/RuntimePrintValue.h etc/cling/Interpreter/RuntimeUniverse.h etc/cling/Interpreter/Value.h && /usr/local/bin/cmake -E env ROOTIGNOREPREFIX=1 /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/etc/dictpch/makepch.py etc/allDict.cxx.pch -I/mnt/build/workspace/root-pullrequests-build/build/include. Build and tests were tried separately in this machine. Everything is fine. The build directory is:. /home/sftnight/gallim_multipython/build. Don't know why it does not work with Jenkins.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4647
https://github.com/root-project/root/pull/4647:284,deployability,build,build,284,> Build failed on ROOT-ubuntu16/nortcxxmod. > [See console output](https://epsft-jenkins.cern.ch/job/root-pullrequests-build/72624/console). > . > ### Errors:. > * FAILED: cd /mnt/build/workspace/root-pullrequests-build/build && /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/build/unix/makepchinput.py /mnt/build/workspace/root-pullrequests-build/root . ON etc/cling/Interpreter/DynamicExprInfo.h etc/cling/Interpreter/DynamicLookupRuntimeUniverse.h etc/cling/Interpreter/DynamicLookupLifetimeHandler.h etc/cling/Interpreter/Exception.h etc/cling/Interpreter/RuntimePrintValue.h etc/cling/Interpreter/RuntimeUniverse.h etc/cling/Interpreter/Value.h && /usr/local/bin/cmake -E env ROOTIGNOREPREFIX=1 /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/etc/dictpch/makepch.py etc/allDict.cxx.pch -I/mnt/build/workspace/root-pullrequests-build/build/include. Build and tests were tried separately in this machine. Everything is fine. The build directory is:. /home/sftnight/gallim_multipython/build. Don't know why it does not work with Jenkins.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4647
https://github.com/root-project/root/pull/4647:295,deployability,build,build,295,> Build failed on ROOT-ubuntu16/nortcxxmod. > [See console output](https://epsft-jenkins.cern.ch/job/root-pullrequests-build/72624/console). > . > ### Errors:. > * FAILED: cd /mnt/build/workspace/root-pullrequests-build/build && /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/build/unix/makepchinput.py /mnt/build/workspace/root-pullrequests-build/root . ON etc/cling/Interpreter/DynamicExprInfo.h etc/cling/Interpreter/DynamicLookupRuntimeUniverse.h etc/cling/Interpreter/DynamicLookupLifetimeHandler.h etc/cling/Interpreter/Exception.h etc/cling/Interpreter/RuntimePrintValue.h etc/cling/Interpreter/RuntimeUniverse.h etc/cling/Interpreter/Value.h && /usr/local/bin/cmake -E env ROOTIGNOREPREFIX=1 /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/etc/dictpch/makepch.py etc/allDict.cxx.pch -I/mnt/build/workspace/root-pullrequests-build/build/include. Build and tests were tried separately in this machine. Everything is fine. The build directory is:. /home/sftnight/gallim_multipython/build. Don't know why it does not work with Jenkins.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4647
https://github.com/root-project/root/pull/4647:327,deployability,build,build,327,> Build failed on ROOT-ubuntu16/nortcxxmod. > [See console output](https://epsft-jenkins.cern.ch/job/root-pullrequests-build/72624/console). > . > ### Errors:. > * FAILED: cd /mnt/build/workspace/root-pullrequests-build/build && /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/build/unix/makepchinput.py /mnt/build/workspace/root-pullrequests-build/root . ON etc/cling/Interpreter/DynamicExprInfo.h etc/cling/Interpreter/DynamicLookupRuntimeUniverse.h etc/cling/Interpreter/DynamicLookupLifetimeHandler.h etc/cling/Interpreter/Exception.h etc/cling/Interpreter/RuntimePrintValue.h etc/cling/Interpreter/RuntimeUniverse.h etc/cling/Interpreter/Value.h && /usr/local/bin/cmake -E env ROOTIGNOREPREFIX=1 /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/etc/dictpch/makepch.py etc/allDict.cxx.pch -I/mnt/build/workspace/root-pullrequests-build/build/include. Build and tests were tried separately in this machine. Everything is fine. The build directory is:. /home/sftnight/gallim_multipython/build. Don't know why it does not work with Jenkins.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4647
https://github.com/root-project/root/pull/4647:361,deployability,build,build,361,> Build failed on ROOT-ubuntu16/nortcxxmod. > [See console output](https://epsft-jenkins.cern.ch/job/root-pullrequests-build/72624/console). > . > ### Errors:. > * FAILED: cd /mnt/build/workspace/root-pullrequests-build/build && /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/build/unix/makepchinput.py /mnt/build/workspace/root-pullrequests-build/root . ON etc/cling/Interpreter/DynamicExprInfo.h etc/cling/Interpreter/DynamicLookupRuntimeUniverse.h etc/cling/Interpreter/DynamicLookupLifetimeHandler.h etc/cling/Interpreter/Exception.h etc/cling/Interpreter/RuntimePrintValue.h etc/cling/Interpreter/RuntimeUniverse.h etc/cling/Interpreter/Value.h && /usr/local/bin/cmake -E env ROOTIGNOREPREFIX=1 /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/etc/dictpch/makepch.py etc/allDict.cxx.pch -I/mnt/build/workspace/root-pullrequests-build/build/include. Build and tests were tried separately in this machine. Everything is fine. The build directory is:. /home/sftnight/gallim_multipython/build. Don't know why it does not work with Jenkins.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4647
https://github.com/root-project/root/pull/4647:740,deployability,build,build,740,> Build failed on ROOT-ubuntu16/nortcxxmod. > [See console output](https://epsft-jenkins.cern.ch/job/root-pullrequests-build/72624/console). > . > ### Errors:. > * FAILED: cd /mnt/build/workspace/root-pullrequests-build/build && /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/build/unix/makepchinput.py /mnt/build/workspace/root-pullrequests-build/root . ON etc/cling/Interpreter/DynamicExprInfo.h etc/cling/Interpreter/DynamicLookupRuntimeUniverse.h etc/cling/Interpreter/DynamicLookupLifetimeHandler.h etc/cling/Interpreter/Exception.h etc/cling/Interpreter/RuntimePrintValue.h etc/cling/Interpreter/RuntimeUniverse.h etc/cling/Interpreter/Value.h && /usr/local/bin/cmake -E env ROOTIGNOREPREFIX=1 /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/etc/dictpch/makepch.py etc/allDict.cxx.pch -I/mnt/build/workspace/root-pullrequests-build/build/include. Build and tests were tried separately in this machine. Everything is fine. The build directory is:. /home/sftnight/gallim_multipython/build. Don't know why it does not work with Jenkins.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4647
https://github.com/root-project/root/pull/4647:774,deployability,build,build,774,> Build failed on ROOT-ubuntu16/nortcxxmod. > [See console output](https://epsft-jenkins.cern.ch/job/root-pullrequests-build/72624/console). > . > ### Errors:. > * FAILED: cd /mnt/build/workspace/root-pullrequests-build/build && /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/build/unix/makepchinput.py /mnt/build/workspace/root-pullrequests-build/root . ON etc/cling/Interpreter/DynamicExprInfo.h etc/cling/Interpreter/DynamicLookupRuntimeUniverse.h etc/cling/Interpreter/DynamicLookupLifetimeHandler.h etc/cling/Interpreter/Exception.h etc/cling/Interpreter/RuntimePrintValue.h etc/cling/Interpreter/RuntimeUniverse.h etc/cling/Interpreter/Value.h && /usr/local/bin/cmake -E env ROOTIGNOREPREFIX=1 /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/etc/dictpch/makepch.py etc/allDict.cxx.pch -I/mnt/build/workspace/root-pullrequests-build/build/include. Build and tests were tried separately in this machine. Everything is fine. The build directory is:. /home/sftnight/gallim_multipython/build. Don't know why it does not work with Jenkins.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4647
https://github.com/root-project/root/pull/4647:835,deployability,build,build,835,> Build failed on ROOT-ubuntu16/nortcxxmod. > [See console output](https://epsft-jenkins.cern.ch/job/root-pullrequests-build/72624/console). > . > ### Errors:. > * FAILED: cd /mnt/build/workspace/root-pullrequests-build/build && /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/build/unix/makepchinput.py /mnt/build/workspace/root-pullrequests-build/root . ON etc/cling/Interpreter/DynamicExprInfo.h etc/cling/Interpreter/DynamicLookupRuntimeUniverse.h etc/cling/Interpreter/DynamicLookupLifetimeHandler.h etc/cling/Interpreter/Exception.h etc/cling/Interpreter/RuntimePrintValue.h etc/cling/Interpreter/RuntimeUniverse.h etc/cling/Interpreter/Value.h && /usr/local/bin/cmake -E env ROOTIGNOREPREFIX=1 /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/etc/dictpch/makepch.py etc/allDict.cxx.pch -I/mnt/build/workspace/root-pullrequests-build/build/include. Build and tests were tried separately in this machine. Everything is fine. The build directory is:. /home/sftnight/gallim_multipython/build. Don't know why it does not work with Jenkins.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4647
https://github.com/root-project/root/pull/4647:869,deployability,build,build,869,> Build failed on ROOT-ubuntu16/nortcxxmod. > [See console output](https://epsft-jenkins.cern.ch/job/root-pullrequests-build/72624/console). > . > ### Errors:. > * FAILED: cd /mnt/build/workspace/root-pullrequests-build/build && /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/build/unix/makepchinput.py /mnt/build/workspace/root-pullrequests-build/root . ON etc/cling/Interpreter/DynamicExprInfo.h etc/cling/Interpreter/DynamicLookupRuntimeUniverse.h etc/cling/Interpreter/DynamicLookupLifetimeHandler.h etc/cling/Interpreter/Exception.h etc/cling/Interpreter/RuntimePrintValue.h etc/cling/Interpreter/RuntimeUniverse.h etc/cling/Interpreter/Value.h && /usr/local/bin/cmake -E env ROOTIGNOREPREFIX=1 /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/etc/dictpch/makepch.py etc/allDict.cxx.pch -I/mnt/build/workspace/root-pullrequests-build/build/include. Build and tests were tried separately in this machine. Everything is fine. The build directory is:. /home/sftnight/gallim_multipython/build. Don't know why it does not work with Jenkins.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4647
https://github.com/root-project/root/pull/4647:875,deployability,build,build,875,> Build failed on ROOT-ubuntu16/nortcxxmod. > [See console output](https://epsft-jenkins.cern.ch/job/root-pullrequests-build/72624/console). > . > ### Errors:. > * FAILED: cd /mnt/build/workspace/root-pullrequests-build/build && /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/build/unix/makepchinput.py /mnt/build/workspace/root-pullrequests-build/root . ON etc/cling/Interpreter/DynamicExprInfo.h etc/cling/Interpreter/DynamicLookupRuntimeUniverse.h etc/cling/Interpreter/DynamicLookupLifetimeHandler.h etc/cling/Interpreter/Exception.h etc/cling/Interpreter/RuntimePrintValue.h etc/cling/Interpreter/RuntimeUniverse.h etc/cling/Interpreter/Value.h && /usr/local/bin/cmake -E env ROOTIGNOREPREFIX=1 /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/etc/dictpch/makepch.py etc/allDict.cxx.pch -I/mnt/build/workspace/root-pullrequests-build/build/include. Build and tests were tried separately in this machine. Everything is fine. The build directory is:. /home/sftnight/gallim_multipython/build. Don't know why it does not work with Jenkins.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4647
https://github.com/root-project/root/pull/4647:890,deployability,Build,Build,890,> Build failed on ROOT-ubuntu16/nortcxxmod. > [See console output](https://epsft-jenkins.cern.ch/job/root-pullrequests-build/72624/console). > . > ### Errors:. > * FAILED: cd /mnt/build/workspace/root-pullrequests-build/build && /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/build/unix/makepchinput.py /mnt/build/workspace/root-pullrequests-build/root . ON etc/cling/Interpreter/DynamicExprInfo.h etc/cling/Interpreter/DynamicLookupRuntimeUniverse.h etc/cling/Interpreter/DynamicLookupLifetimeHandler.h etc/cling/Interpreter/Exception.h etc/cling/Interpreter/RuntimePrintValue.h etc/cling/Interpreter/RuntimeUniverse.h etc/cling/Interpreter/Value.h && /usr/local/bin/cmake -E env ROOTIGNOREPREFIX=1 /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/etc/dictpch/makepch.py etc/allDict.cxx.pch -I/mnt/build/workspace/root-pullrequests-build/build/include. Build and tests were tried separately in this machine. Everything is fine. The build directory is:. /home/sftnight/gallim_multipython/build. Don't know why it does not work with Jenkins.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4647
https://github.com/root-project/root/pull/4647:969,deployability,build,build,969,> Build failed on ROOT-ubuntu16/nortcxxmod. > [See console output](https://epsft-jenkins.cern.ch/job/root-pullrequests-build/72624/console). > . > ### Errors:. > * FAILED: cd /mnt/build/workspace/root-pullrequests-build/build && /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/build/unix/makepchinput.py /mnt/build/workspace/root-pullrequests-build/root . ON etc/cling/Interpreter/DynamicExprInfo.h etc/cling/Interpreter/DynamicLookupRuntimeUniverse.h etc/cling/Interpreter/DynamicLookupLifetimeHandler.h etc/cling/Interpreter/Exception.h etc/cling/Interpreter/RuntimePrintValue.h etc/cling/Interpreter/RuntimeUniverse.h etc/cling/Interpreter/Value.h && /usr/local/bin/cmake -E env ROOTIGNOREPREFIX=1 /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/etc/dictpch/makepch.py etc/allDict.cxx.pch -I/mnt/build/workspace/root-pullrequests-build/build/include. Build and tests were tried separately in this machine. Everything is fine. The build directory is:. /home/sftnight/gallim_multipython/build. Don't know why it does not work with Jenkins.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4647
https://github.com/root-project/root/pull/4647:1024,deployability,build,build,1024,> Build failed on ROOT-ubuntu16/nortcxxmod. > [See console output](https://epsft-jenkins.cern.ch/job/root-pullrequests-build/72624/console). > . > ### Errors:. > * FAILED: cd /mnt/build/workspace/root-pullrequests-build/build && /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/build/unix/makepchinput.py /mnt/build/workspace/root-pullrequests-build/root . ON etc/cling/Interpreter/DynamicExprInfo.h etc/cling/Interpreter/DynamicLookupRuntimeUniverse.h etc/cling/Interpreter/DynamicLookupLifetimeHandler.h etc/cling/Interpreter/Exception.h etc/cling/Interpreter/RuntimePrintValue.h etc/cling/Interpreter/RuntimeUniverse.h etc/cling/Interpreter/Value.h && /usr/local/bin/cmake -E env ROOTIGNOREPREFIX=1 /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/etc/dictpch/makepch.py etc/allDict.cxx.pch -I/mnt/build/workspace/root-pullrequests-build/build/include. Build and tests were tried separately in this machine. Everything is fine. The build directory is:. /home/sftnight/gallim_multipython/build. Don't know why it does not work with Jenkins.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4647
https://github.com/root-project/root/pull/4647:151,performance,Error,Errors,151,> Build failed on ROOT-ubuntu16/nortcxxmod. > [See console output](https://epsft-jenkins.cern.ch/job/root-pullrequests-build/72624/console). > . > ### Errors:. > * FAILED: cd /mnt/build/workspace/root-pullrequests-build/build && /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/build/unix/makepchinput.py /mnt/build/workspace/root-pullrequests-build/root . ON etc/cling/Interpreter/DynamicExprInfo.h etc/cling/Interpreter/DynamicLookupRuntimeUniverse.h etc/cling/Interpreter/DynamicLookupLifetimeHandler.h etc/cling/Interpreter/Exception.h etc/cling/Interpreter/RuntimePrintValue.h etc/cling/Interpreter/RuntimeUniverse.h etc/cling/Interpreter/Value.h && /usr/local/bin/cmake -E env ROOTIGNOREPREFIX=1 /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/etc/dictpch/makepch.py etc/allDict.cxx.pch -I/mnt/build/workspace/root-pullrequests-build/build/include. Build and tests were tried separately in this machine. Everything is fine. The build directory is:. /home/sftnight/gallim_multipython/build. Don't know why it does not work with Jenkins.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4647
https://github.com/root-project/root/pull/4647:8,reliability,fail,failed,8,> Build failed on ROOT-ubuntu16/nortcxxmod. > [See console output](https://epsft-jenkins.cern.ch/job/root-pullrequests-build/72624/console). > . > ### Errors:. > * FAILED: cd /mnt/build/workspace/root-pullrequests-build/build && /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/build/unix/makepchinput.py /mnt/build/workspace/root-pullrequests-build/root . ON etc/cling/Interpreter/DynamicExprInfo.h etc/cling/Interpreter/DynamicLookupRuntimeUniverse.h etc/cling/Interpreter/DynamicLookupLifetimeHandler.h etc/cling/Interpreter/Exception.h etc/cling/Interpreter/RuntimePrintValue.h etc/cling/Interpreter/RuntimeUniverse.h etc/cling/Interpreter/Value.h && /usr/local/bin/cmake -E env ROOTIGNOREPREFIX=1 /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/etc/dictpch/makepch.py etc/allDict.cxx.pch -I/mnt/build/workspace/root-pullrequests-build/build/include. Build and tests were tried separately in this machine. Everything is fine. The build directory is:. /home/sftnight/gallim_multipython/build. Don't know why it does not work with Jenkins.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4647
https://github.com/root-project/root/pull/4647:164,reliability,FAIL,FAILED,164,> Build failed on ROOT-ubuntu16/nortcxxmod. > [See console output](https://epsft-jenkins.cern.ch/job/root-pullrequests-build/72624/console). > . > ### Errors:. > * FAILED: cd /mnt/build/workspace/root-pullrequests-build/build && /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/build/unix/makepchinput.py /mnt/build/workspace/root-pullrequests-build/root . ON etc/cling/Interpreter/DynamicExprInfo.h etc/cling/Interpreter/DynamicLookupRuntimeUniverse.h etc/cling/Interpreter/DynamicLookupLifetimeHandler.h etc/cling/Interpreter/Exception.h etc/cling/Interpreter/RuntimePrintValue.h etc/cling/Interpreter/RuntimeUniverse.h etc/cling/Interpreter/Value.h && /usr/local/bin/cmake -E env ROOTIGNOREPREFIX=1 /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/etc/dictpch/makepch.py etc/allDict.cxx.pch -I/mnt/build/workspace/root-pullrequests-build/build/include. Build and tests were tried separately in this machine. Everything is fine. The build directory is:. /home/sftnight/gallim_multipython/build. Don't know why it does not work with Jenkins.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4647
https://github.com/root-project/root/pull/4647:1049,reliability,doe,does,1049,> Build failed on ROOT-ubuntu16/nortcxxmod. > [See console output](https://epsft-jenkins.cern.ch/job/root-pullrequests-build/72624/console). > . > ### Errors:. > * FAILED: cd /mnt/build/workspace/root-pullrequests-build/build && /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/build/unix/makepchinput.py /mnt/build/workspace/root-pullrequests-build/root . ON etc/cling/Interpreter/DynamicExprInfo.h etc/cling/Interpreter/DynamicLookupRuntimeUniverse.h etc/cling/Interpreter/DynamicLookupLifetimeHandler.h etc/cling/Interpreter/Exception.h etc/cling/Interpreter/RuntimePrintValue.h etc/cling/Interpreter/RuntimeUniverse.h etc/cling/Interpreter/Value.h && /usr/local/bin/cmake -E env ROOTIGNOREPREFIX=1 /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/etc/dictpch/makepch.py etc/allDict.cxx.pch -I/mnt/build/workspace/root-pullrequests-build/build/include. Build and tests were tried separately in this machine. Everything is fine. The build directory is:. /home/sftnight/gallim_multipython/build. Don't know why it does not work with Jenkins.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4647
https://github.com/root-project/root/pull/4647:151,safety,Error,Errors,151,> Build failed on ROOT-ubuntu16/nortcxxmod. > [See console output](https://epsft-jenkins.cern.ch/job/root-pullrequests-build/72624/console). > . > ### Errors:. > * FAILED: cd /mnt/build/workspace/root-pullrequests-build/build && /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/build/unix/makepchinput.py /mnt/build/workspace/root-pullrequests-build/root . ON etc/cling/Interpreter/DynamicExprInfo.h etc/cling/Interpreter/DynamicLookupRuntimeUniverse.h etc/cling/Interpreter/DynamicLookupLifetimeHandler.h etc/cling/Interpreter/Exception.h etc/cling/Interpreter/RuntimePrintValue.h etc/cling/Interpreter/RuntimeUniverse.h etc/cling/Interpreter/Value.h && /usr/local/bin/cmake -E env ROOTIGNOREPREFIX=1 /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/etc/dictpch/makepch.py etc/allDict.cxx.pch -I/mnt/build/workspace/root-pullrequests-build/build/include. Build and tests were tried separately in this machine. Everything is fine. The build directory is:. /home/sftnight/gallim_multipython/build. Don't know why it does not work with Jenkins.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4647
https://github.com/root-project/root/pull/4647:545,safety,Except,Exception,545,> Build failed on ROOT-ubuntu16/nortcxxmod. > [See console output](https://epsft-jenkins.cern.ch/job/root-pullrequests-build/72624/console). > . > ### Errors:. > * FAILED: cd /mnt/build/workspace/root-pullrequests-build/build && /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/build/unix/makepchinput.py /mnt/build/workspace/root-pullrequests-build/root . ON etc/cling/Interpreter/DynamicExprInfo.h etc/cling/Interpreter/DynamicLookupRuntimeUniverse.h etc/cling/Interpreter/DynamicLookupLifetimeHandler.h etc/cling/Interpreter/Exception.h etc/cling/Interpreter/RuntimePrintValue.h etc/cling/Interpreter/RuntimeUniverse.h etc/cling/Interpreter/Value.h && /usr/local/bin/cmake -E env ROOTIGNOREPREFIX=1 /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/etc/dictpch/makepch.py etc/allDict.cxx.pch -I/mnt/build/workspace/root-pullrequests-build/build/include. Build and tests were tried separately in this machine. Everything is fine. The build directory is:. /home/sftnight/gallim_multipython/build. Don't know why it does not work with Jenkins.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4647
https://github.com/root-project/root/pull/4647:900,safety,test,tests,900,> Build failed on ROOT-ubuntu16/nortcxxmod. > [See console output](https://epsft-jenkins.cern.ch/job/root-pullrequests-build/72624/console). > . > ### Errors:. > * FAILED: cd /mnt/build/workspace/root-pullrequests-build/build && /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/build/unix/makepchinput.py /mnt/build/workspace/root-pullrequests-build/root . ON etc/cling/Interpreter/DynamicExprInfo.h etc/cling/Interpreter/DynamicLookupRuntimeUniverse.h etc/cling/Interpreter/DynamicLookupLifetimeHandler.h etc/cling/Interpreter/Exception.h etc/cling/Interpreter/RuntimePrintValue.h etc/cling/Interpreter/RuntimeUniverse.h etc/cling/Interpreter/Value.h && /usr/local/bin/cmake -E env ROOTIGNOREPREFIX=1 /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/etc/dictpch/makepch.py etc/allDict.cxx.pch -I/mnt/build/workspace/root-pullrequests-build/build/include. Build and tests were tried separately in this machine. Everything is fine. The build directory is:. /home/sftnight/gallim_multipython/build. Don't know why it does not work with Jenkins.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4647
https://github.com/root-project/root/pull/4647:900,testability,test,tests,900,> Build failed on ROOT-ubuntu16/nortcxxmod. > [See console output](https://epsft-jenkins.cern.ch/job/root-pullrequests-build/72624/console). > . > ### Errors:. > * FAILED: cd /mnt/build/workspace/root-pullrequests-build/build && /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/build/unix/makepchinput.py /mnt/build/workspace/root-pullrequests-build/root . ON etc/cling/Interpreter/DynamicExprInfo.h etc/cling/Interpreter/DynamicLookupRuntimeUniverse.h etc/cling/Interpreter/DynamicLookupLifetimeHandler.h etc/cling/Interpreter/Exception.h etc/cling/Interpreter/RuntimePrintValue.h etc/cling/Interpreter/RuntimeUniverse.h etc/cling/Interpreter/Value.h && /usr/local/bin/cmake -E env ROOTIGNOREPREFIX=1 /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/etc/dictpch/makepch.py etc/allDict.cxx.pch -I/mnt/build/workspace/root-pullrequests-build/build/include. Build and tests were tried separately in this machine. Everything is fine. The build directory is:. /home/sftnight/gallim_multipython/build. Don't know why it does not work with Jenkins.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4647
https://github.com/root-project/root/pull/4647:151,usability,Error,Errors,151,> Build failed on ROOT-ubuntu16/nortcxxmod. > [See console output](https://epsft-jenkins.cern.ch/job/root-pullrequests-build/72624/console). > . > ### Errors:. > * FAILED: cd /mnt/build/workspace/root-pullrequests-build/build && /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/build/unix/makepchinput.py /mnt/build/workspace/root-pullrequests-build/root . ON etc/cling/Interpreter/DynamicExprInfo.h etc/cling/Interpreter/DynamicLookupRuntimeUniverse.h etc/cling/Interpreter/DynamicLookupLifetimeHandler.h etc/cling/Interpreter/Exception.h etc/cling/Interpreter/RuntimePrintValue.h etc/cling/Interpreter/RuntimeUniverse.h etc/cling/Interpreter/Value.h && /usr/local/bin/cmake -E env ROOTIGNOREPREFIX=1 /usr/bin/python /mnt/build/workspace/root-pullrequests-build/root/etc/dictpch/makepch.py etc/allDict.cxx.pch -I/mnt/build/workspace/root-pullrequests-build/build/include. Build and tests were tried separately in this machine. Everything is fine. The build directory is:. /home/sftnight/gallim_multipython/build. Don't know why it does not work with Jenkins.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4647
https://github.com/root-project/root/pull/4647:11,deployability,build,build,11,@phsft-bot build with flags -Dpyroot_experimental=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4647
https://github.com/root-project/root/pull/4647:11,deployability,build,build,11,@phsft-bot build with flags -Dpyroot_experimental=OFF,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4647
https://github.com/root-project/root/pull/4649:279,performance,time,times,279,"Hi @goi42 , thank you very much for the contribution! We definitely want the typo fix and it looks like @pcanal likes the new feature in `TDirectoryFile`. However, for `Snapshot` I wonder whether we shouldn't figure out why `Snapshot` tries to create the same directory multiple times in the first place -- i.e. your change might silence the only sign we have that something fishy is going on in Snapshot.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:347,security,sign,sign,347,"Hi @goi42 , thank you very much for the contribution! We definitely want the typo fix and it looks like @pcanal likes the new feature in `TDirectoryFile`. However, for `Snapshot` I wonder whether we shouldn't figure out why `Snapshot` tries to create the same directory multiple times in the first place -- i.e. your change might silence the only sign we have that something fishy is going on in Snapshot.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:93,performance,time,times,93,"> Is it in fact the case that Snapshot should not be trying to create the directory multiple times? Let's just say it's not a conscious design choice :sweat_smile: requires a bit of investigation -- might be nothing, and it's fine to just silence the warnings, or it might be some undesirable behavior that we should correct (maybe there is more work than that that is done too many times and shouldn't)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:383,performance,time,times,383,"> Is it in fact the case that Snapshot should not be trying to create the directory multiple times? Let's just say it's not a conscious design choice :sweat_smile: requires a bit of investigation -- might be nothing, and it's fine to just silence the warnings, or it might be some undesirable behavior that we should correct (maybe there is more work than that that is done too many times and shouldn't)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:293,usability,behavi,behavior,293,"> Is it in fact the case that Snapshot should not be trying to create the directory multiple times? Let's just say it's not a conscious design choice :sweat_smile: requires a bit of investigation -- might be nothing, and it's fine to just silence the warnings, or it might be some undesirable behavior that we should correct (maybe there is more work than that that is done too many times and shouldn't)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:97,usability,behavi,behavior,97,Looks good. Thanks. One last question (my apologies if I missed the answer): why a difference in behavior between TDirectory and TDirectoryFile?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:117,security,sign,sign,117,"Great, thanks! Looks like we just need @pcanal to verify the requested changes and for @Axel-Naumann and @dpiparo to sign off.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:50,testability,verif,verify,50,"Great, thanks! Looks like we just need @pcanal to verify the requested changes and for @Axel-Naumann and @dpiparo to sign off.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:62,safety,test,test,62,I'll go ahead and merge this. Would you also be able to add a test for the feature (tested either directly or indirectly via TDataFrame)?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:84,safety,test,tested,84,I'll go ahead and merge this. Would you also be able to add a test for the feature (tested either directly or indirectly via TDataFrame)?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:62,testability,test,test,62,I'll go ahead and merge this. Would you also be able to add a test for the feature (tested either directly or indirectly via TDataFrame)?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:84,testability,test,tested,84,I'll go ahead and merge this. Would you also be able to add a test for the feature (tested either directly or indirectly via TDataFrame)?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:72,availability,error,error,72,"@pcanal I've added the requested tests. However, it is failing with the error. ```text. ***Failed Error regular expression found in output. Regex=[FAILED|Error in] 30.74 sec. ```. I'm not sure what's causing this problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:98,availability,Error,Error,98,"@pcanal I've added the requested tests. However, it is failing with the error. ```text. ***Failed Error regular expression found in output. Regex=[FAILED|Error in] 30.74 sec. ```. I'm not sure what's causing this problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:154,availability,Error,Error,154,"@pcanal I've added the requested tests. However, it is failing with the error. ```text. ***Failed Error regular expression found in output. Regex=[FAILED|Error in] 30.74 sec. ```. I'm not sure what's causing this problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:55,deployability,fail,failing,55,"@pcanal I've added the requested tests. However, it is failing with the error. ```text. ***Failed Error regular expression found in output. Regex=[FAILED|Error in] 30.74 sec. ```. I'm not sure what's causing this problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:91,deployability,Fail,Failed,91,"@pcanal I've added the requested tests. However, it is failing with the error. ```text. ***Failed Error regular expression found in output. Regex=[FAILED|Error in] 30.74 sec. ```. I'm not sure what's causing this problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:147,deployability,FAIL,FAILED,147,"@pcanal I've added the requested tests. However, it is failing with the error. ```text. ***Failed Error regular expression found in output. Regex=[FAILED|Error in] 30.74 sec. ```. I'm not sure what's causing this problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:72,performance,error,error,72,"@pcanal I've added the requested tests. However, it is failing with the error. ```text. ***Failed Error regular expression found in output. Regex=[FAILED|Error in] 30.74 sec. ```. I'm not sure what's causing this problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:98,performance,Error,Error,98,"@pcanal I've added the requested tests. However, it is failing with the error. ```text. ***Failed Error regular expression found in output. Regex=[FAILED|Error in] 30.74 sec. ```. I'm not sure what's causing this problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:154,performance,Error,Error,154,"@pcanal I've added the requested tests. However, it is failing with the error. ```text. ***Failed Error regular expression found in output. Regex=[FAILED|Error in] 30.74 sec. ```. I'm not sure what's causing this problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:55,reliability,fail,failing,55,"@pcanal I've added the requested tests. However, it is failing with the error. ```text. ***Failed Error regular expression found in output. Regex=[FAILED|Error in] 30.74 sec. ```. I'm not sure what's causing this problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:91,reliability,Fail,Failed,91,"@pcanal I've added the requested tests. However, it is failing with the error. ```text. ***Failed Error regular expression found in output. Regex=[FAILED|Error in] 30.74 sec. ```. I'm not sure what's causing this problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:147,reliability,FAIL,FAILED,147,"@pcanal I've added the requested tests. However, it is failing with the error. ```text. ***Failed Error regular expression found in output. Regex=[FAILED|Error in] 30.74 sec. ```. I'm not sure what's causing this problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:33,safety,test,tests,33,"@pcanal I've added the requested tests. However, it is failing with the error. ```text. ***Failed Error regular expression found in output. Regex=[FAILED|Error in] 30.74 sec. ```. I'm not sure what's causing this problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:72,safety,error,error,72,"@pcanal I've added the requested tests. However, it is failing with the error. ```text. ***Failed Error regular expression found in output. Regex=[FAILED|Error in] 30.74 sec. ```. I'm not sure what's causing this problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:98,safety,Error,Error,98,"@pcanal I've added the requested tests. However, it is failing with the error. ```text. ***Failed Error regular expression found in output. Regex=[FAILED|Error in] 30.74 sec. ```. I'm not sure what's causing this problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:154,safety,Error,Error,154,"@pcanal I've added the requested tests. However, it is failing with the error. ```text. ***Failed Error regular expression found in output. Regex=[FAILED|Error in] 30.74 sec. ```. I'm not sure what's causing this problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:33,testability,test,tests,33,"@pcanal I've added the requested tests. However, it is failing with the error. ```text. ***Failed Error regular expression found in output. Regex=[FAILED|Error in] 30.74 sec. ```. I'm not sure what's causing this problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:72,usability,error,error,72,"@pcanal I've added the requested tests. However, it is failing with the error. ```text. ***Failed Error regular expression found in output. Regex=[FAILED|Error in] 30.74 sec. ```. I'm not sure what's causing this problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:98,usability,Error,Error,98,"@pcanal I've added the requested tests. However, it is failing with the error. ```text. ***Failed Error regular expression found in output. Regex=[FAILED|Error in] 30.74 sec. ```. I'm not sure what's causing this problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:154,usability,Error,Error,154,"@pcanal I've added the requested tests. However, it is failing with the error. ```text. ***Failed Error regular expression found in output. Regex=[FAILED|Error in] 30.74 sec. ```. I'm not sure what's causing this problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:121,usability,help,help,121,"Okay, @pcanal, I think it's ready to go. Let me know if any other changes need to be made. Thanks for your attention and help!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:11,deployability,build,build,11,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:57,deployability,build,build,57,@pcanal I cast the pointers into intptr_t. Hopefully the build will work now.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:11,deployability,build,build,11,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:76,deployability,build,build,76,"@pcanal I have switched to using %p, but I see you have already started the build. Let me know if you prefer I revert to casting after all.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:102,usability,prefer,prefer,102,"@pcanal I have switched to using %p, but I see you have already started the build. Let me know if you prefer I revert to casting after all.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:11,deployability,build,build,11,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:73,deployability,build,build,73,"@pcanal sorry for the many adjustments. I don't see these warnings on my build, so I'm sort of shooting in the dark. Hopefully this last change finally fixes it.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:11,deployability,build,build,11,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:11,deployability,build,build,11,"@phsft-bot build just on mac1014/cxx17, windows10/cxx14 with flags -DCTEST_TEST_EXCLUDE_NONE=On",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:8,availability,failur,failure,8,Windows failure is infrastructure related. Merging. Thank you very much for your contribution!!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:8,deployability,fail,failure,8,Windows failure is infrastructure related. Merging. Thank you very much for your contribution!!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:19,deployability,infrastructur,infrastructure,19,Windows failure is infrastructure related. Merging. Thank you very much for your contribution!!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:8,performance,failur,failure,8,Windows failure is infrastructure related. Merging. Thank you very much for your contribution!!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4649:8,reliability,fail,failure,8,Windows failure is infrastructure related. Merging. Thank you very much for your contribution!!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4649
https://github.com/root-project/root/pull/4650:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4650
https://github.com/root-project/root/pull/4651:11,deployability,build,build,11,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4651
https://github.com/root-project/root/pull/4651:34,deployability,build,build,34,@bellenot Do you know why the TBB build failed 'just' this time on Windows?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4651
https://github.com/root-project/root/pull/4651:40,deployability,fail,failed,40,@bellenot Do you know why the TBB build failed 'just' this time on Windows?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4651
https://github.com/root-project/root/pull/4651:59,performance,time,time,59,@bellenot Do you know why the TBB build failed 'just' this time on Windows?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4651
https://github.com/root-project/root/pull/4651:40,reliability,fail,failed,40,@bellenot Do you know why the TBB build failed 'just' this time on Windows?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4651
https://github.com/root-project/root/pull/4651:12,availability,failur,failure,12,The windows failure is unrelated merging.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4651
https://github.com/root-project/root/pull/4651:12,deployability,fail,failure,12,The windows failure is unrelated merging.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4651
https://github.com/root-project/root/pull/4651:12,performance,failur,failure,12,The windows failure is unrelated merging.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4651
https://github.com/root-project/root/pull/4651:12,reliability,fail,failure,12,The windows failure is unrelated merging.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4651
https://github.com/root-project/root/pull/4652:105,performance,Network,NetworkDesigner,105,[This](https://github.com/linev/root/blob/e6888cc8d4fbee97a3a637851d632112f4de56ea/etc/notebook/JsMVA/js/NetworkDesigner.js#L22) should also be fixed.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4652
https://github.com/root-project/root/pull/4652:105,security,Network,NetworkDesigner,105,[This](https://github.com/linev/root/blob/e6888cc8d4fbee97a3a637851d632112f4de56ea/etc/notebook/JsMVA/js/NetworkDesigner.js#L22) should also be fixed.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4652
https://github.com/root-project/root/pull/4653:1,availability,sli,slinev,1,@slinev please check,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4653
https://github.com/root-project/root/pull/4653:1,reliability,sli,slinev,1,@slinev please check,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4653
https://github.com/root-project/root/pull/4654:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4654
https://github.com/root-project/root/pull/4654:22,safety,review,review,22,Let's wait for @linev review,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4654
https://github.com/root-project/root/pull/4654:22,testability,review,review,22,Let's wait for @linev review,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4654
https://github.com/root-project/root/pull/4655:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4655
https://github.com/root-project/root/pull/4656:11,deployability,build,build,11,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4656
https://github.com/root-project/root/pull/4656:8,deployability,updat,updated,8,Jenkins updated wrongly the status of this PR. Cdash shows full set of tests being green.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4656
https://github.com/root-project/root/pull/4656:83,energy efficiency,green,green,83,Jenkins updated wrongly the status of this PR. Cdash shows full set of tests being green.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4656
https://github.com/root-project/root/pull/4656:8,safety,updat,updated,8,Jenkins updated wrongly the status of this PR. Cdash shows full set of tests being green.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4656
https://github.com/root-project/root/pull/4656:71,safety,test,tests,71,Jenkins updated wrongly the status of this PR. Cdash shows full set of tests being green.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4656
https://github.com/root-project/root/pull/4656:8,security,updat,updated,8,Jenkins updated wrongly the status of this PR. Cdash shows full set of tests being green.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4656
https://github.com/root-project/root/pull/4656:71,testability,test,tests,71,Jenkins updated wrongly the status of this PR. Cdash shows full set of tests being green.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4656
https://github.com/root-project/root/pull/4656:28,usability,statu,status,28,Jenkins updated wrongly the status of this PR. Cdash shows full set of tests being green.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4656
https://github.com/root-project/root/pull/4662:19,usability,dialog,dialog,19,"> I guess the same dialog can be used to save and to open files, right? There are small differences between Save as and Open and New file dialog. But in principle, same class will be used to cover all use cases.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4662
https://github.com/root-project/root/pull/4662:138,usability,dialog,dialog,138,"> I guess the same dialog can be used to save and to open files, right? There are small differences between Save as and Open and New file dialog. But in principle, same class will be used to cover all use cases.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4662
https://github.com/root-project/root/pull/4664:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4664
https://github.com/root-project/root/pull/4668:14,availability,ping,ping,14,@ktf @aalkin: ping: this is an alternative solution that works for me to solve the LLVM symbol issue.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:78,interoperability,platform,platforms,78,@davidrohr We have at least Mac which does not have RTLD_DEEPBIND and several platforms where things are not working properly .. @Axel-Naumann might be able to give more information on why that is the case.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:38,reliability,doe,does,38,@davidrohr We have at least Mac which does not have RTLD_DEEPBIND and several platforms where things are not working properly .. @Axel-Naumann might be able to give more information on why that is the case.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:379,deployability,depend,dependencies,379,"@pcanal : Thx, I have seen that. For MacOS, as I said in the OP, I was expecting problems.. I am really puzzled by the segfaults though. I mean, if it was working before, I do not see how the RTLD_DEEPBIND should break something. That basically means, that there is already a global symbol of something loaded, that should have precedence over symbols in libCling and libCling's dependencies. But OK, I am not that much an expert of the ROOT internals.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:303,energy efficiency,load,loaded,303,"@pcanal : Thx, I have seen that. For MacOS, as I said in the OP, I was expecting problems.. I am really puzzled by the segfaults though. I mean, if it was working before, I do not see how the RTLD_DEEPBIND should break something. That basically means, that there is already a global symbol of something loaded, that should have precedence over symbols in libCling and libCling's dependencies. But OK, I am not that much an expert of the ROOT internals.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:379,integrability,depend,dependencies,379,"@pcanal : Thx, I have seen that. For MacOS, as I said in the OP, I was expecting problems.. I am really puzzled by the segfaults though. I mean, if it was working before, I do not see how the RTLD_DEEPBIND should break something. That basically means, that there is already a global symbol of something loaded, that should have precedence over symbols in libCling and libCling's dependencies. But OK, I am not that much an expert of the ROOT internals.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:379,modifiability,depend,dependencies,379,"@pcanal : Thx, I have seen that. For MacOS, as I said in the OP, I was expecting problems.. I am really puzzled by the segfaults though. I mean, if it was working before, I do not see how the RTLD_DEEPBIND should break something. That basically means, that there is already a global symbol of something loaded, that should have precedence over symbols in libCling and libCling's dependencies. But OK, I am not that much an expert of the ROOT internals.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:303,performance,load,loaded,303,"@pcanal : Thx, I have seen that. For MacOS, as I said in the OP, I was expecting problems.. I am really puzzled by the segfaults though. I mean, if it was working before, I do not see how the RTLD_DEEPBIND should break something. That basically means, that there is already a global symbol of something loaded, that should have precedence over symbols in libCling and libCling's dependencies. But OK, I am not that much an expert of the ROOT internals.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:379,safety,depend,dependencies,379,"@pcanal : Thx, I have seen that. For MacOS, as I said in the OP, I was expecting problems.. I am really puzzled by the segfaults though. I mean, if it was working before, I do not see how the RTLD_DEEPBIND should break something. That basically means, that there is already a global symbol of something loaded, that should have precedence over symbols in libCling and libCling's dependencies. But OK, I am not that much an expert of the ROOT internals.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:379,testability,depend,dependencies,379,"@pcanal : Thx, I have seen that. For MacOS, as I said in the OP, I was expecting problems.. I am really puzzled by the segfaults though. I mean, if it was working before, I do not see how the RTLD_DEEPBIND should break something. That basically means, that there is already a global symbol of something loaded, that should have precedence over symbols in libCling and libCling's dependencies. But OK, I am not that much an expert of the ROOT internals.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:155,deployability,patch,patch,155,"Why would you remove that line? - This lines hides ROOT's LLVM 5 symbols from other libraries, so this should be fine is certainly what we want. - What my patch should do is is kind of the other way around, if there are other libraries exposing LLVM symbols, ROOT should still take its own LLVM 5 symbols. In this way, other libraries do not need to hide their symbols.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:155,safety,patch,patch,155,"Why would you remove that line? - This lines hides ROOT's LLVM 5 symbols from other libraries, so this should be fine is certainly what we want. - What my patch should do is is kind of the other way around, if there are other libraries exposing LLVM symbols, ROOT should still take its own LLVM 5 symbols. In this way, other libraries do not need to hide their symbols.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:155,security,patch,patch,155,"Why would you remove that line? - This lines hides ROOT's LLVM 5 symbols from other libraries, so this should be fine is certainly what we want. - What my patch should do is is kind of the other way around, if there are other libraries exposing LLVM symbols, ROOT should still take its own LLVM 5 symbols. In this way, other libraries do not need to hide their symbols.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:236,security,expos,exposing,236,"Why would you remove that line? - This lines hides ROOT's LLVM 5 symbols from other libraries, so this should be fine is certainly what we want. - What my patch should do is is kind of the other way around, if there are other libraries exposing LLVM symbols, ROOT should still take its own LLVM 5 symbols. In this way, other libraries do not need to hide their symbols.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:862,availability,error,error,862,"> Why would you remove that line? > . > * This lines hides ROOT's LLVM 5 symbols from other libraries, so this should be fine is certainly what we want. > * What my patch should do is is kind of the other way around, if there are other libraries exposing LLVM symbols, ROOT should still take its own LLVM 5 symbols. In this way, other libraries do not need to hide their symbols. I’ve missed a bit where your intent is to lift the requirements on other llvm libraries being compiled with hidden visibility. Could you describe your setup in a bit more detail? dlopen-ing libCling is one side of the problem the other is the jit symbol resolution (https://github.com/root-project/root/blob/master/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299) I suspect the latter is the issue. . PS: Can you paste the issue you have and a particular code snippet and error message.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:165,deployability,patch,patch,165,"> Why would you remove that line? > . > * This lines hides ROOT's LLVM 5 symbols from other libraries, so this should be fine is certainly what we want. > * What my patch should do is is kind of the other way around, if there are other libraries exposing LLVM symbols, ROOT should still take its own LLVM 5 symbols. In this way, other libraries do not need to hide their symbols. I’ve missed a bit where your intent is to lift the requirements on other llvm libraries being compiled with hidden visibility. Could you describe your setup in a bit more detail? dlopen-ing libCling is one side of the problem the other is the jit symbol resolution (https://github.com/root-project/root/blob/master/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299) I suspect the latter is the issue. . PS: Can you paste the issue you have and a particular code snippet and error message.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:868,integrability,messag,message,868,"> Why would you remove that line? > . > * This lines hides ROOT's LLVM 5 symbols from other libraries, so this should be fine is certainly what we want. > * What my patch should do is is kind of the other way around, if there are other libraries exposing LLVM symbols, ROOT should still take its own LLVM 5 symbols. In this way, other libraries do not need to hide their symbols. I’ve missed a bit where your intent is to lift the requirements on other llvm libraries being compiled with hidden visibility. Could you describe your setup in a bit more detail? dlopen-ing libCling is one side of the problem the other is the jit symbol resolution (https://github.com/root-project/root/blob/master/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299) I suspect the latter is the issue. . PS: Can you paste the issue you have and a particular code snippet and error message.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:868,interoperability,messag,message,868,"> Why would you remove that line? > . > * This lines hides ROOT's LLVM 5 symbols from other libraries, so this should be fine is certainly what we want. > * What my patch should do is is kind of the other way around, if there are other libraries exposing LLVM symbols, ROOT should still take its own LLVM 5 symbols. In this way, other libraries do not need to hide their symbols. I’ve missed a bit where your intent is to lift the requirements on other llvm libraries being compiled with hidden visibility. Could you describe your setup in a bit more detail? dlopen-ing libCling is one side of the problem the other is the jit symbol resolution (https://github.com/root-project/root/blob/master/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299) I suspect the latter is the issue. . PS: Can you paste the issue you have and a particular code snippet and error message.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:862,performance,error,error,862,"> Why would you remove that line? > . > * This lines hides ROOT's LLVM 5 symbols from other libraries, so this should be fine is certainly what we want. > * What my patch should do is is kind of the other way around, if there are other libraries exposing LLVM symbols, ROOT should still take its own LLVM 5 symbols. In this way, other libraries do not need to hide their symbols. I’ve missed a bit where your intent is to lift the requirements on other llvm libraries being compiled with hidden visibility. Could you describe your setup in a bit more detail? dlopen-ing libCling is one side of the problem the other is the jit symbol resolution (https://github.com/root-project/root/blob/master/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299) I suspect the latter is the issue. . PS: Can you paste the issue you have and a particular code snippet and error message.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:165,safety,patch,patch,165,"> Why would you remove that line? > . > * This lines hides ROOT's LLVM 5 symbols from other libraries, so this should be fine is certainly what we want. > * What my patch should do is is kind of the other way around, if there are other libraries exposing LLVM symbols, ROOT should still take its own LLVM 5 symbols. In this way, other libraries do not need to hide their symbols. I’ve missed a bit where your intent is to lift the requirements on other llvm libraries being compiled with hidden visibility. Could you describe your setup in a bit more detail? dlopen-ing libCling is one side of the problem the other is the jit symbol resolution (https://github.com/root-project/root/blob/master/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299) I suspect the latter is the issue. . PS: Can you paste the issue you have and a particular code snippet and error message.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:862,safety,error,error,862,"> Why would you remove that line? > . > * This lines hides ROOT's LLVM 5 symbols from other libraries, so this should be fine is certainly what we want. > * What my patch should do is is kind of the other way around, if there are other libraries exposing LLVM symbols, ROOT should still take its own LLVM 5 symbols. In this way, other libraries do not need to hide their symbols. I’ve missed a bit where your intent is to lift the requirements on other llvm libraries being compiled with hidden visibility. Could you describe your setup in a bit more detail? dlopen-ing libCling is one side of the problem the other is the jit symbol resolution (https://github.com/root-project/root/blob/master/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299) I suspect the latter is the issue. . PS: Can you paste the issue you have and a particular code snippet and error message.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:165,security,patch,patch,165,"> Why would you remove that line? > . > * This lines hides ROOT's LLVM 5 symbols from other libraries, so this should be fine is certainly what we want. > * What my patch should do is is kind of the other way around, if there are other libraries exposing LLVM symbols, ROOT should still take its own LLVM 5 symbols. In this way, other libraries do not need to hide their symbols. I’ve missed a bit where your intent is to lift the requirements on other llvm libraries being compiled with hidden visibility. Could you describe your setup in a bit more detail? dlopen-ing libCling is one side of the problem the other is the jit symbol resolution (https://github.com/root-project/root/blob/master/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299) I suspect the latter is the issue. . PS: Can you paste the issue you have and a particular code snippet and error message.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:246,security,expos,exposing,246,"> Why would you remove that line? > . > * This lines hides ROOT's LLVM 5 symbols from other libraries, so this should be fine is certainly what we want. > * What my patch should do is is kind of the other way around, if there are other libraries exposing LLVM symbols, ROOT should still take its own LLVM 5 symbols. In this way, other libraries do not need to hide their symbols. I’ve missed a bit where your intent is to lift the requirements on other llvm libraries being compiled with hidden visibility. Could you describe your setup in a bit more detail? dlopen-ing libCling is one side of the problem the other is the jit symbol resolution (https://github.com/root-project/root/blob/master/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299) I suspect the latter is the issue. . PS: Can you paste the issue you have and a particular code snippet and error message.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:862,usability,error,error,862,"> Why would you remove that line? > . > * This lines hides ROOT's LLVM 5 symbols from other libraries, so this should be fine is certainly what we want. > * What my patch should do is is kind of the other way around, if there are other libraries exposing LLVM symbols, ROOT should still take its own LLVM 5 symbols. In this way, other libraries do not need to hide their symbols. I’ve missed a bit where your intent is to lift the requirements on other llvm libraries being compiled with hidden visibility. Could you describe your setup in a bit more detail? dlopen-ing libCling is one side of the problem the other is the jit symbol resolution (https://github.com/root-project/root/blob/master/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299) I suspect the latter is the issue. . PS: Can you paste the issue you have and a particular code snippet and error message.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:239,availability,error,error,239,"I have trouble compiling the ALICE O2 with ROOT and some other libraries, which come with LLVM. For me, this is in particular:. - arrow with gandiva. - glfw with vulkan support. - several OpenCL runtimes, which use LLVM. I was getting the error `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` and a segmentation fault thereafter. Now, it is a bit complicated to require from all 3rd party libraries that they do not export LLVM symbols, so I was trying to solve the problem on the ROOT side. I fully agree that the problem is most likely due to just in time resolving of symbols. But I am wondering why my patch would break something in the ROOT ctests. Before my patch, the check would make sure that there are no other LLVM symbols present. But when there are no other symbols present, my patch shouldn't change anything. One could try to open libCling with RTLD_NOW instead of RTLD_LAZY, but I am not sure whether that would change anything.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:346,availability,fault,fault,346,"I have trouble compiling the ALICE O2 with ROOT and some other libraries, which come with LLVM. For me, this is in particular:. - arrow with gandiva. - glfw with vulkan support. - several OpenCL runtimes, which use LLVM. I was getting the error `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` and a segmentation fault thereafter. Now, it is a bit complicated to require from all 3rd party libraries that they do not export LLVM symbols, so I was trying to solve the problem on the ROOT side. I fully agree that the problem is most likely due to just in time resolving of symbols. But I am wondering why my patch would break something in the ROOT ctests. Before my patch, the check would make sure that there are no other LLVM symbols present. But when there are no other symbols present, my patch shouldn't change anything. One could try to open libCling with RTLD_NOW instead of RTLD_LAZY, but I am not sure whether that would change anything.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:640,deployability,patch,patch,640,"I have trouble compiling the ALICE O2 with ROOT and some other libraries, which come with LLVM. For me, this is in particular:. - arrow with gandiva. - glfw with vulkan support. - several OpenCL runtimes, which use LLVM. I was getting the error `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` and a segmentation fault thereafter. Now, it is a bit complicated to require from all 3rd party libraries that they do not export LLVM symbols, so I was trying to solve the problem on the ROOT side. I fully agree that the problem is most likely due to just in time resolving of symbols. But I am wondering why my patch would break something in the ROOT ctests. Before my patch, the check would make sure that there are no other LLVM symbols present. But when there are no other symbols present, my patch shouldn't change anything. One could try to open libCling with RTLD_NOW instead of RTLD_LAZY, but I am not sure whether that would change anything.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:698,deployability,patch,patch,698,"I have trouble compiling the ALICE O2 with ROOT and some other libraries, which come with LLVM. For me, this is in particular:. - arrow with gandiva. - glfw with vulkan support. - several OpenCL runtimes, which use LLVM. I was getting the error `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` and a segmentation fault thereafter. Now, it is a bit complicated to require from all 3rd party libraries that they do not export LLVM symbols, so I was trying to solve the problem on the ROOT side. I fully agree that the problem is most likely due to just in time resolving of symbols. But I am wondering why my patch would break something in the ROOT ctests. Before my patch, the check would make sure that there are no other LLVM symbols present. But when there are no other symbols present, my patch shouldn't change anything. One could try to open libCling with RTLD_NOW instead of RTLD_LAZY, but I am not sure whether that would change anything.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:825,deployability,patch,patch,825,"I have trouble compiling the ALICE O2 with ROOT and some other libraries, which come with LLVM. For me, this is in particular:. - arrow with gandiva. - glfw with vulkan support. - several OpenCL runtimes, which use LLVM. I was getting the error `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` and a segmentation fault thereafter. Now, it is a bit complicated to require from all 3rd party libraries that they do not export LLVM symbols, so I was trying to solve the problem on the ROOT side. I fully agree that the problem is most likely due to just in time resolving of symbols. But I am wondering why my patch would break something in the ROOT ctests. Before my patch, the check would make sure that there are no other LLVM symbols present. But when there are no other symbols present, my patch shouldn't change anything. One could try to open libCling with RTLD_NOW instead of RTLD_LAZY, but I am not sure whether that would change anything.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:346,energy efficiency,fault,fault,346,"I have trouble compiling the ALICE O2 with ROOT and some other libraries, which come with LLVM. For me, this is in particular:. - arrow with gandiva. - glfw with vulkan support. - several OpenCL runtimes, which use LLVM. I was getting the error `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` and a segmentation fault thereafter. Now, it is a bit complicated to require from all 3rd party libraries that they do not export LLVM symbols, so I was trying to solve the problem on the ROOT side. I fully agree that the problem is most likely due to just in time resolving of symbols. But I am wondering why my patch would break something in the ROOT ctests. Before my patch, the check would make sure that there are no other LLVM symbols present. But when there are no other symbols present, my patch shouldn't change anything. One could try to open libCling with RTLD_NOW instead of RTLD_LAZY, but I am not sure whether that would change anything.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:239,performance,error,error,239,"I have trouble compiling the ALICE O2 with ROOT and some other libraries, which come with LLVM. For me, this is in particular:. - arrow with gandiva. - glfw with vulkan support. - several OpenCL runtimes, which use LLVM. I was getting the error `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` and a segmentation fault thereafter. Now, it is a bit complicated to require from all 3rd party libraries that they do not export LLVM symbols, so I was trying to solve the problem on the ROOT side. I fully agree that the problem is most likely due to just in time resolving of symbols. But I am wondering why my patch would break something in the ROOT ctests. Before my patch, the check would make sure that there are no other LLVM symbols present. But when there are no other symbols present, my patch shouldn't change anything. One could try to open libCling with RTLD_NOW instead of RTLD_LAZY, but I am not sure whether that would change anything.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:346,performance,fault,fault,346,"I have trouble compiling the ALICE O2 with ROOT and some other libraries, which come with LLVM. For me, this is in particular:. - arrow with gandiva. - glfw with vulkan support. - several OpenCL runtimes, which use LLVM. I was getting the error `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` and a segmentation fault thereafter. Now, it is a bit complicated to require from all 3rd party libraries that they do not export LLVM symbols, so I was trying to solve the problem on the ROOT side. I fully agree that the problem is most likely due to just in time resolving of symbols. But I am wondering why my patch would break something in the ROOT ctests. Before my patch, the check would make sure that there are no other LLVM symbols present. But when there are no other symbols present, my patch shouldn't change anything. One could try to open libCling with RTLD_NOW instead of RTLD_LAZY, but I am not sure whether that would change anything.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:587,performance,time,time,587,"I have trouble compiling the ALICE O2 with ROOT and some other libraries, which come with LLVM. For me, this is in particular:. - arrow with gandiva. - glfw with vulkan support. - several OpenCL runtimes, which use LLVM. I was getting the error `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` and a segmentation fault thereafter. Now, it is a bit complicated to require from all 3rd party libraries that they do not export LLVM symbols, so I was trying to solve the problem on the ROOT side. I fully agree that the problem is most likely due to just in time resolving of symbols. But I am wondering why my patch would break something in the ROOT ctests. Before my patch, the check would make sure that there are no other LLVM symbols present. But when there are no other symbols present, my patch shouldn't change anything. One could try to open libCling with RTLD_NOW instead of RTLD_LAZY, but I am not sure whether that would change anything.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:346,reliability,fault,fault,346,"I have trouble compiling the ALICE O2 with ROOT and some other libraries, which come with LLVM. For me, this is in particular:. - arrow with gandiva. - glfw with vulkan support. - several OpenCL runtimes, which use LLVM. I was getting the error `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` and a segmentation fault thereafter. Now, it is a bit complicated to require from all 3rd party libraries that they do not export LLVM symbols, so I was trying to solve the problem on the ROOT side. I fully agree that the problem is most likely due to just in time resolving of symbols. But I am wondering why my patch would break something in the ROOT ctests. Before my patch, the check would make sure that there are no other LLVM symbols present. But when there are no other symbols present, my patch shouldn't change anything. One could try to open libCling with RTLD_NOW instead of RTLD_LAZY, but I am not sure whether that would change anything.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:239,safety,error,error,239,"I have trouble compiling the ALICE O2 with ROOT and some other libraries, which come with LLVM. For me, this is in particular:. - arrow with gandiva. - glfw with vulkan support. - several OpenCL runtimes, which use LLVM. I was getting the error `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` and a segmentation fault thereafter. Now, it is a bit complicated to require from all 3rd party libraries that they do not export LLVM symbols, so I was trying to solve the problem on the ROOT side. I fully agree that the problem is most likely due to just in time resolving of symbols. But I am wondering why my patch would break something in the ROOT ctests. Before my patch, the check would make sure that there are no other LLVM symbols present. But when there are no other symbols present, my patch shouldn't change anything. One could try to open libCling with RTLD_NOW instead of RTLD_LAZY, but I am not sure whether that would change anything.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:346,safety,fault,fault,346,"I have trouble compiling the ALICE O2 with ROOT and some other libraries, which come with LLVM. For me, this is in particular:. - arrow with gandiva. - glfw with vulkan support. - several OpenCL runtimes, which use LLVM. I was getting the error `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` and a segmentation fault thereafter. Now, it is a bit complicated to require from all 3rd party libraries that they do not export LLVM symbols, so I was trying to solve the problem on the ROOT side. I fully agree that the problem is most likely due to just in time resolving of symbols. But I am wondering why my patch would break something in the ROOT ctests. Before my patch, the check would make sure that there are no other LLVM symbols present. But when there are no other symbols present, my patch shouldn't change anything. One could try to open libCling with RTLD_NOW instead of RTLD_LAZY, but I am not sure whether that would change anything.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:381,safety,compl,complicated,381,"I have trouble compiling the ALICE O2 with ROOT and some other libraries, which come with LLVM. For me, this is in particular:. - arrow with gandiva. - glfw with vulkan support. - several OpenCL runtimes, which use LLVM. I was getting the error `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` and a segmentation fault thereafter. Now, it is a bit complicated to require from all 3rd party libraries that they do not export LLVM symbols, so I was trying to solve the problem on the ROOT side. I fully agree that the problem is most likely due to just in time resolving of symbols. But I am wondering why my patch would break something in the ROOT ctests. Before my patch, the check would make sure that there are no other LLVM symbols present. But when there are no other symbols present, my patch shouldn't change anything. One could try to open libCling with RTLD_NOW instead of RTLD_LAZY, but I am not sure whether that would change anything.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:640,safety,patch,patch,640,"I have trouble compiling the ALICE O2 with ROOT and some other libraries, which come with LLVM. For me, this is in particular:. - arrow with gandiva. - glfw with vulkan support. - several OpenCL runtimes, which use LLVM. I was getting the error `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` and a segmentation fault thereafter. Now, it is a bit complicated to require from all 3rd party libraries that they do not export LLVM symbols, so I was trying to solve the problem on the ROOT side. I fully agree that the problem is most likely due to just in time resolving of symbols. But I am wondering why my patch would break something in the ROOT ctests. Before my patch, the check would make sure that there are no other LLVM symbols present. But when there are no other symbols present, my patch shouldn't change anything. One could try to open libCling with RTLD_NOW instead of RTLD_LAZY, but I am not sure whether that would change anything.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:698,safety,patch,patch,698,"I have trouble compiling the ALICE O2 with ROOT and some other libraries, which come with LLVM. For me, this is in particular:. - arrow with gandiva. - glfw with vulkan support. - several OpenCL runtimes, which use LLVM. I was getting the error `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` and a segmentation fault thereafter. Now, it is a bit complicated to require from all 3rd party libraries that they do not export LLVM symbols, so I was trying to solve the problem on the ROOT side. I fully agree that the problem is most likely due to just in time resolving of symbols. But I am wondering why my patch would break something in the ROOT ctests. Before my patch, the check would make sure that there are no other LLVM symbols present. But when there are no other symbols present, my patch shouldn't change anything. One could try to open libCling with RTLD_NOW instead of RTLD_LAZY, but I am not sure whether that would change anything.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:825,safety,patch,patch,825,"I have trouble compiling the ALICE O2 with ROOT and some other libraries, which come with LLVM. For me, this is in particular:. - arrow with gandiva. - glfw with vulkan support. - several OpenCL runtimes, which use LLVM. I was getting the error `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` and a segmentation fault thereafter. Now, it is a bit complicated to require from all 3rd party libraries that they do not export LLVM symbols, so I was trying to solve the problem on the ROOT side. I fully agree that the problem is most likely due to just in time resolving of symbols. But I am wondering why my patch would break something in the ROOT ctests. Before my patch, the check would make sure that there are no other LLVM symbols present. But when there are no other symbols present, my patch shouldn't change anything. One could try to open libCling with RTLD_NOW instead of RTLD_LAZY, but I am not sure whether that would change anything.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:381,security,compl,complicated,381,"I have trouble compiling the ALICE O2 with ROOT and some other libraries, which come with LLVM. For me, this is in particular:. - arrow with gandiva. - glfw with vulkan support. - several OpenCL runtimes, which use LLVM. I was getting the error `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` and a segmentation fault thereafter. Now, it is a bit complicated to require from all 3rd party libraries that they do not export LLVM symbols, so I was trying to solve the problem on the ROOT side. I fully agree that the problem is most likely due to just in time resolving of symbols. But I am wondering why my patch would break something in the ROOT ctests. Before my patch, the check would make sure that there are no other LLVM symbols present. But when there are no other symbols present, my patch shouldn't change anything. One could try to open libCling with RTLD_NOW instead of RTLD_LAZY, but I am not sure whether that would change anything.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:640,security,patch,patch,640,"I have trouble compiling the ALICE O2 with ROOT and some other libraries, which come with LLVM. For me, this is in particular:. - arrow with gandiva. - glfw with vulkan support. - several OpenCL runtimes, which use LLVM. I was getting the error `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` and a segmentation fault thereafter. Now, it is a bit complicated to require from all 3rd party libraries that they do not export LLVM symbols, so I was trying to solve the problem on the ROOT side. I fully agree that the problem is most likely due to just in time resolving of symbols. But I am wondering why my patch would break something in the ROOT ctests. Before my patch, the check would make sure that there are no other LLVM symbols present. But when there are no other symbols present, my patch shouldn't change anything. One could try to open libCling with RTLD_NOW instead of RTLD_LAZY, but I am not sure whether that would change anything.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:698,security,patch,patch,698,"I have trouble compiling the ALICE O2 with ROOT and some other libraries, which come with LLVM. For me, this is in particular:. - arrow with gandiva. - glfw with vulkan support. - several OpenCL runtimes, which use LLVM. I was getting the error `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` and a segmentation fault thereafter. Now, it is a bit complicated to require from all 3rd party libraries that they do not export LLVM symbols, so I was trying to solve the problem on the ROOT side. I fully agree that the problem is most likely due to just in time resolving of symbols. But I am wondering why my patch would break something in the ROOT ctests. Before my patch, the check would make sure that there are no other LLVM symbols present. But when there are no other symbols present, my patch shouldn't change anything. One could try to open libCling with RTLD_NOW instead of RTLD_LAZY, but I am not sure whether that would change anything.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:825,security,patch,patch,825,"I have trouble compiling the ALICE O2 with ROOT and some other libraries, which come with LLVM. For me, this is in particular:. - arrow with gandiva. - glfw with vulkan support. - several OpenCL runtimes, which use LLVM. I was getting the error `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` and a segmentation fault thereafter. Now, it is a bit complicated to require from all 3rd party libraries that they do not export LLVM symbols, so I was trying to solve the problem on the ROOT side. I fully agree that the problem is most likely due to just in time resolving of symbols. But I am wondering why my patch would break something in the ROOT ctests. Before my patch, the check would make sure that there are no other LLVM symbols present. But when there are no other symbols present, my patch shouldn't change anything. One could try to open libCling with RTLD_NOW instead of RTLD_LAZY, but I am not sure whether that would change anything.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:169,usability,support,support,169,"I have trouble compiling the ALICE O2 with ROOT and some other libraries, which come with LLVM. For me, this is in particular:. - arrow with gandiva. - glfw with vulkan support. - several OpenCL runtimes, which use LLVM. I was getting the error `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` and a segmentation fault thereafter. Now, it is a bit complicated to require from all 3rd party libraries that they do not export LLVM symbols, so I was trying to solve the problem on the ROOT side. I fully agree that the problem is most likely due to just in time resolving of symbols. But I am wondering why my patch would break something in the ROOT ctests. Before my patch, the check would make sure that there are no other LLVM symbols present. But when there are no other symbols present, my patch shouldn't change anything. One could try to open libCling with RTLD_NOW instead of RTLD_LAZY, but I am not sure whether that would change anything.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:239,usability,error,error,239,"I have trouble compiling the ALICE O2 with ROOT and some other libraries, which come with LLVM. For me, this is in particular:. - arrow with gandiva. - glfw with vulkan support. - several OpenCL runtimes, which use LLVM. I was getting the error `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` and a segmentation fault thereafter. Now, it is a bit complicated to require from all 3rd party libraries that they do not export LLVM symbols, so I was trying to solve the problem on the ROOT side. I fully agree that the problem is most likely due to just in time resolving of symbols. But I am wondering why my patch would break something in the ROOT ctests. Before my patch, the check would make sure that there are no other LLVM symbols present. But when there are no other symbols present, my patch shouldn't change anything. One could try to open libCling with RTLD_NOW instead of RTLD_LAZY, but I am not sure whether that would change anything.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:441,availability,error,error,441,"Example:. ```. #include <TROOT.h>. int main(int argc, char** argv) {. gROOT->GetInterpreter();. return 0;. }. ```. with the following command (using a system-installation of apache-arrow width gandiva):. ```. c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so.14.1.0 && ./test. ```. will show the `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` error. The problem with the opencl runtime is analogous.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:158,deployability,instal,installation,158,"Example:. ```. #include <TROOT.h>. int main(int argc, char** argv) {. gROOT->GetInterpreter();. return 0;. }. ```. with the following command (using a system-installation of apache-arrow width gandiva):. ```. c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so.14.1.0 && ./test. ```. will show the `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` error. The problem with the opencl runtime is analogous.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:441,performance,error,error,441,"Example:. ```. #include <TROOT.h>. int main(int argc, char** argv) {. gROOT->GetInterpreter();. return 0;. }. ```. with the following command (using a system-installation of apache-arrow width gandiva):. ```. c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so.14.1.0 && ./test. ```. will show the `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` error. The problem with the opencl runtime is analogous.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:216,safety,test,test,216,"Example:. ```. #include <TROOT.h>. int main(int argc, char** argv) {. gROOT->GetInterpreter();. return 0;. }. ```. with the following command (using a system-installation of apache-arrow width gandiva):. ```. c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so.14.1.0 && ./test. ```. will show the `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` error. The problem with the opencl runtime is analogous.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:288,safety,test,test,288,"Example:. ```. #include <TROOT.h>. int main(int argc, char** argv) {. gROOT->GetInterpreter();. return 0;. }. ```. with the following command (using a system-installation of apache-arrow width gandiva):. ```. c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so.14.1.0 && ./test. ```. will show the `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` error. The problem with the opencl runtime is analogous.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:334,safety,test,test,334,"Example:. ```. #include <TROOT.h>. int main(int argc, char** argv) {. gROOT->GetInterpreter();. return 0;. }. ```. with the following command (using a system-installation of apache-arrow width gandiva):. ```. c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so.14.1.0 && ./test. ```. will show the `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` error. The problem with the opencl runtime is analogous.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:441,safety,error,error,441,"Example:. ```. #include <TROOT.h>. int main(int argc, char** argv) {. gROOT->GetInterpreter();. return 0;. }. ```. with the following command (using a system-installation of apache-arrow width gandiva):. ```. c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so.14.1.0 && ./test. ```. will show the `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` error. The problem with the opencl runtime is analogous.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:216,testability,test,test,216,"Example:. ```. #include <TROOT.h>. int main(int argc, char** argv) {. gROOT->GetInterpreter();. return 0;. }. ```. with the following command (using a system-installation of apache-arrow width gandiva):. ```. c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so.14.1.0 && ./test. ```. will show the `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` error. The problem with the opencl runtime is analogous.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:288,testability,test,test,288,"Example:. ```. #include <TROOT.h>. int main(int argc, char** argv) {. gROOT->GetInterpreter();. return 0;. }. ```. with the following command (using a system-installation of apache-arrow width gandiva):. ```. c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so.14.1.0 && ./test. ```. will show the `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` error. The problem with the opencl runtime is analogous.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:334,testability,test,test,334,"Example:. ```. #include <TROOT.h>. int main(int argc, char** argv) {. gROOT->GetInterpreter();. return 0;. }. ```. with the following command (using a system-installation of apache-arrow width gandiva):. ```. c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so.14.1.0 && ./test. ```. will show the `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` error. The problem with the opencl runtime is analogous.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:134,usability,command,command,134,"Example:. ```. #include <TROOT.h>. int main(int argc, char** argv) {. gROOT->GetInterpreter();. return 0;. }. ```. with the following command (using a system-installation of apache-arrow width gandiva):. ```. c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so.14.1.0 && ./test. ```. will show the `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` error. The problem with the opencl runtime is analogous.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:441,usability,error,error,441,"Example:. ```. #include <TROOT.h>. int main(int argc, char** argv) {. gROOT->GetInterpreter();. return 0;. }. ```. with the following command (using a system-installation of apache-arrow width gandiva):. ```. c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so.14.1.0 && ./test. ```. will show the `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` error. The problem with the opencl runtime is analogous.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:366,deployability,patch,patch,366,"For reference: I just tried the ctests also locally with and without RTLD_DEEPBIND, and I can confirm that the DEEPBIND option makes some of them crash also for me. For some reason, none of the tests in the ALICE software with ROOT have triggered this problem. I tried also with RTLD_NOW instead of RTLD_LAZY but that doesn't change anything. So unfortunately, this patch is not working as intended. I'd still like to understand what is the problem with it, since I still think this is the much better solution compared to requiring that all 3rd party libraries hide LLVM symbols.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:318,reliability,doe,doesn,318,"For reference: I just tried the ctests also locally with and without RTLD_DEEPBIND, and I can confirm that the DEEPBIND option makes some of them crash also for me. For some reason, none of the tests in the ALICE software with ROOT have triggered this problem. I tried also with RTLD_NOW instead of RTLD_LAZY but that doesn't change anything. So unfortunately, this patch is not working as intended. I'd still like to understand what is the problem with it, since I still think this is the much better solution compared to requiring that all 3rd party libraries hide LLVM symbols.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:194,safety,test,tests,194,"For reference: I just tried the ctests also locally with and without RTLD_DEEPBIND, and I can confirm that the DEEPBIND option makes some of them crash also for me. For some reason, none of the tests in the ALICE software with ROOT have triggered this problem. I tried also with RTLD_NOW instead of RTLD_LAZY but that doesn't change anything. So unfortunately, this patch is not working as intended. I'd still like to understand what is the problem with it, since I still think this is the much better solution compared to requiring that all 3rd party libraries hide LLVM symbols.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:366,safety,patch,patch,366,"For reference: I just tried the ctests also locally with and without RTLD_DEEPBIND, and I can confirm that the DEEPBIND option makes some of them crash also for me. For some reason, none of the tests in the ALICE software with ROOT have triggered this problem. I tried also with RTLD_NOW instead of RTLD_LAZY but that doesn't change anything. So unfortunately, this patch is not working as intended. I'd still like to understand what is the problem with it, since I still think this is the much better solution compared to requiring that all 3rd party libraries hide LLVM symbols.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:366,security,patch,patch,366,"For reference: I just tried the ctests also locally with and without RTLD_DEEPBIND, and I can confirm that the DEEPBIND option makes some of them crash also for me. For some reason, none of the tests in the ALICE software with ROOT have triggered this problem. I tried also with RTLD_NOW instead of RTLD_LAZY but that doesn't change anything. So unfortunately, this patch is not working as intended. I'd still like to understand what is the problem with it, since I still think this is the much better solution compared to requiring that all 3rd party libraries hide LLVM symbols.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:194,testability,test,tests,194,"For reference: I just tried the ctests also locally with and without RTLD_DEEPBIND, and I can confirm that the DEEPBIND option makes some of them crash also for me. For some reason, none of the tests in the ALICE software with ROOT have triggered this problem. I tried also with RTLD_NOW instead of RTLD_LAZY but that doesn't change anything. So unfortunately, this patch is not working as intended. I'd still like to understand what is the problem with it, since I still think this is the much better solution compared to requiring that all 3rd party libraries hide LLVM symbols.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:418,testability,understand,understand,418,"For reference: I just tried the ctests also locally with and without RTLD_DEEPBIND, and I can confirm that the DEEPBIND option makes some of them crash also for me. For some reason, none of the tests in the ALICE software with ROOT have triggered this problem. I tried also with RTLD_NOW instead of RTLD_LAZY but that doesn't change anything. So unfortunately, this patch is not working as intended. I'd still like to understand what is the problem with it, since I still think this is the much better solution compared to requiring that all 3rd party libraries hide LLVM symbols.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:94,usability,confirm,confirm,94,"For reference: I just tried the ctests also locally with and without RTLD_DEEPBIND, and I can confirm that the DEEPBIND option makes some of them crash also for me. For some reason, none of the tests in the ALICE software with ROOT have triggered this problem. I tried also with RTLD_NOW instead of RTLD_LAZY but that doesn't change anything. So unfortunately, this patch is not working as intended. I'd still like to understand what is the problem with it, since I still think this is the much better solution compared to requiring that all 3rd party libraries hide LLVM symbols.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:483,availability,error,error,483,"> Example:. > . > ```. > #include <TROOT.h>. > int main(int argc, char** argv) {. > gROOT->GetInterpreter();. > return 0;. > }. > ```. > . > with the following command (using a system-installation of apache-arrow width gandiva):. > . > ```. > c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so.14.1.0 && ./test. > ```. > . > will show the `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` error. > . > The problem with the opencl runtime is analogous. So, would the error still be there if you change the example to something like:. ```. #include <TROOT.h>. static auto force_init = gROOT->GetInterpreter();. int main(int argc, char** argv) {. return 0;. }. ```. why is `/usr/lib64/libgandiva.so.14.1.0 ` initialized/dlopened first?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:560,availability,error,error,560,"> Example:. > . > ```. > #include <TROOT.h>. > int main(int argc, char** argv) {. > gROOT->GetInterpreter();. > return 0;. > }. > ```. > . > with the following command (using a system-installation of apache-arrow width gandiva):. > . > ```. > c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so.14.1.0 && ./test. > ```. > . > will show the `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` error. > . > The problem with the opencl runtime is analogous. So, would the error still be there if you change the example to something like:. ```. #include <TROOT.h>. static auto force_init = gROOT->GetInterpreter();. int main(int argc, char** argv) {. return 0;. }. ```. why is `/usr/lib64/libgandiva.so.14.1.0 ` initialized/dlopened first?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:184,deployability,instal,installation,184,"> Example:. > . > ```. > #include <TROOT.h>. > int main(int argc, char** argv) {. > gROOT->GetInterpreter();. > return 0;. > }. > ```. > . > with the following command (using a system-installation of apache-arrow width gandiva):. > . > ```. > c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so.14.1.0 && ./test. > ```. > . > will show the `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` error. > . > The problem with the opencl runtime is analogous. So, would the error still be there if you change the example to something like:. ```. #include <TROOT.h>. static auto force_init = gROOT->GetInterpreter();. int main(int argc, char** argv) {. return 0;. }. ```. why is `/usr/lib64/libgandiva.so.14.1.0 ` initialized/dlopened first?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:483,performance,error,error,483,"> Example:. > . > ```. > #include <TROOT.h>. > int main(int argc, char** argv) {. > gROOT->GetInterpreter();. > return 0;. > }. > ```. > . > with the following command (using a system-installation of apache-arrow width gandiva):. > . > ```. > c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so.14.1.0 && ./test. > ```. > . > will show the `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` error. > . > The problem with the opencl runtime is analogous. So, would the error still be there if you change the example to something like:. ```. #include <TROOT.h>. static auto force_init = gROOT->GetInterpreter();. int main(int argc, char** argv) {. return 0;. }. ```. why is `/usr/lib64/libgandiva.so.14.1.0 ` initialized/dlopened first?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:560,performance,error,error,560,"> Example:. > . > ```. > #include <TROOT.h>. > int main(int argc, char** argv) {. > gROOT->GetInterpreter();. > return 0;. > }. > ```. > . > with the following command (using a system-installation of apache-arrow width gandiva):. > . > ```. > c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so.14.1.0 && ./test. > ```. > . > will show the `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` error. > . > The problem with the opencl runtime is analogous. So, would the error still be there if you change the example to something like:. ```. #include <TROOT.h>. static auto force_init = gROOT->GetInterpreter();. int main(int argc, char** argv) {. return 0;. }. ```. why is `/usr/lib64/libgandiva.so.14.1.0 ` initialized/dlopened first?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:250,safety,test,test,250,"> Example:. > . > ```. > #include <TROOT.h>. > int main(int argc, char** argv) {. > gROOT->GetInterpreter();. > return 0;. > }. > ```. > . > with the following command (using a system-installation of apache-arrow width gandiva):. > . > ```. > c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so.14.1.0 && ./test. > ```. > . > will show the `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` error. > . > The problem with the opencl runtime is analogous. So, would the error still be there if you change the example to something like:. ```. #include <TROOT.h>. static auto force_init = gROOT->GetInterpreter();. int main(int argc, char** argv) {. return 0;. }. ```. why is `/usr/lib64/libgandiva.so.14.1.0 ` initialized/dlopened first?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:322,safety,test,test,322,"> Example:. > . > ```. > #include <TROOT.h>. > int main(int argc, char** argv) {. > gROOT->GetInterpreter();. > return 0;. > }. > ```. > . > with the following command (using a system-installation of apache-arrow width gandiva):. > . > ```. > c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so.14.1.0 && ./test. > ```. > . > will show the `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` error. > . > The problem with the opencl runtime is analogous. So, would the error still be there if you change the example to something like:. ```. #include <TROOT.h>. static auto force_init = gROOT->GetInterpreter();. int main(int argc, char** argv) {. return 0;. }. ```. why is `/usr/lib64/libgandiva.so.14.1.0 ` initialized/dlopened first?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:368,safety,test,test,368,"> Example:. > . > ```. > #include <TROOT.h>. > int main(int argc, char** argv) {. > gROOT->GetInterpreter();. > return 0;. > }. > ```. > . > with the following command (using a system-installation of apache-arrow width gandiva):. > . > ```. > c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so.14.1.0 && ./test. > ```. > . > will show the `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` error. > . > The problem with the opencl runtime is analogous. So, would the error still be there if you change the example to something like:. ```. #include <TROOT.h>. static auto force_init = gROOT->GetInterpreter();. int main(int argc, char** argv) {. return 0;. }. ```. why is `/usr/lib64/libgandiva.so.14.1.0 ` initialized/dlopened first?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:483,safety,error,error,483,"> Example:. > . > ```. > #include <TROOT.h>. > int main(int argc, char** argv) {. > gROOT->GetInterpreter();. > return 0;. > }. > ```. > . > with the following command (using a system-installation of apache-arrow width gandiva):. > . > ```. > c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so.14.1.0 && ./test. > ```. > . > will show the `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` error. > . > The problem with the opencl runtime is analogous. So, would the error still be there if you change the example to something like:. ```. #include <TROOT.h>. static auto force_init = gROOT->GetInterpreter();. int main(int argc, char** argv) {. return 0;. }. ```. why is `/usr/lib64/libgandiva.so.14.1.0 ` initialized/dlopened first?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:560,safety,error,error,560,"> Example:. > . > ```. > #include <TROOT.h>. > int main(int argc, char** argv) {. > gROOT->GetInterpreter();. > return 0;. > }. > ```. > . > with the following command (using a system-installation of apache-arrow width gandiva):. > . > ```. > c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so.14.1.0 && ./test. > ```. > . > will show the `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` error. > . > The problem with the opencl runtime is analogous. So, would the error still be there if you change the example to something like:. ```. #include <TROOT.h>. static auto force_init = gROOT->GetInterpreter();. int main(int argc, char** argv) {. return 0;. }. ```. why is `/usr/lib64/libgandiva.so.14.1.0 ` initialized/dlopened first?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:250,testability,test,test,250,"> Example:. > . > ```. > #include <TROOT.h>. > int main(int argc, char** argv) {. > gROOT->GetInterpreter();. > return 0;. > }. > ```. > . > with the following command (using a system-installation of apache-arrow width gandiva):. > . > ```. > c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so.14.1.0 && ./test. > ```. > . > will show the `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` error. > . > The problem with the opencl runtime is analogous. So, would the error still be there if you change the example to something like:. ```. #include <TROOT.h>. static auto force_init = gROOT->GetInterpreter();. int main(int argc, char** argv) {. return 0;. }. ```. why is `/usr/lib64/libgandiva.so.14.1.0 ` initialized/dlopened first?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:322,testability,test,test,322,"> Example:. > . > ```. > #include <TROOT.h>. > int main(int argc, char** argv) {. > gROOT->GetInterpreter();. > return 0;. > }. > ```. > . > with the following command (using a system-installation of apache-arrow width gandiva):. > . > ```. > c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so.14.1.0 && ./test. > ```. > . > will show the `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` error. > . > The problem with the opencl runtime is analogous. So, would the error still be there if you change the example to something like:. ```. #include <TROOT.h>. static auto force_init = gROOT->GetInterpreter();. int main(int argc, char** argv) {. return 0;. }. ```. why is `/usr/lib64/libgandiva.so.14.1.0 ` initialized/dlopened first?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:368,testability,test,test,368,"> Example:. > . > ```. > #include <TROOT.h>. > int main(int argc, char** argv) {. > gROOT->GetInterpreter();. > return 0;. > }. > ```. > . > with the following command (using a system-installation of apache-arrow width gandiva):. > . > ```. > c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so.14.1.0 && ./test. > ```. > . > will show the `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` error. > . > The problem with the opencl runtime is analogous. So, would the error still be there if you change the example to something like:. ```. #include <TROOT.h>. static auto force_init = gROOT->GetInterpreter();. int main(int argc, char** argv) {. return 0;. }. ```. why is `/usr/lib64/libgandiva.so.14.1.0 ` initialized/dlopened first?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:160,usability,command,command,160,"> Example:. > . > ```. > #include <TROOT.h>. > int main(int argc, char** argv) {. > gROOT->GetInterpreter();. > return 0;. > }. > ```. > . > with the following command (using a system-installation of apache-arrow width gandiva):. > . > ```. > c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so.14.1.0 && ./test. > ```. > . > will show the `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` error. > . > The problem with the opencl runtime is analogous. So, would the error still be there if you change the example to something like:. ```. #include <TROOT.h>. static auto force_init = gROOT->GetInterpreter();. int main(int argc, char** argv) {. return 0;. }. ```. why is `/usr/lib64/libgandiva.so.14.1.0 ` initialized/dlopened first?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:483,usability,error,error,483,"> Example:. > . > ```. > #include <TROOT.h>. > int main(int argc, char** argv) {. > gROOT->GetInterpreter();. > return 0;. > }. > ```. > . > with the following command (using a system-installation of apache-arrow width gandiva):. > . > ```. > c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so.14.1.0 && ./test. > ```. > . > will show the `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` error. > . > The problem with the opencl runtime is analogous. So, would the error still be there if you change the example to something like:. ```. #include <TROOT.h>. static auto force_init = gROOT->GetInterpreter();. int main(int argc, char** argv) {. return 0;. }. ```. why is `/usr/lib64/libgandiva.so.14.1.0 ` initialized/dlopened first?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:560,usability,error,error,560,"> Example:. > . > ```. > #include <TROOT.h>. > int main(int argc, char** argv) {. > gROOT->GetInterpreter();. > return 0;. > }. > ```. > . > with the following command (using a system-installation of apache-arrow width gandiva):. > . > ```. > c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so.14.1.0 && ./test. > ```. > . > will show the `...please hide them or dlopen() them after the call to TROOT::InitInterpreter()` error. > . > The problem with the opencl runtime is analogous. So, would the error still be there if you change the example to something like:. ```. #include <TROOT.h>. static auto force_init = gROOT->GetInterpreter();. int main(int argc, char** argv) {. return 0;. }. ```. why is `/usr/lib64/libgandiva.so.14.1.0 ` initialized/dlopened first?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:16,availability,error,error,16,"> So, would the error still be there if you change the example to something like:. > . > ```. > #include <TROOT.h>. > static auto force_init = gROOT->GetInterpreter();. > int main(int argc, char** argv) {. > return 0;. > }. > ```. Well, in that case it depends on what is loaded first, but there could be other static objects loading symbols from the other LLVM, so even if this would work, it would be only by chance. It just depends on the order.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:253,deployability,depend,depends,253,"> So, would the error still be there if you change the example to something like:. > . > ```. > #include <TROOT.h>. > static auto force_init = gROOT->GetInterpreter();. > int main(int argc, char** argv) {. > return 0;. > }. > ```. Well, in that case it depends on what is loaded first, but there could be other static objects loading symbols from the other LLVM, so even if this would work, it would be only by chance. It just depends on the order.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:427,deployability,depend,depends,427,"> So, would the error still be there if you change the example to something like:. > . > ```. > #include <TROOT.h>. > static auto force_init = gROOT->GetInterpreter();. > int main(int argc, char** argv) {. > return 0;. > }. > ```. Well, in that case it depends on what is loaded first, but there could be other static objects loading symbols from the other LLVM, so even if this would work, it would be only by chance. It just depends on the order.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:272,energy efficiency,load,loaded,272,"> So, would the error still be there if you change the example to something like:. > . > ```. > #include <TROOT.h>. > static auto force_init = gROOT->GetInterpreter();. > int main(int argc, char** argv) {. > return 0;. > }. > ```. Well, in that case it depends on what is loaded first, but there could be other static objects loading symbols from the other LLVM, so even if this would work, it would be only by chance. It just depends on the order.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:326,energy efficiency,load,loading,326,"> So, would the error still be there if you change the example to something like:. > . > ```. > #include <TROOT.h>. > static auto force_init = gROOT->GetInterpreter();. > int main(int argc, char** argv) {. > return 0;. > }. > ```. Well, in that case it depends on what is loaded first, but there could be other static objects loading symbols from the other LLVM, so even if this would work, it would be only by chance. It just depends on the order.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:253,integrability,depend,depends,253,"> So, would the error still be there if you change the example to something like:. > . > ```. > #include <TROOT.h>. > static auto force_init = gROOT->GetInterpreter();. > int main(int argc, char** argv) {. > return 0;. > }. > ```. Well, in that case it depends on what is loaded first, but there could be other static objects loading symbols from the other LLVM, so even if this would work, it would be only by chance. It just depends on the order.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:427,integrability,depend,depends,427,"> So, would the error still be there if you change the example to something like:. > . > ```. > #include <TROOT.h>. > static auto force_init = gROOT->GetInterpreter();. > int main(int argc, char** argv) {. > return 0;. > }. > ```. Well, in that case it depends on what is loaded first, but there could be other static objects loading symbols from the other LLVM, so even if this would work, it would be only by chance. It just depends on the order.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:253,modifiability,depend,depends,253,"> So, would the error still be there if you change the example to something like:. > . > ```. > #include <TROOT.h>. > static auto force_init = gROOT->GetInterpreter();. > int main(int argc, char** argv) {. > return 0;. > }. > ```. Well, in that case it depends on what is loaded first, but there could be other static objects loading symbols from the other LLVM, so even if this would work, it would be only by chance. It just depends on the order.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:427,modifiability,depend,depends,427,"> So, would the error still be there if you change the example to something like:. > . > ```. > #include <TROOT.h>. > static auto force_init = gROOT->GetInterpreter();. > int main(int argc, char** argv) {. > return 0;. > }. > ```. Well, in that case it depends on what is loaded first, but there could be other static objects loading symbols from the other LLVM, so even if this would work, it would be only by chance. It just depends on the order.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:16,performance,error,error,16,"> So, would the error still be there if you change the example to something like:. > . > ```. > #include <TROOT.h>. > static auto force_init = gROOT->GetInterpreter();. > int main(int argc, char** argv) {. > return 0;. > }. > ```. Well, in that case it depends on what is loaded first, but there could be other static objects loading symbols from the other LLVM, so even if this would work, it would be only by chance. It just depends on the order.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:272,performance,load,loaded,272,"> So, would the error still be there if you change the example to something like:. > . > ```. > #include <TROOT.h>. > static auto force_init = gROOT->GetInterpreter();. > int main(int argc, char** argv) {. > return 0;. > }. > ```. Well, in that case it depends on what is loaded first, but there could be other static objects loading symbols from the other LLVM, so even if this would work, it would be only by chance. It just depends on the order.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:326,performance,load,loading,326,"> So, would the error still be there if you change the example to something like:. > . > ```. > #include <TROOT.h>. > static auto force_init = gROOT->GetInterpreter();. > int main(int argc, char** argv) {. > return 0;. > }. > ```. Well, in that case it depends on what is loaded first, but there could be other static objects loading symbols from the other LLVM, so even if this would work, it would be only by chance. It just depends on the order.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:16,safety,error,error,16,"> So, would the error still be there if you change the example to something like:. > . > ```. > #include <TROOT.h>. > static auto force_init = gROOT->GetInterpreter();. > int main(int argc, char** argv) {. > return 0;. > }. > ```. Well, in that case it depends on what is loaded first, but there could be other static objects loading symbols from the other LLVM, so even if this would work, it would be only by chance. It just depends on the order.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:253,safety,depend,depends,253,"> So, would the error still be there if you change the example to something like:. > . > ```. > #include <TROOT.h>. > static auto force_init = gROOT->GetInterpreter();. > int main(int argc, char** argv) {. > return 0;. > }. > ```. Well, in that case it depends on what is loaded first, but there could be other static objects loading symbols from the other LLVM, so even if this would work, it would be only by chance. It just depends on the order.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:427,safety,depend,depends,427,"> So, would the error still be there if you change the example to something like:. > . > ```. > #include <TROOT.h>. > static auto force_init = gROOT->GetInterpreter();. > int main(int argc, char** argv) {. > return 0;. > }. > ```. Well, in that case it depends on what is loaded first, but there could be other static objects loading symbols from the other LLVM, so even if this would work, it would be only by chance. It just depends on the order.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:253,testability,depend,depends,253,"> So, would the error still be there if you change the example to something like:. > . > ```. > #include <TROOT.h>. > static auto force_init = gROOT->GetInterpreter();. > int main(int argc, char** argv) {. > return 0;. > }. > ```. Well, in that case it depends on what is loaded first, but there could be other static objects loading symbols from the other LLVM, so even if this would work, it would be only by chance. It just depends on the order.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:427,testability,depend,depends,427,"> So, would the error still be there if you change the example to something like:. > . > ```. > #include <TROOT.h>. > static auto force_init = gROOT->GetInterpreter();. > int main(int argc, char** argv) {. > return 0;. > }. > ```. Well, in that case it depends on what is loaded first, but there could be other static objects loading symbols from the other LLVM, so even if this would work, it would be only by chance. It just depends on the order.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:16,usability,error,error,16,"> So, would the error still be there if you change the example to something like:. > . > ```. > #include <TROOT.h>. > static auto force_init = gROOT->GetInterpreter();. > int main(int argc, char** argv) {. > return 0;. > }. > ```. Well, in that case it depends on what is loaded first, but there could be other static objects loading symbols from the other LLVM, so even if this would work, it would be only by chance. It just depends on the order.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:472,interoperability,specif,specific,472,"> . > why is `/usr/lib64/libgandiva.so.14.1.0 ` initialized/dlopened first? The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:145,reliability,doe,does,145,"> . > why is `/usr/lib64/libgandiva.so.14.1.0 ` initialized/dlopened first? The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:295,safety,avoid,avoided,295,"> . > why is `/usr/lib64/libgandiva.so.14.1.0 ` initialized/dlopened first? The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:756,availability,fault,faults,756,"I have in the mean time found the root cause why my patch fails:. - It is due to copy relocations of <iostream> symbols from libstdc++. - Crashes happen whenever cling wants to output text via cout / cerr / etc. - The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). The problem can be avoided if executables are compiled with -fPIC as well. I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:52,deployability,patch,patch,52,"I have in the mean time found the root cause why my patch fails:. - It is due to copy relocations of <iostream> symbols from libstdc++. - Crashes happen whenever cling wants to output text via cout / cerr / etc. - The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). The problem can be avoided if executables are compiled with -fPIC as well. I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:58,deployability,fail,fails,58,"I have in the mean time found the root cause why my patch fails:. - It is due to copy relocations of <iostream> symbols from libstdc++. - Crashes happen whenever cling wants to output text via cout / cerr / etc. - The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). The problem can be avoided if executables are compiled with -fPIC as well. I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:693,deployability,fail,failing,693,"I have in the mean time found the root cause why my patch fails:. - It is due to copy relocations of <iostream> symbols from libstdc++. - Crashes happen whenever cling wants to output text via cout / cerr / etc. - The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). The problem can be avoided if executables are compiled with -fPIC as well. I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:418,energy efficiency,load,loaded,418,"I have in the mean time found the root cause why my patch fails:. - It is due to copy relocations of <iostream> symbols from libstdc++. - Crashes happen whenever cling wants to output text via cout / cerr / etc. - The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). The problem can be avoided if executables are compiled with -fPIC as well. I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:756,energy efficiency,fault,faults,756,"I have in the mean time found the root cause why my patch fails:. - It is due to copy relocations of <iostream> symbols from libstdc++. - Crashes happen whenever cling wants to output text via cout / cerr / etc. - The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). The problem can be avoided if executables are compiled with -fPIC as well. I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:19,performance,time,time,19,"I have in the mean time found the root cause why my patch fails:. - It is due to copy relocations of <iostream> symbols from libstdc++. - Crashes happen whenever cling wants to output text via cout / cerr / etc. - The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). The problem can be avoided if executables are compiled with -fPIC as well. I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:418,performance,load,loaded,418,"I have in the mean time found the root cause why my patch fails:. - It is due to copy relocations of <iostream> symbols from libstdc++. - Crashes happen whenever cling wants to output text via cout / cerr / etc. - The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). The problem can be avoided if executables are compiled with -fPIC as well. I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:756,performance,fault,faults,756,"I have in the mean time found the root cause why my patch fails:. - It is due to copy relocations of <iostream> symbols from libstdc++. - Crashes happen whenever cling wants to output text via cout / cerr / etc. - The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). The problem can be avoided if executables are compiled with -fPIC as well. I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:58,reliability,fail,fails,58,"I have in the mean time found the root cause why my patch fails:. - It is due to copy relocations of <iostream> symbols from libstdc++. - Crashes happen whenever cling wants to output text via cout / cerr / etc. - The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). The problem can be avoided if executables are compiled with -fPIC as well. I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:540,reliability,doe,does,540,"I have in the mean time found the root cause why my patch fails:. - It is due to copy relocations of <iostream> symbols from libstdc++. - Crashes happen whenever cling wants to output text via cout / cerr / etc. - The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). The problem can be avoided if executables are compiled with -fPIC as well. I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:693,reliability,fail,failing,693,"I have in the mean time found the root cause why my patch fails:. - It is due to copy relocations of <iostream> symbols from libstdc++. - Crashes happen whenever cling wants to output text via cout / cerr / etc. - The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). The problem can be avoided if executables are compiled with -fPIC as well. I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:756,reliability,fault,faults,756,"I have in the mean time found the root cause why my patch fails:. - It is due to copy relocations of <iostream> symbols from libstdc++. - Crashes happen whenever cling wants to output text via cout / cerr / etc. - The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). The problem can be avoided if executables are compiled with -fPIC as well. I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:52,safety,patch,patch,52,"I have in the mean time found the root cause why my patch fails:. - It is due to copy relocations of <iostream> symbols from libstdc++. - Crashes happen whenever cling wants to output text via cout / cerr / etc. - The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). The problem can be avoided if executables are compiled with -fPIC as well. I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:601,safety,avoid,avoided,601,"I have in the mean time found the root cause why my patch fails:. - It is due to copy relocations of <iostream> symbols from libstdc++. - Crashes happen whenever cling wants to output text via cout / cerr / etc. - The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). The problem can be avoided if executables are compiled with -fPIC as well. I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:756,safety,fault,faults,756,"I have in the mean time found the root cause why my patch fails:. - It is due to copy relocations of <iostream> symbols from libstdc++. - Crashes happen whenever cling wants to output text via cout / cerr / etc. - The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). The problem can be avoided if executables are compiled with -fPIC as well. I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:52,security,patch,patch,52,"I have in the mean time found the root cause why my patch fails:. - It is due to copy relocations of <iostream> symbols from libstdc++. - Crashes happen whenever cling wants to output text via cout / cerr / etc. - The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). The problem can be avoided if executables are compiled with -fPIC as well. I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:868,availability,sli,slips,868,"You should be able to guarantee what gets initialized first, either in your codebase or via the linker. I wish there was a better or even feasible-to-implement way to solve this more elegantly. The underlying issue is that whenever there in unknown (to the interpreter) symbol it will ask the JIT to resolve it. It tries to resolve the symbol via the usual dynamic linker rules and as a last resort it gives the control to ROOT. ROOT, in turn, uses dlsym and dladdr (which have platform-specific bugs) to find the unknown symbol (https://github.com/root-project/root/blob/master/core/metacling/src/TCling.cxx#L6418). Unfortunately, we do not have enough information at that point to be able to distinguish between which symbol is supposed to come from libCling or not. Thus we have a conservative strategy in resolving as much as we can from libCling and if something slips through use later-dlopened libraries. I presume a somewhat better fix would be to make a dlsym and a dlsym in libCling and always return the version of the symbol in libCling. This would be a major change which should happen after the upcoming release...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1015,deployability,version,version,1015,"You should be able to guarantee what gets initialized first, either in your codebase or via the linker. I wish there was a better or even feasible-to-implement way to solve this more elegantly. The underlying issue is that whenever there in unknown (to the interpreter) symbol it will ask the JIT to resolve it. It tries to resolve the symbol via the usual dynamic linker rules and as a last resort it gives the control to ROOT. ROOT, in turn, uses dlsym and dladdr (which have platform-specific bugs) to find the unknown symbol (https://github.com/root-project/root/blob/master/core/metacling/src/TCling.cxx#L6418). Unfortunately, we do not have enough information at that point to be able to distinguish between which symbol is supposed to come from libCling or not. Thus we have a conservative strategy in resolving as much as we can from libCling and if something slips through use later-dlopened libraries. I presume a somewhat better fix would be to make a dlsym and a dlsym in libCling and always return the version of the symbol in libCling. This would be a major change which should happen after the upcoming release...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1118,deployability,releas,release,1118,"You should be able to guarantee what gets initialized first, either in your codebase or via the linker. I wish there was a better or even feasible-to-implement way to solve this more elegantly. The underlying issue is that whenever there in unknown (to the interpreter) symbol it will ask the JIT to resolve it. It tries to resolve the symbol via the usual dynamic linker rules and as a last resort it gives the control to ROOT. ROOT, in turn, uses dlsym and dladdr (which have platform-specific bugs) to find the unknown symbol (https://github.com/root-project/root/blob/master/core/metacling/src/TCling.cxx#L6418). Unfortunately, we do not have enough information at that point to be able to distinguish between which symbol is supposed to come from libCling or not. Thus we have a conservative strategy in resolving as much as we can from libCling and if something slips through use later-dlopened libraries. I presume a somewhat better fix would be to make a dlsym and a dlsym in libCling and always return the version of the symbol in libCling. This would be a major change which should happen after the upcoming release...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:579,energy efficiency,core,core,579,"You should be able to guarantee what gets initialized first, either in your codebase or via the linker. I wish there was a better or even feasible-to-implement way to solve this more elegantly. The underlying issue is that whenever there in unknown (to the interpreter) symbol it will ask the JIT to resolve it. It tries to resolve the symbol via the usual dynamic linker rules and as a last resort it gives the control to ROOT. ROOT, in turn, uses dlsym and dladdr (which have platform-specific bugs) to find the unknown symbol (https://github.com/root-project/root/blob/master/core/metacling/src/TCling.cxx#L6418). Unfortunately, we do not have enough information at that point to be able to distinguish between which symbol is supposed to come from libCling or not. Thus we have a conservative strategy in resolving as much as we can from libCling and if something slips through use later-dlopened libraries. I presume a somewhat better fix would be to make a dlsym and a dlsym in libCling and always return the version of the symbol in libCling. This would be a major change which should happen after the upcoming release...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1015,integrability,version,version,1015,"You should be able to guarantee what gets initialized first, either in your codebase or via the linker. I wish there was a better or even feasible-to-implement way to solve this more elegantly. The underlying issue is that whenever there in unknown (to the interpreter) symbol it will ask the JIT to resolve it. It tries to resolve the symbol via the usual dynamic linker rules and as a last resort it gives the control to ROOT. ROOT, in turn, uses dlsym and dladdr (which have platform-specific bugs) to find the unknown symbol (https://github.com/root-project/root/blob/master/core/metacling/src/TCling.cxx#L6418). Unfortunately, we do not have enough information at that point to be able to distinguish between which symbol is supposed to come from libCling or not. Thus we have a conservative strategy in resolving as much as we can from libCling and if something slips through use later-dlopened libraries. I presume a somewhat better fix would be to make a dlsym and a dlsym in libCling and always return the version of the symbol in libCling. This would be a major change which should happen after the upcoming release...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:478,interoperability,platform,platform-specific,478,"You should be able to guarantee what gets initialized first, either in your codebase or via the linker. I wish there was a better or even feasible-to-implement way to solve this more elegantly. The underlying issue is that whenever there in unknown (to the interpreter) symbol it will ask the JIT to resolve it. It tries to resolve the symbol via the usual dynamic linker rules and as a last resort it gives the control to ROOT. ROOT, in turn, uses dlsym and dladdr (which have platform-specific bugs) to find the unknown symbol (https://github.com/root-project/root/blob/master/core/metacling/src/TCling.cxx#L6418). Unfortunately, we do not have enough information at that point to be able to distinguish between which symbol is supposed to come from libCling or not. Thus we have a conservative strategy in resolving as much as we can from libCling and if something slips through use later-dlopened libraries. I presume a somewhat better fix would be to make a dlsym and a dlsym in libCling and always return the version of the symbol in libCling. This would be a major change which should happen after the upcoming release...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1015,modifiability,version,version,1015,"You should be able to guarantee what gets initialized first, either in your codebase or via the linker. I wish there was a better or even feasible-to-implement way to solve this more elegantly. The underlying issue is that whenever there in unknown (to the interpreter) symbol it will ask the JIT to resolve it. It tries to resolve the symbol via the usual dynamic linker rules and as a last resort it gives the control to ROOT. ROOT, in turn, uses dlsym and dladdr (which have platform-specific bugs) to find the unknown symbol (https://github.com/root-project/root/blob/master/core/metacling/src/TCling.cxx#L6418). Unfortunately, we do not have enough information at that point to be able to distinguish between which symbol is supposed to come from libCling or not. Thus we have a conservative strategy in resolving as much as we can from libCling and if something slips through use later-dlopened libraries. I presume a somewhat better fix would be to make a dlsym and a dlsym in libCling and always return the version of the symbol in libCling. This would be a major change which should happen after the upcoming release...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:868,reliability,sli,slips,868,"You should be able to guarantee what gets initialized first, either in your codebase or via the linker. I wish there was a better or even feasible-to-implement way to solve this more elegantly. The underlying issue is that whenever there in unknown (to the interpreter) symbol it will ask the JIT to resolve it. It tries to resolve the symbol via the usual dynamic linker rules and as a last resort it gives the control to ROOT. ROOT, in turn, uses dlsym and dladdr (which have platform-specific bugs) to find the unknown symbol (https://github.com/root-project/root/blob/master/core/metacling/src/TCling.cxx#L6418). Unfortunately, we do not have enough information at that point to be able to distinguish between which symbol is supposed to come from libCling or not. Thus we have a conservative strategy in resolving as much as we can from libCling and if something slips through use later-dlopened libraries. I presume a somewhat better fix would be to make a dlsym and a dlsym in libCling and always return the version of the symbol in libCling. This would be a major change which should happen after the upcoming release...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:412,security,control,control,412,"You should be able to guarantee what gets initialized first, either in your codebase or via the linker. I wish there was a better or even feasible-to-implement way to solve this more elegantly. The underlying issue is that whenever there in unknown (to the interpreter) symbol it will ask the JIT to resolve it. It tries to resolve the symbol via the usual dynamic linker rules and as a last resort it gives the control to ROOT. ROOT, in turn, uses dlsym and dladdr (which have platform-specific bugs) to find the unknown symbol (https://github.com/root-project/root/blob/master/core/metacling/src/TCling.cxx#L6418). Unfortunately, we do not have enough information at that point to be able to distinguish between which symbol is supposed to come from libCling or not. Thus we have a conservative strategy in resolving as much as we can from libCling and if something slips through use later-dlopened libraries. I presume a somewhat better fix would be to make a dlsym and a dlsym in libCling and always return the version of the symbol in libCling. This would be a major change which should happen after the upcoming release...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:412,testability,control,control,412,"You should be able to guarantee what gets initialized first, either in your codebase or via the linker. I wish there was a better or even feasible-to-implement way to solve this more elegantly. The underlying issue is that whenever there in unknown (to the interpreter) symbol it will ask the JIT to resolve it. It tries to resolve the symbol via the usual dynamic linker rules and as a last resort it gives the control to ROOT. ROOT, in turn, uses dlsym and dladdr (which have platform-specific bugs) to find the unknown symbol (https://github.com/root-project/root/blob/master/core/metacling/src/TCling.cxx#L6418). Unfortunately, we do not have enough information at that point to be able to distinguish between which symbol is supposed to come from libCling or not. Thus we have a conservative strategy in resolving as much as we can from libCling and if something slips through use later-dlopened libraries. I presume a somewhat better fix would be to make a dlsym and a dlsym in libCling and always return the version of the symbol in libCling. This would be a major change which should happen after the upcoming release...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:132,availability,state,states,132,"@vgvassilev : I do not see how I could control this. https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They are loaded before main(), while InitInterpreter() loads libCling only after main().",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:102,energy efficiency,core,core,102,"@vgvassilev : I do not see how I could control this. https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They are loaded before main(), while InitInterpreter() loads libCling only after main().",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:339,energy efficiency,load,loaded,339,"@vgvassilev : I do not see how I could control this. https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They are loaded before main(), while InitInterpreter() loads libCling only after main().",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:385,energy efficiency,load,loads,385,"@vgvassilev : I do not see how I could control this. https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They are loaded before main(), while InitInterpreter() loads libCling only after main().",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:132,integrability,state,states,132,"@vgvassilev : I do not see how I could control this. https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They are loaded before main(), while InitInterpreter() loads libCling only after main().",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:339,performance,load,loaded,339,"@vgvassilev : I do not see how I could control this. https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They are loaded before main(), while InitInterpreter() loads libCling only after main().",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:385,performance,load,loads,385,"@vgvassilev : I do not see how I could control this. https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They are loaded before main(), while InitInterpreter() loads libCling only after main().",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:39,security,control,control,39,"@vgvassilev : I do not see how I could control this. https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They are loaded before main(), while InitInterpreter() loads libCling only after main().",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:39,testability,control,control,39,"@vgvassilev : I do not see how I could control this. https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They are loaded before main(), while InitInterpreter() loads libCling only after main().",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1730,availability,fault,faults,1730,". > I have in the mean time found the root cause why my patch fails:. > . > * It is due to copy relocations of symbols from libstdc++. > . > * Crashes happen whenever cling wants to output text via cout / cerr / etc. > . > * The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > @vgvassilev : I do not see how I could control this. > https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They are loaded before main(), while InitInterpreter() loads libClin",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2467,availability,state,states,2467,"d with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > @vgvassilev : I do not see how I could control this. > https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They are loaded before main(), while InitInterpreter() loads libCling only after main(). This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here: https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. The challenge is to come up with a consistent symbol resolution :).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:3135,availability,consist,consistent,3135,"d with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > @vgvassilev : I do not see how I could control this. > https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They are loaded before main(), while InitInterpreter() loads libCling only after main(). This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here: https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. The challenge is to come up with a consistent symbol resolution :).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:662,deployability,stack,stack,662,"> > why is `/usr/lib64/libgandiva.so.14.1.0 ` initialized/dlopened first? > . > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > . > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > I have in the mean time found the root cause why my patch fails:. > . > * It is due to copy relocations of symbols from libstdc++. > . > * Crashes happen whenever cling wants to output text via cout / cerr / etc. > . > * The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RT",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:690,deployability,depend,depend,690,"> > why is `/usr/lib64/libgandiva.so.14.1.0 ` initialized/dlopened first? > . > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > . > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > I have in the mean time found the root cause why my patch fails:. > . > * It is due to copy relocations of symbols from libstdc++. > . > * Crashes happen whenever cling wants to output text via cout / cerr / etc. > . > * The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RT",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:789,deployability,patch,patch,789,"> > why is `/usr/lib64/libgandiva.so.14.1.0 ` initialized/dlopened first? > . > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > . > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > I have in the mean time found the root cause why my patch fails:. > . > * It is due to copy relocations of symbols from libstdc++. > . > * Crashes happen whenever cling wants to output text via cout / cerr / etc. > . > * The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RT",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:795,deployability,fail,fails,795,"> > why is `/usr/lib64/libgandiva.so.14.1.0 ` initialized/dlopened first? > . > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > . > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > I have in the mean time found the root cause why my patch fails:. > . > * It is due to copy relocations of symbols from libstdc++. > . > * Crashes happen whenever cling wants to output text via cout / cerr / etc. > . > * The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RT",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1667,deployability,fail,failing,1667,"ws which libraries depend on LLVM to avoid pain debugging ROOT. > I have in the mean time found the root cause why my patch fails:. > . > * It is due to copy relocations of symbols from libstdc++. > . > * Crashes happen whenever cling wants to output text via cout / cerr / etc. > . > * The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > @vgvassilev : I do not see how I could control this. > https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They a",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2210,deployability,depend,dependent,2210,"d with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > @vgvassilev : I do not see how I could control this. > https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They are loaded before main(), while InitInterpreter() loads libCling only after main(). This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here: https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. The challenge is to come up with a consistent symbol resolution :).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2908,deployability,log,logic,2908,"d with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > @vgvassilev : I do not see how I could control this. > https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They are loaded before main(), while InitInterpreter() loads libCling only after main(). This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here: https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. The challenge is to come up with a consistent symbol resolution :).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1162,energy efficiency,load,loaded,1162," libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > . > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > I have in the mean time found the root cause why my patch fails:. > . > * It is due to copy relocations of symbols from libstdc++. > . > * Crashes happen whenever cling wants to output text via cout / cerr / etc. > . > * The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. T",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1730,energy efficiency,fault,faults,1730,". > I have in the mean time found the root cause why my patch fails:. > . > * It is due to copy relocations of symbols from libstdc++. > . > * Crashes happen whenever cling wants to output text via cout / cerr / etc. > . > * The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > @vgvassilev : I do not see how I could control this. > https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They are loaded before main(), while InitInterpreter() loads libClin",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2437,energy efficiency,core,core,2437,"d with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > @vgvassilev : I do not see how I could control this. > https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They are loaded before main(), while InitInterpreter() loads libCling only after main(). This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here: https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. The challenge is to come up with a consistent symbol resolution :).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2674,energy efficiency,load,loaded,2674,"d with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > @vgvassilev : I do not see how I could control this. > https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They are loaded before main(), while InitInterpreter() loads libCling only after main(). This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here: https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. The challenge is to come up with a consistent symbol resolution :).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2720,energy efficiency,load,loads,2720,"d with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > @vgvassilev : I do not see how I could control this. > https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They are loaded before main(), while InitInterpreter() loads libCling only after main(). This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here: https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. The challenge is to come up with a consistent symbol resolution :).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:690,integrability,depend,depend,690,"> > why is `/usr/lib64/libgandiva.so.14.1.0 ` initialized/dlopened first? > . > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > . > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > I have in the mean time found the root cause why my patch fails:. > . > * It is due to copy relocations of symbols from libstdc++. > . > * Crashes happen whenever cling wants to output text via cout / cerr / etc. > . > * The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RT",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1510,integrability,translat,translate,1510,"it would affect any library that uses LLVM. Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > I have in the mean time found the root cause why my patch fails:. > . > * It is due to copy relocations of symbols from libstdc++. > . > * Crashes happen whenever cling wants to output text via cout / cerr / etc. > . > * The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > @vgvassilev : I do not see how I could control this. > https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called a",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2210,integrability,depend,dependent,2210,"d with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > @vgvassilev : I do not see how I could control this. > https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They are loaded before main(), while InitInterpreter() loads libCling only after main(). This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here: https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. The challenge is to come up with a consistent symbol resolution :).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2467,integrability,state,states,2467,"d with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > @vgvassilev : I do not see how I could control this. > https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They are loaded before main(), while InitInterpreter() loads libCling only after main(). This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here: https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. The challenge is to come up with a consistent symbol resolution :).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2783,integrability,sub,subsequent,2783,"d with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > @vgvassilev : I do not see how I could control this. > https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They are loaded before main(), while InitInterpreter() loads libCling only after main(). This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here: https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. The challenge is to come up with a consistent symbol resolution :).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:482,interoperability,specif,specific,482,"> > why is `/usr/lib64/libgandiva.so.14.1.0 ` initialized/dlopened first? > . > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > . > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > I have in the mean time found the root cause why my patch fails:. > . > * It is due to copy relocations of symbols from libstdc++. > . > * Crashes happen whenever cling wants to output text via cout / cerr / etc. > . > * The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RT",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1510,interoperability,translat,translate,1510,"it would affect any library that uses LLVM. Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > I have in the mean time found the root cause why my patch fails:. > . > * It is due to copy relocations of symbols from libstdc++. > . > * Crashes happen whenever cling wants to output text via cout / cerr / etc. > . > * The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > @vgvassilev : I do not see how I could control this. > https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called a",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:690,modifiability,depend,depend,690,"> > why is `/usr/lib64/libgandiva.so.14.1.0 ` initialized/dlopened first? > . > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > . > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > I have in the mean time found the root cause why my patch fails:. > . > * It is due to copy relocations of symbols from libstdc++. > . > * Crashes happen whenever cling wants to output text via cout / cerr / etc. > . > * The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RT",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1396,modifiability,portab,portable,1396,"but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > I have in the mean time found the root cause why my patch fails:. > . > * It is due to copy relocations of symbols from libstdc++. > . > * Crashes happen whenever cling wants to output text via cout / cerr / etc. > . > * The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > @vgvassilev : I do not see how I could control this. > https://gith",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2210,modifiability,depend,dependent,2210,"d with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > @vgvassilev : I do not see how I could control this. > https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They are loaded before main(), while InitInterpreter() loads libCling only after main(). This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here: https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. The challenge is to come up with a consistent symbol resolution :).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:756,performance,time,time,756,"> > why is `/usr/lib64/libgandiva.so.14.1.0 ` initialized/dlopened first? > . > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > . > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > I have in the mean time found the root cause why my patch fails:. > . > * It is due to copy relocations of symbols from libstdc++. > . > * Crashes happen whenever cling wants to output text via cout / cerr / etc. > . > * The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RT",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1162,performance,load,loaded,1162," libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > . > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > I have in the mean time found the root cause why my patch fails:. > . > * It is due to copy relocations of symbols from libstdc++. > . > * Crashes happen whenever cling wants to output text via cout / cerr / etc. > . > * The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. T",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1475,performance,time,time,1475," not specific to libgandiva only, but it would affect any library that uses LLVM. Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > I have in the mean time found the root cause why my patch fails:. > . > * It is due to copy relocations of symbols from libstdc++. > . > * Crashes happen whenever cling wants to output text via cout / cerr / etc. > . > * The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > @vgvassilev : I do not see how I could control this. > https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states tha",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1730,performance,fault,faults,1730,". > I have in the mean time found the root cause why my patch fails:. > . > * It is due to copy relocations of symbols from libstdc++. > . > * Crashes happen whenever cling wants to output text via cout / cerr / etc. > . > * The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > @vgvassilev : I do not see how I could control this. > https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They are loaded before main(), while InitInterpreter() loads libClin",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2674,performance,load,loaded,2674,"d with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > @vgvassilev : I do not see how I could control this. > https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They are loaded before main(), while InitInterpreter() loads libCling only after main(). This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here: https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. The challenge is to come up with a consistent symbol resolution :).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2720,performance,load,loads,2720,"d with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > @vgvassilev : I do not see how I could control this. > https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They are loaded before main(), while InitInterpreter() loads libCling only after main(). This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here: https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. The challenge is to come up with a consistent symbol resolution :).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:149,reliability,doe,does,149,"> > why is `/usr/lib64/libgandiva.so.14.1.0 ` initialized/dlopened first? > . > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > . > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > I have in the mean time found the root cause why my patch fails:. > . > * It is due to copy relocations of symbols from libstdc++. > . > * Crashes happen whenever cling wants to output text via cout / cerr / etc. > . > * The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RT",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:795,reliability,fail,fails,795,"> > why is `/usr/lib64/libgandiva.so.14.1.0 ` initialized/dlopened first? > . > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > . > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > I have in the mean time found the root cause why my patch fails:. > . > * It is due to copy relocations of symbols from libstdc++. > . > * Crashes happen whenever cling wants to output text via cout / cerr / etc. > . > * The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RT",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1284,reliability,doe,does,1284,"ree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > I have in the mean time found the root cause why my patch fails:. > . > * It is due to copy relocations of symbols from libstdc++. > . > * Crashes happen whenever cling wants to output text via cout / cerr / etc. > . > * The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fP",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1667,reliability,fail,failing,1667,"ws which libraries depend on LLVM to avoid pain debugging ROOT. > I have in the mean time found the root cause why my patch fails:. > . > * It is due to copy relocations of symbols from libstdc++. > . > * Crashes happen whenever cling wants to output text via cout / cerr / etc. > . > * The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > @vgvassilev : I do not see how I could control this. > https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They a",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1730,reliability,fault,faults,1730,". > I have in the mean time found the root cause why my patch fails:. > . > * It is due to copy relocations of symbols from libstdc++. > . > * Crashes happen whenever cling wants to output text via cout / cerr / etc. > . > * The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > @vgvassilev : I do not see how I could control this. > https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They are loaded before main(), while InitInterpreter() loads libClin",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:305,safety,avoid,avoided,305,"> > why is `/usr/lib64/libgandiva.so.14.1.0 ` initialized/dlopened first? > . > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > . > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > I have in the mean time found the root cause why my patch fails:. > . > * It is due to copy relocations of symbols from libstdc++. > . > * Crashes happen whenever cling wants to output text via cout / cerr / etc. > . > * The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RT",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:690,safety,depend,depend,690,"> > why is `/usr/lib64/libgandiva.so.14.1.0 ` initialized/dlopened first? > . > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > . > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > I have in the mean time found the root cause why my patch fails:. > . > * It is due to copy relocations of symbols from libstdc++. > . > * Crashes happen whenever cling wants to output text via cout / cerr / etc. > . > * The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RT",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:708,safety,avoid,avoid,708,"> > why is `/usr/lib64/libgandiva.so.14.1.0 ` initialized/dlopened first? > . > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > . > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > I have in the mean time found the root cause why my patch fails:. > . > * It is due to copy relocations of symbols from libstdc++. > . > * Crashes happen whenever cling wants to output text via cout / cerr / etc. > . > * The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RT",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:789,safety,patch,patch,789,"> > why is `/usr/lib64/libgandiva.so.14.1.0 ` initialized/dlopened first? > . > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > . > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > I have in the mean time found the root cause why my patch fails:. > . > * It is due to copy relocations of symbols from libstdc++. > . > * Crashes happen whenever cling wants to output text via cout / cerr / etc. > . > * The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RT",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1573,safety,avoid,avoided,1573,"se should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > I have in the mean time found the root cause why my patch fails:. > . > * It is due to copy relocations of symbols from libstdc++. > . > * Crashes happen whenever cling wants to output text via cout / cerr / etc. > . > * The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > @vgvassilev : I do not see how I could control this. > https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1730,safety,fault,faults,1730,". > I have in the mean time found the root cause why my patch fails:. > . > * It is due to copy relocations of symbols from libstdc++. > . > * Crashes happen whenever cling wants to output text via cout / cerr / etc. > . > * The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > @vgvassilev : I do not see how I could control this. > https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They are loaded before main(), while InitInterpreter() loads libClin",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2210,safety,depend,dependent,2210,"d with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > @vgvassilev : I do not see how I could control this. > https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They are loaded before main(), while InitInterpreter() loads libCling only after main(). This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here: https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. The challenge is to come up with a consistent symbol resolution :).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2908,safety,log,logic,2908,"d with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > @vgvassilev : I do not see how I could control this. > https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They are loaded before main(), while InitInterpreter() loads libCling only after main(). This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here: https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. The challenge is to come up with a consistent symbol resolution :).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:789,security,patch,patch,789,"> > why is `/usr/lib64/libgandiva.so.14.1.0 ` initialized/dlopened first? > . > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > . > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > I have in the mean time found the root cause why my patch fails:. > . > * It is due to copy relocations of symbols from libstdc++. > . > * Crashes happen whenever cling wants to output text via cout / cerr / etc. > . > * The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RT",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2372,security,control,control,2372,"d with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > @vgvassilev : I do not see how I could control this. > https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They are loaded before main(), while InitInterpreter() loads libCling only after main(). This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here: https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. The challenge is to come up with a consistent symbol resolution :).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2908,security,log,logic,2908,"d with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > @vgvassilev : I do not see how I could control this. > https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They are loaded before main(), while InitInterpreter() loads libCling only after main(). This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here: https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. The challenge is to come up with a consistent symbol resolution :).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:690,testability,depend,depend,690,"> > why is `/usr/lib64/libgandiva.so.14.1.0 ` initialized/dlopened first? > . > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > . > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > I have in the mean time found the root cause why my patch fails:. > . > * It is due to copy relocations of symbols from libstdc++. > . > * Crashes happen whenever cling wants to output text via cout / cerr / etc. > . > * The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RT",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2210,testability,depend,dependent,2210,"d with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > @vgvassilev : I do not see how I could control this. > https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They are loaded before main(), while InitInterpreter() loads libCling only after main(). This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here: https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. The challenge is to come up with a consistent symbol resolution :).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2372,testability,control,control,2372,"d with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > @vgvassilev : I do not see how I could control this. > https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They are loaded before main(), while InitInterpreter() loads libCling only after main(). This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here: https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. The challenge is to come up with a consistent symbol resolution :).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2908,testability,log,logic,2908,"d with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > @vgvassilev : I do not see how I could control this. > https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They are loaded before main(), while InitInterpreter() loads libCling only after main(). This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here: https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. The challenge is to come up with a consistent symbol resolution :).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1453,usability,behavi,behavior,1453,"also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > I have in the mean time found the root cause why my patch fails:. > . > * It is due to copy relocations of symbols from libstdc++. > . > * Crashes happen whenever cling wants to output text via cout / cerr / etc. > . > * The problem is that there are 2 instances of cout / cerr: The first created by the executable itself through copy relocation, when the executable prints something via cout. The second created by libCling loaded with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > @vgvassilev : I do not see how I could control this. > https://github.com/root-project/root/blob/master/core/base/src/TROOT.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:3135,usability,consist,consistent,3135,"d with RTLD_DEEPBIND. (By design, RTLD_DEEPBIND links to libstdc++ first before checking the global namespace, so it does not see the copy-relocated symbol.). I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > . > The problem can be avoided if executables are compiled with -fPIC as well. > I just tried locally to compile the failing ROOT ctests with -fPIC and this fixed the segmentation faults. > The question is whether this is a proper solution, since it would require to compile all executables with -fPIC. On the other hand, I don't know how to fix this in another way. Perhaps this could be enabled via a special CMake option for ROOT, which enables RTLD_DEEPBIND for libCling and -fPIC for all executables. IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > @vgvassilev : I do not see how I could control this. > https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2037 states that InitInterpreter() should be called after main(). Therefore, as we link to libgandiva, which links to llvm libs, the system LLVM symbols will always be in the global namespace by design. They are loaded before main(), while InitInterpreter() loads libCling only after main(). This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here: https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. The challenge is to come up with a consistent symbol resolution :).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2462,availability,consist,consistent,2462,"/ arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > . > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > . > The challenge is to come up with a consistent symbol resolution :). Just as a comment, two other possibilities would be to:. - put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. - If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:590,deployability,stack,stack,590,"> > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > . > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again,",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:618,deployability,depend,depend,618,"> > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > . > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again,",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:748,deployability,depend,dependency,748,"> > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > . > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again,",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1475,deployability,depend,dependent,1475," > . > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > . > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > . > The challenge is to come up with a consistent symbol ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2222,deployability,log,logic,2222,"/ arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > . > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > . > The challenge is to come up with a consistent symbol resolution :). Just as a comment, two other possibilities would be to:. - put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. - If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1873,energy efficiency,reduc,reduce-relocation,1873,"/ arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > . > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > . > The challenge is to come up with a consistent symbol resolution :). Just as a comment, two other possibilities would be to:. - put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. - If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:618,integrability,depend,depend,618,"> > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > . > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again,",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:748,integrability,depend,dependency,748,"> > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > . > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again,",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1185,integrability,translat,translate,1185,"s opened. > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > . > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check a",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1475,integrability,depend,dependent,1475," > . > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > . > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > . > The challenge is to come up with a consistent symbol ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2097,integrability,sub,subsequent,2097,"/ arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > . > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > . > The challenge is to come up with a consistent symbol resolution :). Just as a comment, two other possibilities would be to:. - put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. - If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2714,integrability,event,eventually,2714,"/ arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > . > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > . > The challenge is to come up with a consistent symbol resolution :). Just as a comment, two other possibilities would be to:. - put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. - If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:404,interoperability,specif,specific,404,"> > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > . > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again,",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1185,interoperability,translat,translate,1185,"s opened. > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > . > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check a",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1604,interoperability,share,shared,1604," libraries depend on LLVM to avoid pain debugging ROOT. > . Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > . > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > . > The challenge is to come up with a consistent symbol resolution :). Just as a comment, two other possibilities would be to:. - put the llvm / clang which are embedded in ROOT into ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:618,modifiability,depend,depend,618,"> > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > . > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again,",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:748,modifiability,depend,dependency,748,"> > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > . > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again,",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1071,modifiability,portab,portable,1071,"es not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > . > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > This ch",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1475,modifiability,depend,dependent,1475," > . > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > . > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > . > The challenge is to come up with a consistent symbol ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1150,performance,time,time,1150," it will always be after libgandiva was opened. > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > . > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from t",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:73,reliability,doe,does,73,"> > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > . > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again,",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:227,safety,avoid,avoided,227,"> > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > . > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again,",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:618,safety,depend,depend,618,"> > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > . > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again,",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:636,safety,avoid,avoid,636,"> > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > . > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again,",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:748,safety,depend,dependency,748,"> > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > . > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again,",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:852,safety,compl,complicated,852,"> > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > . > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again,",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1475,safety,depend,dependent,1475," > . > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > . > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > . > The challenge is to come up with a consistent symbol ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2049,safety,avoid,avoiding,2049,"/ arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > . > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > . > The challenge is to come up with a consistent symbol resolution :). Just as a comment, two other possibilities would be to:. - put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. - If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2222,safety,log,logic,2222,"/ arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > . > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > . > The challenge is to come up with a consistent symbol resolution :). Just as a comment, two other possibilities would be to:. - put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. - If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:715,security,control,control,715,"> > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > . > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again,",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:852,security,compl,complicated,852,"> > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > . > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again,",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2222,security,log,logic,2222,"/ arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > . > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > . > The challenge is to come up with a consistent symbol resolution :). Just as a comment, two other possibilities would be to:. - put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. - If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:618,testability,depend,depend,618,"> > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > . > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again,",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:715,testability,control,control,715,"> > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > . > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again,",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:748,testability,depend,dependency,748,"> > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > . > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again,",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1475,testability,depend,dependent,1475," > . > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > . > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > . > The challenge is to come up with a consistent symbol ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2222,testability,log,logic,2222,"/ arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > . > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > . > The challenge is to come up with a consistent symbol resolution :). Just as a comment, two other possibilities would be to:. - put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. - If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1128,usability,behavi,behavior,1128,"after the main(), so it will always be after libgandiva was opened. > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > . > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > This check is to protect the subsequent `dlsyms` in TCling to re",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2462,usability,consist,consistent,2462,"/ arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > . > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > . > The challenge is to come up with a consistent symbol resolution :). Just as a comment, two other possibilities would be to:. - put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. - If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2502,availability,consist,consistent,2502," overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > . > > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > > . > > The challenge is to come up with a consistent symbol resolution :). > > Just as a comment, two other possibilities would be to:. > . > * put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. This likely would not fix the global statics. > . > * If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang. We are in the versioning hell, as the version of the system LLVM might differ from the ones the `libgandiva` ships with. There we are facing a similar issue -- to make sure the JIT does not pick the wrong symbol.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:604,deployability,stack,stack,604,"> > > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > > . > > . > > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . > Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > . > > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:632,deployability,depend,depend,632,"> > > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > > . > > . > > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . > Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > . > > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:764,deployability,depend,dependency,764,"> > > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > > . > > . > > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . > Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > . > > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1505,deployability,depend,dependent,1505,"tely, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . > Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > . > > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > . > > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > > . > > The challenge is to come up with a consiste",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2260,deployability,log,logic,2260," overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > . > > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > > . > > The challenge is to come up with a consistent symbol resolution :). > > Just as a comment, two other possibilities would be to:. > . > * put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. This likely would not fix the global statics. > . > * If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang. We are in the versioning hell, as the version of the system LLVM might differ from the ones the `libgandiva` ships with. There we are facing a similar issue -- to make sure the JIT does not pick the wrong symbol.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2922,deployability,version,versioning,2922," overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > . > > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > > . > > The challenge is to come up with a consistent symbol resolution :). > > Just as a comment, two other possibilities would be to:. > . > * put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. This likely would not fix the global statics. > . > * If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang. We are in the versioning hell, as the version of the system LLVM might differ from the ones the `libgandiva` ships with. There we are facing a similar issue -- to make sure the JIT does not pick the wrong symbol.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2946,deployability,version,version,2946," overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > . > > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > > . > > The challenge is to come up with a consistent symbol resolution :). > > Just as a comment, two other possibilities would be to:. > . > * put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. This likely would not fix the global statics. > . > * If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang. We are in the versioning hell, as the version of the system LLVM might differ from the ones the `libgandiva` ships with. There we are facing a similar issue -- to make sure the JIT does not pick the wrong symbol.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1905,energy efficiency,reduc,reduce-relocation,1905,"with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > . > > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > . > > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > > . > > The challenge is to come up with a consistent symbol resolution :). > > Just as a comment, two other possibilities would be to:. > . > * put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. This likely would not fix the global statics. > . > * If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang. We are",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:632,integrability,depend,depend,632,"> > > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > > . > > . > > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . > Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > . > > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:764,integrability,depend,dependency,764,"> > > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > > . > > . > > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . > Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > . > > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1207,integrability,translat,translate,1207,"ree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > > . > > . > > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . > Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > . > > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > . > > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1505,integrability,depend,dependent,1505,"tely, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . > Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > . > > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > . > > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > > . > > The challenge is to come up with a consiste",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2135,integrability,sub,subsequent,2135," overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > . > > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > > . > > The challenge is to come up with a consistent symbol resolution :). > > Just as a comment, two other possibilities would be to:. > . > * put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. This likely would not fix the global statics. > . > * If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang. We are in the versioning hell, as the version of the system LLVM might differ from the ones the `libgandiva` ships with. There we are facing a similar issue -- to make sure the JIT does not pick the wrong symbol.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2816,integrability,event,eventually,2816," overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > . > > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > > . > > The challenge is to come up with a consistent symbol resolution :). > > Just as a comment, two other possibilities would be to:. > . > * put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. This likely would not fix the global statics. > . > * If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang. We are in the versioning hell, as the version of the system LLVM might differ from the ones the `libgandiva` ships with. There we are facing a similar issue -- to make sure the JIT does not pick the wrong symbol.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2922,integrability,version,versioning,2922," overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > . > > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > > . > > The challenge is to come up with a consistent symbol resolution :). > > Just as a comment, two other possibilities would be to:. > . > * put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. This likely would not fix the global statics. > . > * If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang. We are in the versioning hell, as the version of the system LLVM might differ from the ones the `libgandiva` ships with. There we are facing a similar issue -- to make sure the JIT does not pick the wrong symbol.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2946,integrability,version,version,2946," overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > . > > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > > . > > The challenge is to come up with a consistent symbol resolution :). > > Just as a comment, two other possibilities would be to:. > . > * put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. This likely would not fix the global statics. > . > * If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang. We are in the versioning hell, as the version of the system LLVM might differ from the ones the `libgandiva` ships with. There we are facing a similar issue -- to make sure the JIT does not pick the wrong symbol.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:408,interoperability,specif,specific,408,"> > > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > > . > > . > > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . > Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > . > > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1207,interoperability,translat,translate,1207,"ree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > > . > > . > > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . > Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > . > > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > . > > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1636,interoperability,share,shared,1636,"on LLVM to avoid pain debugging ROOT. > . > Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > . > > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > . > > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > > . > > The challenge is to come up with a consistent symbol resolution :). > > Just as a comment, two other possibilities would be to:. > . > * put the llvm / clang which are embe",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:632,modifiability,depend,depend,632,"> > > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > > . > > . > > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . > Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > . > > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:764,modifiability,depend,dependency,764,"> > > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > > . > > . > > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . > Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > . > > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1093,modifiability,portab,portable,1093,"ing, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > > . > > . > > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . > Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > . > > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1505,modifiability,depend,dependent,1505,"tely, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . > Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > . > > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > . > > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > > . > > The challenge is to come up with a consiste",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2922,modifiability,version,versioning,2922," overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > . > > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > > . > > The challenge is to come up with a consistent symbol resolution :). > > Just as a comment, two other possibilities would be to:. > . > * put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. This likely would not fix the global statics. > . > * If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang. We are in the versioning hell, as the version of the system LLVM might differ from the ones the `libgandiva` ships with. There we are facing a similar issue -- to make sure the JIT does not pick the wrong symbol.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2946,modifiability,version,version,2946," overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > . > > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > > . > > The challenge is to come up with a consistent symbol resolution :). > > Just as a comment, two other possibilities would be to:. > . > * put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. This likely would not fix the global statics. > . > * If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang. We are in the versioning hell, as the version of the system LLVM might differ from the ones the `libgandiva` ships with. There we are facing a similar issue -- to make sure the JIT does not pick the wrong symbol.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1172,performance,time,time,1172,"fter libgandiva was opened. > > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > > . > > . > > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . > Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > . > > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > . > > This check is to protect the subsequent `dlsyms` in TCling to resolv",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:75,reliability,doe,does,75,"> > > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > > . > > . > > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . > Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > . > > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:3089,reliability,doe,does,3089," overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > . > > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > > . > > The challenge is to come up with a consistent symbol resolution :). > > Just as a comment, two other possibilities would be to:. > . > * put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. This likely would not fix the global statics. > . > * If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang. We are in the versioning hell, as the version of the system LLVM might differ from the ones the `libgandiva` ships with. There we are facing a similar issue -- to make sure the JIT does not pick the wrong symbol.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:231,safety,avoid,avoided,231,"> > > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > > . > > . > > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . > Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > . > > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:632,safety,depend,depend,632,"> > > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > > . > > . > > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . > Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > . > > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:650,safety,avoid,avoid,650,"> > > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > > . > > . > > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . > Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > . > > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:764,safety,depend,dependency,764,"> > > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > > . > > . > > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . > Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > . > > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:868,safety,compl,complicated,868,"> > > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > > . > > . > > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . > Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > . > > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1505,safety,depend,dependent,1505,"tely, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . > Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > . > > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > . > > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > > . > > The challenge is to come up with a consiste",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2081,safety,avoid,avoiding,2081," is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > . > > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > > . > > The challenge is to come up with a consistent symbol resolution :). > > Just as a comment, two other possibilities would be to:. > . > * put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. This likely would not fix the global statics. > . > * If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang. We are in the versioning hell, as the version of the system LLVM might differ from the ones the `libgandiva` ships with. There we are facing a similar issue -- to make sure the ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2260,safety,log,logic,2260," overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > . > > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > > . > > The challenge is to come up with a consistent symbol resolution :). > > Just as a comment, two other possibilities would be to:. > . > * put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. This likely would not fix the global statics. > . > * If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang. We are in the versioning hell, as the version of the system LLVM might differ from the ones the `libgandiva` ships with. There we are facing a similar issue -- to make sure the JIT does not pick the wrong symbol.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:731,security,control,control,731,"> > > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > > . > > . > > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . > Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > . > > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:868,security,compl,complicated,868,"> > > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > > . > > . > > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . > Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > . > > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2260,security,log,logic,2260," overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > . > > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > > . > > The challenge is to come up with a consistent symbol resolution :). > > Just as a comment, two other possibilities would be to:. > . > * put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. This likely would not fix the global statics. > . > * If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang. We are in the versioning hell, as the version of the system LLVM might differ from the ones the `libgandiva` ships with. There we are facing a similar issue -- to make sure the JIT does not pick the wrong symbol.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:632,testability,depend,depend,632,"> > > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > > . > > . > > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . > Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > . > > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:731,testability,control,control,731,"> > > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > > . > > . > > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . > Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > . > > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:764,testability,depend,dependency,764,"> > > The reason is that we link to libgandiva (we do not dlopen it). ROOT does not link to libCling, but InitInterpreter() is called after the main(), so it will always be after libgandiva was opened. > > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > > . > > . > > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . > Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > . > > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1505,testability,depend,dependent,1505,"tely, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . > Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > . > > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > . > > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > > . > > The challenge is to come up with a consiste",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2260,testability,log,logic,2260," overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > . > > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > > . > > The challenge is to come up with a consistent symbol resolution :). > > Just as a comment, two other possibilities would be to:. > . > * put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. This likely would not fix the global statics. > . > * If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang. We are in the versioning hell, as the version of the system LLVM might differ from the ones the `libgandiva` ships with. There we are facing a similar issue -- to make sure the JIT does not pick the wrong symbol.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:1150,usability,behavi,behavior,1150," it will always be after libgandiva was opened. > > > I agree, that could be avoided if we would dlopen libgandiva, and make sure to do gROOT->GetInterpreter() beforehand, but this would require some changes to our software. And also this problem is not specific to libgandiva only, but it would affect any library that uses LLVM. > > . > > . > > Unfortunately, those should be carefully attended because of ROOT. I would feel more comfortable if my stack knows which libraries depend on LLVM to avoid pain debugging ROOT. > . > Well, the problem is that this is no so easy to control. LLVM can come in from a dependency chain via many libraries like OpenCL / Vulkan / arrow. And I am afraid this will become more complicated in the future. Instead of messing with each of them, I thought it might be better to fix the issue in a single place on the ROOT side. > . > > I am not a huge fan of the `RTLD_DEEPBIND` approach because it is not portable and it essentially overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > . > > This check is to protect the subsequent `dlsyms`",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:2502,usability,consist,consistent,2502," overrides the dynamic linker behavior yet one more time. I am not sure how this would translate to Windows for example. > . > I agree, me neither. If we can find a better and cleaner way, I am absolutely in favor of that. > . > > IIUC, `RTLD_DEEPBIND` alters the search order of the dynamic linker and using -fPIC intends to deduplicate. That seems as bad as preloading a set of llvm dependent libraries, IMO. Do we need `libgandiva.so` to be compiled with -fPIC or just the executables which 'use' ROOT? > . > All shared libraries must be compiled with -fPIC by definition, so libgandiva is already compiler with -fPIC. The change would only be for exectuables, which usually do not have -fPIC by default. But then actually other libraries have similar requirements, e.g. Qt5 (with -reduce-relocation flag, which is the default) requires all executables to link against Qt to be compiled with -fPIC. But again, if there is a better way, I am also in favor of avoiding -fPIC-. > . > > This check is to protect the subsequent `dlsyms` in TCling to resolve symbols from the wrong place. We can fix the check and play with the JIT resolution logic by playing with the search order here:. > > https://github.com/root-project/root/blob/39630b7530771be3e4643048361886dcfb057f07/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp#L299-L302. > > . > > The challenge is to come up with a consistent symbol resolution :). > > Just as a comment, two other possibilities would be to:. > . > * put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. This likely would not fix the global statics. > . > * If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang. We are in the versioning hell, as the version of the system LLVM might differ from the ones the `libgandiva` ships with. There we are facing a similar issue -- to make sure the JIT does not pick the wrong symbol.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:505,deployability,version,versioning,505,"> > ```. > > * put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. > > ```. > . > This likely would not fix the global statics. > . I do not see how that would break with global statics. All root-builtin llvm/clang statics would just go to the namespace as well. > > ```. > > * If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang. > > ```. > . > We are in the versioning hell, as the version of the system LLVM might differ from the ones the `libgandiva` ships with. There we are facing a similar issue -- to make sure the JIT does not pick the wrong symbol. Well, if gandiva ships their own llvm, then I would consider it their duty to hide their symbols as well in order to avoid a collision with the system llvm. What I am trying to fix mainly is linking to libraries that use the system/default llvm.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:529,deployability,version,version,529,"> > ```. > > * put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. > > ```. > . > This likely would not fix the global statics. > . I do not see how that would break with global statics. All root-builtin llvm/clang statics would just go to the namespace as well. > > ```. > > * If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang. > > ```. > . > We are in the versioning hell, as the version of the system LLVM might differ from the ones the `libgandiva` ships with. There we are facing a similar issue -- to make sure the JIT does not pick the wrong symbol. Well, if gandiva ships their own llvm, then I would consider it their duty to hide their symbols as well in order to avoid a collision with the system llvm. What I am trying to fix mainly is linking to libraries that use the system/default llvm.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:384,integrability,event,eventually,384,"> > ```. > > * put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. > > ```. > . > This likely would not fix the global statics. > . I do not see how that would break with global statics. All root-builtin llvm/clang statics would just go to the namespace as well. > > ```. > > * If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang. > > ```. > . > We are in the versioning hell, as the version of the system LLVM might differ from the ones the `libgandiva` ships with. There we are facing a similar issue -- to make sure the JIT does not pick the wrong symbol. Well, if gandiva ships their own llvm, then I would consider it their duty to hide their symbols as well in order to avoid a collision with the system llvm. What I am trying to fix mainly is linking to libraries that use the system/default llvm.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:505,integrability,version,versioning,505,"> > ```. > > * put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. > > ```. > . > This likely would not fix the global statics. > . I do not see how that would break with global statics. All root-builtin llvm/clang statics would just go to the namespace as well. > > ```. > > * If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang. > > ```. > . > We are in the versioning hell, as the version of the system LLVM might differ from the ones the `libgandiva` ships with. There we are facing a similar issue -- to make sure the JIT does not pick the wrong symbol. Well, if gandiva ships their own llvm, then I would consider it their duty to hide their symbols as well in order to avoid a collision with the system llvm. What I am trying to fix mainly is linking to libraries that use the system/default llvm.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:529,integrability,version,version,529,"> > ```. > > * put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. > > ```. > . > This likely would not fix the global statics. > . I do not see how that would break with global statics. All root-builtin llvm/clang statics would just go to the namespace as well. > > ```. > > * If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang. > > ```. > . > We are in the versioning hell, as the version of the system LLVM might differ from the ones the `libgandiva` ships with. There we are facing a similar issue -- to make sure the JIT does not pick the wrong symbol. Well, if gandiva ships their own llvm, then I would consider it their duty to hide their symbols as well in order to avoid a collision with the system llvm. What I am trying to fix mainly is linking to libraries that use the system/default llvm.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:505,modifiability,version,versioning,505,"> > ```. > > * put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. > > ```. > . > This likely would not fix the global statics. > . I do not see how that would break with global statics. All root-builtin llvm/clang statics would just go to the namespace as well. > > ```. > > * If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang. > > ```. > . > We are in the versioning hell, as the version of the system LLVM might differ from the ones the `libgandiva` ships with. There we are facing a similar issue -- to make sure the JIT does not pick the wrong symbol. Well, if gandiva ships their own llvm, then I would consider it their duty to hide their symbols as well in order to avoid a collision with the system llvm. What I am trying to fix mainly is linking to libraries that use the system/default llvm.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:529,modifiability,version,version,529,"> > ```. > > * put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. > > ```. > . > This likely would not fix the global statics. > . I do not see how that would break with global statics. All root-builtin llvm/clang statics would just go to the namespace as well. > > ```. > > * If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang. > > ```. > . > We are in the versioning hell, as the version of the system LLVM might differ from the ones the `libgandiva` ships with. There we are facing a similar issue -- to make sure the JIT does not pick the wrong symbol. Well, if gandiva ships their own llvm, then I would consider it their duty to hide their symbols as well in order to avoid a collision with the system llvm. What I am trying to fix mainly is linking to libraries that use the system/default llvm.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:672,reliability,doe,does,672,"> > ```. > > * put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. > > ```. > . > This likely would not fix the global statics. > . I do not see how that would break with global statics. All root-builtin llvm/clang statics would just go to the namespace as well. > > ```. > > * If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang. > > ```. > . > We are in the versioning hell, as the version of the system LLVM might differ from the ones the `libgandiva` ships with. There we are facing a similar issue -- to make sure the JIT does not pick the wrong symbol. Well, if gandiva ships their own llvm, then I would consider it their duty to hide their symbols as well in order to avoid a collision with the system llvm. What I am trying to fix mainly is linking to libraries that use the system/default llvm.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:821,safety,avoid,avoid,821,"> > ```. > > * put the llvm / clang which are embedded in ROOT into a namespace, so the symbols do not collide with system LLVM symbols. > > ```. > . > This likely would not fix the global statics. > . I do not see how that would break with global statics. All root-builtin llvm/clang statics would just go to the namespace as well. > > ```. > > * If the clang changes are upstreamed eventually, this shouldn't be necessary anymore, since cling could use system LLVM / Clang. > > ```. > . > We are in the versioning hell, as the version of the system LLVM might differ from the ones the `libgandiva` ships with. There we are facing a similar issue -- to make sure the JIT does not pick the wrong symbol. Well, if gandiva ships their own llvm, then I would consider it their duty to hide their symbols as well in order to avoid a collision with the system llvm. What I am trying to fix mainly is linking to libraries that use the system/default llvm.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:57,deployability,version,version,57,"@vgvassilev : Could you run the CI again? I pushed a new version, that might work at least for ALICE, using the fPIC fix I described above. PLEASE DO NOT MERGE THIS! I would just like to see if it passes your CI.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:57,integrability,version,version,57,"@vgvassilev : Could you run the CI again? I pushed a new version, that might work at least for ALICE, using the fPIC fix I described above. PLEASE DO NOT MERGE THIS! I would just like to see if it passes your CI.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:57,modifiability,version,version,57,"@vgvassilev : Could you run the CI again? I pushed a new version, that might work at least for ALICE, using the fPIC fix I described above. PLEASE DO NOT MERGE THIS! I would just like to see if it passes your CI.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:49,deployability,build,build,49,"Do I understand correctly, that only the windows build failed? From the log, I actually do not understand what was the problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:55,deployability,fail,failed,55,"Do I understand correctly, that only the windows build failed? From the log, I actually do not understand what was the problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:72,deployability,log,log,72,"Do I understand correctly, that only the windows build failed? From the log, I actually do not understand what was the problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:55,reliability,fail,failed,55,"Do I understand correctly, that only the windows build failed? From the log, I actually do not understand what was the problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:72,safety,log,log,72,"Do I understand correctly, that only the windows build failed? From the log, I actually do not understand what was the problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:72,security,log,log,72,"Do I understand correctly, that only the windows build failed? From the log, I actually do not understand what was the problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:5,testability,understand,understand,5,"Do I understand correctly, that only the windows build failed? From the log, I actually do not understand what was the problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:72,testability,log,log,72,"Do I understand correctly, that only the windows build failed? From the log, I actually do not understand what was the problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:95,testability,understand,understand,95,"Do I understand correctly, that only the windows build failed? From the log, I actually do not understand what was the problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:20,testability,understand,understand,20,> I actually do not understand what was the problem. It's a bug in our CI infra that forces everyone to *also* fork roottest...,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:5,deployability,patch,patch,5,"This patch will not work out as it is for ROOT, since it has too many side effects. Closing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:5,safety,patch,patch,5,"This patch will not work out as it is for ROOT, since it has too many side effects. Closing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4668:5,security,patch,patch,5,"This patch will not work out as it is for ROOT, since it has too many side effects. Closing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4668
https://github.com/root-project/root/pull/4671:11,deployability,build,build,11,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4671
https://github.com/root-project/root/pull/4671:2,availability,error,error,2,> error: The last gc run reported the following. Please correct the root cause. is fixed.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4671
https://github.com/root-project/root/pull/4671:2,performance,error,error,2,> error: The last gc run reported the following. Please correct the root cause. is fixed.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4671
https://github.com/root-project/root/pull/4671:2,safety,error,error,2,> error: The last gc run reported the following. Please correct the root cause. is fixed.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4671
https://github.com/root-project/root/pull/4671:2,usability,error,error,2,> error: The last gc run reported the following. Please correct the root cause. is fixed.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4671
https://github.com/root-project/root/pull/4671:11,deployability,build,build,11,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4671
https://github.com/root-project/root/pull/4671:74,deployability,stack,stack,74,"@bellenot . > To illustrate the different behaviors, here is the original stack trace . and what is the new one?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4671
https://github.com/root-project/root/pull/4671:80,testability,trace,trace,80,"@bellenot . > To illustrate the different behaviors, here is the original stack trace . and what is the new one?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4671
https://github.com/root-project/root/pull/4671:42,usability,behavi,behaviors,42,"@bellenot . > To illustrate the different behaviors, here is the original stack trace . and what is the new one?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4671
https://github.com/root-project/root/pull/4671:81,deployability,stack,stack,81,"> @bellenot. > . > > To illustrate the different behaviors, here is the original stack trace. > . > and what is the new one? Look carefully, they both are in the comment...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4671
https://github.com/root-project/root/pull/4671:87,testability,trace,trace,87,"> @bellenot. > . > > To illustrate the different behaviors, here is the original stack trace. > . > and what is the new one? Look carefully, they both are in the comment...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4671
https://github.com/root-project/root/pull/4671:49,usability,behavi,behaviors,49,"> @bellenot. > . > > To illustrate the different behaviors, here is the original stack trace. > . > and what is the new one? Look carefully, they both are in the comment...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4671
https://github.com/root-project/root/pull/4671:95,deployability,updat,update,95,"@pcanal do you have any further comment on this? Since this is needed only when we do the next update of cppyy in experimental PyROOT, and we are not doing that update for 6.20, I propose we delay the merging of this PR until after we tag 6.20.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4671
https://github.com/root-project/root/pull/4671:161,deployability,updat,update,161,"@pcanal do you have any further comment on this? Since this is needed only when we do the next update of cppyy in experimental PyROOT, and we are not doing that update for 6.20, I propose we delay the merging of this PR until after we tag 6.20.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4671
https://github.com/root-project/root/pull/4671:95,safety,updat,update,95,"@pcanal do you have any further comment on this? Since this is needed only when we do the next update of cppyy in experimental PyROOT, and we are not doing that update for 6.20, I propose we delay the merging of this PR until after we tag 6.20.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4671
https://github.com/root-project/root/pull/4671:161,safety,updat,update,161,"@pcanal do you have any further comment on this? Since this is needed only when we do the next update of cppyy in experimental PyROOT, and we are not doing that update for 6.20, I propose we delay the merging of this PR until after we tag 6.20.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4671
https://github.com/root-project/root/pull/4671:95,security,updat,update,95,"@pcanal do you have any further comment on this? Since this is needed only when we do the next update of cppyy in experimental PyROOT, and we are not doing that update for 6.20, I propose we delay the merging of this PR until after we tag 6.20.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4671
https://github.com/root-project/root/pull/4671:161,security,updat,update,161,"@pcanal do you have any further comment on this? Since this is needed only when we do the next update of cppyy in experimental PyROOT, and we are not doing that update for 6.20, I propose we delay the merging of this PR until after we tag 6.20.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4671
https://github.com/root-project/root/pull/4671:11,deployability,build,build,11,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4671
https://github.com/root-project/root/pull/4671:26,safety,test,test,26,Do we have a (standalone) test of the new feature?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4671
https://github.com/root-project/root/pull/4671:26,testability,test,test,26,Do we have a (standalone) test of the new feature?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4671
https://github.com/root-project/root/pull/4671:132,deployability,updat,updated,132,"> Do we have a (standalone) test of the new feature? Sure, I will write one in C++, I can't do it in Python now because we have not updated the cppyy of PyROOT experimental yet (since we need the changes of this PR for that).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4671
https://github.com/root-project/root/pull/4671:28,safety,test,test,28,"> Do we have a (standalone) test of the new feature? Sure, I will write one in C++, I can't do it in Python now because we have not updated the cppyy of PyROOT experimental yet (since we need the changes of this PR for that).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4671
https://github.com/root-project/root/pull/4671:132,safety,updat,updated,132,"> Do we have a (standalone) test of the new feature? Sure, I will write one in C++, I can't do it in Python now because we have not updated the cppyy of PyROOT experimental yet (since we need the changes of this PR for that).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4671
https://github.com/root-project/root/pull/4671:132,security,updat,updated,132,"> Do we have a (standalone) test of the new feature? Sure, I will write one in C++, I can't do it in Python now because we have not updated the cppyy of PyROOT experimental yet (since we need the changes of this PR for that).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4671
https://github.com/root-project/root/pull/4671:28,testability,test,test,28,"> Do we have a (standalone) test of the new feature? Sure, I will write one in C++, I can't do it in Python now because we have not updated the cppyy of PyROOT experimental yet (since we need the changes of this PR for that).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4671
https://github.com/root-project/root/pull/4671:47,availability,failur,failure,47,@pcanal gtest added: b872271ba. Multicore test failure above is unrelated to this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4671
https://github.com/root-project/root/pull/4671:47,deployability,fail,failure,47,@pcanal gtest added: b872271ba. Multicore test failure above is unrelated to this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4671
https://github.com/root-project/root/pull/4671:47,performance,failur,failure,47,@pcanal gtest added: b872271ba. Multicore test failure above is unrelated to this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4671
https://github.com/root-project/root/pull/4671:47,reliability,fail,failure,47,@pcanal gtest added: b872271ba. Multicore test failure above is unrelated to this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4671
https://github.com/root-project/root/pull/4671:42,safety,test,test,42,@pcanal gtest added: b872271ba. Multicore test failure above is unrelated to this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4671
https://github.com/root-project/root/pull/4671:42,testability,test,test,42,@pcanal gtest added: b872271ba. Multicore test failure above is unrelated to this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4671
https://github.com/root-project/root/pull/4672:11,deployability,build,build,11,@phsft-bot build with flags -Dpyroot_experimental=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4672
https://github.com/root-project/root/pull/4673:11,deployability,build,build,11,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4673
https://github.com/root-project/root/pull/4673:11,deployability,build,build,11,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4673
https://github.com/root-project/root/pull/4673:4,availability,failur,failure,4,The failure is unrelated. Merging. Thank you very much!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4673
https://github.com/root-project/root/pull/4673:4,deployability,fail,failure,4,The failure is unrelated. Merging. Thank you very much!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4673
https://github.com/root-project/root/pull/4673:4,performance,failur,failure,4,The failure is unrelated. Merging. Thank you very much!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4673
https://github.com/root-project/root/pull/4673:4,reliability,fail,failure,4,The failure is unrelated. Merging. Thank you very much!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4673
https://github.com/root-project/root/pull/4674:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4674
https://github.com/root-project/root/pull/4674:62,performance,I/O,I/O,62,@pcanal I think all the immediate changes we discussed in the I/O meeting are in,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4674
https://github.com/root-project/root/pull/4674:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4674
https://github.com/root-project/root/pull/4675:11,deployability,build,build,11,@phsft-bot build with flags -DCMAKE_BUILD_TYPE=Debug -DLLVM_BUILD_TYPE=Debug,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:11,deployability,build,build,11,@phsft-bot build with flags -DCMAKE_BUILD_TYPE=Release -DLLVM_BUILD_TYPE=RelWithDebInfo,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:47,deployability,Releas,Release,47,@phsft-bot build with flags -DCMAKE_BUILD_TYPE=Release -DLLVM_BUILD_TYPE=RelWithDebInfo,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:11,deployability,build,build,11,@phsft-bot build with flags -DCMAKE_BUILD_TYPE=Release -DLLVM_BUILD_TYPE=Release,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:47,deployability,Releas,Release,47,@phsft-bot build with flags -DCMAKE_BUILD_TYPE=Release -DLLVM_BUILD_TYPE=Release,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:73,deployability,Releas,Release,73,@phsft-bot build with flags -DCMAKE_BUILD_TYPE=Release -DLLVM_BUILD_TYPE=Release,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:199,deployability,log,logic,199,> Looks like we have register something atexit (https://github.com/root-project/root/blame/master/core/base/src/TApplication.cxx#L162). Why TApplication does not rely on the regular gROOT's shutdown logic in TROOT.cxx? Because TApplication are usually/often created after TROOT and we want to get the atexit at much at the tip of the chain (i.e. actually executed as early as possible).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:98,energy efficiency,core,core,98,> Looks like we have register something atexit (https://github.com/root-project/root/blame/master/core/base/src/TApplication.cxx#L162). Why TApplication does not rely on the regular gROOT's shutdown logic in TROOT.cxx? Because TApplication are usually/often created after TROOT and we want to get the atexit at much at the tip of the chain (i.e. actually executed as early as possible).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:153,reliability,doe,does,153,> Looks like we have register something atexit (https://github.com/root-project/root/blame/master/core/base/src/TApplication.cxx#L162). Why TApplication does not rely on the regular gROOT's shutdown logic in TROOT.cxx? Because TApplication are usually/often created after TROOT and we want to get the atexit at much at the tip of the chain (i.e. actually executed as early as possible).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:199,safety,log,logic,199,> Looks like we have register something atexit (https://github.com/root-project/root/blame/master/core/base/src/TApplication.cxx#L162). Why TApplication does not rely on the regular gROOT's shutdown logic in TROOT.cxx? Because TApplication are usually/often created after TROOT and we want to get the atexit at much at the tip of the chain (i.e. actually executed as early as possible).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:199,security,log,logic,199,> Looks like we have register something atexit (https://github.com/root-project/root/blame/master/core/base/src/TApplication.cxx#L162). Why TApplication does not rely on the regular gROOT's shutdown logic in TROOT.cxx? Because TApplication are usually/often created after TROOT and we want to get the atexit at much at the tip of the chain (i.e. actually executed as early as possible).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:199,testability,log,logic,199,> Looks like we have register something atexit (https://github.com/root-project/root/blame/master/core/base/src/TApplication.cxx#L162). Why TApplication does not rely on the regular gROOT's shutdown logic in TROOT.cxx? Because TApplication are usually/often created after TROOT and we want to get the atexit at much at the tip of the chain (i.e. actually executed as early as possible).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:323,usability,tip,tip,323,> Looks like we have register something atexit (https://github.com/root-project/root/blame/master/core/base/src/TApplication.cxx#L162). Why TApplication does not rely on the regular gROOT's shutdown logic in TROOT.cxx? Because TApplication are usually/often created after TROOT and we want to get the atexit at much at the tip of the chain (i.e. actually executed as early as possible).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:11,deployability,build,build,11,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:11,deployability,build,build,11,@phsft-bot build just on ROOT-ubuntu18.04-i386/cxx14,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:11,deployability,build,build,11,"@phsft-bot build on ROOT-performance-centos7-multicore/default, ROOT-fedora27/noimt, ROOT-fedora29/python3, ROOT-fedora30/cxx14, ROOT-ubuntu16/nortcxxmod, ROOT-ubuntu18.04-i386/cxx14, mac1014/cxx17, windows10/cxx14 with flags -DCTEST_TEST_EXCLUDE_NONE=On",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:25,performance,perform,performance-,25,"@phsft-bot build on ROOT-performance-centos7-multicore/default, ROOT-fedora27/noimt, ROOT-fedora29/python3, ROOT-fedora30/cxx14, ROOT-ubuntu16/nortcxxmod, ROOT-ubuntu18.04-i386/cxx14, mac1014/cxx17, windows10/cxx14 with flags -DCTEST_TEST_EXCLUDE_NONE=On",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:25,usability,perform,performance-,25,"@phsft-bot build on ROOT-performance-centos7-multicore/default, ROOT-fedora27/noimt, ROOT-fedora29/python3, ROOT-fedora30/cxx14, ROOT-ubuntu16/nortcxxmod, ROOT-ubuntu18.04-i386/cxx14, mac1014/cxx17, windows10/cxx14 with flags -DCTEST_TEST_EXCLUDE_NONE=On",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:201,deployability,log,logic,201,"> > Looks like we have register something atexit (https://github.com/root-project/root/blame/master/core/base/src/TApplication.cxx#L162). Why TApplication does not rely on the regular gROOT's shutdown logic in TROOT.cxx? > . > Because TApplication are usually/often created after TROOT and we want to get the atexit at much at the tip of the chain (i.e. actually executed as early as possible). That's confusing, `TROOT::ShutDown` already makes this call in the proper order. I've removed this piece of code and let's see if tests will be green.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:100,energy efficiency,core,core,100,"> > Looks like we have register something atexit (https://github.com/root-project/root/blame/master/core/base/src/TApplication.cxx#L162). Why TApplication does not rely on the regular gROOT's shutdown logic in TROOT.cxx? > . > Because TApplication are usually/often created after TROOT and we want to get the atexit at much at the tip of the chain (i.e. actually executed as early as possible). That's confusing, `TROOT::ShutDown` already makes this call in the proper order. I've removed this piece of code and let's see if tests will be green.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:539,energy efficiency,green,green,539,"> > Looks like we have register something atexit (https://github.com/root-project/root/blame/master/core/base/src/TApplication.cxx#L162). Why TApplication does not rely on the regular gROOT's shutdown logic in TROOT.cxx? > . > Because TApplication are usually/often created after TROOT and we want to get the atexit at much at the tip of the chain (i.e. actually executed as early as possible). That's confusing, `TROOT::ShutDown` already makes this call in the proper order. I've removed this piece of code and let's see if tests will be green.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:155,reliability,doe,does,155,"> > Looks like we have register something atexit (https://github.com/root-project/root/blame/master/core/base/src/TApplication.cxx#L162). Why TApplication does not rely on the regular gROOT's shutdown logic in TROOT.cxx? > . > Because TApplication are usually/often created after TROOT and we want to get the atexit at much at the tip of the chain (i.e. actually executed as early as possible). That's confusing, `TROOT::ShutDown` already makes this call in the proper order. I've removed this piece of code and let's see if tests will be green.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:201,safety,log,logic,201,"> > Looks like we have register something atexit (https://github.com/root-project/root/blame/master/core/base/src/TApplication.cxx#L162). Why TApplication does not rely on the regular gROOT's shutdown logic in TROOT.cxx? > . > Because TApplication are usually/often created after TROOT and we want to get the atexit at much at the tip of the chain (i.e. actually executed as early as possible). That's confusing, `TROOT::ShutDown` already makes this call in the proper order. I've removed this piece of code and let's see if tests will be green.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:525,safety,test,tests,525,"> > Looks like we have register something atexit (https://github.com/root-project/root/blame/master/core/base/src/TApplication.cxx#L162). Why TApplication does not rely on the regular gROOT's shutdown logic in TROOT.cxx? > . > Because TApplication are usually/often created after TROOT and we want to get the atexit at much at the tip of the chain (i.e. actually executed as early as possible). That's confusing, `TROOT::ShutDown` already makes this call in the proper order. I've removed this piece of code and let's see if tests will be green.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:201,security,log,logic,201,"> > Looks like we have register something atexit (https://github.com/root-project/root/blame/master/core/base/src/TApplication.cxx#L162). Why TApplication does not rely on the regular gROOT's shutdown logic in TROOT.cxx? > . > Because TApplication are usually/often created after TROOT and we want to get the atexit at much at the tip of the chain (i.e. actually executed as early as possible). That's confusing, `TROOT::ShutDown` already makes this call in the proper order. I've removed this piece of code and let's see if tests will be green.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:201,testability,log,logic,201,"> > Looks like we have register something atexit (https://github.com/root-project/root/blame/master/core/base/src/TApplication.cxx#L162). Why TApplication does not rely on the regular gROOT's shutdown logic in TROOT.cxx? > . > Because TApplication are usually/often created after TROOT and we want to get the atexit at much at the tip of the chain (i.e. actually executed as early as possible). That's confusing, `TROOT::ShutDown` already makes this call in the proper order. I've removed this piece of code and let's see if tests will be green.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:525,testability,test,tests,525,"> > Looks like we have register something atexit (https://github.com/root-project/root/blame/master/core/base/src/TApplication.cxx#L162). Why TApplication does not rely on the regular gROOT's shutdown logic in TROOT.cxx? > . > Because TApplication are usually/often created after TROOT and we want to get the atexit at much at the tip of the chain (i.e. actually executed as early as possible). That's confusing, `TROOT::ShutDown` already makes this call in the proper order. I've removed this piece of code and let's see if tests will be green.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:331,usability,tip,tip,331,"> > Looks like we have register something atexit (https://github.com/root-project/root/blame/master/core/base/src/TApplication.cxx#L162). Why TApplication does not rely on the regular gROOT's shutdown logic in TROOT.cxx? > . > Because TApplication are usually/often created after TROOT and we want to get the atexit at much at the tip of the chain (i.e. actually executed as early as possible). That's confusing, `TROOT::ShutDown` already makes this call in the proper order. I've removed this piece of code and let's see if tests will be green.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:54,availability,failur,failures,54,Note that the projectroot.test.test_stressHistFactory failures are likely real - an indication of an inf loop.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:54,deployability,fail,failures,54,Note that the projectroot.test.test_stressHistFactory failures are likely real - an indication of an inf loop.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:54,performance,failur,failures,54,Note that the projectroot.test.test_stressHistFactory failures are likely real - an indication of an inf loop.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:54,reliability,fail,failures,54,Note that the projectroot.test.test_stressHistFactory failures are likely real - an indication of an inf loop.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:26,safety,test,test,26,Note that the projectroot.test.test_stressHistFactory failures are likely real - an indication of an inf loop.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:26,testability,test,test,26,Note that the projectroot.test.test_stressHistFactory failures are likely real - an indication of an inf loop.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:84,usability,indicat,indication,84,Note that the projectroot.test.test_stressHistFactory failures are likely real - an indication of an inf loop.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:60,availability,state,state,60,"Indeed, static destruction in RooFit is still not in a good state. I could imagine a deadlock in std::at_exit.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:60,integrability,state,state,60,"Indeed, static destruction in RooFit is still not in a good state. I could imagine a deadlock in std::at_exit.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:85,performance,deadlock,deadlock,85,"Indeed, static destruction in RooFit is still not in a good state. I could imagine a deadlock in std::at_exit.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:112,availability,failur,failure,112,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On. Looks like it was a glitch. I can not reproduce these failure even at the nodes.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:11,deployability,build,build,11,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On. Looks like it was a glitch. I can not reproduce these failure even at the nodes.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:112,deployability,fail,failure,112,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On. Looks like it was a glitch. I can not reproduce these failure even at the nodes.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:112,performance,failur,failure,112,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On. Looks like it was a glitch. I can not reproduce these failure even at the nodes.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:112,reliability,fail,failure,112,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On. Looks like it was a glitch. I can not reproduce these failure even at the nodes.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4675:92,availability,heal,heal,92,> projectroot.runtutorials.tutorial_v7_line.cxx. is due to a broken Mac node. I'm trying to heal it; for the moment it's taken out of Jenkins.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4675
https://github.com/root-project/root/pull/4676:11,deployability,build,build,11,"@phsft-bot build just on ROOT-ubuntu16/nortcxxmod, ROOT-fedora27/noimt",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4676
https://github.com/root-project/root/pull/4676:11,deployability,build,build,11,"@phsft-bot build just on ROOT-ubuntu16, ROOT-fedora27",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4676
https://github.com/root-project/root/pull/4676:11,deployability,build,build,11,@phsft-bot build just on ROOT-ubuntu16/nortcxxmod,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4676
https://github.com/root-project/root/pull/4679:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4679
https://github.com/root-project/root/pull/4680:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4680
https://github.com/root-project/root/pull/4682:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4682
https://github.com/root-project/root/pull/4683:25,availability,Error,Error,25,"FYI, the similar [`llvm::Error`](https://llvm.org/doxygen/classllvm_1_1Error.html). [`llvm::Expected`](https://llvm.org/doxygen/classllvm_1_1Expected.html). is basically a `std::variant<value, llvm::Error>`, where getting the value is only permitted after having checked the error state.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:199,availability,Error,Error,199,"FYI, the similar [`llvm::Error`](https://llvm.org/doxygen/classllvm_1_1Error.html). [`llvm::Expected`](https://llvm.org/doxygen/classllvm_1_1Expected.html). is basically a `std::variant<value, llvm::Error>`, where getting the value is only permitted after having checked the error state.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:275,availability,error,error,275,"FYI, the similar [`llvm::Error`](https://llvm.org/doxygen/classllvm_1_1Error.html). [`llvm::Expected`](https://llvm.org/doxygen/classllvm_1_1Expected.html). is basically a `std::variant<value, llvm::Error>`, where getting the value is only permitted after having checked the error state.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:281,availability,state,state,281,"FYI, the similar [`llvm::Error`](https://llvm.org/doxygen/classllvm_1_1Error.html). [`llvm::Expected`](https://llvm.org/doxygen/classllvm_1_1Expected.html). is basically a `std::variant<value, llvm::Error>`, where getting the value is only permitted after having checked the error state.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:281,integrability,state,state,281,"FYI, the similar [`llvm::Error`](https://llvm.org/doxygen/classllvm_1_1Error.html). [`llvm::Expected`](https://llvm.org/doxygen/classllvm_1_1Expected.html). is basically a `std::variant<value, llvm::Error>`, where getting the value is only permitted after having checked the error state.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:25,performance,Error,Error,25,"FYI, the similar [`llvm::Error`](https://llvm.org/doxygen/classllvm_1_1Error.html). [`llvm::Expected`](https://llvm.org/doxygen/classllvm_1_1Expected.html). is basically a `std::variant<value, llvm::Error>`, where getting the value is only permitted after having checked the error state.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:199,performance,Error,Error,199,"FYI, the similar [`llvm::Error`](https://llvm.org/doxygen/classllvm_1_1Error.html). [`llvm::Expected`](https://llvm.org/doxygen/classllvm_1_1Expected.html). is basically a `std::variant<value, llvm::Error>`, where getting the value is only permitted after having checked the error state.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:275,performance,error,error,275,"FYI, the similar [`llvm::Error`](https://llvm.org/doxygen/classllvm_1_1Error.html). [`llvm::Expected`](https://llvm.org/doxygen/classllvm_1_1Expected.html). is basically a `std::variant<value, llvm::Error>`, where getting the value is only permitted after having checked the error state.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:25,safety,Error,Error,25,"FYI, the similar [`llvm::Error`](https://llvm.org/doxygen/classllvm_1_1Error.html). [`llvm::Expected`](https://llvm.org/doxygen/classllvm_1_1Expected.html). is basically a `std::variant<value, llvm::Error>`, where getting the value is only permitted after having checked the error state.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:199,safety,Error,Error,199,"FYI, the similar [`llvm::Error`](https://llvm.org/doxygen/classllvm_1_1Error.html). [`llvm::Expected`](https://llvm.org/doxygen/classllvm_1_1Expected.html). is basically a `std::variant<value, llvm::Error>`, where getting the value is only permitted after having checked the error state.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:275,safety,error,error,275,"FYI, the similar [`llvm::Error`](https://llvm.org/doxygen/classllvm_1_1Error.html). [`llvm::Expected`](https://llvm.org/doxygen/classllvm_1_1Expected.html). is basically a `std::variant<value, llvm::Error>`, where getting the value is only permitted after having checked the error state.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:25,usability,Error,Error,25,"FYI, the similar [`llvm::Error`](https://llvm.org/doxygen/classllvm_1_1Error.html). [`llvm::Expected`](https://llvm.org/doxygen/classllvm_1_1Expected.html). is basically a `std::variant<value, llvm::Error>`, where getting the value is only permitted after having checked the error state.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:199,usability,Error,Error,199,"FYI, the similar [`llvm::Error`](https://llvm.org/doxygen/classllvm_1_1Error.html). [`llvm::Expected`](https://llvm.org/doxygen/classllvm_1_1Expected.html). is basically a `std::variant<value, llvm::Error>`, where getting the value is only permitted after having checked the error state.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:275,usability,error,error,275,"FYI, the similar [`llvm::Error`](https://llvm.org/doxygen/classllvm_1_1Error.html). [`llvm::Expected`](https://llvm.org/doxygen/classllvm_1_1Expected.html). is basically a `std::variant<value, llvm::Error>`, where getting the value is only permitted after having checked the error state.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:50,availability,state,state,50,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:125,availability,error,error,125,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:329,availability,operat,operator,329,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:401,availability,state,state,401,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:533,availability,error,error,533,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:539,availability,state,state,539,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:655,availability,error,error,655,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:742,availability,state,state,742,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:797,availability,error,error,797,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:852,availability,state,state,852,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:963,availability,error,error,963,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:1044,availability,operat,operator,1044,"n state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:1127,availability,operat,operator,1127,"in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:1247,availability,operat,operator,1247,"rk(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: all",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:1417,availability,error,error,1417,"s to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:1608,availability,state,state,1608,"ven be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the develo",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:1834,availability,error,error,1834,"e use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versu",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:1840,availability,state,state,1840,"a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus mani",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:2254,availability,error,error,2254,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:2338,availability,error,errors,2338,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:2360,availability,slo,slow,2360,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:2484,availability,error,error,2484,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:2646,availability,state,state,2646,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:2776,availability,error,error,2776,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:2782,availability,state,state,2782,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:2924,availability,state,state,2924,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:2954,availability,robust,robust,2954,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:109,deployability,stack,stack,109,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:1176,deployability,stack,stack,1176,"in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:1319,deployability,stack,stack,1319,"rator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always t",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:1462,deployability,fail,failed,1462,"work()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exc",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:2819,deployability,stack,stack,2819,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:3003,deployability,stack,stack,3003,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:353,energy efficiency,model,modelBackground,353,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:641,energy efficiency,model,modeled,641,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:1271,energy efficiency,model,modelBackground,1271,"). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:50,integrability,state,state,50,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:401,integrability,state,state,401,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:539,integrability,state,state,539,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:742,integrability,state,state,742,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:852,integrability,state,state,852,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:998,integrability,sub,subsequent,998,"m not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.co",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:1423,integrability,messag,message,1423,"row an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but AB",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:1598,integrability,inject,injecting,1598," might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because th",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:1608,integrability,state,state,1608,"ven be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the develo",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:1840,integrability,state,state,1840,"a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus mani",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:2179,integrability,topic,topic,2179,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:2646,integrability,state,state,2646,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:2782,integrability,state,state,2782,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:2924,integrability,state,state,2924,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:3080,integrability,messag,messages,3080,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:1423,interoperability,messag,message,1423,"row an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but AB",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:3080,interoperability,messag,messages,3080,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:125,performance,error,error,125,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:533,performance,error,error,533,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:655,performance,error,error,655,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:797,performance,error,error,797,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:963,performance,error,error,963,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:1417,performance,error,error,1417,"s to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:1834,performance,error,error,1834,"e use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versu",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:2254,performance,error,error,2254,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:2338,performance,error,errors,2338,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:2484,performance,error,error,2484,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:2776,performance,error,error,2776,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:1462,reliability,fail,failed,1462,"work()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exc",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:2360,reliability,slo,slow,2360,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:2954,reliability,robust,robust,2954,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:3069,reliability,diagno,diagnostic,3069,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:40,safety,except,exception,40,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:125,safety,error,error,125,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:391,safety,except,exception,391,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:434,safety,except,exception,434,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:533,safety,error,error,533,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:655,safety,error,error,655,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:731,safety,except,exception,731,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:797,safety,error,error,797,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:900,safety,except,exception,900,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:963,safety,error,error,963,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:1359,safety,except,exception,1359,"ound(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:1417,safety,error,error,1417,"s to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:1834,safety,error,error,1834,"e use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versu",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:2254,safety,error,error,2254,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:2290,safety,except,exceptions,2290,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:2338,safety,error,errors,2338,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:2462,safety,except,exceptions,2462,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:2484,safety,error,error,2484,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:2667,safety,except,exceptions,2667,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:2706,safety,except,exceptions,2706,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:2776,safety,error,error,2776,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:2954,safety,robust,robust,2954,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:353,security,model,modelBackground,353,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:570,security,access,accessing,570,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:641,security,model,modeled,641,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:1271,security,model,modelBackground,1271,"). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:1598,security,inject,injecting,1598," might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because th",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:1182,testability,trace,trace,1182,"RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:1325,testability,trace,trace,1325,":operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw i",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:3069,testability,diagno,diagnostic,3069,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:125,usability,error,error,125,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:343,usability,User,UserCode,343,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:533,usability,error,error,533,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:655,usability,error,error,655,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:797,usability,error,error,797,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:963,usability,error,error,963,"I am not convinced yet by the immediate exception state. For discussion purposes, let's assume the following stack causes an error in `linux_read_from_network`, which is captured in a `RStatus` in `ROOT::ReadFromNetwork()`:. ```. linux_read_from_network(). ROOT::ReadFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:1261,usability,User,UserCode,1261,"adFromNetwork(). ROOT::RNetFile::Read(). ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. The immediate exception state would allow us to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:1417,usability,error,error,1417,"s to throw an exception in `ROOT::ReadFromNetwork()`. But `ROOT::RNetFile::Read()` might want/need to handle the error state, e.g. by retrying, or by accessing alternative sources. It might even be that a partial read is modeled as an error. This would require `ROOT::ReadFromNetwork()` to force the ""immediate exception"" state to a certain value and reset it later - which is error prone and awkward; it shows that we use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations ",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:1834,usability,error,error,1834,"e use a global state that needs local knowledge. If ""immediate exception"" is false and `ROOT::ReadFromNetwork()` captures the error and returns it, same for all subsequent frames but `ROOT::RNTupleIterator::operator++()` (which cannot return a `RStatus`), then only `ROOT::RNTupleIterator::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versu",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:2254,usability,error,error,2254,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:2338,usability,error,errors,2338,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:2484,usability,error,error,2484,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:2776,usability,error,error,2776,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:3057,usability,user,user-facing,3057,"tor::operator++()` will throw. This would shorten the stack trace shown by a potential crash to. ```. ROOT::RNTupleIterator::operator++(). UserCode::modelBackground(). ```. - we would not know the stack trace that actually triggered the exception. We would likely have some info captured in the error message (e.g. ""ROOT::ReadFromNetwork() failed to call linux_read_from_network()""), but we'd miss the connection, i.e. `ROOT::RNetFile::Read()`. One way of handling that is by injecting state:. ```. RStatus ROOT::RNetFile::Read() {. RStatus res(ROOT::ReadFromNetwork());. ... return R__STATUS_PASSTHROUGH(res); // registers res to have passed through ""ROOT::RNetFile::Read()"" by emplacing a frame string *if* in error state. ```. That's similar to [`llvm::PrettyStackTraceEntry`](https://llvm.org/doxygen/classllvm_1_1PrettyStackTraceEntry.html), see usage [here](https://github.com/llvm/llvm-project/blob/df494f7512b0ecebdf3d7be97695a1b6278c0336/clang/lib/CodeGen/BackendUtil.cpp#L909). FYI, there has been a multi-hundred email discussion on exactly this topic on the C++ committee mailing list, with pretty much two camps: allow error code handling (with potential exceptions) versus just always throw in case of errors, and if that's slow, go fix the compiler / runtime library implementations (but ABI break). **TL;DR**:. I agree that exceptions instead of error codes allow for nicer code. I don't think that we can have that nice code when we introduce `RStatus`, because the developer of that code must not assume a state for ""immediate exceptions"". In the end, we cannot use exceptions (across frames returning `RStatus`) and need to handle the error state, *always*. That leaves missing stack frames versus manipulation of a global (with developers dangerously and tacitly assuming a default state) - where IMHO it's more robust to have a mechanism to supply the missing stack frames (which can then - even better! - include user-facing diagnostic messages rather than just function names).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:48,availability,error,error,48,"I am uncertain about the missing separation of ""error code"" and ""payload value"" for some value types. E.g. `RStatus<FILE*>` versus `RStatus<std::string>` (where the string is read from a file) seem similar: the value represents the result of a potentially failing operation. But in the latter case the value does not encode failure, while in the former it does (the `FILE*` being `== nullptr`). Maybe that's just me, but maybe that calls for something similar to `llvm::Expected` that then handles the error case internally. Especially for pointers that might be a better interface, forcing a validity check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:264,availability,operat,operation,264,"I am uncertain about the missing separation of ""error code"" and ""payload value"" for some value types. E.g. `RStatus<FILE*>` versus `RStatus<std::string>` (where the string is read from a file) seem similar: the value represents the result of a potentially failing operation. But in the latter case the value does not encode failure, while in the former it does (the `FILE*` being `== nullptr`). Maybe that's just me, but maybe that calls for something similar to `llvm::Expected` that then handles the error case internally. Especially for pointers that might be a better interface, forcing a validity check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:324,availability,failur,failure,324,"I am uncertain about the missing separation of ""error code"" and ""payload value"" for some value types. E.g. `RStatus<FILE*>` versus `RStatus<std::string>` (where the string is read from a file) seem similar: the value represents the result of a potentially failing operation. But in the latter case the value does not encode failure, while in the former it does (the `FILE*` being `== nullptr`). Maybe that's just me, but maybe that calls for something similar to `llvm::Expected` that then handles the error case internally. Especially for pointers that might be a better interface, forcing a validity check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:502,availability,error,error,502,"I am uncertain about the missing separation of ""error code"" and ""payload value"" for some value types. E.g. `RStatus<FILE*>` versus `RStatus<std::string>` (where the string is read from a file) seem similar: the value represents the result of a potentially failing operation. But in the latter case the value does not encode failure, while in the former it does (the `FILE*` being `== nullptr`). Maybe that's just me, but maybe that calls for something similar to `llvm::Expected` that then handles the error case internally. Especially for pointers that might be a better interface, forcing a validity check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:256,deployability,fail,failing,256,"I am uncertain about the missing separation of ""error code"" and ""payload value"" for some value types. E.g. `RStatus<FILE*>` versus `RStatus<std::string>` (where the string is read from a file) seem similar: the value represents the result of a potentially failing operation. But in the latter case the value does not encode failure, while in the former it does (the `FILE*` being `== nullptr`). Maybe that's just me, but maybe that calls for something similar to `llvm::Expected` that then handles the error case internally. Especially for pointers that might be a better interface, forcing a validity check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:324,deployability,fail,failure,324,"I am uncertain about the missing separation of ""error code"" and ""payload value"" for some value types. E.g. `RStatus<FILE*>` versus `RStatus<std::string>` (where the string is read from a file) seem similar: the value represents the result of a potentially failing operation. But in the latter case the value does not encode failure, while in the former it does (the `FILE*` being `== nullptr`). Maybe that's just me, but maybe that calls for something similar to `llvm::Expected` that then handles the error case internally. Especially for pointers that might be a better interface, forcing a validity check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:572,integrability,interfac,interface,572,"I am uncertain about the missing separation of ""error code"" and ""payload value"" for some value types. E.g. `RStatus<FILE*>` versus `RStatus<std::string>` (where the string is read from a file) seem similar: the value represents the result of a potentially failing operation. But in the latter case the value does not encode failure, while in the former it does (the `FILE*` being `== nullptr`). Maybe that's just me, but maybe that calls for something similar to `llvm::Expected` that then handles the error case internally. Especially for pointers that might be a better interface, forcing a validity check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:572,interoperability,interfac,interface,572,"I am uncertain about the missing separation of ""error code"" and ""payload value"" for some value types. E.g. `RStatus<FILE*>` versus `RStatus<std::string>` (where the string is read from a file) seem similar: the value represents the result of a potentially failing operation. But in the latter case the value does not encode failure, while in the former it does (the `FILE*` being `== nullptr`). Maybe that's just me, but maybe that calls for something similar to `llvm::Expected` that then handles the error case internally. Especially for pointers that might be a better interface, forcing a validity check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:572,modifiability,interfac,interface,572,"I am uncertain about the missing separation of ""error code"" and ""payload value"" for some value types. E.g. `RStatus<FILE*>` versus `RStatus<std::string>` (where the string is read from a file) seem similar: the value represents the result of a potentially failing operation. But in the latter case the value does not encode failure, while in the former it does (the `FILE*` being `== nullptr`). Maybe that's just me, but maybe that calls for something similar to `llvm::Expected` that then handles the error case internally. Especially for pointers that might be a better interface, forcing a validity check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:48,performance,error,error,48,"I am uncertain about the missing separation of ""error code"" and ""payload value"" for some value types. E.g. `RStatus<FILE*>` versus `RStatus<std::string>` (where the string is read from a file) seem similar: the value represents the result of a potentially failing operation. But in the latter case the value does not encode failure, while in the former it does (the `FILE*` being `== nullptr`). Maybe that's just me, but maybe that calls for something similar to `llvm::Expected` that then handles the error case internally. Especially for pointers that might be a better interface, forcing a validity check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:324,performance,failur,failure,324,"I am uncertain about the missing separation of ""error code"" and ""payload value"" for some value types. E.g. `RStatus<FILE*>` versus `RStatus<std::string>` (where the string is read from a file) seem similar: the value represents the result of a potentially failing operation. But in the latter case the value does not encode failure, while in the former it does (the `FILE*` being `== nullptr`). Maybe that's just me, but maybe that calls for something similar to `llvm::Expected` that then handles the error case internally. Especially for pointers that might be a better interface, forcing a validity check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:502,performance,error,error,502,"I am uncertain about the missing separation of ""error code"" and ""payload value"" for some value types. E.g. `RStatus<FILE*>` versus `RStatus<std::string>` (where the string is read from a file) seem similar: the value represents the result of a potentially failing operation. But in the latter case the value does not encode failure, while in the former it does (the `FILE*` being `== nullptr`). Maybe that's just me, but maybe that calls for something similar to `llvm::Expected` that then handles the error case internally. Especially for pointers that might be a better interface, forcing a validity check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:256,reliability,fail,failing,256,"I am uncertain about the missing separation of ""error code"" and ""payload value"" for some value types. E.g. `RStatus<FILE*>` versus `RStatus<std::string>` (where the string is read from a file) seem similar: the value represents the result of a potentially failing operation. But in the latter case the value does not encode failure, while in the former it does (the `FILE*` being `== nullptr`). Maybe that's just me, but maybe that calls for something similar to `llvm::Expected` that then handles the error case internally. Especially for pointers that might be a better interface, forcing a validity check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:308,reliability,doe,does,308,"I am uncertain about the missing separation of ""error code"" and ""payload value"" for some value types. E.g. `RStatus<FILE*>` versus `RStatus<std::string>` (where the string is read from a file) seem similar: the value represents the result of a potentially failing operation. But in the latter case the value does not encode failure, while in the former it does (the `FILE*` being `== nullptr`). Maybe that's just me, but maybe that calls for something similar to `llvm::Expected` that then handles the error case internally. Especially for pointers that might be a better interface, forcing a validity check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:324,reliability,fail,failure,324,"I am uncertain about the missing separation of ""error code"" and ""payload value"" for some value types. E.g. `RStatus<FILE*>` versus `RStatus<std::string>` (where the string is read from a file) seem similar: the value represents the result of a potentially failing operation. But in the latter case the value does not encode failure, while in the former it does (the `FILE*` being `== nullptr`). Maybe that's just me, but maybe that calls for something similar to `llvm::Expected` that then handles the error case internally. Especially for pointers that might be a better interface, forcing a validity check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:356,reliability,doe,does,356,"I am uncertain about the missing separation of ""error code"" and ""payload value"" for some value types. E.g. `RStatus<FILE*>` versus `RStatus<std::string>` (where the string is read from a file) seem similar: the value represents the result of a potentially failing operation. But in the latter case the value does not encode failure, while in the former it does (the `FILE*` being `== nullptr`). Maybe that's just me, but maybe that calls for something similar to `llvm::Expected` that then handles the error case internally. Especially for pointers that might be a better interface, forcing a validity check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:48,safety,error,error,48,"I am uncertain about the missing separation of ""error code"" and ""payload value"" for some value types. E.g. `RStatus<FILE*>` versus `RStatus<std::string>` (where the string is read from a file) seem similar: the value represents the result of a potentially failing operation. But in the latter case the value does not encode failure, while in the former it does (the `FILE*` being `== nullptr`). Maybe that's just me, but maybe that calls for something similar to `llvm::Expected` that then handles the error case internally. Especially for pointers that might be a better interface, forcing a validity check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:502,safety,error,error,502,"I am uncertain about the missing separation of ""error code"" and ""payload value"" for some value types. E.g. `RStatus<FILE*>` versus `RStatus<std::string>` (where the string is read from a file) seem similar: the value represents the result of a potentially failing operation. But in the latter case the value does not encode failure, while in the former it does (the `FILE*` being `== nullptr`). Maybe that's just me, but maybe that calls for something similar to `llvm::Expected` that then handles the error case internally. Especially for pointers that might be a better interface, forcing a validity check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:593,safety,valid,validity,593,"I am uncertain about the missing separation of ""error code"" and ""payload value"" for some value types. E.g. `RStatus<FILE*>` versus `RStatus<std::string>` (where the string is read from a file) seem similar: the value represents the result of a potentially failing operation. But in the latter case the value does not encode failure, while in the former it does (the `FILE*` being `== nullptr`). Maybe that's just me, but maybe that calls for something similar to `llvm::Expected` that then handles the error case internally. Especially for pointers that might be a better interface, forcing a validity check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:48,usability,error,error,48,"I am uncertain about the missing separation of ""error code"" and ""payload value"" for some value types. E.g. `RStatus<FILE*>` versus `RStatus<std::string>` (where the string is read from a file) seem similar: the value represents the result of a potentially failing operation. But in the latter case the value does not encode failure, while in the former it does (the `FILE*` being `== nullptr`). Maybe that's just me, but maybe that calls for something similar to `llvm::Expected` that then handles the error case internally. Especially for pointers that might be a better interface, forcing a validity check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:502,usability,error,error,502,"I am uncertain about the missing separation of ""error code"" and ""payload value"" for some value types. E.g. `RStatus<FILE*>` versus `RStatus<std::string>` (where the string is read from a file) seem similar: the value represents the result of a potentially failing operation. But in the latter case the value does not encode failure, while in the former it does (the `FILE*` being `== nullptr`). Maybe that's just me, but maybe that calls for something similar to `llvm::Expected` that then handles the error case internally. Especially for pointers that might be a better interface, forcing a validity check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:98,availability,error,error,98,"I think I can follow. That would mean that we accept the cost of allocating strings (stack frame, error message) in the RStatus class in case of errors.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:145,availability,error,errors,145,"I think I can follow. That would mean that we accept the cost of allocating strings (stack frame, error message) in the RStatus class in case of errors.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:85,deployability,stack,stack,85,"I think I can follow. That would mean that we accept the cost of allocating strings (stack frame, error message) in the RStatus class in case of errors.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:65,energy efficiency,alloc,allocating,65,"I think I can follow. That would mean that we accept the cost of allocating strings (stack frame, error message) in the RStatus class in case of errors.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:104,integrability,messag,message,104,"I think I can follow. That would mean that we accept the cost of allocating strings (stack frame, error message) in the RStatus class in case of errors.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:104,interoperability,messag,message,104,"I think I can follow. That would mean that we accept the cost of allocating strings (stack frame, error message) in the RStatus class in case of errors.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:98,performance,error,error,98,"I think I can follow. That would mean that we accept the cost of allocating strings (stack frame, error message) in the RStatus class in case of errors.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:145,performance,error,errors,145,"I think I can follow. That would mean that we accept the cost of allocating strings (stack frame, error message) in the RStatus class in case of errors.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:98,safety,error,error,98,"I think I can follow. That would mean that we accept the cost of allocating strings (stack frame, error message) in the RStatus class in case of errors.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:145,safety,error,errors,145,"I think I can follow. That would mean that we accept the cost of allocating strings (stack frame, error message) in the RStatus class in case of errors.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:98,usability,error,error,98,"I think I can follow. That would mean that we accept the cost of allocating strings (stack frame, error message) in the RStatus class in case of errors.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:145,usability,error,errors,145,"I think I can follow. That would mean that we accept the cost of allocating strings (stack frame, error message) in the RStatus class in case of errors.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:68,deployability,updat,updated,68,@Axel-Naumann @pcanal Reworked a bit along the discussed lines (see updated PR message).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:79,integrability,messag,message,79,@Axel-Naumann @pcanal Reworked a bit along the discussed lines (see updated PR message).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:79,interoperability,messag,message,79,@Axel-Naumann @pcanal Reworked a bit along the discussed lines (see updated PR message).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:68,safety,updat,updated,68,@Axel-Naumann @pcanal Reworked a bit along the discussed lines (see updated PR message).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:68,security,updat,updated,68,@Axel-Naumann @pcanal Reworked a bit along the discussed lines (see updated PR message).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:11,deployability,build,build,11,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4683:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4683
https://github.com/root-project/root/pull/4684:43,usability,progress,progress,43,@Axel-Naumann I'm taking over here to make progress on ROOT-10033.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4684
https://github.com/root-project/root/pull/4685:11,deployability,build,build,11,@phsft-bot build !,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4685
https://github.com/root-project/root/pull/4685:4,usability,progress,progress,4,Any progress on this ?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4685
https://github.com/root-project/root/pull/4686:11,deployability,build,build,11,@phsft-bot build with flags -Dpyroot_experimental=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4686
https://github.com/root-project/root/pull/4686:11,deployability,build,build,11,@phsft-bot build with flags -Dpyroot_experimental=OFF,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4686
https://github.com/root-project/root/pull/4686:11,deployability,build,build,11,@phsft-bot build with flags -Dpyroot_experimental=OFF,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4686
https://github.com/root-project/root/pull/4686:11,deployability,build,build,11,@phsft-bot build with flags -Dpyroot_experimental=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4686
https://github.com/root-project/root/pull/4687:113,modifiability,concern,concerns,113,"I don't see any connection between these two (but the mention of ""shutdown""). IMHO these are completely separate concerns.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4687
https://github.com/root-project/root/pull/4687:93,safety,compl,completely,93,"I don't see any connection between these two (but the mention of ""shutdown""). IMHO these are completely separate concerns.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4687
https://github.com/root-project/root/pull/4687:93,security,compl,completely,93,"I don't see any connection between these two (but the mention of ""shutdown""). IMHO these are completely separate concerns.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4687
https://github.com/root-project/root/pull/4687:113,testability,concern,concerns,113,"I don't see any connection between these two (but the mention of ""shutdown""). IMHO these are completely separate concerns.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4687
https://github.com/root-project/root/pull/4687:35,interoperability,share,shared,35,"Ok, fair enough. I was thinking of shared ptr semantics of gROOT making the soft shutdown somewhat more natural.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4687
https://github.com/root-project/root/pull/4687:46,interoperability,semant,semantics,46,"Ok, fair enough. I was thinking of shared ptr semantics of gROOT making the soft shutdown somewhat more natural.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4687
https://github.com/root-project/root/pull/4687:158,deployability,unload,unloaded,158,"Note that a shared_ptr semantic does not help here, since we need to trigger something to happen ""right after the end of main and before any other library is unloaded"" and a gROOT help by shared_ptr would by definition on mark/trigger when the last 'ROOT' library is unloaded.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4687
https://github.com/root-project/root/pull/4687:267,deployability,unload,unloaded,267,"Note that a shared_ptr semantic does not help here, since we need to trigger something to happen ""right after the end of main and before any other library is unloaded"" and a gROOT help by shared_ptr would by definition on mark/trigger when the last 'ROOT' library is unloaded.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4687
https://github.com/root-project/root/pull/4687:23,interoperability,semant,semantic,23,"Note that a shared_ptr semantic does not help here, since we need to trigger something to happen ""right after the end of main and before any other library is unloaded"" and a gROOT help by shared_ptr would by definition on mark/trigger when the last 'ROOT' library is unloaded.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4687
https://github.com/root-project/root/pull/4687:32,reliability,doe,does,32,"Note that a shared_ptr semantic does not help here, since we need to trigger something to happen ""right after the end of main and before any other library is unloaded"" and a gROOT help by shared_ptr would by definition on mark/trigger when the last 'ROOT' library is unloaded.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4687
https://github.com/root-project/root/pull/4687:41,usability,help,help,41,"Note that a shared_ptr semantic does not help here, since we need to trigger something to happen ""right after the end of main and before any other library is unloaded"" and a gROOT help by shared_ptr would by definition on mark/trigger when the last 'ROOT' library is unloaded.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4687
https://github.com/root-project/root/pull/4687:180,usability,help,help,180,"Note that a shared_ptr semantic does not help here, since we need to trigger something to happen ""right after the end of main and before any other library is unloaded"" and a gROOT help by shared_ptr would by definition on mark/trigger when the last 'ROOT' library is unloaded.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4687
https://github.com/root-project/root/pull/4687:230,deployability,build,builds,230,I've just pushed the requested changes. Solomonic decision between @Axel-Naumann 's and @pcanal 's suggestions: the soft teardown function is now called `ClearProxiedObjects` :smile: . Let's wait for a final confirmation from the builds and I'll merge.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4687
https://github.com/root-project/root/pull/4687:154,usability,Clear,ClearProxiedObjects,154,I've just pushed the requested changes. Solomonic decision between @Axel-Naumann 's and @pcanal 's suggestions: the soft teardown function is now called `ClearProxiedObjects` :smile: . Let's wait for a final confirmation from the builds and I'll merge.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4687
https://github.com/root-project/root/pull/4687:208,usability,confirm,confirmation,208,I've just pushed the requested changes. Solomonic decision between @Axel-Naumann 's and @pcanal 's suggestions: the soft teardown function is now called `ClearProxiedObjects` :smile: . Let's wait for a final confirmation from the builds and I'll merge.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4687
https://github.com/root-project/root/pull/4688:0,availability,Ping,Ping,0,"Ping @Axel-Naumann. Clearly I have nothing to do with these test failures, so what should I do next?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4688
https://github.com/root-project/root/pull/4688:65,availability,failur,failures,65,"Ping @Axel-Naumann. Clearly I have nothing to do with these test failures, so what should I do next?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4688
https://github.com/root-project/root/pull/4688:65,deployability,fail,failures,65,"Ping @Axel-Naumann. Clearly I have nothing to do with these test failures, so what should I do next?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4688
https://github.com/root-project/root/pull/4688:65,performance,failur,failures,65,"Ping @Axel-Naumann. Clearly I have nothing to do with these test failures, so what should I do next?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4688
https://github.com/root-project/root/pull/4688:65,reliability,fail,failures,65,"Ping @Axel-Naumann. Clearly I have nothing to do with these test failures, so what should I do next?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4688
https://github.com/root-project/root/pull/4688:60,safety,test,test,60,"Ping @Axel-Naumann. Clearly I have nothing to do with these test failures, so what should I do next?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4688
https://github.com/root-project/root/pull/4688:60,testability,test,test,60,"Ping @Axel-Naumann. Clearly I have nothing to do with these test failures, so what should I do next?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4688
https://github.com/root-project/root/pull/4688:20,usability,Clear,Clearly,20,"Ping @Axel-Naumann. Clearly I have nothing to do with these test failures, so what should I do next?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4688
https://github.com/root-project/root/pull/4688:98,deployability,build,build,98,"Regarding Windows: we have a bug in our CI infra that forces you to fork roottest for the Windows build to succeed. Could you do that, please?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4688
https://github.com/root-project/root/pull/4688:6,availability,failur,failures,6,These failures are indeed unrelated (and should now be fixed in master).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4688
https://github.com/root-project/root/pull/4688:6,deployability,fail,failures,6,These failures are indeed unrelated (and should now be fixed in master).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4688
https://github.com/root-project/root/pull/4688:6,performance,failur,failures,6,These failures are indeed unrelated (and should now be fixed in master).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4688
https://github.com/root-project/root/pull/4688:6,reliability,fail,failures,6,These failures are indeed unrelated (and should now be fixed in master).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4688
https://github.com/root-project/root/pull/4689:26,safety,test,test,26,"Thx, i have seen it, will test it later today.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:26,testability,test,test,26,"Thx, i have seen it, will test it later today.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:193,availability,Error,Error,193,"@Axel-Naumann : I think this patch is correct in any case, since the symbols should be hidden. Unfortunately, it is not enough to solve our problem. My test case from #4668 still yields:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. - The first line `LLVM SYMBOLS ARE EXPOSED....` is because the check in core/base/src/TROOT.cxx is not disabled, so this this is irrelevant. In fact, if your patch would work, this check should be removed. - The second error `... inconsistency in registered....` however is the same problem we saw before, with the 2 LLVM instances clashing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:390,availability,Error,Error,390,"@Axel-Naumann : I think this patch is correct in any case, since the symbols should be hidden. Unfortunately, it is not enough to solve our problem. My test case from #4668 still yields:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. - The first line `LLVM SYMBOLS ARE EXPOSED....` is because the check in core/base/src/TROOT.cxx is not disabled, so this this is irrelevant. In fact, if your patch would work, this check should be removed. - The second error `... inconsistency in registered....` however is the same problem we saw before, with the 2 LLVM instances clashing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:446,availability,ERROR,ERROR,446,"@Axel-Naumann : I think this patch is correct in any case, since the symbols should be hidden. Unfortunately, it is not enough to solve our problem. My test case from #4668 still yields:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. - The first line `LLVM SYMBOLS ARE EXPOSED....` is because the check in core/base/src/TROOT.cxx is not disabled, so this this is irrelevant. In fact, if your patch would work, this check should be removed. - The second error `... inconsistency in registered....` however is the same problem we saw before, with the 2 LLVM instances clashing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:726,availability,error,error,726,"@Axel-Naumann : I think this patch is correct in any case, since the symbols should be hidden. Unfortunately, it is not enough to solve our problem. My test case from #4668 still yields:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. - The first line `LLVM SYMBOLS ARE EXPOSED....` is because the check in core/base/src/TROOT.cxx is not disabled, so this this is irrelevant. In fact, if your patch would work, this check should be removed. - The second error `... inconsistency in registered....` however is the same problem we saw before, with the 2 LLVM instances clashing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:29,deployability,patch,patch,29,"@Axel-Naumann : I think this patch is correct in any case, since the symbols should be hidden. Unfortunately, it is not enough to solve our problem. My test case from #4668 still yields:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. - The first line `LLVM SYMBOLS ARE EXPOSED....` is because the check in core/base/src/TROOT.cxx is not disabled, so this this is irrelevant. In fact, if your patch would work, this check should be removed. - The second error `... inconsistency in registered....` however is the same problem we saw before, with the 2 LLVM instances clashing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:405,deployability,version,version,405,"@Axel-Naumann : I think this patch is correct in any case, since the symbols should be hidden. Unfortunately, it is not enough to solve our problem. My test case from #4668 still yields:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. - The first line `LLVM SYMBOLS ARE EXPOSED....` is because the check in core/base/src/TROOT.cxx is not disabled, so this this is irrelevant. In fact, if your patch would work, this check should be removed. - The second error `... inconsistency in registered....` however is the same problem we saw before, with the 2 LLVM instances clashing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:665,deployability,patch,patch,665,"@Axel-Naumann : I think this patch is correct in any case, since the symbols should be hidden. Unfortunately, it is not enough to solve our problem. My test case from #4668 still yields:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. - The first line `LLVM SYMBOLS ARE EXPOSED....` is because the check in core/base/src/TROOT.cxx is not disabled, so this this is irrelevant. In fact, if your patch would work, this check should be removed. - The second error `... inconsistency in registered....` however is the same problem we saw before, with the 2 LLVM instances clashing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:579,energy efficiency,core,core,579,"@Axel-Naumann : I think this patch is correct in any case, since the symbols should be hidden. Unfortunately, it is not enough to solve our problem. My test case from #4668 still yields:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. - The first line `LLVM SYMBOLS ARE EXPOSED....` is because the check in core/base/src/TROOT.cxx is not disabled, so this this is irrelevant. In fact, if your patch would work, this check should be removed. - The second error `... inconsistency in registered....` however is the same problem we saw before, with the 2 LLVM instances clashing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:405,integrability,version,version,405,"@Axel-Naumann : I think this patch is correct in any case, since the symbols should be hidden. Unfortunately, it is not enough to solve our problem. My test case from #4668 still yields:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. - The first line `LLVM SYMBOLS ARE EXPOSED....` is because the check in core/base/src/TROOT.cxx is not disabled, so this this is irrelevant. In fact, if your patch would work, this check should be removed. - The second error `... inconsistency in registered....` however is the same problem we saw before, with the 2 LLVM instances clashing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:405,modifiability,version,version,405,"@Axel-Naumann : I think this patch is correct in any case, since the symbols should be hidden. Unfortunately, it is not enough to solve our problem. My test case from #4668 still yields:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. - The first line `LLVM SYMBOLS ARE EXPOSED....` is because the check in core/base/src/TROOT.cxx is not disabled, so this this is irrelevant. In fact, if your patch would work, this check should be removed. - The second error `... inconsistency in registered....` however is the same problem we saw before, with the 2 LLVM instances clashing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:193,performance,Error,Error,193,"@Axel-Naumann : I think this patch is correct in any case, since the symbols should be hidden. Unfortunately, it is not enough to solve our problem. My test case from #4668 still yields:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. - The first line `LLVM SYMBOLS ARE EXPOSED....` is because the check in core/base/src/TROOT.cxx is not disabled, so this this is irrelevant. In fact, if your patch would work, this check should be removed. - The second error `... inconsistency in registered....` however is the same problem we saw before, with the 2 LLVM instances clashing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:390,performance,Error,Error,390,"@Axel-Naumann : I think this patch is correct in any case, since the symbols should be hidden. Unfortunately, it is not enough to solve our problem. My test case from #4668 still yields:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. - The first line `LLVM SYMBOLS ARE EXPOSED....` is because the check in core/base/src/TROOT.cxx is not disabled, so this this is irrelevant. In fact, if your patch would work, this check should be removed. - The second error `... inconsistency in registered....` however is the same problem we saw before, with the 2 LLVM instances clashing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:446,performance,ERROR,ERROR,446,"@Axel-Naumann : I think this patch is correct in any case, since the symbols should be hidden. Unfortunately, it is not enough to solve our problem. My test case from #4668 still yields:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. - The first line `LLVM SYMBOLS ARE EXPOSED....` is because the check in core/base/src/TROOT.cxx is not disabled, so this this is irrelevant. In fact, if your patch would work, this check should be removed. - The second error `... inconsistency in registered....` however is the same problem we saw before, with the 2 LLVM instances clashing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:726,performance,error,error,726,"@Axel-Naumann : I think this patch is correct in any case, since the symbols should be hidden. Unfortunately, it is not enough to solve our problem. My test case from #4668 still yields:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. - The first line `LLVM SYMBOLS ARE EXPOSED....` is because the check in core/base/src/TROOT.cxx is not disabled, so this this is irrelevant. In fact, if your patch would work, this check should be removed. - The second error `... inconsistency in registered....` however is the same problem we saw before, with the 2 LLVM instances clashing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:29,safety,patch,patch,29,"@Axel-Naumann : I think this patch is correct in any case, since the symbols should be hidden. Unfortunately, it is not enough to solve our problem. My test case from #4668 still yields:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. - The first line `LLVM SYMBOLS ARE EXPOSED....` is because the check in core/base/src/TROOT.cxx is not disabled, so this this is irrelevant. In fact, if your patch would work, this check should be removed. - The second error `... inconsistency in registered....` however is the same problem we saw before, with the 2 LLVM instances clashing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:152,safety,test,test,152,"@Axel-Naumann : I think this patch is correct in any case, since the symbols should be hidden. Unfortunately, it is not enough to solve our problem. My test case from #4668 still yields:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. - The first line `LLVM SYMBOLS ARE EXPOSED....` is because the check in core/base/src/TROOT.cxx is not disabled, so this this is irrelevant. In fact, if your patch would work, this check should be removed. - The second error `... inconsistency in registered....` however is the same problem we saw before, with the 2 LLVM instances clashing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:193,safety,Error,Error,193,"@Axel-Naumann : I think this patch is correct in any case, since the symbols should be hidden. Unfortunately, it is not enough to solve our problem. My test case from #4668 still yields:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. - The first line `LLVM SYMBOLS ARE EXPOSED....` is because the check in core/base/src/TROOT.cxx is not disabled, so this this is irrelevant. In fact, if your patch would work, this check should be removed. - The second error `... inconsistency in registered....` however is the same problem we saw before, with the 2 LLVM instances clashing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:390,safety,Error,Error,390,"@Axel-Naumann : I think this patch is correct in any case, since the symbols should be hidden. Unfortunately, it is not enough to solve our problem. My test case from #4668 still yields:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. - The first line `LLVM SYMBOLS ARE EXPOSED....` is because the check in core/base/src/TROOT.cxx is not disabled, so this this is irrelevant. In fact, if your patch would work, this check should be removed. - The second error `... inconsistency in registered....` however is the same problem we saw before, with the 2 LLVM instances clashing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:446,safety,ERROR,ERROR,446,"@Axel-Naumann : I think this patch is correct in any case, since the symbols should be hidden. Unfortunately, it is not enough to solve our problem. My test case from #4668 still yields:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. - The first line `LLVM SYMBOLS ARE EXPOSED....` is because the check in core/base/src/TROOT.cxx is not disabled, so this this is irrelevant. In fact, if your patch would work, this check should be removed. - The second error `... inconsistency in registered....` however is the same problem we saw before, with the 2 LLVM instances clashing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:665,safety,patch,patch,665,"@Axel-Naumann : I think this patch is correct in any case, since the symbols should be hidden. Unfortunately, it is not enough to solve our problem. My test case from #4668 still yields:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. - The first line `LLVM SYMBOLS ARE EXPOSED....` is because the check in core/base/src/TROOT.cxx is not disabled, so this this is irrelevant. In fact, if your patch would work, this check should be removed. - The second error `... inconsistency in registered....` however is the same problem we saw before, with the 2 LLVM instances clashing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:726,safety,error,error,726,"@Axel-Naumann : I think this patch is correct in any case, since the symbols should be hidden. Unfortunately, it is not enough to solve our problem. My test case from #4668 still yields:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. - The first line `LLVM SYMBOLS ARE EXPOSED....` is because the check in core/base/src/TROOT.cxx is not disabled, so this this is irrelevant. In fact, if your patch would work, this check should be removed. - The second error `... inconsistency in registered....` however is the same problem we saw before, with the 2 LLVM instances clashing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:29,security,patch,patch,29,"@Axel-Naumann : I think this patch is correct in any case, since the symbols should be hidden. Unfortunately, it is not enough to solve our problem. My test case from #4668 still yields:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. - The first line `LLVM SYMBOLS ARE EXPOSED....` is because the check in core/base/src/TROOT.cxx is not disabled, so this this is irrelevant. In fact, if your patch would work, this check should be removed. - The second error `... inconsistency in registered....` however is the same problem we saw before, with the 2 LLVM instances clashing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:254,security,EXPOS,EXPOSED,254,"@Axel-Naumann : I think this patch is correct in any case, since the symbols should be hidden. Unfortunately, it is not enough to solve our problem. My test case from #4668 still yields:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. - The first line `LLVM SYMBOLS ARE EXPOSED....` is because the check in core/base/src/TROOT.cxx is not disabled, so this this is irrelevant. In fact, if your patch would work, this check should be removed. - The second error `... inconsistency in registered....` however is the same problem we saw before, with the 2 LLVM instances clashing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:542,security,EXPOS,EXPOSED,542,"@Axel-Naumann : I think this patch is correct in any case, since the symbols should be hidden. Unfortunately, it is not enough to solve our problem. My test case from #4668 still yields:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. - The first line `LLVM SYMBOLS ARE EXPOSED....` is because the check in core/base/src/TROOT.cxx is not disabled, so this this is irrelevant. In fact, if your patch would work, this check should be removed. - The second error `... inconsistency in registered....` however is the same problem we saw before, with the 2 LLVM instances clashing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:665,security,patch,patch,665,"@Axel-Naumann : I think this patch is correct in any case, since the symbols should be hidden. Unfortunately, it is not enough to solve our problem. My test case from #4668 still yields:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. - The first line `LLVM SYMBOLS ARE EXPOSED....` is because the check in core/base/src/TROOT.cxx is not disabled, so this this is irrelevant. In fact, if your patch would work, this check should be removed. - The second error `... inconsistency in registered....` however is the same problem we saw before, with the 2 LLVM instances clashing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:152,testability,test,test,152,"@Axel-Naumann : I think this patch is correct in any case, since the symbols should be hidden. Unfortunately, it is not enough to solve our problem. My test case from #4668 still yields:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. - The first line `LLVM SYMBOLS ARE EXPOSED....` is because the check in core/base/src/TROOT.cxx is not disabled, so this this is irrelevant. In fact, if your patch would work, this check should be removed. - The second error `... inconsistency in registered....` however is the same problem we saw before, with the 2 LLVM instances clashing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:193,usability,Error,Error,193,"@Axel-Naumann : I think this patch is correct in any case, since the symbols should be hidden. Unfortunately, it is not enough to solve our problem. My test case from #4668 still yields:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. - The first line `LLVM SYMBOLS ARE EXPOSED....` is because the check in core/base/src/TROOT.cxx is not disabled, so this this is irrelevant. In fact, if your patch would work, this check should be removed. - The second error `... inconsistency in registered....` however is the same problem we saw before, with the 2 LLVM instances clashing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:378,usability,Command,CommandLine,378,"@Axel-Naumann : I think this patch is correct in any case, since the symbols should be hidden. Unfortunately, it is not enough to solve our problem. My test case from #4668 still yields:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. - The first line `LLVM SYMBOLS ARE EXPOSED....` is because the check in core/base/src/TROOT.cxx is not disabled, so this this is irrelevant. In fact, if your patch would work, this check should be removed. - The second error `... inconsistency in registered....` however is the same problem we saw before, with the 2 LLVM instances clashing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:390,usability,Error,Error,390,"@Axel-Naumann : I think this patch is correct in any case, since the symbols should be hidden. Unfortunately, it is not enough to solve our problem. My test case from #4668 still yields:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. - The first line `LLVM SYMBOLS ARE EXPOSED....` is because the check in core/base/src/TROOT.cxx is not disabled, so this this is irrelevant. In fact, if your patch would work, this check should be removed. - The second error `... inconsistency in registered....` however is the same problem we saw before, with the 2 LLVM instances clashing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:446,usability,ERROR,ERROR,446,"@Axel-Naumann : I think this patch is correct in any case, since the symbols should be hidden. Unfortunately, it is not enough to solve our problem. My test case from #4668 still yields:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. - The first line `LLVM SYMBOLS ARE EXPOSED....` is because the check in core/base/src/TROOT.cxx is not disabled, so this this is irrelevant. In fact, if your patch would work, this check should be removed. - The second error `... inconsistency in registered....` however is the same problem we saw before, with the 2 LLVM instances clashing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:481,usability,Command,CommandLine,481,"@Axel-Naumann : I think this patch is correct in any case, since the symbols should be hidden. Unfortunately, it is not enough to solve our problem. My test case from #4668 still yields:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. - The first line `LLVM SYMBOLS ARE EXPOSED....` is because the check in core/base/src/TROOT.cxx is not disabled, so this this is irrelevant. In fact, if your patch would work, this check should be removed. - The second error `... inconsistency in registered....` however is the same problem we saw before, with the 2 LLVM instances clashing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:726,usability,error,error,726,"@Axel-Naumann : I think this patch is correct in any case, since the symbols should be hidden. Unfortunately, it is not enough to solve our problem. My test case from #4668 still yields:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. - The first line `LLVM SYMBOLS ARE EXPOSED....` is because the check in core/base/src/TROOT.cxx is not disabled, so this this is irrelevant. In fact, if your patch would work, this check should be removed. - The second error `... inconsistency in registered....` however is the same problem we saw before, with the 2 LLVM instances clashing.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:27,availability,error,error,27,"@davidrohr :. > The second error ... inconsistency in registered.... however is the same problem we saw before, with the 2 LLVM instances clashing. Damn. I tried with `LD_PRELOAD`ing libllvm and that worked *with* this PR, and failed *without* this PR. Can you come up with a reproducer for what you see? I'll merge this nonetheless.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:227,deployability,fail,failed,227,"@davidrohr :. > The second error ... inconsistency in registered.... however is the same problem we saw before, with the 2 LLVM instances clashing. Damn. I tried with `LD_PRELOAD`ing libllvm and that worked *with* this PR, and failed *without* this PR. Can you come up with a reproducer for what you see? I'll merge this nonetheless.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:27,performance,error,error,27,"@davidrohr :. > The second error ... inconsistency in registered.... however is the same problem we saw before, with the 2 LLVM instances clashing. Damn. I tried with `LD_PRELOAD`ing libllvm and that worked *with* this PR, and failed *without* this PR. Can you come up with a reproducer for what you see? I'll merge this nonetheless.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:227,reliability,fail,failed,227,"@davidrohr :. > The second error ... inconsistency in registered.... however is the same problem we saw before, with the 2 LLVM instances clashing. Damn. I tried with `LD_PRELOAD`ing libllvm and that worked *with* this PR, and failed *without* this PR. Can you come up with a reproducer for what you see? I'll merge this nonetheless.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:27,safety,error,error,27,"@davidrohr :. > The second error ... inconsistency in registered.... however is the same problem we saw before, with the 2 LLVM instances clashing. Damn. I tried with `LD_PRELOAD`ing libllvm and that worked *with* this PR, and failed *without* this PR. Can you come up with a reproducer for what you see? I'll merge this nonetheless.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:27,usability,error,error,27,"@davidrohr :. > The second error ... inconsistency in registered.... however is the same problem we saw before, with the 2 LLVM instances clashing. Damn. I tried with `LD_PRELOAD`ing libllvm and that worked *with* this PR, and failed *without* this PR. Can you come up with a reproducer for what you see? I'll merge this nonetheless.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:348,availability,error,error,348,"> Can you come up with a reproducer for what you see? @Axel-Naumann : The following simple test case. ```. #include <TROOT.h>. int main(int argc, char** argv) {. gROOT->GetInterpreter();. return 0;. }. ```. compiled via. `c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so`. yields the error for me. I have a system installation of arrow with gandiva. If I remove the libgandiva.so from the command line, it works fine.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:378,deployability,instal,installation,378,"> Can you come up with a reproducer for what you see? @Axel-Naumann : The following simple test case. ```. #include <TROOT.h>. int main(int argc, char** argv) {. gROOT->GetInterpreter();. return 0;. }. ```. compiled via. `c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so`. yields the error for me. I have a system installation of arrow with gandiva. If I remove the libgandiva.so from the command line, it works fine.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:348,performance,error,error,348,"> Can you come up with a reproducer for what you see? @Axel-Naumann : The following simple test case. ```. #include <TROOT.h>. int main(int argc, char** argv) {. gROOT->GetInterpreter();. return 0;. }. ```. compiled via. `c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so`. yields the error for me. I have a system installation of arrow with gandiva. If I remove the libgandiva.so from the command line, it works fine.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:91,safety,test,test,91,"> Can you come up with a reproducer for what you see? @Axel-Naumann : The following simple test case. ```. #include <TROOT.h>. int main(int argc, char** argv) {. gROOT->GetInterpreter();. return 0;. }. ```. compiled via. `c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so`. yields the error for me. I have a system installation of arrow with gandiva. If I remove the libgandiva.so from the command line, it works fine.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:229,safety,test,test,229,"> Can you come up with a reproducer for what you see? @Axel-Naumann : The following simple test case. ```. #include <TROOT.h>. int main(int argc, char** argv) {. gROOT->GetInterpreter();. return 0;. }. ```. compiled via. `c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so`. yields the error for me. I have a system installation of arrow with gandiva. If I remove the libgandiva.so from the command line, it works fine.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:301,safety,test,test,301,"> Can you come up with a reproducer for what you see? @Axel-Naumann : The following simple test case. ```. #include <TROOT.h>. int main(int argc, char** argv) {. gROOT->GetInterpreter();. return 0;. }. ```. compiled via. `c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so`. yields the error for me. I have a system installation of arrow with gandiva. If I remove the libgandiva.so from the command line, it works fine.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:348,safety,error,error,348,"> Can you come up with a reproducer for what you see? @Axel-Naumann : The following simple test case. ```. #include <TROOT.h>. int main(int argc, char** argv) {. gROOT->GetInterpreter();. return 0;. }. ```. compiled via. `c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so`. yields the error for me. I have a system installation of arrow with gandiva. If I remove the libgandiva.so from the command line, it works fine.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:84,testability,simpl,simple,84,"> Can you come up with a reproducer for what you see? @Axel-Naumann : The following simple test case. ```. #include <TROOT.h>. int main(int argc, char** argv) {. gROOT->GetInterpreter();. return 0;. }. ```. compiled via. `c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so`. yields the error for me. I have a system installation of arrow with gandiva. If I remove the libgandiva.so from the command line, it works fine.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:91,testability,test,test,91,"> Can you come up with a reproducer for what you see? @Axel-Naumann : The following simple test case. ```. #include <TROOT.h>. int main(int argc, char** argv) {. gROOT->GetInterpreter();. return 0;. }. ```. compiled via. `c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so`. yields the error for me. I have a system installation of arrow with gandiva. If I remove the libgandiva.so from the command line, it works fine.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:229,testability,test,test,229,"> Can you come up with a reproducer for what you see? @Axel-Naumann : The following simple test case. ```. #include <TROOT.h>. int main(int argc, char** argv) {. gROOT->GetInterpreter();. return 0;. }. ```. compiled via. `c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so`. yields the error for me. I have a system installation of arrow with gandiva. If I remove the libgandiva.so from the command line, it works fine.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:301,testability,test,test,301,"> Can you come up with a reproducer for what you see? @Axel-Naumann : The following simple test case. ```. #include <TROOT.h>. int main(int argc, char** argv) {. gROOT->GetInterpreter();. return 0;. }. ```. compiled via. `c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so`. yields the error for me. I have a system installation of arrow with gandiva. If I remove the libgandiva.so from the command line, it works fine.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:84,usability,simpl,simple,84,"> Can you come up with a reproducer for what you see? @Axel-Naumann : The following simple test case. ```. #include <TROOT.h>. int main(int argc, char** argv) {. gROOT->GetInterpreter();. return 0;. }. ```. compiled via. `c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so`. yields the error for me. I have a system installation of arrow with gandiva. If I remove the libgandiva.so from the command line, it works fine.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:348,usability,error,error,348,"> Can you come up with a reproducer for what you see? @Axel-Naumann : The following simple test case. ```. #include <TROOT.h>. int main(int argc, char** argv) {. gROOT->GetInterpreter();. return 0;. }. ```. compiled via. `c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so`. yields the error for me. I have a system installation of arrow with gandiva. If I remove the libgandiva.so from the command line, it works fine.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:453,usability,command,command,453,"> Can you come up with a reproducer for what you see? @Axel-Naumann : The following simple test case. ```. #include <TROOT.h>. int main(int argc, char** argv) {. gROOT->GetInterpreter();. return 0;. }. ```. compiled via. `c++ -o test -O0 -ggdb `root-config --libs` -I`root-config --incdir` -std=c++17 test.cpp /usr/lib64/libgandiva.so`. yields the error for me. I have a system installation of arrow with gandiva. If I remove the libgandiva.so from the command line, it works fine.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:81,deployability,fail,failed,81,"> Damn. I tried with `LD_PRELOAD`ing libllvm and that worked _with_ this PR, and failed _without_ this PR. Damn, that is weird. Should be the same as linking to libgandiva. I'll try that on my setup to double-check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:81,reliability,fail,failed,81,"> Damn. I tried with `LD_PRELOAD`ing libllvm and that worked _with_ this PR, and failed _without_ this PR. Damn, that is weird. Should be the same as linking to libgandiva. I'll try that on my setup to double-check.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:172,availability,error,error,172,"@Axel-Naumann : I have rebuilt ROOT from scratch and attempted my above test case with. ```. LD_PRELOAD=/usr/lib64/libgandiva.so ./test. ```. which still gives me the same error:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. Perhaps preloading individual LLVM libraries works, but with gandiva it certainly doesn't. So unfortunately this patch is insufficient to solve my problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:185,availability,Error,Error,185,"@Axel-Naumann : I have rebuilt ROOT from scratch and attempted my above test case with. ```. LD_PRELOAD=/usr/lib64/libgandiva.so ./test. ```. which still gives me the same error:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. Perhaps preloading individual LLVM libraries works, but with gandiva it certainly doesn't. So unfortunately this patch is insufficient to solve my problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:382,availability,Error,Error,382,"@Axel-Naumann : I have rebuilt ROOT from scratch and attempted my above test case with. ```. LD_PRELOAD=/usr/lib64/libgandiva.so ./test. ```. which still gives me the same error:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. Perhaps preloading individual LLVM libraries works, but with gandiva it certainly doesn't. So unfortunately this patch is insufficient to solve my problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:438,availability,ERROR,ERROR,438,"@Axel-Naumann : I have rebuilt ROOT from scratch and attempted my above test case with. ```. LD_PRELOAD=/usr/lib64/libgandiva.so ./test. ```. which still gives me the same error:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. Perhaps preloading individual LLVM libraries works, but with gandiva it certainly doesn't. So unfortunately this patch is insufficient to solve my problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:397,deployability,version,version,397,"@Axel-Naumann : I have rebuilt ROOT from scratch and attempted my above test case with. ```. LD_PRELOAD=/usr/lib64/libgandiva.so ./test. ```. which still gives me the same error:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. Perhaps preloading individual LLVM libraries works, but with gandiva it certainly doesn't. So unfortunately this patch is insufficient to solve my problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:612,deployability,patch,patch,612,"@Axel-Naumann : I have rebuilt ROOT from scratch and attempted my above test case with. ```. LD_PRELOAD=/usr/lib64/libgandiva.so ./test. ```. which still gives me the same error:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. Perhaps preloading individual LLVM libraries works, but with gandiva it certainly doesn't. So unfortunately this patch is insufficient to solve my problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:397,integrability,version,version,397,"@Axel-Naumann : I have rebuilt ROOT from scratch and attempted my above test case with. ```. LD_PRELOAD=/usr/lib64/libgandiva.so ./test. ```. which still gives me the same error:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. Perhaps preloading individual LLVM libraries works, but with gandiva it certainly doesn't. So unfortunately this patch is insufficient to solve my problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:397,modifiability,version,version,397,"@Axel-Naumann : I have rebuilt ROOT from scratch and attempted my above test case with. ```. LD_PRELOAD=/usr/lib64/libgandiva.so ./test. ```. which still gives me the same error:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. Perhaps preloading individual LLVM libraries works, but with gandiva it certainly doesn't. So unfortunately this patch is insufficient to solve my problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:172,performance,error,error,172,"@Axel-Naumann : I have rebuilt ROOT from scratch and attempted my above test case with. ```. LD_PRELOAD=/usr/lib64/libgandiva.so ./test. ```. which still gives me the same error:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. Perhaps preloading individual LLVM libraries works, but with gandiva it certainly doesn't. So unfortunately this patch is insufficient to solve my problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:185,performance,Error,Error,185,"@Axel-Naumann : I have rebuilt ROOT from scratch and attempted my above test case with. ```. LD_PRELOAD=/usr/lib64/libgandiva.so ./test. ```. which still gives me the same error:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. Perhaps preloading individual LLVM libraries works, but with gandiva it certainly doesn't. So unfortunately this patch is insufficient to solve my problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:382,performance,Error,Error,382,"@Axel-Naumann : I have rebuilt ROOT from scratch and attempted my above test case with. ```. LD_PRELOAD=/usr/lib64/libgandiva.so ./test. ```. which still gives me the same error:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. Perhaps preloading individual LLVM libraries works, but with gandiva it certainly doesn't. So unfortunately this patch is insufficient to solve my problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:438,performance,ERROR,ERROR,438,"@Axel-Naumann : I have rebuilt ROOT from scratch and attempted my above test case with. ```. LD_PRELOAD=/usr/lib64/libgandiva.so ./test. ```. which still gives me the same error:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. Perhaps preloading individual LLVM libraries works, but with gandiva it certainly doesn't. So unfortunately this patch is insufficient to solve my problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:581,reliability,doe,doesn,581,"@Axel-Naumann : I have rebuilt ROOT from scratch and attempted my above test case with. ```. LD_PRELOAD=/usr/lib64/libgandiva.so ./test. ```. which still gives me the same error:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. Perhaps preloading individual LLVM libraries works, but with gandiva it certainly doesn't. So unfortunately this patch is insufficient to solve my problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:72,safety,test,test,72,"@Axel-Naumann : I have rebuilt ROOT from scratch and attempted my above test case with. ```. LD_PRELOAD=/usr/lib64/libgandiva.so ./test. ```. which still gives me the same error:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. Perhaps preloading individual LLVM libraries works, but with gandiva it certainly doesn't. So unfortunately this patch is insufficient to solve my problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:131,safety,test,test,131,"@Axel-Naumann : I have rebuilt ROOT from scratch and attempted my above test case with. ```. LD_PRELOAD=/usr/lib64/libgandiva.so ./test. ```. which still gives me the same error:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. Perhaps preloading individual LLVM libraries works, but with gandiva it certainly doesn't. So unfortunately this patch is insufficient to solve my problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:172,safety,error,error,172,"@Axel-Naumann : I have rebuilt ROOT from scratch and attempted my above test case with. ```. LD_PRELOAD=/usr/lib64/libgandiva.so ./test. ```. which still gives me the same error:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. Perhaps preloading individual LLVM libraries works, but with gandiva it certainly doesn't. So unfortunately this patch is insufficient to solve my problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:185,safety,Error,Error,185,"@Axel-Naumann : I have rebuilt ROOT from scratch and attempted my above test case with. ```. LD_PRELOAD=/usr/lib64/libgandiva.so ./test. ```. which still gives me the same error:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. Perhaps preloading individual LLVM libraries works, but with gandiva it certainly doesn't. So unfortunately this patch is insufficient to solve my problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:382,safety,Error,Error,382,"@Axel-Naumann : I have rebuilt ROOT from scratch and attempted my above test case with. ```. LD_PRELOAD=/usr/lib64/libgandiva.so ./test. ```. which still gives me the same error:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. Perhaps preloading individual LLVM libraries works, but with gandiva it certainly doesn't. So unfortunately this patch is insufficient to solve my problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:438,safety,ERROR,ERROR,438,"@Axel-Naumann : I have rebuilt ROOT from scratch and attempted my above test case with. ```. LD_PRELOAD=/usr/lib64/libgandiva.so ./test. ```. which still gives me the same error:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. Perhaps preloading individual LLVM libraries works, but with gandiva it certainly doesn't. So unfortunately this patch is insufficient to solve my problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:612,safety,patch,patch,612,"@Axel-Naumann : I have rebuilt ROOT from scratch and attempted my above test case with. ```. LD_PRELOAD=/usr/lib64/libgandiva.so ./test. ```. which still gives me the same error:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. Perhaps preloading individual LLVM libraries works, but with gandiva it certainly doesn't. So unfortunately this patch is insufficient to solve my problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:246,security,EXPOS,EXPOSED,246,"@Axel-Naumann : I have rebuilt ROOT from scratch and attempted my above test case with. ```. LD_PRELOAD=/usr/lib64/libgandiva.so ./test. ```. which still gives me the same error:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. Perhaps preloading individual LLVM libraries works, but with gandiva it certainly doesn't. So unfortunately this patch is insufficient to solve my problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:612,security,patch,patch,612,"@Axel-Naumann : I have rebuilt ROOT from scratch and attempted my above test case with. ```. LD_PRELOAD=/usr/lib64/libgandiva.so ./test. ```. which still gives me the same error:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. Perhaps preloading individual LLVM libraries works, but with gandiva it certainly doesn't. So unfortunately this patch is insufficient to solve my problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:72,testability,test,test,72,"@Axel-Naumann : I have rebuilt ROOT from scratch and attempted my above test case with. ```. LD_PRELOAD=/usr/lib64/libgandiva.so ./test. ```. which still gives me the same error:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. Perhaps preloading individual LLVM libraries works, but with gandiva it certainly doesn't. So unfortunately this patch is insufficient to solve my problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:131,testability,test,test,131,"@Axel-Naumann : I have rebuilt ROOT from scratch and attempted my above test case with. ```. LD_PRELOAD=/usr/lib64/libgandiva.so ./test. ```. which still gives me the same error:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. Perhaps preloading individual LLVM libraries works, but with gandiva it certainly doesn't. So unfortunately this patch is insufficient to solve my problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:172,usability,error,error,172,"@Axel-Naumann : I have rebuilt ROOT from scratch and attempted my above test case with. ```. LD_PRELOAD=/usr/lib64/libgandiva.so ./test. ```. which still gives me the same error:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. Perhaps preloading individual LLVM libraries works, but with gandiva it certainly doesn't. So unfortunately this patch is insufficient to solve my problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:185,usability,Error,Error,185,"@Axel-Naumann : I have rebuilt ROOT from scratch and attempted my above test case with. ```. LD_PRELOAD=/usr/lib64/libgandiva.so ./test. ```. which still gives me the same error:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. Perhaps preloading individual LLVM libraries works, but with gandiva it certainly doesn't. So unfortunately this patch is insufficient to solve my problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:370,usability,Command,CommandLine,370,"@Axel-Naumann : I have rebuilt ROOT from scratch and attempted my above test case with. ```. LD_PRELOAD=/usr/lib64/libgandiva.so ./test. ```. which still gives me the same error:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. Perhaps preloading individual LLVM libraries works, but with gandiva it certainly doesn't. So unfortunately this patch is insufficient to solve my problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:382,usability,Error,Error,382,"@Axel-Naumann : I have rebuilt ROOT from scratch and attempted my above test case with. ```. LD_PRELOAD=/usr/lib64/libgandiva.so ./test. ```. which still gives me the same error:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. Perhaps preloading individual LLVM libraries works, but with gandiva it certainly doesn't. So unfortunately this patch is insufficient to solve my problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:438,usability,ERROR,ERROR,438,"@Axel-Naumann : I have rebuilt ROOT from scratch and attempted my above test case with. ```. LD_PRELOAD=/usr/lib64/libgandiva.so ./test. ```. which still gives me the same error:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. Perhaps preloading individual LLVM libraries works, but with gandiva it certainly doesn't. So unfortunately this patch is insufficient to solve my problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:473,usability,Command,CommandLine,473,"@Axel-Naumann : I have rebuilt ROOT from scratch and attempted my above test case with. ```. LD_PRELOAD=/usr/lib64/libgandiva.so ./test. ```. which still gives me the same error:. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! : CommandLine Error: Option 'version' registered more than once! LLVM ERROR: inconsistency in registered CommandLine options. ```. Perhaps preloading individual LLVM libraries works, but with gandiva it certainly doesn't. So unfortunately this patch is insufficient to solve my problem.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:63,security,hack,hack,63,"@Axel-Naumann : Did you have a chance to attempt the namespace hack we discussed, perhaps it has a better chance of solving the issue.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:278,availability,Error,Error,278,"@Axel-Naumann : I have to admit I have been stupid and my last posts have been wrong. I did built root without builtin_llvm, so this could not have worked by designed. I have rebuilt now with builtin_llvm and with your patch, and now I am only getting the warning message. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! ```. But this is clear, since ROOT just checks for the presence of the LLVM symbols. I am now rebuilding the ALICE software with this ROOT and checking whether the segfaults are gone.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:219,deployability,patch,patch,219,"@Axel-Naumann : I have to admit I have been stupid and my last posts have been wrong. I did built root without builtin_llvm, so this could not have worked by designed. I have rebuilt now with builtin_llvm and with your patch, and now I am only getting the warning message. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! ```. But this is clear, since ROOT just checks for the presence of the LLVM symbols. I am now rebuilding the ALICE software with this ROOT and checking whether the segfaults are gone.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:264,integrability,messag,message,264,"@Axel-Naumann : I have to admit I have been stupid and my last posts have been wrong. I did built root without builtin_llvm, so this could not have worked by designed. I have rebuilt now with builtin_llvm and with your patch, and now I am only getting the warning message. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! ```. But this is clear, since ROOT just checks for the presence of the LLVM symbols. I am now rebuilding the ALICE software with this ROOT and checking whether the segfaults are gone.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:264,interoperability,messag,message,264,"@Axel-Naumann : I have to admit I have been stupid and my last posts have been wrong. I did built root without builtin_llvm, so this could not have worked by designed. I have rebuilt now with builtin_llvm and with your patch, and now I am only getting the warning message. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! ```. But this is clear, since ROOT just checks for the presence of the LLVM symbols. I am now rebuilding the ALICE software with this ROOT and checking whether the segfaults are gone.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:278,performance,Error,Error,278,"@Axel-Naumann : I have to admit I have been stupid and my last posts have been wrong. I did built root without builtin_llvm, so this could not have worked by designed. I have rebuilt now with builtin_llvm and with your patch, and now I am only getting the warning message. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! ```. But this is clear, since ROOT just checks for the presence of the LLVM symbols. I am now rebuilding the ALICE software with this ROOT and checking whether the segfaults are gone.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:219,safety,patch,patch,219,"@Axel-Naumann : I have to admit I have been stupid and my last posts have been wrong. I did built root without builtin_llvm, so this could not have worked by designed. I have rebuilt now with builtin_llvm and with your patch, and now I am only getting the warning message. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! ```. But this is clear, since ROOT just checks for the presence of the LLVM symbols. I am now rebuilding the ALICE software with this ROOT and checking whether the segfaults are gone.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:278,safety,Error,Error,278,"@Axel-Naumann : I have to admit I have been stupid and my last posts have been wrong. I did built root without builtin_llvm, so this could not have worked by designed. I have rebuilt now with builtin_llvm and with your patch, and now I am only getting the warning message. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! ```. But this is clear, since ROOT just checks for the presence of the LLVM symbols. I am now rebuilding the ALICE software with this ROOT and checking whether the segfaults are gone.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:219,security,patch,patch,219,"@Axel-Naumann : I have to admit I have been stupid and my last posts have been wrong. I did built root without builtin_llvm, so this could not have worked by designed. I have rebuilt now with builtin_llvm and with your patch, and now I am only getting the warning message. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! ```. But this is clear, since ROOT just checks for the presence of the LLVM symbols. I am now rebuilding the ALICE software with this ROOT and checking whether the segfaults are gone.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:339,security,EXPOS,EXPOSED,339,"@Axel-Naumann : I have to admit I have been stupid and my last posts have been wrong. I did built root without builtin_llvm, so this could not have worked by designed. I have rebuilt now with builtin_llvm and with your patch, and now I am only getting the warning message. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! ```. But this is clear, since ROOT just checks for the presence of the LLVM symbols. I am now rebuilding the ALICE software with this ROOT and checking whether the segfaults are gone.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:278,usability,Error,Error,278,"@Axel-Naumann : I have to admit I have been stupid and my last posts have been wrong. I did built root without builtin_llvm, so this could not have worked by designed. I have rebuilt now with builtin_llvm and with your patch, and now I am only getting the warning message. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! ```. But this is clear, since ROOT just checks for the presence of the LLVM symbols. I am now rebuilding the ALICE software with this ROOT and checking whether the segfaults are gone.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:478,usability,clear,clear,478,"@Axel-Naumann : I have to admit I have been stupid and my last posts have been wrong. I did built root without builtin_llvm, so this could not have worked by designed. I have rebuilt now with builtin_llvm and with your patch, and now I am only getting the warning message. ```. Error in <UnknownClass::InitInterpreter()>: LLVM SYMBOLS ARE EXPOSED TO CLING! This will cause problems; please hide them or dlopen() them after the call to TROOT::InitInterpreter()! ```. But this is clear, since ROOT just checks for the presence of the LLVM symbols. I am now rebuilding the ALICE software with this ROOT and checking whether the segfaults are gone.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:21,deployability,patch,patch,21,"@Axel-Naumann : This patch is fully working for us. Thx a lot and sorry for the false information before. Could you cherry-pick this to 6.18.00-patches? In addition, the warning in https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#2052 should be disabled, when ROOT is compiled with -DBUILTIN_LLVM. Otherwise it is misleading.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:144,deployability,patch,patches,144,"@Axel-Naumann : This patch is fully working for us. Thx a lot and sorry for the false information before. Could you cherry-pick this to 6.18.00-patches? In addition, the warning in https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#2052 should be disabled, when ROOT is compiled with -DBUILTIN_LLVM. Otherwise it is misleading.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:230,energy efficiency,core,core,230,"@Axel-Naumann : This patch is fully working for us. Thx a lot and sorry for the false information before. Could you cherry-pick this to 6.18.00-patches? In addition, the warning in https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#2052 should be disabled, when ROOT is compiled with -DBUILTIN_LLVM. Otherwise it is misleading.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:21,safety,patch,patch,21,"@Axel-Naumann : This patch is fully working for us. Thx a lot and sorry for the false information before. Could you cherry-pick this to 6.18.00-patches? In addition, the warning in https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#2052 should be disabled, when ROOT is compiled with -DBUILTIN_LLVM. Otherwise it is misleading.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:144,safety,patch,patches,144,"@Axel-Naumann : This patch is fully working for us. Thx a lot and sorry for the false information before. Could you cherry-pick this to 6.18.00-patches? In addition, the warning in https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#2052 should be disabled, when ROOT is compiled with -DBUILTIN_LLVM. Otherwise it is misleading.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:21,security,patch,patch,21,"@Axel-Naumann : This patch is fully working for us. Thx a lot and sorry for the false information before. Could you cherry-pick this to 6.18.00-patches? In addition, the warning in https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#2052 should be disabled, when ROOT is compiled with -DBUILTIN_LLVM. Otherwise it is misleading.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4689:144,security,patch,patches,144,"@Axel-Naumann : This patch is fully working for us. Thx a lot and sorry for the false information before. Could you cherry-pick this to 6.18.00-patches? In addition, the warning in https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#2052 should be disabled, when ROOT is compiled with -DBUILTIN_LLVM. Otherwise it is misleading.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4689
https://github.com/root-project/root/pull/4690:76,availability,slo,slow,76,"(Btw, sorry for the CI noise, my current technique for local ROOT builds is slow and leads to an unsustainable infinitely growing Docker image so I'm currently investigating a better solution. Once that's up and running, I'll be able to run local tests more easily.)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4690
https://github.com/root-project/root/pull/4690:66,deployability,build,builds,66,"(Btw, sorry for the CI noise, my current technique for local ROOT builds is slow and leads to an unsustainable infinitely growing Docker image so I'm currently investigating a better solution. Once that's up and running, I'll be able to run local tests more easily.)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4690
https://github.com/root-project/root/pull/4690:33,energy efficiency,current,current,33,"(Btw, sorry for the CI noise, my current technique for local ROOT builds is slow and leads to an unsustainable infinitely growing Docker image so I'm currently investigating a better solution. Once that's up and running, I'll be able to run local tests more easily.)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4690
https://github.com/root-project/root/pull/4690:150,energy efficiency,current,currently,150,"(Btw, sorry for the CI noise, my current technique for local ROOT builds is slow and leads to an unsustainable infinitely growing Docker image so I'm currently investigating a better solution. Once that's up and running, I'll be able to run local tests more easily.)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4690
https://github.com/root-project/root/pull/4690:76,reliability,slo,slow,76,"(Btw, sorry for the CI noise, my current technique for local ROOT builds is slow and leads to an unsustainable infinitely growing Docker image so I'm currently investigating a better solution. Once that's up and running, I'll be able to run local tests more easily.)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4690
https://github.com/root-project/root/pull/4690:247,safety,test,tests,247,"(Btw, sorry for the CI noise, my current technique for local ROOT builds is slow and leads to an unsustainable infinitely growing Docker image so I'm currently investigating a better solution. Once that's up and running, I'll be able to run local tests more easily.)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4690
https://github.com/root-project/root/pull/4690:247,testability,test,tests,247,"(Btw, sorry for the CI noise, my current technique for local ROOT builds is slow and leads to an unsustainable infinitely growing Docker image so I'm currently investigating a better solution. Once that's up and running, I'll be able to run local tests more easily.)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4690
https://github.com/root-project/root/pull/4691:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4691
https://github.com/root-project/root/pull/4691:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4691
https://github.com/root-project/root/pull/4693:11,deployability,build,build,11,@phsft-bot build with flags -Dpyroot_experimental=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4693
https://github.com/root-project/root/pull/4695:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4695
https://github.com/root-project/root/pull/4696:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4696
https://github.com/root-project/root/pull/4696:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4696
https://github.com/root-project/root/pull/4698:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4698
https://github.com/root-project/root/pull/4698:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4698
https://github.com/root-project/root/pull/4698:78,safety,valid,valid,78,"I'm sorry, there was another place where I was using C-style programming only valid under g++ and not c++. Now I also fixed this one.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4698
https://github.com/root-project/root/pull/4698:114,availability,error,error,114,"Actually I got to admit I have no idea why there are tests failing on ROOT-ubuntu16/nortcxxmod. Acccording to the error message this seems to be related to the function TGraph::AllocateArrays which I did not touch at all, so this might be an unrelated issue.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4698
https://github.com/root-project/root/pull/4698:59,deployability,fail,failing,59,"Actually I got to admit I have no idea why there are tests failing on ROOT-ubuntu16/nortcxxmod. Acccording to the error message this seems to be related to the function TGraph::AllocateArrays which I did not touch at all, so this might be an unrelated issue.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4698
https://github.com/root-project/root/pull/4698:177,energy efficiency,Alloc,AllocateArrays,177,"Actually I got to admit I have no idea why there are tests failing on ROOT-ubuntu16/nortcxxmod. Acccording to the error message this seems to be related to the function TGraph::AllocateArrays which I did not touch at all, so this might be an unrelated issue.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4698
https://github.com/root-project/root/pull/4698:120,integrability,messag,message,120,"Actually I got to admit I have no idea why there are tests failing on ROOT-ubuntu16/nortcxxmod. Acccording to the error message this seems to be related to the function TGraph::AllocateArrays which I did not touch at all, so this might be an unrelated issue.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4698
https://github.com/root-project/root/pull/4698:120,interoperability,messag,message,120,"Actually I got to admit I have no idea why there are tests failing on ROOT-ubuntu16/nortcxxmod. Acccording to the error message this seems to be related to the function TGraph::AllocateArrays which I did not touch at all, so this might be an unrelated issue.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4698
https://github.com/root-project/root/pull/4698:114,performance,error,error,114,"Actually I got to admit I have no idea why there are tests failing on ROOT-ubuntu16/nortcxxmod. Acccording to the error message this seems to be related to the function TGraph::AllocateArrays which I did not touch at all, so this might be an unrelated issue.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4698
https://github.com/root-project/root/pull/4698:59,reliability,fail,failing,59,"Actually I got to admit I have no idea why there are tests failing on ROOT-ubuntu16/nortcxxmod. Acccording to the error message this seems to be related to the function TGraph::AllocateArrays which I did not touch at all, so this might be an unrelated issue.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4698
https://github.com/root-project/root/pull/4698:53,safety,test,tests,53,"Actually I got to admit I have no idea why there are tests failing on ROOT-ubuntu16/nortcxxmod. Acccording to the error message this seems to be related to the function TGraph::AllocateArrays which I did not touch at all, so this might be an unrelated issue.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4698
https://github.com/root-project/root/pull/4698:114,safety,error,error,114,"Actually I got to admit I have no idea why there are tests failing on ROOT-ubuntu16/nortcxxmod. Acccording to the error message this seems to be related to the function TGraph::AllocateArrays which I did not touch at all, so this might be an unrelated issue.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4698
https://github.com/root-project/root/pull/4698:53,testability,test,tests,53,"Actually I got to admit I have no idea why there are tests failing on ROOT-ubuntu16/nortcxxmod. Acccording to the error message this seems to be related to the function TGraph::AllocateArrays which I did not touch at all, so this might be an unrelated issue.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4698
https://github.com/root-project/root/pull/4698:114,usability,error,error,114,"Actually I got to admit I have no idea why there are tests failing on ROOT-ubuntu16/nortcxxmod. Acccording to the error message this seems to be related to the function TGraph::AllocateArrays which I did not touch at all, so this might be an unrelated issue.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4698
https://github.com/root-project/root/pull/4698:38,deployability,build,build,38,Could an admin please trigger another build?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4698
https://github.com/root-project/root/pull/4698:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4698
https://github.com/root-project/root/pull/4698:4,availability,failur,failure,4,The failure is probably due to https://github.com/root-project/root/pull/4699,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4698
https://github.com/root-project/root/pull/4698:4,deployability,fail,failure,4,The failure is probably due to https://github.com/root-project/root/pull/4699,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4698
https://github.com/root-project/root/pull/4698:4,performance,failur,failure,4,The failure is probably due to https://github.com/root-project/root/pull/4699,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4698
https://github.com/root-project/root/pull/4698:4,reliability,fail,failure,4,The failure is probably due to https://github.com/root-project/root/pull/4699,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4698
https://github.com/root-project/root/pull/4698:79,availability,error,error,79,"Ok, everything seems fine now. The two failed builds seem to be related to the error @vgvassilev mentioned. I will keep watching whether further problems occur.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4698
https://github.com/root-project/root/pull/4698:39,deployability,fail,failed,39,"Ok, everything seems fine now. The two failed builds seem to be related to the error @vgvassilev mentioned. I will keep watching whether further problems occur.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4698
https://github.com/root-project/root/pull/4698:46,deployability,build,builds,46,"Ok, everything seems fine now. The two failed builds seem to be related to the error @vgvassilev mentioned. I will keep watching whether further problems occur.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4698
https://github.com/root-project/root/pull/4698:79,performance,error,error,79,"Ok, everything seems fine now. The two failed builds seem to be related to the error @vgvassilev mentioned. I will keep watching whether further problems occur.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4698
https://github.com/root-project/root/pull/4698:39,reliability,fail,failed,39,"Ok, everything seems fine now. The two failed builds seem to be related to the error @vgvassilev mentioned. I will keep watching whether further problems occur.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4698
https://github.com/root-project/root/pull/4698:79,safety,error,error,79,"Ok, everything seems fine now. The two failed builds seem to be related to the error @vgvassilev mentioned. I will keep watching whether further problems occur.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4698
https://github.com/root-project/root/pull/4698:79,usability,error,error,79,"Ok, everything seems fine now. The two failed builds seem to be related to the error @vgvassilev mentioned. I will keep watching whether further problems occur.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4698
https://github.com/root-project/root/pull/4699:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4699
https://github.com/root-project/root/pull/4700:11,deployability,build,build,11,@phsft-bot build with-flags -Dpyroot_experimental=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4700
https://github.com/root-project/root/pull/4700:11,deployability,build,build,11,@phsft-bot build with flags -Dpyroot_experimental=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4700
https://github.com/root-project/root/pull/4701:26,deployability,instal,install,26,"@amadio . I did not found install() command for ""ui5"" directory. . Actually, most easy way to use in the install command ""ui5"" path from build directory.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4701
https://github.com/root-project/root/pull/4701:105,deployability,instal,install,105,"@amadio . I did not found install() command for ""ui5"" directory. . Actually, most easy way to use in the install command ""ui5"" path from build directory.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4701
https://github.com/root-project/root/pull/4701:137,deployability,build,build,137,"@amadio . I did not found install() command for ""ui5"" directory. . Actually, most easy way to use in the install command ""ui5"" path from build directory.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4701
https://github.com/root-project/root/pull/4701:36,usability,command,command,36,"@amadio . I did not found install() command for ""ui5"" directory. . Actually, most easy way to use in the install command ""ui5"" path from build directory.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4701
https://github.com/root-project/root/pull/4701:113,usability,command,command,113,"@amadio . I did not found install() command for ""ui5"" directory. . Actually, most easy way to use in the install command ""ui5"" path from build directory.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4701
https://github.com/root-project/root/pull/4702:261,energy efficiency,core,core,261,This hasn't fixed [ROOT-10472](https://sft.its.cern.ch/jira/browse/ROOT-10472) but it did make me notice that `-Dbuiltin_clang=OFF` triggers these two for linking cling itself:. https://github.com/root-project/root/blob/407dd686240427022bcdac17fc49e679dce64030/core/rootcling_stage1/CMakeLists.txt#L21-L31. https://github.com/root-project/root/blob/f7bcad0c573153d94f2a3f3577a70df553a18c77/core/metacling/src/CMakeLists.txt#L68-L78,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4702
https://github.com/root-project/root/pull/4702:390,energy efficiency,core,core,390,This hasn't fixed [ROOT-10472](https://sft.its.cern.ch/jira/browse/ROOT-10472) but it did make me notice that `-Dbuiltin_clang=OFF` triggers these two for linking cling itself:. https://github.com/root-project/root/blob/407dd686240427022bcdac17fc49e679dce64030/core/rootcling_stage1/CMakeLists.txt#L21-L31. https://github.com/root-project/root/blob/f7bcad0c573153d94f2a3f3577a70df553a18c77/core/metacling/src/CMakeLists.txt#L68-L78,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4702
https://github.com/root-project/root/pull/4702:30,reliability,doe,does,30,@chrisburr please let us know does it work for you or just open new PR :),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4702
https://github.com/root-project/root/pull/4706:56,safety,review,reviewer,56,@vgvassilev Tagging you since I am unable to add you as reviewer.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4706
https://github.com/root-project/root/pull/4706:56,testability,review,reviewer,56,@vgvassilev Tagging you since I am unable to add you as reviewer.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4706
https://github.com/root-project/root/pull/4707:235,deployability,log,log,235,"@HadrienG2 Thank you very much for the very valuable contributions. A small improvement; in general we try to avoid ""merge commit"" whenever possible. (i.e. here the 2 commit should probably have been squashed before merging and/or the log of the 2nd commit be updated to reflect its purpose).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4707
https://github.com/root-project/root/pull/4707:260,deployability,updat,updated,260,"@HadrienG2 Thank you very much for the very valuable contributions. A small improvement; in general we try to avoid ""merge commit"" whenever possible. (i.e. here the 2 commit should probably have been squashed before merging and/or the log of the 2nd commit be updated to reflect its purpose).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4707
https://github.com/root-project/root/pull/4707:110,safety,avoid,avoid,110,"@HadrienG2 Thank you very much for the very valuable contributions. A small improvement; in general we try to avoid ""merge commit"" whenever possible. (i.e. here the 2 commit should probably have been squashed before merging and/or the log of the 2nd commit be updated to reflect its purpose).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4707
https://github.com/root-project/root/pull/4707:235,safety,log,log,235,"@HadrienG2 Thank you very much for the very valuable contributions. A small improvement; in general we try to avoid ""merge commit"" whenever possible. (i.e. here the 2 commit should probably have been squashed before merging and/or the log of the 2nd commit be updated to reflect its purpose).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4707
https://github.com/root-project/root/pull/4707:260,safety,updat,updated,260,"@HadrienG2 Thank you very much for the very valuable contributions. A small improvement; in general we try to avoid ""merge commit"" whenever possible. (i.e. here the 2 commit should probably have been squashed before merging and/or the log of the 2nd commit be updated to reflect its purpose).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4707
https://github.com/root-project/root/pull/4707:235,security,log,log,235,"@HadrienG2 Thank you very much for the very valuable contributions. A small improvement; in general we try to avoid ""merge commit"" whenever possible. (i.e. here the 2 commit should probably have been squashed before merging and/or the log of the 2nd commit be updated to reflect its purpose).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4707
https://github.com/root-project/root/pull/4707:260,security,updat,updated,260,"@HadrienG2 Thank you very much for the very valuable contributions. A small improvement; in general we try to avoid ""merge commit"" whenever possible. (i.e. here the 2 commit should probably have been squashed before merging and/or the log of the 2nd commit be updated to reflect its purpose).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4707
https://github.com/root-project/root/pull/4707:235,testability,log,log,235,"@HadrienG2 Thank you very much for the very valuable contributions. A small improvement; in general we try to avoid ""merge commit"" whenever possible. (i.e. here the 2 commit should probably have been squashed before merging and/or the log of the 2nd commit be updated to reflect its purpose).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4707
https://github.com/root-project/root/pull/4707:132,performance,time,time,132,"Ah, sorry, I was used to ""Squash and merge"" being the default-selected choice on GitHub and clicked without reading carefully. This time it wasn't, obviously, most likely because I did the merge from a different computer.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4707
https://github.com/root-project/root/pull/4710:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4710
https://github.com/root-project/root/pull/4710:11,deployability,build,build,11,@phsft-bot build just on windows10/cxx14,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4710
https://github.com/root-project/root/pull/4712:11,deployability,build,build,11,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4712
https://github.com/root-project/root/pull/4715:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4715
https://github.com/root-project/root/pull/4715:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4715
https://github.com/root-project/root/pull/4716:11,deployability,build,build,11,@phsft-bot build! @reikdas could you describe this in the release notes here: https://github.com/root-project/root/blob/master/README/ReleaseNotes/v620/index.md#deprecation-and-removal,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4716
https://github.com/root-project/root/pull/4716:58,deployability,releas,release,58,@phsft-bot build! @reikdas could you describe this in the release notes here: https://github.com/root-project/root/blob/master/README/ReleaseNotes/v620/index.md#deprecation-and-removal,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4716
https://github.com/root-project/root/pull/4716:134,deployability,Releas,ReleaseNotes,134,@phsft-bot build! @reikdas could you describe this in the release notes here: https://github.com/root-project/root/blob/master/README/ReleaseNotes/v620/index.md#deprecation-and-removal,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4716
https://github.com/root-project/root/pull/4716:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4716
https://github.com/root-project/root/pull/4716:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4716
https://github.com/root-project/root/pull/4716:116,deployability,releas,release,116,"why are we removing/deprecating the -r option ""now"", isn't that too soon (i.e. are the rootmap file deprecated this release?)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4716
https://github.com/root-project/root/pull/4716:347,deployability,releas,release,347,"That's a good question. I did not see a practical use case for this in first place. It seems it has been introduced quite long ago in root-project/root@64e9dbe5c72c0ccc8a942e8cec19fbdfe81200bd However, it did not have any documentation (besides the commit message) and I doubt it was picked up by the users. The rootmaps are not deprecated by the release in the usual meaning of deprecation. From this release onward the rootmap files should be considered a legacy feature. We should limit their use because we have a superior system. I do not think the deprecation is premature. It will give us a better understanding if we need this option. If we do we should have something similar with modules, if we don't it would reduce the complexity of rootcling.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4716
https://github.com/root-project/root/pull/4716:402,deployability,releas,release,402,"That's a good question. I did not see a practical use case for this in first place. It seems it has been introduced quite long ago in root-project/root@64e9dbe5c72c0ccc8a942e8cec19fbdfe81200bd However, it did not have any documentation (besides the commit message) and I doubt it was picked up by the users. The rootmaps are not deprecated by the release in the usual meaning of deprecation. From this release onward the rootmap files should be considered a legacy feature. We should limit their use because we have a superior system. I do not think the deprecation is premature. It will give us a better understanding if we need this option. If we do we should have something similar with modules, if we don't it would reduce the complexity of rootcling.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4716
https://github.com/root-project/root/pull/4716:690,deployability,modul,modules,690,"That's a good question. I did not see a practical use case for this in first place. It seems it has been introduced quite long ago in root-project/root@64e9dbe5c72c0ccc8a942e8cec19fbdfe81200bd However, it did not have any documentation (besides the commit message) and I doubt it was picked up by the users. The rootmaps are not deprecated by the release in the usual meaning of deprecation. From this release onward the rootmap files should be considered a legacy feature. We should limit their use because we have a superior system. I do not think the deprecation is premature. It will give us a better understanding if we need this option. If we do we should have something similar with modules, if we don't it would reduce the complexity of rootcling.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4716
https://github.com/root-project/root/pull/4716:720,energy efficiency,reduc,reduce,720,"That's a good question. I did not see a practical use case for this in first place. It seems it has been introduced quite long ago in root-project/root@64e9dbe5c72c0ccc8a942e8cec19fbdfe81200bd However, it did not have any documentation (besides the commit message) and I doubt it was picked up by the users. The rootmaps are not deprecated by the release in the usual meaning of deprecation. From this release onward the rootmap files should be considered a legacy feature. We should limit their use because we have a superior system. I do not think the deprecation is premature. It will give us a better understanding if we need this option. If we do we should have something similar with modules, if we don't it would reduce the complexity of rootcling.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4716
https://github.com/root-project/root/pull/4716:256,integrability,messag,message,256,"That's a good question. I did not see a practical use case for this in first place. It seems it has been introduced quite long ago in root-project/root@64e9dbe5c72c0ccc8a942e8cec19fbdfe81200bd However, it did not have any documentation (besides the commit message) and I doubt it was picked up by the users. The rootmaps are not deprecated by the release in the usual meaning of deprecation. From this release onward the rootmap files should be considered a legacy feature. We should limit their use because we have a superior system. I do not think the deprecation is premature. It will give us a better understanding if we need this option. If we do we should have something similar with modules, if we don't it would reduce the complexity of rootcling.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4716
https://github.com/root-project/root/pull/4716:256,interoperability,messag,message,256,"That's a good question. I did not see a practical use case for this in first place. It seems it has been introduced quite long ago in root-project/root@64e9dbe5c72c0ccc8a942e8cec19fbdfe81200bd However, it did not have any documentation (besides the commit message) and I doubt it was picked up by the users. The rootmaps are not deprecated by the release in the usual meaning of deprecation. From this release onward the rootmap files should be considered a legacy feature. We should limit their use because we have a superior system. I do not think the deprecation is premature. It will give us a better understanding if we need this option. If we do we should have something similar with modules, if we don't it would reduce the complexity of rootcling.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4716
https://github.com/root-project/root/pull/4716:690,modifiability,modul,modules,690,"That's a good question. I did not see a practical use case for this in first place. It seems it has been introduced quite long ago in root-project/root@64e9dbe5c72c0ccc8a942e8cec19fbdfe81200bd However, it did not have any documentation (besides the commit message) and I doubt it was picked up by the users. The rootmaps are not deprecated by the release in the usual meaning of deprecation. From this release onward the rootmap files should be considered a legacy feature. We should limit their use because we have a superior system. I do not think the deprecation is premature. It will give us a better understanding if we need this option. If we do we should have something similar with modules, if we don't it would reduce the complexity of rootcling.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4716
https://github.com/root-project/root/pull/4716:40,reliability,pra,practical,40,"That's a good question. I did not see a practical use case for this in first place. It seems it has been introduced quite long ago in root-project/root@64e9dbe5c72c0ccc8a942e8cec19fbdfe81200bd However, it did not have any documentation (besides the commit message) and I doubt it was picked up by the users. The rootmaps are not deprecated by the release in the usual meaning of deprecation. From this release onward the rootmap files should be considered a legacy feature. We should limit their use because we have a superior system. I do not think the deprecation is premature. It will give us a better understanding if we need this option. If we do we should have something similar with modules, if we don't it would reduce the complexity of rootcling.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4716
https://github.com/root-project/root/pull/4716:690,safety,modul,modules,690,"That's a good question. I did not see a practical use case for this in first place. It seems it has been introduced quite long ago in root-project/root@64e9dbe5c72c0ccc8a942e8cec19fbdfe81200bd However, it did not have any documentation (besides the commit message) and I doubt it was picked up by the users. The rootmaps are not deprecated by the release in the usual meaning of deprecation. From this release onward the rootmap files should be considered a legacy feature. We should limit their use because we have a superior system. I do not think the deprecation is premature. It will give us a better understanding if we need this option. If we do we should have something similar with modules, if we don't it would reduce the complexity of rootcling.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4716
https://github.com/root-project/root/pull/4716:731,safety,compl,complexity,731,"That's a good question. I did not see a practical use case for this in first place. It seems it has been introduced quite long ago in root-project/root@64e9dbe5c72c0ccc8a942e8cec19fbdfe81200bd However, it did not have any documentation (besides the commit message) and I doubt it was picked up by the users. The rootmaps are not deprecated by the release in the usual meaning of deprecation. From this release onward the rootmap files should be considered a legacy feature. We should limit their use because we have a superior system. I do not think the deprecation is premature. It will give us a better understanding if we need this option. If we do we should have something similar with modules, if we don't it would reduce the complexity of rootcling.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4716
https://github.com/root-project/root/pull/4716:731,security,compl,complexity,731,"That's a good question. I did not see a practical use case for this in first place. It seems it has been introduced quite long ago in root-project/root@64e9dbe5c72c0ccc8a942e8cec19fbdfe81200bd However, it did not have any documentation (besides the commit message) and I doubt it was picked up by the users. The rootmaps are not deprecated by the release in the usual meaning of deprecation. From this release onward the rootmap files should be considered a legacy feature. We should limit their use because we have a superior system. I do not think the deprecation is premature. It will give us a better understanding if we need this option. If we do we should have something similar with modules, if we don't it would reduce the complexity of rootcling.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4716
https://github.com/root-project/root/pull/4716:605,testability,understand,understanding,605,"That's a good question. I did not see a practical use case for this in first place. It seems it has been introduced quite long ago in root-project/root@64e9dbe5c72c0ccc8a942e8cec19fbdfe81200bd However, it did not have any documentation (besides the commit message) and I doubt it was picked up by the users. The rootmaps are not deprecated by the release in the usual meaning of deprecation. From this release onward the rootmap files should be considered a legacy feature. We should limit their use because we have a superior system. I do not think the deprecation is premature. It will give us a better understanding if we need this option. If we do we should have something similar with modules, if we don't it would reduce the complexity of rootcling.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4716
https://github.com/root-project/root/pull/4716:222,usability,document,documentation,222,"That's a good question. I did not see a practical use case for this in first place. It seems it has been introduced quite long ago in root-project/root@64e9dbe5c72c0ccc8a942e8cec19fbdfe81200bd However, it did not have any documentation (besides the commit message) and I doubt it was picked up by the users. The rootmaps are not deprecated by the release in the usual meaning of deprecation. From this release onward the rootmap files should be considered a legacy feature. We should limit their use because we have a superior system. I do not think the deprecation is premature. It will give us a better understanding if we need this option. If we do we should have something similar with modules, if we don't it would reduce the complexity of rootcling.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4716
https://github.com/root-project/root/pull/4716:301,usability,user,users,301,"That's a good question. I did not see a practical use case for this in first place. It seems it has been introduced quite long ago in root-project/root@64e9dbe5c72c0ccc8a942e8cec19fbdfe81200bd However, it did not have any documentation (besides the commit message) and I doubt it was picked up by the users. The rootmaps are not deprecated by the release in the usual meaning of deprecation. From this release onward the rootmap files should be considered a legacy feature. We should limit their use because we have a superior system. I do not think the deprecation is premature. It will give us a better understanding if we need this option. If we do we should have something similar with modules, if we don't it would reduce the complexity of rootcling.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4716
https://github.com/root-project/root/pull/4716:47,deployability,releas,release,47,"This seems to have a valid use case. Given the release time frame, I'd feel much more comfortable in reverting this until we figure out the corner cases.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4716
https://github.com/root-project/root/pull/4716:55,performance,time,time,55,"This seems to have a valid use case. Given the release time frame, I'd feel much more comfortable in reverting this until we figure out the corner cases.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4716
https://github.com/root-project/root/pull/4716:21,safety,valid,valid,21,"This seems to have a valid use case. Given the release time frame, I'd feel much more comfortable in reverting this until we figure out the corner cases.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4716
https://github.com/root-project/root/pull/4717:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:11,deployability,build,build,11,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:11,deployability,build,build,11,@phsft-bot build just on mac1014 with flags -Druntime_cxxmodules=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:11,deployability,build,build,11,@phsft-bot build just on mac1014/cxx17 with flags -Druntime_cxxmodules=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:11,deployability,build,build,11,@phsft-bot build just on mac1014 with flags -Druntime_cxxmodules=On -DCMAKE_BUILD_TYPE=Debug -DLLVM_BUILD_TYPE=Debug,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:11,deployability,build,build,11,@phsft-bot build just on mac1014 with flags -Druntime_cxxmodules=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:11,deployability,build,build,11,@phsft-bot build just on mac1014 with flags -Druntime_cxxmodules=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:11,deployability,build,build,11,@phsft-bot build just on mac1014 with flags -Druntime_cxxmodules=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:11,deployability,build,build,11,@phsft-bot build just on mac1014 with flags -Druntime_cxxmodules=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:11,deployability,build,build,11,@phsft-bot build just on mac1014/cxx17 with flags -Druntime_cxxmodules=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:324,deployability,patch,patch,324,> Hide libNew from symbol resolution. This a good and necessary thing. It also made be realize that it might not be a unique case. Previously the user was explicitly/positively listing the libraries to be considered for autoloading (by creating a rootmap file and/or having it listed in one). If I understand correctly this patch now consider all libraries that are on the LD_LIBRARY_PATH. The fact that some libraries should not be autoloaded (like libNew) means that we probably need to add a 'new feature' to allow the user to remove some libraries from considerations.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:324,safety,patch,patch,324,> Hide libNew from symbol resolution. This a good and necessary thing. It also made be realize that it might not be a unique case. Previously the user was explicitly/positively listing the libraries to be considered for autoloading (by creating a rootmap file and/or having it listed in one). If I understand correctly this patch now consider all libraries that are on the LD_LIBRARY_PATH. The fact that some libraries should not be autoloaded (like libNew) means that we probably need to add a 'new feature' to allow the user to remove some libraries from considerations.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:324,security,patch,patch,324,> Hide libNew from symbol resolution. This a good and necessary thing. It also made be realize that it might not be a unique case. Previously the user was explicitly/positively listing the libraries to be considered for autoloading (by creating a rootmap file and/or having it listed in one). If I understand correctly this patch now consider all libraries that are on the LD_LIBRARY_PATH. The fact that some libraries should not be autoloaded (like libNew) means that we probably need to add a 'new feature' to allow the user to remove some libraries from considerations.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:298,testability,understand,understand,298,> Hide libNew from symbol resolution. This a good and necessary thing. It also made be realize that it might not be a unique case. Previously the user was explicitly/positively listing the libraries to be considered for autoloading (by creating a rootmap file and/or having it listed in one). If I understand correctly this patch now consider all libraries that are on the LD_LIBRARY_PATH. The fact that some libraries should not be autoloaded (like libNew) means that we probably need to add a 'new feature' to allow the user to remove some libraries from considerations.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:146,usability,user,user,146,> Hide libNew from symbol resolution. This a good and necessary thing. It also made be realize that it might not be a unique case. Previously the user was explicitly/positively listing the libraries to be considered for autoloading (by creating a rootmap file and/or having it listed in one). If I understand correctly this patch now consider all libraries that are on the LD_LIBRARY_PATH. The fact that some libraries should not be autoloaded (like libNew) means that we probably need to add a 'new feature' to allow the user to remove some libraries from considerations.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:522,usability,user,user,522,> Hide libNew from symbol resolution. This a good and necessary thing. It also made be realize that it might not be a unique case. Previously the user was explicitly/positively listing the libraries to be considered for autoloading (by creating a rootmap file and/or having it listed in one). If I understand correctly this patch now consider all libraries that are on the LD_LIBRARY_PATH. The fact that some libraries should not be autoloaded (like libNew) means that we probably need to add a 'new feature' to allow the user to remove some libraries from considerations.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:332,deployability,patch,patch,332,"> > Hide libNew from symbol resolution. > . > This a good and necessary thing. It also made be realize that it might not be a unique case. Previously the user was explicitly/positively listing the libraries to be considered for autoloading (by creating a rootmap file and/or having it listed in one). If I understand correctly this patch now consider all libraries that are on the LD_LIBRARY_PATH. The fact that some libraries should not be autoloaded (like libNew) means that we probably need to add a 'new feature' to allow the user to remove some libraries from considerations. We can only resolve symbols from libraries which we have a module for. This would bring exactly the same feature for ROOTSYS/lib, however, we will still need some facility for ignoring some system libraries.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:640,deployability,modul,module,640,"> > Hide libNew from symbol resolution. > . > This a good and necessary thing. It also made be realize that it might not be a unique case. Previously the user was explicitly/positively listing the libraries to be considered for autoloading (by creating a rootmap file and/or having it listed in one). If I understand correctly this patch now consider all libraries that are on the LD_LIBRARY_PATH. The fact that some libraries should not be autoloaded (like libNew) means that we probably need to add a 'new feature' to allow the user to remove some libraries from considerations. We can only resolve symbols from libraries which we have a module for. This would bring exactly the same feature for ROOTSYS/lib, however, we will still need some facility for ignoring some system libraries.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:640,modifiability,modul,module,640,"> > Hide libNew from symbol resolution. > . > This a good and necessary thing. It also made be realize that it might not be a unique case. Previously the user was explicitly/positively listing the libraries to be considered for autoloading (by creating a rootmap file and/or having it listed in one). If I understand correctly this patch now consider all libraries that are on the LD_LIBRARY_PATH. The fact that some libraries should not be autoloaded (like libNew) means that we probably need to add a 'new feature' to allow the user to remove some libraries from considerations. We can only resolve symbols from libraries which we have a module for. This would bring exactly the same feature for ROOTSYS/lib, however, we will still need some facility for ignoring some system libraries.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:332,safety,patch,patch,332,"> > Hide libNew from symbol resolution. > . > This a good and necessary thing. It also made be realize that it might not be a unique case. Previously the user was explicitly/positively listing the libraries to be considered for autoloading (by creating a rootmap file and/or having it listed in one). If I understand correctly this patch now consider all libraries that are on the LD_LIBRARY_PATH. The fact that some libraries should not be autoloaded (like libNew) means that we probably need to add a 'new feature' to allow the user to remove some libraries from considerations. We can only resolve symbols from libraries which we have a module for. This would bring exactly the same feature for ROOTSYS/lib, however, we will still need some facility for ignoring some system libraries.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:640,safety,modul,module,640,"> > Hide libNew from symbol resolution. > . > This a good and necessary thing. It also made be realize that it might not be a unique case. Previously the user was explicitly/positively listing the libraries to be considered for autoloading (by creating a rootmap file and/or having it listed in one). If I understand correctly this patch now consider all libraries that are on the LD_LIBRARY_PATH. The fact that some libraries should not be autoloaded (like libNew) means that we probably need to add a 'new feature' to allow the user to remove some libraries from considerations. We can only resolve symbols from libraries which we have a module for. This would bring exactly the same feature for ROOTSYS/lib, however, we will still need some facility for ignoring some system libraries.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:332,security,patch,patch,332,"> > Hide libNew from symbol resolution. > . > This a good and necessary thing. It also made be realize that it might not be a unique case. Previously the user was explicitly/positively listing the libraries to be considered for autoloading (by creating a rootmap file and/or having it listed in one). If I understand correctly this patch now consider all libraries that are on the LD_LIBRARY_PATH. The fact that some libraries should not be autoloaded (like libNew) means that we probably need to add a 'new feature' to allow the user to remove some libraries from considerations. We can only resolve symbols from libraries which we have a module for. This would bring exactly the same feature for ROOTSYS/lib, however, we will still need some facility for ignoring some system libraries.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:306,testability,understand,understand,306,"> > Hide libNew from symbol resolution. > . > This a good and necessary thing. It also made be realize that it might not be a unique case. Previously the user was explicitly/positively listing the libraries to be considered for autoloading (by creating a rootmap file and/or having it listed in one). If I understand correctly this patch now consider all libraries that are on the LD_LIBRARY_PATH. The fact that some libraries should not be autoloaded (like libNew) means that we probably need to add a 'new feature' to allow the user to remove some libraries from considerations. We can only resolve symbols from libraries which we have a module for. This would bring exactly the same feature for ROOTSYS/lib, however, we will still need some facility for ignoring some system libraries.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:154,usability,user,user,154,"> > Hide libNew from symbol resolution. > . > This a good and necessary thing. It also made be realize that it might not be a unique case. Previously the user was explicitly/positively listing the libraries to be considered for autoloading (by creating a rootmap file and/or having it listed in one). If I understand correctly this patch now consider all libraries that are on the LD_LIBRARY_PATH. The fact that some libraries should not be autoloaded (like libNew) means that we probably need to add a 'new feature' to allow the user to remove some libraries from considerations. We can only resolve symbols from libraries which we have a module for. This would bring exactly the same feature for ROOTSYS/lib, however, we will still need some facility for ignoring some system libraries.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:530,usability,user,user,530,"> > Hide libNew from symbol resolution. > . > This a good and necessary thing. It also made be realize that it might not be a unique case. Previously the user was explicitly/positively listing the libraries to be considered for autoloading (by creating a rootmap file and/or having it listed in one). If I understand correctly this patch now consider all libraries that are on the LD_LIBRARY_PATH. The fact that some libraries should not be autoloaded (like libNew) means that we probably need to add a 'new feature' to allow the user to remove some libraries from considerations. We can only resolve symbols from libraries which we have a module for. This would bring exactly the same feature for ROOTSYS/lib, however, we will still need some facility for ignoring some system libraries.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:61,deployability,modul,module,61,> We can only resolve symbols from libraries which we have a module for. I am confused. I would not expect libNew to have a module (it does not have a dictionary if I remember correctly).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:124,deployability,modul,module,124,> We can only resolve symbols from libraries which we have a module for. I am confused. I would not expect libNew to have a module (it does not have a dictionary if I remember correctly).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:61,modifiability,modul,module,61,> We can only resolve symbols from libraries which we have a module for. I am confused. I would not expect libNew to have a module (it does not have a dictionary if I remember correctly).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:124,modifiability,modul,module,124,> We can only resolve symbols from libraries which we have a module for. I am confused. I would not expect libNew to have a module (it does not have a dictionary if I remember correctly).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:135,reliability,doe,does,135,> We can only resolve symbols from libraries which we have a module for. I am confused. I would not expect libNew to have a module (it does not have a dictionary if I remember correctly).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:61,safety,modul,module,61,> We can only resolve symbols from libraries which we have a module for. I am confused. I would not expect libNew to have a module (it does not have a dictionary if I remember correctly).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:124,safety,modul,module,124,> We can only resolve symbols from libraries which we have a module for. I am confused. I would not expect libNew to have a module (it does not have a dictionary if I remember correctly).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:167,safety,reme,remember,167,> We can only resolve symbols from libraries which we have a module for. I am confused. I would not expect libNew to have a module (it does not have a dictionary if I remember correctly).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:63,deployability,modul,module,63,> > We can only resolve symbols from libraries which we have a module for. > . > I am confused. I would not expect libNew to have a module (it does not have a dictionary if I remember correctly). My proposal was to limit the infrastructure to only resolve symbols from ROOT libraries when there is a corresponding module. This rule will exclude libNew and all other potential libraries which in the non-modules ROOT do not have a rootmap file entries.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:132,deployability,modul,module,132,> > We can only resolve symbols from libraries which we have a module for. > . > I am confused. I would not expect libNew to have a module (it does not have a dictionary if I remember correctly). My proposal was to limit the infrastructure to only resolve symbols from ROOT libraries when there is a corresponding module. This rule will exclude libNew and all other potential libraries which in the non-modules ROOT do not have a rootmap file entries.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:225,deployability,infrastructur,infrastructure,225,> > We can only resolve symbols from libraries which we have a module for. > . > I am confused. I would not expect libNew to have a module (it does not have a dictionary if I remember correctly). My proposal was to limit the infrastructure to only resolve symbols from ROOT libraries when there is a corresponding module. This rule will exclude libNew and all other potential libraries which in the non-modules ROOT do not have a rootmap file entries.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:314,deployability,modul,module,314,> > We can only resolve symbols from libraries which we have a module for. > . > I am confused. I would not expect libNew to have a module (it does not have a dictionary if I remember correctly). My proposal was to limit the infrastructure to only resolve symbols from ROOT libraries when there is a corresponding module. This rule will exclude libNew and all other potential libraries which in the non-modules ROOT do not have a rootmap file entries.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:403,deployability,modul,modules,403,> > We can only resolve symbols from libraries which we have a module for. > . > I am confused. I would not expect libNew to have a module (it does not have a dictionary if I remember correctly). My proposal was to limit the infrastructure to only resolve symbols from ROOT libraries when there is a corresponding module. This rule will exclude libNew and all other potential libraries which in the non-modules ROOT do not have a rootmap file entries.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:63,modifiability,modul,module,63,> > We can only resolve symbols from libraries which we have a module for. > . > I am confused. I would not expect libNew to have a module (it does not have a dictionary if I remember correctly). My proposal was to limit the infrastructure to only resolve symbols from ROOT libraries when there is a corresponding module. This rule will exclude libNew and all other potential libraries which in the non-modules ROOT do not have a rootmap file entries.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:132,modifiability,modul,module,132,> > We can only resolve symbols from libraries which we have a module for. > . > I am confused. I would not expect libNew to have a module (it does not have a dictionary if I remember correctly). My proposal was to limit the infrastructure to only resolve symbols from ROOT libraries when there is a corresponding module. This rule will exclude libNew and all other potential libraries which in the non-modules ROOT do not have a rootmap file entries.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:314,modifiability,modul,module,314,> > We can only resolve symbols from libraries which we have a module for. > . > I am confused. I would not expect libNew to have a module (it does not have a dictionary if I remember correctly). My proposal was to limit the infrastructure to only resolve symbols from ROOT libraries when there is a corresponding module. This rule will exclude libNew and all other potential libraries which in the non-modules ROOT do not have a rootmap file entries.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:403,modifiability,modul,modules,403,> > We can only resolve symbols from libraries which we have a module for. > . > I am confused. I would not expect libNew to have a module (it does not have a dictionary if I remember correctly). My proposal was to limit the infrastructure to only resolve symbols from ROOT libraries when there is a corresponding module. This rule will exclude libNew and all other potential libraries which in the non-modules ROOT do not have a rootmap file entries.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:143,reliability,doe,does,143,> > We can only resolve symbols from libraries which we have a module for. > . > I am confused. I would not expect libNew to have a module (it does not have a dictionary if I remember correctly). My proposal was to limit the infrastructure to only resolve symbols from ROOT libraries when there is a corresponding module. This rule will exclude libNew and all other potential libraries which in the non-modules ROOT do not have a rootmap file entries.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:63,safety,modul,module,63,> > We can only resolve symbols from libraries which we have a module for. > . > I am confused. I would not expect libNew to have a module (it does not have a dictionary if I remember correctly). My proposal was to limit the infrastructure to only resolve symbols from ROOT libraries when there is a corresponding module. This rule will exclude libNew and all other potential libraries which in the non-modules ROOT do not have a rootmap file entries.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:132,safety,modul,module,132,> > We can only resolve symbols from libraries which we have a module for. > . > I am confused. I would not expect libNew to have a module (it does not have a dictionary if I remember correctly). My proposal was to limit the infrastructure to only resolve symbols from ROOT libraries when there is a corresponding module. This rule will exclude libNew and all other potential libraries which in the non-modules ROOT do not have a rootmap file entries.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:175,safety,reme,remember,175,> > We can only resolve symbols from libraries which we have a module for. > . > I am confused. I would not expect libNew to have a module (it does not have a dictionary if I remember correctly). My proposal was to limit the infrastructure to only resolve symbols from ROOT libraries when there is a corresponding module. This rule will exclude libNew and all other potential libraries which in the non-modules ROOT do not have a rootmap file entries.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:314,safety,modul,module,314,> > We can only resolve symbols from libraries which we have a module for. > . > I am confused. I would not expect libNew to have a module (it does not have a dictionary if I remember correctly). My proposal was to limit the infrastructure to only resolve symbols from ROOT libraries when there is a corresponding module. This rule will exclude libNew and all other potential libraries which in the non-modules ROOT do not have a rootmap file entries.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:403,safety,modul,modules,403,> > We can only resolve symbols from libraries which we have a module for. > . > I am confused. I would not expect libNew to have a module (it does not have a dictionary if I remember correctly). My proposal was to limit the infrastructure to only resolve symbols from ROOT libraries when there is a corresponding module. This rule will exclude libNew and all other potential libraries which in the non-modules ROOT do not have a rootmap file entries.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:31,deployability,infrastructur,infrastructure,31,"> My proposal was to limit the infrastructure to only resolve symbols from ROOT libraries when there is a corresponding module. I understand now :). I assume you mean ""from ROOT and user libraries"". Also this will eventually relate to the rootcling '-r' (i.e. be part of autoloading without a dicitonary (and this potentially without header to stick into a module)).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:120,deployability,modul,module,120,"> My proposal was to limit the infrastructure to only resolve symbols from ROOT libraries when there is a corresponding module. I understand now :). I assume you mean ""from ROOT and user libraries"". Also this will eventually relate to the rootcling '-r' (i.e. be part of autoloading without a dicitonary (and this potentially without header to stick into a module)).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:357,deployability,modul,module,357,"> My proposal was to limit the infrastructure to only resolve symbols from ROOT libraries when there is a corresponding module. I understand now :). I assume you mean ""from ROOT and user libraries"". Also this will eventually relate to the rootcling '-r' (i.e. be part of autoloading without a dicitonary (and this potentially without header to stick into a module)).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:214,integrability,event,eventually,214,"> My proposal was to limit the infrastructure to only resolve symbols from ROOT libraries when there is a corresponding module. I understand now :). I assume you mean ""from ROOT and user libraries"". Also this will eventually relate to the rootcling '-r' (i.e. be part of autoloading without a dicitonary (and this potentially without header to stick into a module)).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:120,modifiability,modul,module,120,"> My proposal was to limit the infrastructure to only resolve symbols from ROOT libraries when there is a corresponding module. I understand now :). I assume you mean ""from ROOT and user libraries"". Also this will eventually relate to the rootcling '-r' (i.e. be part of autoloading without a dicitonary (and this potentially without header to stick into a module)).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:357,modifiability,modul,module,357,"> My proposal was to limit the infrastructure to only resolve symbols from ROOT libraries when there is a corresponding module. I understand now :). I assume you mean ""from ROOT and user libraries"". Also this will eventually relate to the rootcling '-r' (i.e. be part of autoloading without a dicitonary (and this potentially without header to stick into a module)).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:120,safety,modul,module,120,"> My proposal was to limit the infrastructure to only resolve symbols from ROOT libraries when there is a corresponding module. I understand now :). I assume you mean ""from ROOT and user libraries"". Also this will eventually relate to the rootcling '-r' (i.e. be part of autoloading without a dicitonary (and this potentially without header to stick into a module)).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:357,safety,modul,module,357,"> My proposal was to limit the infrastructure to only resolve symbols from ROOT libraries when there is a corresponding module. I understand now :). I assume you mean ""from ROOT and user libraries"". Also this will eventually relate to the rootcling '-r' (i.e. be part of autoloading without a dicitonary (and this potentially without header to stick into a module)).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:130,testability,understand,understand,130,"> My proposal was to limit the infrastructure to only resolve symbols from ROOT libraries when there is a corresponding module. I understand now :). I assume you mean ""from ROOT and user libraries"". Also this will eventually relate to the rootcling '-r' (i.e. be part of autoloading without a dicitonary (and this potentially without header to stick into a module)).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:182,usability,user,user,182,"> My proposal was to limit the infrastructure to only resolve symbols from ROOT libraries when there is a corresponding module. I understand now :). I assume you mean ""from ROOT and user libraries"". Also this will eventually relate to the rootcling '-r' (i.e. be part of autoloading without a dicitonary (and this potentially without header to stick into a module)).",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:11,deployability,build,build,11,@phsft-bot build just on mac1014 with flags -Druntime_cxxmodules=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:11,deployability,build,build,11,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:11,deployability,build,build,11,@phsft-bot build with flags -DCMAKE_BUILD_TYPE=RelWithDebInfo -DLLVM_BUILD_TYPE=RelWithDebInfo -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:11,deployability,build,build,11,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:11,deployability,build,build,11,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4717:11,deployability,build,build,11,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4717
https://github.com/root-project/root/pull/4718:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4718
https://github.com/root-project/root/pull/4718:27,deployability,fail,fails,27,"Ok, the important platform fails. We check again once this works again.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4718
https://github.com/root-project/root/pull/4718:18,interoperability,platform,platform,18,"Ok, the important platform fails. We check again once this works again.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4718
https://github.com/root-project/root/pull/4718:27,reliability,fail,fails,27,"Ok, the important platform fails. We check again once this works again.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4718
https://github.com/root-project/root/pull/4718:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4718
https://github.com/root-project/root/pull/4719:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4719
https://github.com/root-project/root/pull/4719:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4719
https://github.com/root-project/root/pull/4719:29,availability,failur,failures,29,I do not see how the windows failures might be related.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4719
https://github.com/root-project/root/pull/4719:29,deployability,fail,failures,29,I do not see how the windows failures might be related.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4719
https://github.com/root-project/root/pull/4719:29,performance,failur,failures,29,I do not see how the windows failures might be related.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4719
https://github.com/root-project/root/pull/4719:29,reliability,fail,failures,29,I do not see how the windows failures might be related.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4719
https://github.com/root-project/root/pull/4719:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4719
https://github.com/root-project/root/pull/4720:37,deployability,build,build,37,"Thanks for the fix! We don't need to build, as only docs were changed.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4720
https://github.com/root-project/root/pull/4721:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:338,availability,sli,slightly,338,"OK, I forgot to change the ROOT7 implementations. The build on Mac seems to fail cause the expressions for line join and line cap method I found on the internet are invalid. I changed them, but unfortunatly cannot test it locally cause I dont own a Mac. About the failing tests I assume that this is due to the additional attribute which slightly changes filesizes. What would be the best way to resolve this? I would assume that the values in roottest need to be updated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:54,deployability,build,build,54,"OK, I forgot to change the ROOT7 implementations. The build on Mac seems to fail cause the expressions for line join and line cap method I found on the internet are invalid. I changed them, but unfortunatly cannot test it locally cause I dont own a Mac. About the failing tests I assume that this is due to the additional attribute which slightly changes filesizes. What would be the best way to resolve this? I would assume that the values in roottest need to be updated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:76,deployability,fail,fail,76,"OK, I forgot to change the ROOT7 implementations. The build on Mac seems to fail cause the expressions for line join and line cap method I found on the internet are invalid. I changed them, but unfortunatly cannot test it locally cause I dont own a Mac. About the failing tests I assume that this is due to the additional attribute which slightly changes filesizes. What would be the best way to resolve this? I would assume that the values in roottest need to be updated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:264,deployability,fail,failing,264,"OK, I forgot to change the ROOT7 implementations. The build on Mac seems to fail cause the expressions for line join and line cap method I found on the internet are invalid. I changed them, but unfortunatly cannot test it locally cause I dont own a Mac. About the failing tests I assume that this is due to the additional attribute which slightly changes filesizes. What would be the best way to resolve this? I would assume that the values in roottest need to be updated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:464,deployability,updat,updated,464,"OK, I forgot to change the ROOT7 implementations. The build on Mac seems to fail cause the expressions for line join and line cap method I found on the internet are invalid. I changed them, but unfortunatly cannot test it locally cause I dont own a Mac. About the failing tests I assume that this is due to the additional attribute which slightly changes filesizes. What would be the best way to resolve this? I would assume that the values in roottest need to be updated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:76,reliability,fail,fail,76,"OK, I forgot to change the ROOT7 implementations. The build on Mac seems to fail cause the expressions for line join and line cap method I found on the internet are invalid. I changed them, but unfortunatly cannot test it locally cause I dont own a Mac. About the failing tests I assume that this is due to the additional attribute which slightly changes filesizes. What would be the best way to resolve this? I would assume that the values in roottest need to be updated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:264,reliability,fail,failing,264,"OK, I forgot to change the ROOT7 implementations. The build on Mac seems to fail cause the expressions for line join and line cap method I found on the internet are invalid. I changed them, but unfortunatly cannot test it locally cause I dont own a Mac. About the failing tests I assume that this is due to the additional attribute which slightly changes filesizes. What would be the best way to resolve this? I would assume that the values in roottest need to be updated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:338,reliability,sli,slightly,338,"OK, I forgot to change the ROOT7 implementations. The build on Mac seems to fail cause the expressions for line join and line cap method I found on the internet are invalid. I changed them, but unfortunatly cannot test it locally cause I dont own a Mac. About the failing tests I assume that this is due to the additional attribute which slightly changes filesizes. What would be the best way to resolve this? I would assume that the values in roottest need to be updated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:214,safety,test,test,214,"OK, I forgot to change the ROOT7 implementations. The build on Mac seems to fail cause the expressions for line join and line cap method I found on the internet are invalid. I changed them, but unfortunatly cannot test it locally cause I dont own a Mac. About the failing tests I assume that this is due to the additional attribute which slightly changes filesizes. What would be the best way to resolve this? I would assume that the values in roottest need to be updated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:272,safety,test,tests,272,"OK, I forgot to change the ROOT7 implementations. The build on Mac seems to fail cause the expressions for line join and line cap method I found on the internet are invalid. I changed them, but unfortunatly cannot test it locally cause I dont own a Mac. About the failing tests I assume that this is due to the additional attribute which slightly changes filesizes. What would be the best way to resolve this? I would assume that the values in roottest need to be updated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:464,safety,updat,updated,464,"OK, I forgot to change the ROOT7 implementations. The build on Mac seems to fail cause the expressions for line join and line cap method I found on the internet are invalid. I changed them, but unfortunatly cannot test it locally cause I dont own a Mac. About the failing tests I assume that this is due to the additional attribute which slightly changes filesizes. What would be the best way to resolve this? I would assume that the values in roottest need to be updated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:464,security,updat,updated,464,"OK, I forgot to change the ROOT7 implementations. The build on Mac seems to fail cause the expressions for line join and line cap method I found on the internet are invalid. I changed them, but unfortunatly cannot test it locally cause I dont own a Mac. About the failing tests I assume that this is due to the additional attribute which slightly changes filesizes. What would be the best way to resolve this? I would assume that the values in roottest need to be updated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:214,testability,test,test,214,"OK, I forgot to change the ROOT7 implementations. The build on Mac seems to fail cause the expressions for line join and line cap method I found on the internet are invalid. I changed them, but unfortunatly cannot test it locally cause I dont own a Mac. About the failing tests I assume that this is due to the additional attribute which slightly changes filesizes. What would be the best way to resolve this? I would assume that the values in roottest need to be updated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:272,testability,test,tests,272,"OK, I forgot to change the ROOT7 implementations. The build on Mac seems to fail cause the expressions for line join and line cap method I found on the internet are invalid. I changed them, but unfortunatly cannot test it locally cause I dont own a Mac. About the failing tests I assume that this is due to the additional attribute which slightly changes filesizes. What would be the best way to resolve this? I would assume that the values in roottest need to be updated.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:362,deployability,API,API,362,"General comment - you have to preserve old functionality as much as possible. In your particular case - when adding new argument to the constructor (like TAttMarker), you have to provide default value for it that existing user code still can be compiled. . Also you redefines some virtual methods (adding extra arguments) - means if any user code relies on that API, it will be ""silently"" broken. Probably here one should not modify existing virtual methods, but add extra ones for new marker attributes",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:362,integrability,API,API,362,"General comment - you have to preserve old functionality as much as possible. In your particular case - when adding new argument to the constructor (like TAttMarker), you have to provide default value for it that existing user code still can be compiled. . Also you redefines some virtual methods (adding extra arguments) - means if any user code relies on that API, it will be ""silently"" broken. Probably here one should not modify existing virtual methods, but add extra ones for new marker attributes",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:362,interoperability,API,API,362,"General comment - you have to preserve old functionality as much as possible. In your particular case - when adding new argument to the constructor (like TAttMarker), you have to provide default value for it that existing user code still can be compiled. . Also you redefines some virtual methods (adding extra arguments) - means if any user code relies on that API, it will be ""silently"" broken. Probably here one should not modify existing virtual methods, but add extra ones for new marker attributes",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:426,security,modif,modify,426,"General comment - you have to preserve old functionality as much as possible. In your particular case - when adding new argument to the constructor (like TAttMarker), you have to provide default value for it that existing user code still can be compiled. . Also you redefines some virtual methods (adding extra arguments) - means if any user code relies on that API, it will be ""silently"" broken. Probably here one should not modify existing virtual methods, but add extra ones for new marker attributes",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:222,usability,user,user,222,"General comment - you have to preserve old functionality as much as possible. In your particular case - when adding new argument to the constructor (like TAttMarker), you have to provide default value for it that existing user code still can be compiled. . Also you redefines some virtual methods (adding extra arguments) - means if any user code relies on that API, it will be ""silently"" broken. Probably here one should not modify existing virtual methods, but add extra ones for new marker attributes",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:337,usability,user,user,337,"General comment - you have to preserve old functionality as much as possible. In your particular case - when adding new argument to the constructor (like TAttMarker), you have to provide default value for it that existing user code still can be compiled. . Also you redefines some virtual methods (adding extra arguments) - means if any user code relies on that API, it will be ""silently"" broken. Probably here one should not modify existing virtual methods, but add extra ones for new marker attributes",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:106,interoperability,compatib,compatibility,106,"Thanks for the comment @linev . I clearly see your point and I got to admit I was not thinking much about compatibility when I wrote this feature although this is a crucial point for a toolkit like ROOT. About the default value for the constructor everything is totally fine. About the redefined virtual functions, I am not 100% sure what is the best way to resolve the problem. Probably providing a default value for the new parameter like I did for TAttMarker::SaveMarkerAttributes will not be enough. I was asking myself whether it is better to overload the virtual function with the additional parameter or to define a complete new function with a different name. Maybe you can give me an advice on how to resolve this problem since am not fully familiar with the concept of virtual functions and the consequences of a particular implementation. All the best,. Simon Spies",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:426,modifiability,paramet,parameter,426,"Thanks for the comment @linev . I clearly see your point and I got to admit I was not thinking much about compatibility when I wrote this feature although this is a crucial point for a toolkit like ROOT. About the default value for the constructor everything is totally fine. About the redefined virtual functions, I am not 100% sure what is the best way to resolve the problem. Probably providing a default value for the new parameter like I did for TAttMarker::SaveMarkerAttributes will not be enough. I was asking myself whether it is better to overload the virtual function with the additional parameter or to define a complete new function with a different name. Maybe you can give me an advice on how to resolve this problem since am not fully familiar with the concept of virtual functions and the consequences of a particular implementation. All the best,. Simon Spies",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:598,modifiability,paramet,parameter,598,"Thanks for the comment @linev . I clearly see your point and I got to admit I was not thinking much about compatibility when I wrote this feature although this is a crucial point for a toolkit like ROOT. About the default value for the constructor everything is totally fine. About the redefined virtual functions, I am not 100% sure what is the best way to resolve the problem. Probably providing a default value for the new parameter like I did for TAttMarker::SaveMarkerAttributes will not be enough. I was asking myself whether it is better to overload the virtual function with the additional parameter or to define a complete new function with a different name. Maybe you can give me an advice on how to resolve this problem since am not fully familiar with the concept of virtual functions and the consequences of a particular implementation. All the best,. Simon Spies",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:623,safety,compl,complete,623,"Thanks for the comment @linev . I clearly see your point and I got to admit I was not thinking much about compatibility when I wrote this feature although this is a crucial point for a toolkit like ROOT. About the default value for the constructor everything is totally fine. About the redefined virtual functions, I am not 100% sure what is the best way to resolve the problem. Probably providing a default value for the new parameter like I did for TAttMarker::SaveMarkerAttributes will not be enough. I was asking myself whether it is better to overload the virtual function with the additional parameter or to define a complete new function with a different name. Maybe you can give me an advice on how to resolve this problem since am not fully familiar with the concept of virtual functions and the consequences of a particular implementation. All the best,. Simon Spies",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:623,security,compl,complete,623,"Thanks for the comment @linev . I clearly see your point and I got to admit I was not thinking much about compatibility when I wrote this feature although this is a crucial point for a toolkit like ROOT. About the default value for the constructor everything is totally fine. About the redefined virtual functions, I am not 100% sure what is the best way to resolve the problem. Probably providing a default value for the new parameter like I did for TAttMarker::SaveMarkerAttributes will not be enough. I was asking myself whether it is better to overload the virtual function with the additional parameter or to define a complete new function with a different name. Maybe you can give me an advice on how to resolve this problem since am not fully familiar with the concept of virtual functions and the consequences of a particular implementation. All the best,. Simon Spies",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:34,usability,clear,clearly,34,"Thanks for the comment @linev . I clearly see your point and I got to admit I was not thinking much about compatibility when I wrote this feature although this is a crucial point for a toolkit like ROOT. About the default value for the constructor everything is totally fine. About the redefined virtual functions, I am not 100% sure what is the best way to resolve the problem. Probably providing a default value for the new parameter like I did for TAttMarker::SaveMarkerAttributes will not be enough. I was asking myself whether it is better to overload the virtual function with the additional parameter or to define a complete new function with a different name. Maybe you can give me an advice on how to resolve this problem since am not fully familiar with the concept of virtual functions and the consequences of a particular implementation. All the best,. Simon Spies",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:185,usability,tool,toolkit,185,"Thanks for the comment @linev . I clearly see your point and I got to admit I was not thinking much about compatibility when I wrote this feature although this is a crucial point for a toolkit like ROOT. About the default value for the constructor everything is totally fine. About the redefined virtual functions, I am not 100% sure what is the best way to resolve the problem. Probably providing a default value for the new parameter like I did for TAttMarker::SaveMarkerAttributes will not be enough. I was asking myself whether it is better to overload the virtual function with the additional parameter or to define a complete new function with a different name. Maybe you can give me an advice on how to resolve this problem since am not fully familiar with the concept of virtual functions and the consequences of a particular implementation. All the best,. Simon Spies",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:285,deployability,API,API,285,"> Maybe you can give me an advice on how to resolve this problem since am not fully familiar with the concept of virtual functions and the consequences of a particular implementation. In my mind - one should introduce new methods to configure extra marker attributes. In that case old API remains, only new is introduced. But we should wait for @couet - that he is thinking about it",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:233,integrability,configur,configure,233,"> Maybe you can give me an advice on how to resolve this problem since am not fully familiar with the concept of virtual functions and the consequences of a particular implementation. In my mind - one should introduce new methods to configure extra marker attributes. In that case old API remains, only new is introduced. But we should wait for @couet - that he is thinking about it",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:285,integrability,API,API,285,"> Maybe you can give me an advice on how to resolve this problem since am not fully familiar with the concept of virtual functions and the consequences of a particular implementation. In my mind - one should introduce new methods to configure extra marker attributes. In that case old API remains, only new is introduced. But we should wait for @couet - that he is thinking about it",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:285,interoperability,API,API,285,"> Maybe you can give me an advice on how to resolve this problem since am not fully familiar with the concept of virtual functions and the consequences of a particular implementation. In my mind - one should introduce new methods to configure extra marker attributes. In that case old API remains, only new is introduced. But we should wait for @couet - that he is thinking about it",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:233,modifiability,configur,configure,233,"> Maybe you can give me an advice on how to resolve this problem since am not fully familiar with the concept of virtual functions and the consequences of a particular implementation. In my mind - one should introduce new methods to configure extra marker attributes. In that case old API remains, only new is introduced. But we should wait for @couet - that he is thinking about it",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:233,security,configur,configure,233,"> Maybe you can give me an advice on how to resolve this problem since am not fully familiar with the concept of virtual functions and the consequences of a particular implementation. In my mind - one should introduce new methods to configure extra marker attributes. In that case old API remains, only new is introduced. But we should wait for @couet - that he is thinking about it",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:93,availability,error,errors,93,Could an admin please start another build? I would like to know whether at least the compile errors are fixed now.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:36,deployability,build,build,36,Could an admin please start another build? I would like to know whether at least the compile errors are fixed now.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:93,performance,error,errors,93,Could an admin please start another build? I would like to know whether at least the compile errors are fixed now.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:93,safety,error,errors,93,Could an admin please start another build? I would like to know whether at least the compile errors are fixed now.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:93,usability,error,errors,93,Could an admin please start another build? I would like to know whether at least the compile errors are fixed now.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:310,deployability,configurat,configurations,310,I have another question: Several changes of this PR require an adjustment of the reference values of some tests. What is the correct way to get new reference values? Can I just run the test macros and take the results as new reference values or do they need to be calculated on a specific system with specific configurations?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:310,integrability,configur,configurations,310,I have another question: Several changes of this PR require an adjustment of the reference values of some tests. What is the correct way to get new reference values? Can I just run the test macros and take the results as new reference values or do they need to be calculated on a specific system with specific configurations?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:280,interoperability,specif,specific,280,I have another question: Several changes of this PR require an adjustment of the reference values of some tests. What is the correct way to get new reference values? Can I just run the test macros and take the results as new reference values or do they need to be calculated on a specific system with specific configurations?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:301,interoperability,specif,specific,301,I have another question: Several changes of this PR require an adjustment of the reference values of some tests. What is the correct way to get new reference values? Can I just run the test macros and take the results as new reference values or do they need to be calculated on a specific system with specific configurations?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:310,modifiability,configur,configurations,310,I have another question: Several changes of this PR require an adjustment of the reference values of some tests. What is the correct way to get new reference values? Can I just run the test macros and take the results as new reference values or do they need to be calculated on a specific system with specific configurations?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:106,safety,test,tests,106,I have another question: Several changes of this PR require an adjustment of the reference values of some tests. What is the correct way to get new reference values? Can I just run the test macros and take the results as new reference values or do they need to be calculated on a specific system with specific configurations?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:185,safety,test,test,185,I have another question: Several changes of this PR require an adjustment of the reference values of some tests. What is the correct way to get new reference values? Can I just run the test macros and take the results as new reference values or do they need to be calculated on a specific system with specific configurations?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:310,security,configur,configurations,310,I have another question: Several changes of this PR require an adjustment of the reference values of some tests. What is the correct way to get new reference values? Can I just run the test macros and take the results as new reference values or do they need to be calculated on a specific system with specific configurations?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:106,testability,test,tests,106,I have another question: Several changes of this PR require an adjustment of the reference values of some tests. What is the correct way to get new reference values? Can I just run the test macros and take the results as new reference values or do they need to be calculated on a specific system with specific configurations?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:185,testability,test,test,185,I have another question: Several changes of this PR require an adjustment of the reference values of some tests. What is the correct way to get new reference values? Can I just run the test macros and take the results as new reference values or do they need to be calculated on a specific system with specific configurations?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:285,availability,failur,failures,285,"> Can I just run the test macros and take the results as new reference values or do they need to be calculated on a specific system with specific configurations? You should be able to run it on almost any system. If the results changed across systems, we would constantly see a lot of failures.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:146,deployability,configurat,configurations,146,"> Can I just run the test macros and take the results as new reference values or do they need to be calculated on a specific system with specific configurations? You should be able to run it on almost any system. If the results changed across systems, we would constantly see a lot of failures.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:285,deployability,fail,failures,285,"> Can I just run the test macros and take the results as new reference values or do they need to be calculated on a specific system with specific configurations? You should be able to run it on almost any system. If the results changed across systems, we would constantly see a lot of failures.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:146,integrability,configur,configurations,146,"> Can I just run the test macros and take the results as new reference values or do they need to be calculated on a specific system with specific configurations? You should be able to run it on almost any system. If the results changed across systems, we would constantly see a lot of failures.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:116,interoperability,specif,specific,116,"> Can I just run the test macros and take the results as new reference values or do they need to be calculated on a specific system with specific configurations? You should be able to run it on almost any system. If the results changed across systems, we would constantly see a lot of failures.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:137,interoperability,specif,specific,137,"> Can I just run the test macros and take the results as new reference values or do they need to be calculated on a specific system with specific configurations? You should be able to run it on almost any system. If the results changed across systems, we would constantly see a lot of failures.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:146,modifiability,configur,configurations,146,"> Can I just run the test macros and take the results as new reference values or do they need to be calculated on a specific system with specific configurations? You should be able to run it on almost any system. If the results changed across systems, we would constantly see a lot of failures.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:285,performance,failur,failures,285,"> Can I just run the test macros and take the results as new reference values or do they need to be calculated on a specific system with specific configurations? You should be able to run it on almost any system. If the results changed across systems, we would constantly see a lot of failures.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:285,reliability,fail,failures,285,"> Can I just run the test macros and take the results as new reference values or do they need to be calculated on a specific system with specific configurations? You should be able to run it on almost any system. If the results changed across systems, we would constantly see a lot of failures.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:21,safety,test,test,21,"> Can I just run the test macros and take the results as new reference values or do they need to be calculated on a specific system with specific configurations? You should be able to run it on almost any system. If the results changed across systems, we would constantly see a lot of failures.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:146,security,configur,configurations,146,"> Can I just run the test macros and take the results as new reference values or do they need to be calculated on a specific system with specific configurations? You should be able to run it on almost any system. If the results changed across systems, we would constantly see a lot of failures.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:21,testability,test,test,21,"> Can I just run the test macros and take the results as new reference values or do they need to be calculated on a specific system with specific configurations? You should be able to run it on almost any system. If the results changed across systems, we would constantly see a lot of failures.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:527,safety,test,tested,527,"OK, it seems to me this project is getting out of control, since I was not aware of how much is connected to it. However, I still think the feature is something to keep in mind, because I think it would be a very nice and valueble addition for ROOT. Furthermore, I think the implemenataion of TStyle::SetLineCapPS is something we should have in ROOT, since I see no reason why we should have TStyle::SetLineJoinPS, but not TStyle::SetLineCapPS. Maybe it would be better to divide this PR into serveral smaller ones that can be tested more easily. What do you think about it?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:50,security,control,control,50,"OK, it seems to me this project is getting out of control, since I was not aware of how much is connected to it. However, I still think the feature is something to keep in mind, because I think it would be a very nice and valueble addition for ROOT. Furthermore, I think the implemenataion of TStyle::SetLineCapPS is something we should have in ROOT, since I see no reason why we should have TStyle::SetLineJoinPS, but not TStyle::SetLineCapPS. Maybe it would be better to divide this PR into serveral smaller ones that can be tested more easily. What do you think about it?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:50,testability,control,control,50,"OK, it seems to me this project is getting out of control, since I was not aware of how much is connected to it. However, I still think the feature is something to keep in mind, because I think it would be a very nice and valueble addition for ROOT. Furthermore, I think the implemenataion of TStyle::SetLineCapPS is something we should have in ROOT, since I see no reason why we should have TStyle::SetLineJoinPS, but not TStyle::SetLineCapPS. Maybe it would be better to divide this PR into serveral smaller ones that can be tested more easily. What do you think about it?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:527,testability,test,tested,527,"OK, it seems to me this project is getting out of control, since I was not aware of how much is connected to it. However, I still think the feature is something to keep in mind, because I think it would be a very nice and valueble addition for ROOT. Furthermore, I think the implemenataion of TStyle::SetLineCapPS is something we should have in ROOT, since I see no reason why we should have TStyle::SetLineJoinPS, but not TStyle::SetLineCapPS. Maybe it would be better to divide this PR into serveral smaller ones that can be tested more easily. What do you think about it?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:203,testability,simpl,simple,203,Sorry for this late comment. I had some other urgent matters to deal with. My general comment is that the line width is not part of of the marker attributes. Seems to me markers attributes should remain simple. Some markers are also filled polygon. Would you like to apply the fill style to them ? I guess not. I guess the best way to implement what you need is to define new marker types. We are not limited in number. If you want a star with bigger line width we can ad a new marker type. Any way the useful line width is limited and surely smaller than 10.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:203,usability,simpl,simple,203,Sorry for this late comment. I had some other urgent matters to deal with. My general comment is that the line width is not part of of the marker attributes. Seems to me markers attributes should remain simple. Some markers are also filled polygon. Would you like to apply the fill style to them ? I guess not. I guess the best way to implement what you need is to define new marker types. We are not limited in number. If you want a star with bigger line width we can ad a new marker type. Any way the useful line width is limited and surely smaller than 10.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:135,availability,avail,available,135,"Thanks for you reply @couet, I see your point that it's not ideal to define an attribute that is only used by approximatly half of all available styles. The main reason I wanted to have this feature is that I realized that lines with a width of 1 can become badly visible in presentations or on posters which is why I prefer to use line width 2 as default everywhere. For the implementation via the marker styles as you propose I see basically 2 ways to implement this:. 1. At the moment we have marker styles up to 49. One could just start to redefine all existing marker styles where a linewidth makes sense from 50 upwards with a linewidth of 1, 2, 3 ... However, I think this might become confusing if further styles are added in the future, because then there will be no logic behind the numbers and the corresponding markers, although there is not much logic behind the style numbers right now too. 2. One could define it in a way that adding 100 to the marker style corresponds to an increase of the linewidth of 1. As an example the regular + marker with linewidth 1 would be 2, with linewidth 2 it would be 102, with linewidth 3 202 ... I know this would be rather equal to defining a standalone linewidth attribute, but it would allow us to add up to 50 additional marker styles in the future without breaking the logic and I doubt we will have more than 100 different marker styles one day. Since you are the responsible coordinator for the graphics part of ROOT, I think this decision should be up to you. ----------------------------------------------------------------------------------------------------. Could you also comment on the differences in the drawing of markers 3, 5 (and 31) between classes inheriting from TVirtualX and classes inheriting from TVirtualPS? The following picture shows the difference for marker style 3:. ![temp](https://user-images.githubusercontent.com/5320187/72247392-11cb0980-35f5-11ea-941b-b1ef892442e6.jpg). I think the different implementations shou",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:776,deployability,log,logic,776,"Thanks for you reply @couet, I see your point that it's not ideal to define an attribute that is only used by approximatly half of all available styles. The main reason I wanted to have this feature is that I realized that lines with a width of 1 can become badly visible in presentations or on posters which is why I prefer to use line width 2 as default everywhere. For the implementation via the marker styles as you propose I see basically 2 ways to implement this:. 1. At the moment we have marker styles up to 49. One could just start to redefine all existing marker styles where a linewidth makes sense from 50 upwards with a linewidth of 1, 2, 3 ... However, I think this might become confusing if further styles are added in the future, because then there will be no logic behind the numbers and the corresponding markers, although there is not much logic behind the style numbers right now too. 2. One could define it in a way that adding 100 to the marker style corresponds to an increase of the linewidth of 1. As an example the regular + marker with linewidth 1 would be 2, with linewidth 2 it would be 102, with linewidth 3 202 ... I know this would be rather equal to defining a standalone linewidth attribute, but it would allow us to add up to 50 additional marker styles in the future without breaking the logic and I doubt we will have more than 100 different marker styles one day. Since you are the responsible coordinator for the graphics part of ROOT, I think this decision should be up to you. ----------------------------------------------------------------------------------------------------. Could you also comment on the differences in the drawing of markers 3, 5 (and 31) between classes inheriting from TVirtualX and classes inheriting from TVirtualPS? The following picture shows the difference for marker style 3:. ![temp](https://user-images.githubusercontent.com/5320187/72247392-11cb0980-35f5-11ea-941b-b1ef892442e6.jpg). I think the different implementations shou",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:859,deployability,log,logic,859,"Thanks for you reply @couet, I see your point that it's not ideal to define an attribute that is only used by approximatly half of all available styles. The main reason I wanted to have this feature is that I realized that lines with a width of 1 can become badly visible in presentations or on posters which is why I prefer to use line width 2 as default everywhere. For the implementation via the marker styles as you propose I see basically 2 ways to implement this:. 1. At the moment we have marker styles up to 49. One could just start to redefine all existing marker styles where a linewidth makes sense from 50 upwards with a linewidth of 1, 2, 3 ... However, I think this might become confusing if further styles are added in the future, because then there will be no logic behind the numbers and the corresponding markers, although there is not much logic behind the style numbers right now too. 2. One could define it in a way that adding 100 to the marker style corresponds to an increase of the linewidth of 1. As an example the regular + marker with linewidth 1 would be 2, with linewidth 2 it would be 102, with linewidth 3 202 ... I know this would be rather equal to defining a standalone linewidth attribute, but it would allow us to add up to 50 additional marker styles in the future without breaking the logic and I doubt we will have more than 100 different marker styles one day. Since you are the responsible coordinator for the graphics part of ROOT, I think this decision should be up to you. ----------------------------------------------------------------------------------------------------. Could you also comment on the differences in the drawing of markers 3, 5 (and 31) between classes inheriting from TVirtualX and classes inheriting from TVirtualPS? The following picture shows the difference for marker style 3:. ![temp](https://user-images.githubusercontent.com/5320187/72247392-11cb0980-35f5-11ea-941b-b1ef892442e6.jpg). I think the different implementations shou",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:1324,deployability,log,logic,1324,"to have this feature is that I realized that lines with a width of 1 can become badly visible in presentations or on posters which is why I prefer to use line width 2 as default everywhere. For the implementation via the marker styles as you propose I see basically 2 ways to implement this:. 1. At the moment we have marker styles up to 49. One could just start to redefine all existing marker styles where a linewidth makes sense from 50 upwards with a linewidth of 1, 2, 3 ... However, I think this might become confusing if further styles are added in the future, because then there will be no logic behind the numbers and the corresponding markers, although there is not much logic behind the style numbers right now too. 2. One could define it in a way that adding 100 to the marker style corresponds to an increase of the linewidth of 1. As an example the regular + marker with linewidth 1 would be 2, with linewidth 2 it would be 102, with linewidth 3 202 ... I know this would be rather equal to defining a standalone linewidth attribute, but it would allow us to add up to 50 additional marker styles in the future without breaking the logic and I doubt we will have more than 100 different marker styles one day. Since you are the responsible coordinator for the graphics part of ROOT, I think this decision should be up to you. ----------------------------------------------------------------------------------------------------. Could you also comment on the differences in the drawing of markers 3, 5 (and 31) between classes inheriting from TVirtualX and classes inheriting from TVirtualPS? The following picture shows the difference for marker style 3:. ![temp](https://user-images.githubusercontent.com/5320187/72247392-11cb0980-35f5-11ea-941b-b1ef892442e6.jpg). I think the different implementations should be unified so that markers look the same everywhere. From my point of view the implementation of TVirtualX classes seems better, but I would like to have your opinion on this.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:1669,energy efficiency,draw,drawing,1669,"to have this feature is that I realized that lines with a width of 1 can become badly visible in presentations or on posters which is why I prefer to use line width 2 as default everywhere. For the implementation via the marker styles as you propose I see basically 2 ways to implement this:. 1. At the moment we have marker styles up to 49. One could just start to redefine all existing marker styles where a linewidth makes sense from 50 upwards with a linewidth of 1, 2, 3 ... However, I think this might become confusing if further styles are added in the future, because then there will be no logic behind the numbers and the corresponding markers, although there is not much logic behind the style numbers right now too. 2. One could define it in a way that adding 100 to the marker style corresponds to an increase of the linewidth of 1. As an example the regular + marker with linewidth 1 would be 2, with linewidth 2 it would be 102, with linewidth 3 202 ... I know this would be rather equal to defining a standalone linewidth attribute, but it would allow us to add up to 50 additional marker styles in the future without breaking the logic and I doubt we will have more than 100 different marker styles one day. Since you are the responsible coordinator for the graphics part of ROOT, I think this decision should be up to you. ----------------------------------------------------------------------------------------------------. Could you also comment on the differences in the drawing of markers 3, 5 (and 31) between classes inheriting from TVirtualX and classes inheriting from TVirtualPS? The following picture shows the difference for marker style 3:. ![temp](https://user-images.githubusercontent.com/5320187/72247392-11cb0980-35f5-11ea-941b-b1ef892442e6.jpg). I think the different implementations should be unified so that markers look the same everywhere. From my point of view the implementation of TVirtualX classes seems better, but I would like to have your opinion on this.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:1432,interoperability,coordinat,coordinator,1432,"to have this feature is that I realized that lines with a width of 1 can become badly visible in presentations or on posters which is why I prefer to use line width 2 as default everywhere. For the implementation via the marker styles as you propose I see basically 2 ways to implement this:. 1. At the moment we have marker styles up to 49. One could just start to redefine all existing marker styles where a linewidth makes sense from 50 upwards with a linewidth of 1, 2, 3 ... However, I think this might become confusing if further styles are added in the future, because then there will be no logic behind the numbers and the corresponding markers, although there is not much logic behind the style numbers right now too. 2. One could define it in a way that adding 100 to the marker style corresponds to an increase of the linewidth of 1. As an example the regular + marker with linewidth 1 would be 2, with linewidth 2 it would be 102, with linewidth 3 202 ... I know this would be rather equal to defining a standalone linewidth attribute, but it would allow us to add up to 50 additional marker styles in the future without breaking the logic and I doubt we will have more than 100 different marker styles one day. Since you are the responsible coordinator for the graphics part of ROOT, I think this decision should be up to you. ----------------------------------------------------------------------------------------------------. Could you also comment on the differences in the drawing of markers 3, 5 (and 31) between classes inheriting from TVirtualX and classes inheriting from TVirtualPS? The following picture shows the difference for marker style 3:. ![temp](https://user-images.githubusercontent.com/5320187/72247392-11cb0980-35f5-11ea-941b-b1ef892442e6.jpg). I think the different implementations should be unified so that markers look the same everywhere. From my point of view the implementation of TVirtualX classes seems better, but I would like to have your opinion on this.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:1718,modifiability,inherit,inheriting,1718,"to have this feature is that I realized that lines with a width of 1 can become badly visible in presentations or on posters which is why I prefer to use line width 2 as default everywhere. For the implementation via the marker styles as you propose I see basically 2 ways to implement this:. 1. At the moment we have marker styles up to 49. One could just start to redefine all existing marker styles where a linewidth makes sense from 50 upwards with a linewidth of 1, 2, 3 ... However, I think this might become confusing if further styles are added in the future, because then there will be no logic behind the numbers and the corresponding markers, although there is not much logic behind the style numbers right now too. 2. One could define it in a way that adding 100 to the marker style corresponds to an increase of the linewidth of 1. As an example the regular + marker with linewidth 1 would be 2, with linewidth 2 it would be 102, with linewidth 3 202 ... I know this would be rather equal to defining a standalone linewidth attribute, but it would allow us to add up to 50 additional marker styles in the future without breaking the logic and I doubt we will have more than 100 different marker styles one day. Since you are the responsible coordinator for the graphics part of ROOT, I think this decision should be up to you. ----------------------------------------------------------------------------------------------------. Could you also comment on the differences in the drawing of markers 3, 5 (and 31) between classes inheriting from TVirtualX and classes inheriting from TVirtualPS? The following picture shows the difference for marker style 3:. ![temp](https://user-images.githubusercontent.com/5320187/72247392-11cb0980-35f5-11ea-941b-b1ef892442e6.jpg). I think the different implementations should be unified so that markers look the same everywhere. From my point of view the implementation of TVirtualX classes seems better, but I would like to have your opinion on this.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:1756,modifiability,inherit,inheriting,1756,"to have this feature is that I realized that lines with a width of 1 can become badly visible in presentations or on posters which is why I prefer to use line width 2 as default everywhere. For the implementation via the marker styles as you propose I see basically 2 ways to implement this:. 1. At the moment we have marker styles up to 49. One could just start to redefine all existing marker styles where a linewidth makes sense from 50 upwards with a linewidth of 1, 2, 3 ... However, I think this might become confusing if further styles are added in the future, because then there will be no logic behind the numbers and the corresponding markers, although there is not much logic behind the style numbers right now too. 2. One could define it in a way that adding 100 to the marker style corresponds to an increase of the linewidth of 1. As an example the regular + marker with linewidth 1 would be 2, with linewidth 2 it would be 102, with linewidth 3 202 ... I know this would be rather equal to defining a standalone linewidth attribute, but it would allow us to add up to 50 additional marker styles in the future without breaking the logic and I doubt we will have more than 100 different marker styles one day. Since you are the responsible coordinator for the graphics part of ROOT, I think this decision should be up to you. ----------------------------------------------------------------------------------------------------. Could you also comment on the differences in the drawing of markers 3, 5 (and 31) between classes inheriting from TVirtualX and classes inheriting from TVirtualPS? The following picture shows the difference for marker style 3:. ![temp](https://user-images.githubusercontent.com/5320187/72247392-11cb0980-35f5-11ea-941b-b1ef892442e6.jpg). I think the different implementations should be unified so that markers look the same everywhere. From my point of view the implementation of TVirtualX classes seems better, but I would like to have your opinion on this.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:135,reliability,availab,available,135,"Thanks for you reply @couet, I see your point that it's not ideal to define an attribute that is only used by approximatly half of all available styles. The main reason I wanted to have this feature is that I realized that lines with a width of 1 can become badly visible in presentations or on posters which is why I prefer to use line width 2 as default everywhere. For the implementation via the marker styles as you propose I see basically 2 ways to implement this:. 1. At the moment we have marker styles up to 49. One could just start to redefine all existing marker styles where a linewidth makes sense from 50 upwards with a linewidth of 1, 2, 3 ... However, I think this might become confusing if further styles are added in the future, because then there will be no logic behind the numbers and the corresponding markers, although there is not much logic behind the style numbers right now too. 2. One could define it in a way that adding 100 to the marker style corresponds to an increase of the linewidth of 1. As an example the regular + marker with linewidth 1 would be 2, with linewidth 2 it would be 102, with linewidth 3 202 ... I know this would be rather equal to defining a standalone linewidth attribute, but it would allow us to add up to 50 additional marker styles in the future without breaking the logic and I doubt we will have more than 100 different marker styles one day. Since you are the responsible coordinator for the graphics part of ROOT, I think this decision should be up to you. ----------------------------------------------------------------------------------------------------. Could you also comment on the differences in the drawing of markers 3, 5 (and 31) between classes inheriting from TVirtualX and classes inheriting from TVirtualPS? The following picture shows the difference for marker style 3:. ![temp](https://user-images.githubusercontent.com/5320187/72247392-11cb0980-35f5-11ea-941b-b1ef892442e6.jpg). I think the different implementations shou",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:135,safety,avail,available,135,"Thanks for you reply @couet, I see your point that it's not ideal to define an attribute that is only used by approximatly half of all available styles. The main reason I wanted to have this feature is that I realized that lines with a width of 1 can become badly visible in presentations or on posters which is why I prefer to use line width 2 as default everywhere. For the implementation via the marker styles as you propose I see basically 2 ways to implement this:. 1. At the moment we have marker styles up to 49. One could just start to redefine all existing marker styles where a linewidth makes sense from 50 upwards with a linewidth of 1, 2, 3 ... However, I think this might become confusing if further styles are added in the future, because then there will be no logic behind the numbers and the corresponding markers, although there is not much logic behind the style numbers right now too. 2. One could define it in a way that adding 100 to the marker style corresponds to an increase of the linewidth of 1. As an example the regular + marker with linewidth 1 would be 2, with linewidth 2 it would be 102, with linewidth 3 202 ... I know this would be rather equal to defining a standalone linewidth attribute, but it would allow us to add up to 50 additional marker styles in the future without breaking the logic and I doubt we will have more than 100 different marker styles one day. Since you are the responsible coordinator for the graphics part of ROOT, I think this decision should be up to you. ----------------------------------------------------------------------------------------------------. Could you also comment on the differences in the drawing of markers 3, 5 (and 31) between classes inheriting from TVirtualX and classes inheriting from TVirtualPS? The following picture shows the difference for marker style 3:. ![temp](https://user-images.githubusercontent.com/5320187/72247392-11cb0980-35f5-11ea-941b-b1ef892442e6.jpg). I think the different implementations shou",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:776,safety,log,logic,776,"Thanks for you reply @couet, I see your point that it's not ideal to define an attribute that is only used by approximatly half of all available styles. The main reason I wanted to have this feature is that I realized that lines with a width of 1 can become badly visible in presentations or on posters which is why I prefer to use line width 2 as default everywhere. For the implementation via the marker styles as you propose I see basically 2 ways to implement this:. 1. At the moment we have marker styles up to 49. One could just start to redefine all existing marker styles where a linewidth makes sense from 50 upwards with a linewidth of 1, 2, 3 ... However, I think this might become confusing if further styles are added in the future, because then there will be no logic behind the numbers and the corresponding markers, although there is not much logic behind the style numbers right now too. 2. One could define it in a way that adding 100 to the marker style corresponds to an increase of the linewidth of 1. As an example the regular + marker with linewidth 1 would be 2, with linewidth 2 it would be 102, with linewidth 3 202 ... I know this would be rather equal to defining a standalone linewidth attribute, but it would allow us to add up to 50 additional marker styles in the future without breaking the logic and I doubt we will have more than 100 different marker styles one day. Since you are the responsible coordinator for the graphics part of ROOT, I think this decision should be up to you. ----------------------------------------------------------------------------------------------------. Could you also comment on the differences in the drawing of markers 3, 5 (and 31) between classes inheriting from TVirtualX and classes inheriting from TVirtualPS? The following picture shows the difference for marker style 3:. ![temp](https://user-images.githubusercontent.com/5320187/72247392-11cb0980-35f5-11ea-941b-b1ef892442e6.jpg). I think the different implementations shou",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:859,safety,log,logic,859,"Thanks for you reply @couet, I see your point that it's not ideal to define an attribute that is only used by approximatly half of all available styles. The main reason I wanted to have this feature is that I realized that lines with a width of 1 can become badly visible in presentations or on posters which is why I prefer to use line width 2 as default everywhere. For the implementation via the marker styles as you propose I see basically 2 ways to implement this:. 1. At the moment we have marker styles up to 49. One could just start to redefine all existing marker styles where a linewidth makes sense from 50 upwards with a linewidth of 1, 2, 3 ... However, I think this might become confusing if further styles are added in the future, because then there will be no logic behind the numbers and the corresponding markers, although there is not much logic behind the style numbers right now too. 2. One could define it in a way that adding 100 to the marker style corresponds to an increase of the linewidth of 1. As an example the regular + marker with linewidth 1 would be 2, with linewidth 2 it would be 102, with linewidth 3 202 ... I know this would be rather equal to defining a standalone linewidth attribute, but it would allow us to add up to 50 additional marker styles in the future without breaking the logic and I doubt we will have more than 100 different marker styles one day. Since you are the responsible coordinator for the graphics part of ROOT, I think this decision should be up to you. ----------------------------------------------------------------------------------------------------. Could you also comment on the differences in the drawing of markers 3, 5 (and 31) between classes inheriting from TVirtualX and classes inheriting from TVirtualPS? The following picture shows the difference for marker style 3:. ![temp](https://user-images.githubusercontent.com/5320187/72247392-11cb0980-35f5-11ea-941b-b1ef892442e6.jpg). I think the different implementations shou",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:1324,safety,log,logic,1324,"to have this feature is that I realized that lines with a width of 1 can become badly visible in presentations or on posters which is why I prefer to use line width 2 as default everywhere. For the implementation via the marker styles as you propose I see basically 2 ways to implement this:. 1. At the moment we have marker styles up to 49. One could just start to redefine all existing marker styles where a linewidth makes sense from 50 upwards with a linewidth of 1, 2, 3 ... However, I think this might become confusing if further styles are added in the future, because then there will be no logic behind the numbers and the corresponding markers, although there is not much logic behind the style numbers right now too. 2. One could define it in a way that adding 100 to the marker style corresponds to an increase of the linewidth of 1. As an example the regular + marker with linewidth 1 would be 2, with linewidth 2 it would be 102, with linewidth 3 202 ... I know this would be rather equal to defining a standalone linewidth attribute, but it would allow us to add up to 50 additional marker styles in the future without breaking the logic and I doubt we will have more than 100 different marker styles one day. Since you are the responsible coordinator for the graphics part of ROOT, I think this decision should be up to you. ----------------------------------------------------------------------------------------------------. Could you also comment on the differences in the drawing of markers 3, 5 (and 31) between classes inheriting from TVirtualX and classes inheriting from TVirtualPS? The following picture shows the difference for marker style 3:. ![temp](https://user-images.githubusercontent.com/5320187/72247392-11cb0980-35f5-11ea-941b-b1ef892442e6.jpg). I think the different implementations should be unified so that markers look the same everywhere. From my point of view the implementation of TVirtualX classes seems better, but I would like to have your opinion on this.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:135,security,availab,available,135,"Thanks for you reply @couet, I see your point that it's not ideal to define an attribute that is only used by approximatly half of all available styles. The main reason I wanted to have this feature is that I realized that lines with a width of 1 can become badly visible in presentations or on posters which is why I prefer to use line width 2 as default everywhere. For the implementation via the marker styles as you propose I see basically 2 ways to implement this:. 1. At the moment we have marker styles up to 49. One could just start to redefine all existing marker styles where a linewidth makes sense from 50 upwards with a linewidth of 1, 2, 3 ... However, I think this might become confusing if further styles are added in the future, because then there will be no logic behind the numbers and the corresponding markers, although there is not much logic behind the style numbers right now too. 2. One could define it in a way that adding 100 to the marker style corresponds to an increase of the linewidth of 1. As an example the regular + marker with linewidth 1 would be 2, with linewidth 2 it would be 102, with linewidth 3 202 ... I know this would be rather equal to defining a standalone linewidth attribute, but it would allow us to add up to 50 additional marker styles in the future without breaking the logic and I doubt we will have more than 100 different marker styles one day. Since you are the responsible coordinator for the graphics part of ROOT, I think this decision should be up to you. ----------------------------------------------------------------------------------------------------. Could you also comment on the differences in the drawing of markers 3, 5 (and 31) between classes inheriting from TVirtualX and classes inheriting from TVirtualPS? The following picture shows the difference for marker style 3:. ![temp](https://user-images.githubusercontent.com/5320187/72247392-11cb0980-35f5-11ea-941b-b1ef892442e6.jpg). I think the different implementations shou",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:776,security,log,logic,776,"Thanks for you reply @couet, I see your point that it's not ideal to define an attribute that is only used by approximatly half of all available styles. The main reason I wanted to have this feature is that I realized that lines with a width of 1 can become badly visible in presentations or on posters which is why I prefer to use line width 2 as default everywhere. For the implementation via the marker styles as you propose I see basically 2 ways to implement this:. 1. At the moment we have marker styles up to 49. One could just start to redefine all existing marker styles where a linewidth makes sense from 50 upwards with a linewidth of 1, 2, 3 ... However, I think this might become confusing if further styles are added in the future, because then there will be no logic behind the numbers and the corresponding markers, although there is not much logic behind the style numbers right now too. 2. One could define it in a way that adding 100 to the marker style corresponds to an increase of the linewidth of 1. As an example the regular + marker with linewidth 1 would be 2, with linewidth 2 it would be 102, with linewidth 3 202 ... I know this would be rather equal to defining a standalone linewidth attribute, but it would allow us to add up to 50 additional marker styles in the future without breaking the logic and I doubt we will have more than 100 different marker styles one day. Since you are the responsible coordinator for the graphics part of ROOT, I think this decision should be up to you. ----------------------------------------------------------------------------------------------------. Could you also comment on the differences in the drawing of markers 3, 5 (and 31) between classes inheriting from TVirtualX and classes inheriting from TVirtualPS? The following picture shows the difference for marker style 3:. ![temp](https://user-images.githubusercontent.com/5320187/72247392-11cb0980-35f5-11ea-941b-b1ef892442e6.jpg). I think the different implementations shou",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:859,security,log,logic,859,"Thanks for you reply @couet, I see your point that it's not ideal to define an attribute that is only used by approximatly half of all available styles. The main reason I wanted to have this feature is that I realized that lines with a width of 1 can become badly visible in presentations or on posters which is why I prefer to use line width 2 as default everywhere. For the implementation via the marker styles as you propose I see basically 2 ways to implement this:. 1. At the moment we have marker styles up to 49. One could just start to redefine all existing marker styles where a linewidth makes sense from 50 upwards with a linewidth of 1, 2, 3 ... However, I think this might become confusing if further styles are added in the future, because then there will be no logic behind the numbers and the corresponding markers, although there is not much logic behind the style numbers right now too. 2. One could define it in a way that adding 100 to the marker style corresponds to an increase of the linewidth of 1. As an example the regular + marker with linewidth 1 would be 2, with linewidth 2 it would be 102, with linewidth 3 202 ... I know this would be rather equal to defining a standalone linewidth attribute, but it would allow us to add up to 50 additional marker styles in the future without breaking the logic and I doubt we will have more than 100 different marker styles one day. Since you are the responsible coordinator for the graphics part of ROOT, I think this decision should be up to you. ----------------------------------------------------------------------------------------------------. Could you also comment on the differences in the drawing of markers 3, 5 (and 31) between classes inheriting from TVirtualX and classes inheriting from TVirtualPS? The following picture shows the difference for marker style 3:. ![temp](https://user-images.githubusercontent.com/5320187/72247392-11cb0980-35f5-11ea-941b-b1ef892442e6.jpg). I think the different implementations shou",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:1324,security,log,logic,1324,"to have this feature is that I realized that lines with a width of 1 can become badly visible in presentations or on posters which is why I prefer to use line width 2 as default everywhere. For the implementation via the marker styles as you propose I see basically 2 ways to implement this:. 1. At the moment we have marker styles up to 49. One could just start to redefine all existing marker styles where a linewidth makes sense from 50 upwards with a linewidth of 1, 2, 3 ... However, I think this might become confusing if further styles are added in the future, because then there will be no logic behind the numbers and the corresponding markers, although there is not much logic behind the style numbers right now too. 2. One could define it in a way that adding 100 to the marker style corresponds to an increase of the linewidth of 1. As an example the regular + marker with linewidth 1 would be 2, with linewidth 2 it would be 102, with linewidth 3 202 ... I know this would be rather equal to defining a standalone linewidth attribute, but it would allow us to add up to 50 additional marker styles in the future without breaking the logic and I doubt we will have more than 100 different marker styles one day. Since you are the responsible coordinator for the graphics part of ROOT, I think this decision should be up to you. ----------------------------------------------------------------------------------------------------. Could you also comment on the differences in the drawing of markers 3, 5 (and 31) between classes inheriting from TVirtualX and classes inheriting from TVirtualPS? The following picture shows the difference for marker style 3:. ![temp](https://user-images.githubusercontent.com/5320187/72247392-11cb0980-35f5-11ea-941b-b1ef892442e6.jpg). I think the different implementations should be unified so that markers look the same everywhere. From my point of view the implementation of TVirtualX classes seems better, but I would like to have your opinion on this.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:776,testability,log,logic,776,"Thanks for you reply @couet, I see your point that it's not ideal to define an attribute that is only used by approximatly half of all available styles. The main reason I wanted to have this feature is that I realized that lines with a width of 1 can become badly visible in presentations or on posters which is why I prefer to use line width 2 as default everywhere. For the implementation via the marker styles as you propose I see basically 2 ways to implement this:. 1. At the moment we have marker styles up to 49. One could just start to redefine all existing marker styles where a linewidth makes sense from 50 upwards with a linewidth of 1, 2, 3 ... However, I think this might become confusing if further styles are added in the future, because then there will be no logic behind the numbers and the corresponding markers, although there is not much logic behind the style numbers right now too. 2. One could define it in a way that adding 100 to the marker style corresponds to an increase of the linewidth of 1. As an example the regular + marker with linewidth 1 would be 2, with linewidth 2 it would be 102, with linewidth 3 202 ... I know this would be rather equal to defining a standalone linewidth attribute, but it would allow us to add up to 50 additional marker styles in the future without breaking the logic and I doubt we will have more than 100 different marker styles one day. Since you are the responsible coordinator for the graphics part of ROOT, I think this decision should be up to you. ----------------------------------------------------------------------------------------------------. Could you also comment on the differences in the drawing of markers 3, 5 (and 31) between classes inheriting from TVirtualX and classes inheriting from TVirtualPS? The following picture shows the difference for marker style 3:. ![temp](https://user-images.githubusercontent.com/5320187/72247392-11cb0980-35f5-11ea-941b-b1ef892442e6.jpg). I think the different implementations shou",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:859,testability,log,logic,859,"Thanks for you reply @couet, I see your point that it's not ideal to define an attribute that is only used by approximatly half of all available styles. The main reason I wanted to have this feature is that I realized that lines with a width of 1 can become badly visible in presentations or on posters which is why I prefer to use line width 2 as default everywhere. For the implementation via the marker styles as you propose I see basically 2 ways to implement this:. 1. At the moment we have marker styles up to 49. One could just start to redefine all existing marker styles where a linewidth makes sense from 50 upwards with a linewidth of 1, 2, 3 ... However, I think this might become confusing if further styles are added in the future, because then there will be no logic behind the numbers and the corresponding markers, although there is not much logic behind the style numbers right now too. 2. One could define it in a way that adding 100 to the marker style corresponds to an increase of the linewidth of 1. As an example the regular + marker with linewidth 1 would be 2, with linewidth 2 it would be 102, with linewidth 3 202 ... I know this would be rather equal to defining a standalone linewidth attribute, but it would allow us to add up to 50 additional marker styles in the future without breaking the logic and I doubt we will have more than 100 different marker styles one day. Since you are the responsible coordinator for the graphics part of ROOT, I think this decision should be up to you. ----------------------------------------------------------------------------------------------------. Could you also comment on the differences in the drawing of markers 3, 5 (and 31) between classes inheriting from TVirtualX and classes inheriting from TVirtualPS? The following picture shows the difference for marker style 3:. ![temp](https://user-images.githubusercontent.com/5320187/72247392-11cb0980-35f5-11ea-941b-b1ef892442e6.jpg). I think the different implementations shou",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:1324,testability,log,logic,1324,"to have this feature is that I realized that lines with a width of 1 can become badly visible in presentations or on posters which is why I prefer to use line width 2 as default everywhere. For the implementation via the marker styles as you propose I see basically 2 ways to implement this:. 1. At the moment we have marker styles up to 49. One could just start to redefine all existing marker styles where a linewidth makes sense from 50 upwards with a linewidth of 1, 2, 3 ... However, I think this might become confusing if further styles are added in the future, because then there will be no logic behind the numbers and the corresponding markers, although there is not much logic behind the style numbers right now too. 2. One could define it in a way that adding 100 to the marker style corresponds to an increase of the linewidth of 1. As an example the regular + marker with linewidth 1 would be 2, with linewidth 2 it would be 102, with linewidth 3 202 ... I know this would be rather equal to defining a standalone linewidth attribute, but it would allow us to add up to 50 additional marker styles in the future without breaking the logic and I doubt we will have more than 100 different marker styles one day. Since you are the responsible coordinator for the graphics part of ROOT, I think this decision should be up to you. ----------------------------------------------------------------------------------------------------. Could you also comment on the differences in the drawing of markers 3, 5 (and 31) between classes inheriting from TVirtualX and classes inheriting from TVirtualPS? The following picture shows the difference for marker style 3:. ![temp](https://user-images.githubusercontent.com/5320187/72247392-11cb0980-35f5-11ea-941b-b1ef892442e6.jpg). I think the different implementations should be unified so that markers look the same everywhere. From my point of view the implementation of TVirtualX classes seems better, but I would like to have your opinion on this.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:318,usability,prefer,prefer,318,"Thanks for you reply @couet, I see your point that it's not ideal to define an attribute that is only used by approximatly half of all available styles. The main reason I wanted to have this feature is that I realized that lines with a width of 1 can become badly visible in presentations or on posters which is why I prefer to use line width 2 as default everywhere. For the implementation via the marker styles as you propose I see basically 2 ways to implement this:. 1. At the moment we have marker styles up to 49. One could just start to redefine all existing marker styles where a linewidth makes sense from 50 upwards with a linewidth of 1, 2, 3 ... However, I think this might become confusing if further styles are added in the future, because then there will be no logic behind the numbers and the corresponding markers, although there is not much logic behind the style numbers right now too. 2. One could define it in a way that adding 100 to the marker style corresponds to an increase of the linewidth of 1. As an example the regular + marker with linewidth 1 would be 2, with linewidth 2 it would be 102, with linewidth 3 202 ... I know this would be rather equal to defining a standalone linewidth attribute, but it would allow us to add up to 50 additional marker styles in the future without breaking the logic and I doubt we will have more than 100 different marker styles one day. Since you are the responsible coordinator for the graphics part of ROOT, I think this decision should be up to you. ----------------------------------------------------------------------------------------------------. Could you also comment on the differences in the drawing of markers 3, 5 (and 31) between classes inheriting from TVirtualX and classes inheriting from TVirtualPS? The following picture shows the difference for marker style 3:. ![temp](https://user-images.githubusercontent.com/5320187/72247392-11cb0980-35f5-11ea-941b-b1ef892442e6.jpg). I think the different implementations shou",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:1864,usability,user,user-images,1864,"to have this feature is that I realized that lines with a width of 1 can become badly visible in presentations or on posters which is why I prefer to use line width 2 as default everywhere. For the implementation via the marker styles as you propose I see basically 2 ways to implement this:. 1. At the moment we have marker styles up to 49. One could just start to redefine all existing marker styles where a linewidth makes sense from 50 upwards with a linewidth of 1, 2, 3 ... However, I think this might become confusing if further styles are added in the future, because then there will be no logic behind the numbers and the corresponding markers, although there is not much logic behind the style numbers right now too. 2. One could define it in a way that adding 100 to the marker style corresponds to an increase of the linewidth of 1. As an example the regular + marker with linewidth 1 would be 2, with linewidth 2 it would be 102, with linewidth 3 202 ... I know this would be rather equal to defining a standalone linewidth attribute, but it would allow us to add up to 50 additional marker styles in the future without breaking the logic and I doubt we will have more than 100 different marker styles one day. Since you are the responsible coordinator for the graphics part of ROOT, I think this decision should be up to you. ----------------------------------------------------------------------------------------------------. Could you also comment on the differences in the drawing of markers 3, 5 (and 31) between classes inheriting from TVirtualX and classes inheriting from TVirtualPS? The following picture shows the difference for marker style 3:. ![temp](https://user-images.githubusercontent.com/5320187/72247392-11cb0980-35f5-11ea-941b-b1ef892442e6.jpg). I think the different implementations should be unified so that markers look the same everywhere. From my point of view the implementation of TVirtualX classes seems better, but I would like to have your opinion on this.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:367,reliability,doe,does,367,"@Triple-S . I see your points about posters. One simple way to bypass this issue is or course to use filled markers with seems to me are better any way. But I can understand you need hollow markers. As you may need only a few line widths may be 2, 3 and 4 simply adding new makers makes sense. Given the usually small size of markers, having any possible line widths does not make sense (you will rapidly get big ""blobs"" not understandable). So I am not sure a coding convention is necessary. The different look of the maker 3 should be fixed.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:49,testability,simpl,simple,49,"@Triple-S . I see your points about posters. One simple way to bypass this issue is or course to use filled markers with seems to me are better any way. But I can understand you need hollow markers. As you may need only a few line widths may be 2, 3 and 4 simply adding new makers makes sense. Given the usually small size of markers, having any possible line widths does not make sense (you will rapidly get big ""blobs"" not understandable). So I am not sure a coding convention is necessary. The different look of the maker 3 should be fixed.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:163,testability,understand,understand,163,"@Triple-S . I see your points about posters. One simple way to bypass this issue is or course to use filled markers with seems to me are better any way. But I can understand you need hollow markers. As you may need only a few line widths may be 2, 3 and 4 simply adding new makers makes sense. Given the usually small size of markers, having any possible line widths does not make sense (you will rapidly get big ""blobs"" not understandable). So I am not sure a coding convention is necessary. The different look of the maker 3 should be fixed.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:256,testability,simpl,simply,256,"@Triple-S . I see your points about posters. One simple way to bypass this issue is or course to use filled markers with seems to me are better any way. But I can understand you need hollow markers. As you may need only a few line widths may be 2, 3 and 4 simply adding new makers makes sense. Given the usually small size of markers, having any possible line widths does not make sense (you will rapidly get big ""blobs"" not understandable). So I am not sure a coding convention is necessary. The different look of the maker 3 should be fixed.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:425,testability,understand,understandable,425,"@Triple-S . I see your points about posters. One simple way to bypass this issue is or course to use filled markers with seems to me are better any way. But I can understand you need hollow markers. As you may need only a few line widths may be 2, 3 and 4 simply adding new makers makes sense. Given the usually small size of markers, having any possible line widths does not make sense (you will rapidly get big ""blobs"" not understandable). So I am not sure a coding convention is necessary. The different look of the maker 3 should be fixed.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:49,usability,simpl,simple,49,"@Triple-S . I see your points about posters. One simple way to bypass this issue is or course to use filled markers with seems to me are better any way. But I can understand you need hollow markers. As you may need only a few line widths may be 2, 3 and 4 simply adding new makers makes sense. Given the usually small size of markers, having any possible line widths does not make sense (you will rapidly get big ""blobs"" not understandable). So I am not sure a coding convention is necessary. The different look of the maker 3 should be fixed.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:256,usability,simpl,simply,256,"@Triple-S . I see your points about posters. One simple way to bypass this issue is or course to use filled markers with seems to me are better any way. But I can understand you need hollow markers. As you may need only a few line widths may be 2, 3 and 4 simply adding new makers makes sense. Given the usually small size of markers, having any possible line widths does not make sense (you will rapidly get big ""blobs"" not understandable). So I am not sure a coding convention is necessary. The different look of the maker 3 should be fixed.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:126,energy efficiency,draw,drawing,126,"Alright, then I know how to go on. I will close this PR here and split it into 3 PRs each dedicated to one feature:. 1. Unify drawing of markers 3, 5 (and 31) #4762 . 2. Implementation of TStyle::SetLineCapPS #4765 . 3. Additional markers with thicker lines #4772",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4721:42,usability,close,close,42,"Alright, then I know how to go on. I will close this PR here and split it into 3 PRs each dedicated to one feature:. 1. Unify drawing of markers 3, 5 (and 31) #4762 . 2. Implementation of TStyle::SetLineCapPS #4765 . 3. Additional markers with thicker lines #4772",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4721
https://github.com/root-project/root/pull/4722:250,availability,avail,available,250,"> is a custom memory allocator used in ROOT to output more information about memory pressure. This is not the only purpose. The other purpose is to allow the use of shared memory for inter process communication. > the functionality of libNew is only available in rootn.exe and libNew is statically linked to the binary. This is not the only usage. > we should make it a static library. This is backward incompatible. Having it as a static library means that you must link libNew against every single library that will be using it (as opposed to allowing other possible way to use it, including LD_PRELOAD). Besides, having it as a static library does eliminate the broken case described above (it is just delayed until a library linked against libNew is loaded). That said, libNew should be excluded from any auto-loading mechanism and should only be loaded/linked explicitly by the user.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:21,energy efficiency,alloc,allocator,21,"> is a custom memory allocator used in ROOT to output more information about memory pressure. This is not the only purpose. The other purpose is to allow the use of shared memory for inter process communication. > the functionality of libNew is only available in rootn.exe and libNew is statically linked to the binary. This is not the only usage. > we should make it a static library. This is backward incompatible. Having it as a static library means that you must link libNew against every single library that will be using it (as opposed to allowing other possible way to use it, including LD_PRELOAD). Besides, having it as a static library does eliminate the broken case described above (it is just delayed until a library linked against libNew is loaded). That said, libNew should be excluded from any auto-loading mechanism and should only be loaded/linked explicitly by the user.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:754,energy efficiency,load,loaded,754,"> is a custom memory allocator used in ROOT to output more information about memory pressure. This is not the only purpose. The other purpose is to allow the use of shared memory for inter process communication. > the functionality of libNew is only available in rootn.exe and libNew is statically linked to the binary. This is not the only usage. > we should make it a static library. This is backward incompatible. Having it as a static library means that you must link libNew against every single library that will be using it (as opposed to allowing other possible way to use it, including LD_PRELOAD). Besides, having it as a static library does eliminate the broken case described above (it is just delayed until a library linked against libNew is loaded). That said, libNew should be excluded from any auto-loading mechanism and should only be loaded/linked explicitly by the user.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:814,energy efficiency,load,loading,814,"> is a custom memory allocator used in ROOT to output more information about memory pressure. This is not the only purpose. The other purpose is to allow the use of shared memory for inter process communication. > the functionality of libNew is only available in rootn.exe and libNew is statically linked to the binary. This is not the only usage. > we should make it a static library. This is backward incompatible. Having it as a static library means that you must link libNew against every single library that will be using it (as opposed to allowing other possible way to use it, including LD_PRELOAD). Besides, having it as a static library does eliminate the broken case described above (it is just delayed until a library linked against libNew is loaded). That said, libNew should be excluded from any auto-loading mechanism and should only be loaded/linked explicitly by the user.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:851,energy efficiency,load,loaded,851,"> is a custom memory allocator used in ROOT to output more information about memory pressure. This is not the only purpose. The other purpose is to allow the use of shared memory for inter process communication. > the functionality of libNew is only available in rootn.exe and libNew is statically linked to the binary. This is not the only usage. > we should make it a static library. This is backward incompatible. Having it as a static library means that you must link libNew against every single library that will be using it (as opposed to allowing other possible way to use it, including LD_PRELOAD). Besides, having it as a static library does eliminate the broken case described above (it is just delayed until a library linked against libNew is loaded). That said, libNew should be excluded from any auto-loading mechanism and should only be loaded/linked explicitly by the user.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:165,interoperability,share,shared,165,"> is a custom memory allocator used in ROOT to output more information about memory pressure. This is not the only purpose. The other purpose is to allow the use of shared memory for inter process communication. > the functionality of libNew is only available in rootn.exe and libNew is statically linked to the binary. This is not the only usage. > we should make it a static library. This is backward incompatible. Having it as a static library means that you must link libNew against every single library that will be using it (as opposed to allowing other possible way to use it, including LD_PRELOAD). Besides, having it as a static library does eliminate the broken case described above (it is just delayed until a library linked against libNew is loaded). That said, libNew should be excluded from any auto-loading mechanism and should only be loaded/linked explicitly by the user.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:403,interoperability,incompatib,incompatible,403,"> is a custom memory allocator used in ROOT to output more information about memory pressure. This is not the only purpose. The other purpose is to allow the use of shared memory for inter process communication. > the functionality of libNew is only available in rootn.exe and libNew is statically linked to the binary. This is not the only usage. > we should make it a static library. This is backward incompatible. Having it as a static library means that you must link libNew against every single library that will be using it (as opposed to allowing other possible way to use it, including LD_PRELOAD). Besides, having it as a static library does eliminate the broken case described above (it is just delayed until a library linked against libNew is loaded). That said, libNew should be excluded from any auto-loading mechanism and should only be loaded/linked explicitly by the user.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:14,performance,memor,memory,14,"> is a custom memory allocator used in ROOT to output more information about memory pressure. This is not the only purpose. The other purpose is to allow the use of shared memory for inter process communication. > the functionality of libNew is only available in rootn.exe and libNew is statically linked to the binary. This is not the only usage. > we should make it a static library. This is backward incompatible. Having it as a static library means that you must link libNew against every single library that will be using it (as opposed to allowing other possible way to use it, including LD_PRELOAD). Besides, having it as a static library does eliminate the broken case described above (it is just delayed until a library linked against libNew is loaded). That said, libNew should be excluded from any auto-loading mechanism and should only be loaded/linked explicitly by the user.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:77,performance,memor,memory,77,"> is a custom memory allocator used in ROOT to output more information about memory pressure. This is not the only purpose. The other purpose is to allow the use of shared memory for inter process communication. > the functionality of libNew is only available in rootn.exe and libNew is statically linked to the binary. This is not the only usage. > we should make it a static library. This is backward incompatible. Having it as a static library means that you must link libNew against every single library that will be using it (as opposed to allowing other possible way to use it, including LD_PRELOAD). Besides, having it as a static library does eliminate the broken case described above (it is just delayed until a library linked against libNew is loaded). That said, libNew should be excluded from any auto-loading mechanism and should only be loaded/linked explicitly by the user.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:172,performance,memor,memory,172,"> is a custom memory allocator used in ROOT to output more information about memory pressure. This is not the only purpose. The other purpose is to allow the use of shared memory for inter process communication. > the functionality of libNew is only available in rootn.exe and libNew is statically linked to the binary. This is not the only usage. > we should make it a static library. This is backward incompatible. Having it as a static library means that you must link libNew against every single library that will be using it (as opposed to allowing other possible way to use it, including LD_PRELOAD). Besides, having it as a static library does eliminate the broken case described above (it is just delayed until a library linked against libNew is loaded). That said, libNew should be excluded from any auto-loading mechanism and should only be loaded/linked explicitly by the user.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:754,performance,load,loaded,754,"> is a custom memory allocator used in ROOT to output more information about memory pressure. This is not the only purpose. The other purpose is to allow the use of shared memory for inter process communication. > the functionality of libNew is only available in rootn.exe and libNew is statically linked to the binary. This is not the only usage. > we should make it a static library. This is backward incompatible. Having it as a static library means that you must link libNew against every single library that will be using it (as opposed to allowing other possible way to use it, including LD_PRELOAD). Besides, having it as a static library does eliminate the broken case described above (it is just delayed until a library linked against libNew is loaded). That said, libNew should be excluded from any auto-loading mechanism and should only be loaded/linked explicitly by the user.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:814,performance,load,loading,814,"> is a custom memory allocator used in ROOT to output more information about memory pressure. This is not the only purpose. The other purpose is to allow the use of shared memory for inter process communication. > the functionality of libNew is only available in rootn.exe and libNew is statically linked to the binary. This is not the only usage. > we should make it a static library. This is backward incompatible. Having it as a static library means that you must link libNew against every single library that will be using it (as opposed to allowing other possible way to use it, including LD_PRELOAD). Besides, having it as a static library does eliminate the broken case described above (it is just delayed until a library linked against libNew is loaded). That said, libNew should be excluded from any auto-loading mechanism and should only be loaded/linked explicitly by the user.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:851,performance,load,loaded,851,"> is a custom memory allocator used in ROOT to output more information about memory pressure. This is not the only purpose. The other purpose is to allow the use of shared memory for inter process communication. > the functionality of libNew is only available in rootn.exe and libNew is statically linked to the binary. This is not the only usage. > we should make it a static library. This is backward incompatible. Having it as a static library means that you must link libNew against every single library that will be using it (as opposed to allowing other possible way to use it, including LD_PRELOAD). Besides, having it as a static library does eliminate the broken case described above (it is just delayed until a library linked against libNew is loaded). That said, libNew should be excluded from any auto-loading mechanism and should only be loaded/linked explicitly by the user.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:250,reliability,availab,available,250,"> is a custom memory allocator used in ROOT to output more information about memory pressure. This is not the only purpose. The other purpose is to allow the use of shared memory for inter process communication. > the functionality of libNew is only available in rootn.exe and libNew is statically linked to the binary. This is not the only usage. > we should make it a static library. This is backward incompatible. Having it as a static library means that you must link libNew against every single library that will be using it (as opposed to allowing other possible way to use it, including LD_PRELOAD). Besides, having it as a static library does eliminate the broken case described above (it is just delayed until a library linked against libNew is loaded). That said, libNew should be excluded from any auto-loading mechanism and should only be loaded/linked explicitly by the user.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:646,reliability,doe,does,646,"> is a custom memory allocator used in ROOT to output more information about memory pressure. This is not the only purpose. The other purpose is to allow the use of shared memory for inter process communication. > the functionality of libNew is only available in rootn.exe and libNew is statically linked to the binary. This is not the only usage. > we should make it a static library. This is backward incompatible. Having it as a static library means that you must link libNew against every single library that will be using it (as opposed to allowing other possible way to use it, including LD_PRELOAD). Besides, having it as a static library does eliminate the broken case described above (it is just delayed until a library linked against libNew is loaded). That said, libNew should be excluded from any auto-loading mechanism and should only be loaded/linked explicitly by the user.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:250,safety,avail,available,250,"> is a custom memory allocator used in ROOT to output more information about memory pressure. This is not the only purpose. The other purpose is to allow the use of shared memory for inter process communication. > the functionality of libNew is only available in rootn.exe and libNew is statically linked to the binary. This is not the only usage. > we should make it a static library. This is backward incompatible. Having it as a static library means that you must link libNew against every single library that will be using it (as opposed to allowing other possible way to use it, including LD_PRELOAD). Besides, having it as a static library does eliminate the broken case described above (it is just delayed until a library linked against libNew is loaded). That said, libNew should be excluded from any auto-loading mechanism and should only be loaded/linked explicitly by the user.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:250,security,availab,available,250,"> is a custom memory allocator used in ROOT to output more information about memory pressure. This is not the only purpose. The other purpose is to allow the use of shared memory for inter process communication. > the functionality of libNew is only available in rootn.exe and libNew is statically linked to the binary. This is not the only usage. > we should make it a static library. This is backward incompatible. Having it as a static library means that you must link libNew against every single library that will be using it (as opposed to allowing other possible way to use it, including LD_PRELOAD). Besides, having it as a static library does eliminate the broken case described above (it is just delayed until a library linked against libNew is loaded). That said, libNew should be excluded from any auto-loading mechanism and should only be loaded/linked explicitly by the user.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:7,usability,custom,custom,7,"> is a custom memory allocator used in ROOT to output more information about memory pressure. This is not the only purpose. The other purpose is to allow the use of shared memory for inter process communication. > the functionality of libNew is only available in rootn.exe and libNew is statically linked to the binary. This is not the only usage. > we should make it a static library. This is backward incompatible. Having it as a static library means that you must link libNew against every single library that will be using it (as opposed to allowing other possible way to use it, including LD_PRELOAD). Besides, having it as a static library does eliminate the broken case described above (it is just delayed until a library linked against libNew is loaded). That said, libNew should be excluded from any auto-loading mechanism and should only be loaded/linked explicitly by the user.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:14,usability,memor,memory,14,"> is a custom memory allocator used in ROOT to output more information about memory pressure. This is not the only purpose. The other purpose is to allow the use of shared memory for inter process communication. > the functionality of libNew is only available in rootn.exe and libNew is statically linked to the binary. This is not the only usage. > we should make it a static library. This is backward incompatible. Having it as a static library means that you must link libNew against every single library that will be using it (as opposed to allowing other possible way to use it, including LD_PRELOAD). Besides, having it as a static library does eliminate the broken case described above (it is just delayed until a library linked against libNew is loaded). That said, libNew should be excluded from any auto-loading mechanism and should only be loaded/linked explicitly by the user.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:77,usability,memor,memory,77,"> is a custom memory allocator used in ROOT to output more information about memory pressure. This is not the only purpose. The other purpose is to allow the use of shared memory for inter process communication. > the functionality of libNew is only available in rootn.exe and libNew is statically linked to the binary. This is not the only usage. > we should make it a static library. This is backward incompatible. Having it as a static library means that you must link libNew against every single library that will be using it (as opposed to allowing other possible way to use it, including LD_PRELOAD). Besides, having it as a static library does eliminate the broken case described above (it is just delayed until a library linked against libNew is loaded). That said, libNew should be excluded from any auto-loading mechanism and should only be loaded/linked explicitly by the user.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:172,usability,memor,memory,172,"> is a custom memory allocator used in ROOT to output more information about memory pressure. This is not the only purpose. The other purpose is to allow the use of shared memory for inter process communication. > the functionality of libNew is only available in rootn.exe and libNew is statically linked to the binary. This is not the only usage. > we should make it a static library. This is backward incompatible. Having it as a static library means that you must link libNew against every single library that will be using it (as opposed to allowing other possible way to use it, including LD_PRELOAD). Besides, having it as a static library does eliminate the broken case described above (it is just delayed until a library linked against libNew is loaded). That said, libNew should be excluded from any auto-loading mechanism and should only be loaded/linked explicitly by the user.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:883,usability,user,user,883,"> is a custom memory allocator used in ROOT to output more information about memory pressure. This is not the only purpose. The other purpose is to allow the use of shared memory for inter process communication. > the functionality of libNew is only available in rootn.exe and libNew is statically linked to the binary. This is not the only usage. > we should make it a static library. This is backward incompatible. Having it as a static library means that you must link libNew against every single library that will be using it (as opposed to allowing other possible way to use it, including LD_PRELOAD). Besides, having it as a static library does eliminate the broken case described above (it is just delayed until a library linked against libNew is loaded). That said, libNew should be excluded from any auto-loading mechanism and should only be loaded/linked explicitly by the user.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:268,availability,operat,operators,268,The documentation suggests different approach: https://github.com/root-project/root/blob/master/core/newdelete/inc/MemCheck.h#L30. libNew depends on libCore. If you use LD_PRELOAD I am quite sure libCore will be loaded beforehand and it will use the system new/delete operators *most of the time*. If libNew is part of the binary everything should be fine as the binary takes always precedence.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:138,deployability,depend,depends,138,The documentation suggests different approach: https://github.com/root-project/root/blob/master/core/newdelete/inc/MemCheck.h#L30. libNew depends on libCore. If you use LD_PRELOAD I am quite sure libCore will be loaded beforehand and it will use the system new/delete operators *most of the time*. If libNew is part of the binary everything should be fine as the binary takes always precedence.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:96,energy efficiency,core,core,96,The documentation suggests different approach: https://github.com/root-project/root/blob/master/core/newdelete/inc/MemCheck.h#L30. libNew depends on libCore. If you use LD_PRELOAD I am quite sure libCore will be loaded beforehand and it will use the system new/delete operators *most of the time*. If libNew is part of the binary everything should be fine as the binary takes always precedence.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:212,energy efficiency,load,loaded,212,The documentation suggests different approach: https://github.com/root-project/root/blob/master/core/newdelete/inc/MemCheck.h#L30. libNew depends on libCore. If you use LD_PRELOAD I am quite sure libCore will be loaded beforehand and it will use the system new/delete operators *most of the time*. If libNew is part of the binary everything should be fine as the binary takes always precedence.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:138,integrability,depend,depends,138,The documentation suggests different approach: https://github.com/root-project/root/blob/master/core/newdelete/inc/MemCheck.h#L30. libNew depends on libCore. If you use LD_PRELOAD I am quite sure libCore will be loaded beforehand and it will use the system new/delete operators *most of the time*. If libNew is part of the binary everything should be fine as the binary takes always precedence.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:138,modifiability,depend,depends,138,The documentation suggests different approach: https://github.com/root-project/root/blob/master/core/newdelete/inc/MemCheck.h#L30. libNew depends on libCore. If you use LD_PRELOAD I am quite sure libCore will be loaded beforehand and it will use the system new/delete operators *most of the time*. If libNew is part of the binary everything should be fine as the binary takes always precedence.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:212,performance,load,loaded,212,The documentation suggests different approach: https://github.com/root-project/root/blob/master/core/newdelete/inc/MemCheck.h#L30. libNew depends on libCore. If you use LD_PRELOAD I am quite sure libCore will be loaded beforehand and it will use the system new/delete operators *most of the time*. If libNew is part of the binary everything should be fine as the binary takes always precedence.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:291,performance,time,time,291,The documentation suggests different approach: https://github.com/root-project/root/blob/master/core/newdelete/inc/MemCheck.h#L30. libNew depends on libCore. If you use LD_PRELOAD I am quite sure libCore will be loaded beforehand and it will use the system new/delete operators *most of the time*. If libNew is part of the binary everything should be fine as the binary takes always precedence.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:138,safety,depend,depends,138,The documentation suggests different approach: https://github.com/root-project/root/blob/master/core/newdelete/inc/MemCheck.h#L30. libNew depends on libCore. If you use LD_PRELOAD I am quite sure libCore will be loaded beforehand and it will use the system new/delete operators *most of the time*. If libNew is part of the binary everything should be fine as the binary takes always precedence.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:138,testability,depend,depends,138,The documentation suggests different approach: https://github.com/root-project/root/blob/master/core/newdelete/inc/MemCheck.h#L30. libNew depends on libCore. If you use LD_PRELOAD I am quite sure libCore will be loaded beforehand and it will use the system new/delete operators *most of the time*. If libNew is part of the binary everything should be fine as the binary takes always precedence.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:4,usability,document,documentation,4,The documentation suggests different approach: https://github.com/root-project/root/blob/master/core/newdelete/inc/MemCheck.h#L30. libNew depends on libCore. If you use LD_PRELOAD I am quite sure libCore will be loaded beforehand and it will use the system new/delete operators *most of the time*. If libNew is part of the binary everything should be fine as the binary takes always precedence.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:9,deployability,depend,depends,9,> libNew depends on libCore. If you use LD_PRELOAD I am quite sure libCore will be loaded beforehand . Using libNew for libCore (and the MemCheck usage) is only one of the usage. Another one is the use of TMapFile and support for allocation within a shared memory block.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:83,energy efficiency,load,loaded,83,> libNew depends on libCore. If you use LD_PRELOAD I am quite sure libCore will be loaded beforehand . Using libNew for libCore (and the MemCheck usage) is only one of the usage. Another one is the use of TMapFile and support for allocation within a shared memory block.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:230,energy efficiency,alloc,allocation,230,> libNew depends on libCore. If you use LD_PRELOAD I am quite sure libCore will be loaded beforehand . Using libNew for libCore (and the MemCheck usage) is only one of the usage. Another one is the use of TMapFile and support for allocation within a shared memory block.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:9,integrability,depend,depends,9,> libNew depends on libCore. If you use LD_PRELOAD I am quite sure libCore will be loaded beforehand . Using libNew for libCore (and the MemCheck usage) is only one of the usage. Another one is the use of TMapFile and support for allocation within a shared memory block.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:250,interoperability,share,shared,250,> libNew depends on libCore. If you use LD_PRELOAD I am quite sure libCore will be loaded beforehand . Using libNew for libCore (and the MemCheck usage) is only one of the usage. Another one is the use of TMapFile and support for allocation within a shared memory block.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:9,modifiability,depend,depends,9,> libNew depends on libCore. If you use LD_PRELOAD I am quite sure libCore will be loaded beforehand . Using libNew for libCore (and the MemCheck usage) is only one of the usage. Another one is the use of TMapFile and support for allocation within a shared memory block.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:83,performance,load,loaded,83,> libNew depends on libCore. If you use LD_PRELOAD I am quite sure libCore will be loaded beforehand . Using libNew for libCore (and the MemCheck usage) is only one of the usage. Another one is the use of TMapFile and support for allocation within a shared memory block.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:257,performance,memor,memory,257,> libNew depends on libCore. If you use LD_PRELOAD I am quite sure libCore will be loaded beforehand . Using libNew for libCore (and the MemCheck usage) is only one of the usage. Another one is the use of TMapFile and support for allocation within a shared memory block.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:9,safety,depend,depends,9,> libNew depends on libCore. If you use LD_PRELOAD I am quite sure libCore will be loaded beforehand . Using libNew for libCore (and the MemCheck usage) is only one of the usage. Another one is the use of TMapFile and support for allocation within a shared memory block.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:9,testability,depend,depends,9,> libNew depends on libCore. If you use LD_PRELOAD I am quite sure libCore will be loaded beforehand . Using libNew for libCore (and the MemCheck usage) is only one of the usage. Another one is the use of TMapFile and support for allocation within a shared memory block.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:218,usability,support,support,218,> libNew depends on libCore. If you use LD_PRELOAD I am quite sure libCore will be loaded beforehand . Using libNew for libCore (and the MemCheck usage) is only one of the usage. Another one is the use of TMapFile and support for allocation within a shared memory block.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:257,usability,memor,memory,257,> libNew depends on libCore. If you use LD_PRELOAD I am quite sure libCore will be loaded beforehand . Using libNew for libCore (and the MemCheck usage) is only one of the usage. Another one is the use of TMapFile and support for allocation within a shared memory block.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4722:95,integrability,rout,route,95,"Indeed, making the library static will make it trickier to handle this case. I will go another route in fixing the described issue.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4722
https://github.com/root-project/root/pull/4723:221,interoperability,standard,standard,221,"I think the remaining issues come from the include order of `Python.h`, see here the docs (https://docs.python.org/3.1/extending/extending.html):. > Since Python may define some pre-processor definitions which affect the standard headers on some systems, you must include Python.h before any standard headers are included.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4723
https://github.com/root-project/root/pull/4723:292,interoperability,standard,standard,292,"I think the remaining issues come from the include order of `Python.h`, see here the docs (https://docs.python.org/3.1/extending/extending.html):. > Since Python may define some pre-processor definitions which affect the standard headers on some systems, you must include Python.h before any standard headers are included.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4723
https://github.com/root-project/root/pull/4723:119,modifiability,exten,extending,119,"I think the remaining issues come from the include order of `Python.h`, see here the docs (https://docs.python.org/3.1/extending/extending.html):. > Since Python may define some pre-processor definitions which affect the standard headers on some systems, you must include Python.h before any standard headers are included.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4723
https://github.com/root-project/root/pull/4723:129,modifiability,exten,extending,129,"I think the remaining issues come from the include order of `Python.h`, see here the docs (https://docs.python.org/3.1/extending/extending.html):. > Since Python may define some pre-processor definitions which affect the standard headers on some systems, you must include Python.h before any standard headers are included.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4723
https://github.com/root-project/root/pull/4726:112,deployability,contain,contains,112,"I hit a fancy problem with civetweb on Windows. It does not work properly if I running ROOT from the path which contains symbolic link. I will provide a fast fix, but problem has to be resolved on civetweb side later.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4726
https://github.com/root-project/root/pull/4726:51,reliability,doe,does,51,"I hit a fancy problem with civetweb on Windows. It does not work properly if I running ROOT from the path which contains symbolic link. I will provide a fast fix, but problem has to be resolved on civetweb side later.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4726
https://github.com/root-project/root/pull/4726:114,deployability,contain,contains,114,"> I hit a fancy problem with civetweb on Windows. It does not work properly if I running ROOT from the path which contains symbolic link. I will provide a fast fix, but problem has to be resolved on civetweb side later. There is no symbolic link on Windows...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4726
https://github.com/root-project/root/pull/4726:53,reliability,doe,does,53,"> I hit a fancy problem with civetweb on Windows. It does not work properly if I running ROOT from the path which contains symbolic link. I will provide a fast fix, but problem has to be resolved on civetweb side later. There is no symbolic link on Windows...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4726
https://github.com/root-project/root/pull/4726:209,safety,avoid,avoiding,209,"> There is no symbolic link on Windows... Yes, they are. . On German Windows there is folder ""C:\Programme"", which is just symbolic link to ""C:\Program Files"". And I try to use ROOTSYS as ""C:\Programme\root"", avoiding spaces in the path.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4726
https://github.com/root-project/root/pull/4726:32,usability,shortcut,shortcuts,32,"Oh! OK, I see (they are called `shortcuts` on Windows...) :wink:",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4726
https://github.com/root-project/root/pull/4726:42,deployability,API,API,42,> they are called shortcuts on Windows... API function called CreateSymbolicLink. https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka?redirectedfrom=MSDN,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4726
https://github.com/root-project/root/pull/4726:129,deployability,api,api,129,> they are called shortcuts on Windows... API function called CreateSymbolicLink. https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka?redirectedfrom=MSDN,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4726
https://github.com/root-project/root/pull/4726:42,integrability,API,API,42,> they are called shortcuts on Windows... API function called CreateSymbolicLink. https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka?redirectedfrom=MSDN,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4726
https://github.com/root-project/root/pull/4726:129,integrability,api,api,129,> they are called shortcuts on Windows... API function called CreateSymbolicLink. https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka?redirectedfrom=MSDN,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4726
https://github.com/root-project/root/pull/4726:42,interoperability,API,API,42,> they are called shortcuts on Windows... API function called CreateSymbolicLink. https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka?redirectedfrom=MSDN,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4726
https://github.com/root-project/root/pull/4726:129,interoperability,api,api,129,> they are called shortcuts on Windows... API function called CreateSymbolicLink. https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka?redirectedfrom=MSDN,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4726
https://github.com/root-project/root/pull/4726:18,usability,shortcut,shortcuts,18,> they are called shortcuts on Windows... API function called CreateSymbolicLink. https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka?redirectedfrom=MSDN,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4726
https://github.com/root-project/root/pull/4727:11,deployability,build,build,11,@phsft-bot build with `-Dpyroot_experimental=ON`,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4727
https://github.com/root-project/root/pull/4728:11,deployability,build,build,11,@phsft-bot build with `-Dpyroot_experimental=ON`,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4728
https://github.com/root-project/root/pull/4728:11,deployability,build,build,11,@phsft-bot build with -Dpyroot_experimental=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4728
https://github.com/root-project/root/pull/4729:11,deployability,build,build,11,@phsft-bot build with `-Dpyroot_experimental=ON`,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4729
https://github.com/root-project/root/pull/4730:11,deployability,build,build,11,@phsft-bot build with `-Dpyroot_experimental=ON`,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4730
https://github.com/root-project/root/pull/4733:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4733
https://github.com/root-project/root/pull/4734:0,usability,Close,Close,0,"Close this, new PR will be created",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4734
https://github.com/root-project/root/pull/4735:4,availability,error,error,4,The error sql light is because of failure to connect.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4735
https://github.com/root-project/root/pull/4735:34,availability,failur,failure,34,The error sql light is because of failure to connect.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4735
https://github.com/root-project/root/pull/4735:34,deployability,fail,failure,34,The error sql light is because of failure to connect.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4735
https://github.com/root-project/root/pull/4735:4,performance,error,error,4,The error sql light is because of failure to connect.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4735
https://github.com/root-project/root/pull/4735:34,performance,failur,failure,34,The error sql light is because of failure to connect.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4735
https://github.com/root-project/root/pull/4735:34,reliability,fail,failure,34,The error sql light is because of failure to connect.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4735
https://github.com/root-project/root/pull/4735:4,safety,error,error,4,The error sql light is because of failure to connect.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4735
https://github.com/root-project/root/pull/4735:4,usability,error,error,4,The error sql light is because of failure to connect.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4735
https://github.com/root-project/root/pull/4736:77,reliability,doe,does,77,"I am not sure how well the -Dbuiltin_llvm=Off option is supported, but #4689 does not work if it is off. Not sure if that should trigger a warning somewhere.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:56,usability,support,supported,56,"I am not sure how well the -Dbuiltin_llvm=Off option is supported, but #4689 does not work if it is off. Not sure if that should trigger a warning somewhere.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:133,deployability,build,build,133,"*Shrug*. If people want to provide their own llvm I count on them knowing what they do; they get what they pay for. They *can* still build the external llvm correctly for libCling to not expose symbols. I.e. ""do we have a builtin llvm"" isn't the relevant question to ask. For me, for that case, this PR is good enough.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:187,security,expos,expose,187,"*Shrug*. If people want to provide their own llvm I count on them knowing what they do; they get what they pay for. They *can* still build the external llvm correctly for libCling to not expose symbols. I.e. ""do we have a builtin llvm"" isn't the relevant question to ask. For me, for that case, this PR is good enough.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:135,deployability,build,build,135,"> _Shrug_. If people want to provide their own llvm I count on them knowing what they do; they get what they pay for. They _can_ still build the external llvm correctly for libCling to not expose symbols. I.e. ""do we have a builtin llvm"" isn't the relevant question to ask. For me, for that case, this PR is good enough. Well, I get the point, but I still think it would be good if this was documented somewhere, since it is not obvious for someone providing his own LLVM. I fooled myself with that setup and took few ours to find out ... :( The relevant question would be ""is our LLVM prone to exposed symbols"", but I have no idea how to check that.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:189,security,expos,expose,189,"> _Shrug_. If people want to provide their own llvm I count on them knowing what they do; they get what they pay for. They _can_ still build the external llvm correctly for libCling to not expose symbols. I.e. ""do we have a builtin llvm"" isn't the relevant question to ask. For me, for that case, this PR is good enough. Well, I get the point, but I still think it would be good if this was documented somewhere, since it is not obvious for someone providing his own LLVM. I fooled myself with that setup and took few ours to find out ... :( The relevant question would be ""is our LLVM prone to exposed symbols"", but I have no idea how to check that.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:595,security,expos,exposed,595,"> _Shrug_. If people want to provide their own llvm I count on them knowing what they do; they get what they pay for. They _can_ still build the external llvm correctly for libCling to not expose symbols. I.e. ""do we have a builtin llvm"" isn't the relevant question to ask. For me, for that case, this PR is good enough. Well, I get the point, but I still think it would be good if this was documented somewhere, since it is not obvious for someone providing his own LLVM. I fooled myself with that setup and took few ours to find out ... :( The relevant question would be ""is our LLVM prone to exposed symbols"", but I have no idea how to check that.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:391,usability,document,documented,391,"> _Shrug_. If people want to provide their own llvm I count on them knowing what they do; they get what they pay for. They _can_ still build the external llvm correctly for libCling to not expose symbols. I.e. ""do we have a builtin llvm"" isn't the relevant question to ask. For me, for that case, this PR is good enough. Well, I get the point, but I still think it would be good if this was documented somewhere, since it is not obvious for someone providing his own LLVM. I fooled myself with that setup and took few ours to find out ... :( The relevant question would be ""is our LLVM prone to exposed symbols"", but I have no idea how to check that.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:307,safety,prevent,prevent,307,> is our LLVM prone to exposed symbols. That alone isn't even an issue! You need to. - link libCling against an external llvm with exposed symbols. - *and* link / dlopen into your process *another* llvm with exposed symbols. That's so much mean intentions that I would - still - argue that we don't need to prevent people from doing it :-),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:23,security,expos,exposed,23,> is our LLVM prone to exposed symbols. That alone isn't even an issue! You need to. - link libCling against an external llvm with exposed symbols. - *and* link / dlopen into your process *another* llvm with exposed symbols. That's so much mean intentions that I would - still - argue that we don't need to prevent people from doing it :-),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:131,security,expos,exposed,131,> is our LLVM prone to exposed symbols. That alone isn't even an issue! You need to. - link libCling against an external llvm with exposed symbols. - *and* link / dlopen into your process *another* llvm with exposed symbols. That's so much mean intentions that I would - still - argue that we don't need to prevent people from doing it :-),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:208,security,expos,exposed,208,> is our LLVM prone to exposed symbols. That alone isn't even an issue! You need to. - link libCling against an external llvm with exposed symbols. - *and* link / dlopen into your process *another* llvm with exposed symbols. That's so much mean intentions that I would - still - argue that we don't need to prevent people from doing it :-),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:307,security,preven,prevent,307,> is our LLVM prone to exposed symbols. That alone isn't even an issue! You need to. - link libCling against an external llvm with exposed symbols. - *and* link / dlopen into your process *another* llvm with exposed symbols. That's so much mean intentions that I would - still - argue that we don't need to prevent people from doing it :-),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:282,energy efficiency,core,core,282,I would support having a warning. I have stumbled myself on this issue. . We can use the llvm shared object reader to find if the symbols in libCling are defined but hidden. We do have such code dealing with symbols and symbol flags https://github.com/root-project/root/blob/master/core/metacling/src/TCling.cxx#L6194.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:94,interoperability,share,shared,94,I would support having a warning. I have stumbled myself on this issue. . We can use the llvm shared object reader to find if the symbols in libCling are defined but hidden. We do have such code dealing with symbols and symbol flags https://github.com/root-project/root/blob/master/core/metacling/src/TCling.cxx#L6194.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:8,usability,support,support,8,I would support having a warning. I have stumbled myself on this issue. . We can use the llvm shared object reader to find if the symbols in libCling are defined but hidden. We do have such code dealing with symbols and symbol flags https://github.com/root-project/root/blob/master/core/metacling/src/TCling.cxx#L6194.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:659,availability,Error,Error,659,"Putting something like this in TCling and calling it in the TCling ctor should do:. ```cpp. static bool IsSymbolVisibilityHidden() {. static const std::string libClingLocation = FindLibraryName(&IsFromRootCling());. auto ObjF = llvm::object::ObjectFile::createObjectFile(ROOT::TMetaUtils::GetRealPath(libClingLocation));. if (!ObjF) {. Warn(""TCling__IsSymbolVisibilityHidden"",. ""Failed to read object file %s"", libClingLocation.c_str());. return false;. }. llvm::object::ObjectFile *BinObjFile = ObjF.get().getBinary();. for (const auto &S : BinObjFile->symbols()) {. #ifdef NDEBUG. if (S.getFlags() & llvm::object::SymbolRef::SF_Hidden). return true;. else. Error(""TCling__IsSymbolVisibilityHidden"",. ""Symbol %s is exported. Please compile LLVM with -fvisibility=hidden!\n"", S.getName().data() );. return false;. #else // debug. // In debug mode we make sure all symbols are hidden. if (!(S.getFlags() & llvm::object::SymbolRef::SF_Hidden)) {. Error(""TCling__IsSymbolVisibilityHidden"",. ""Symbol %s is exported. Please compile LLVM with -fvisibility=hidden!\n"", S.getName().data() );. return false;. }. #endif // NDEBUG. }. return true;. }. ```. Needless to say that I did not compile this code. It may need some adjustments... :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:945,availability,Error,Error,945,"Putting something like this in TCling and calling it in the TCling ctor should do:. ```cpp. static bool IsSymbolVisibilityHidden() {. static const std::string libClingLocation = FindLibraryName(&IsFromRootCling());. auto ObjF = llvm::object::ObjectFile::createObjectFile(ROOT::TMetaUtils::GetRealPath(libClingLocation));. if (!ObjF) {. Warn(""TCling__IsSymbolVisibilityHidden"",. ""Failed to read object file %s"", libClingLocation.c_str());. return false;. }. llvm::object::ObjectFile *BinObjFile = ObjF.get().getBinary();. for (const auto &S : BinObjFile->symbols()) {. #ifdef NDEBUG. if (S.getFlags() & llvm::object::SymbolRef::SF_Hidden). return true;. else. Error(""TCling__IsSymbolVisibilityHidden"",. ""Symbol %s is exported. Please compile LLVM with -fvisibility=hidden!\n"", S.getName().data() );. return false;. #else // debug. // In debug mode we make sure all symbols are hidden. if (!(S.getFlags() & llvm::object::SymbolRef::SF_Hidden)) {. Error(""TCling__IsSymbolVisibilityHidden"",. ""Symbol %s is exported. Please compile LLVM with -fvisibility=hidden!\n"", S.getName().data() );. return false;. }. #endif // NDEBUG. }. return true;. }. ```. Needless to say that I did not compile this code. It may need some adjustments... :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:379,deployability,Fail,Failed,379,"Putting something like this in TCling and calling it in the TCling ctor should do:. ```cpp. static bool IsSymbolVisibilityHidden() {. static const std::string libClingLocation = FindLibraryName(&IsFromRootCling());. auto ObjF = llvm::object::ObjectFile::createObjectFile(ROOT::TMetaUtils::GetRealPath(libClingLocation));. if (!ObjF) {. Warn(""TCling__IsSymbolVisibilityHidden"",. ""Failed to read object file %s"", libClingLocation.c_str());. return false;. }. llvm::object::ObjectFile *BinObjFile = ObjF.get().getBinary();. for (const auto &S : BinObjFile->symbols()) {. #ifdef NDEBUG. if (S.getFlags() & llvm::object::SymbolRef::SF_Hidden). return true;. else. Error(""TCling__IsSymbolVisibilityHidden"",. ""Symbol %s is exported. Please compile LLVM with -fvisibility=hidden!\n"", S.getName().data() );. return false;. #else // debug. // In debug mode we make sure all symbols are hidden. if (!(S.getFlags() & llvm::object::SymbolRef::SF_Hidden)) {. Error(""TCling__IsSymbolVisibilityHidden"",. ""Symbol %s is exported. Please compile LLVM with -fvisibility=hidden!\n"", S.getName().data() );. return false;. }. #endif // NDEBUG. }. return true;. }. ```. Needless to say that I did not compile this code. It may need some adjustments... :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:659,performance,Error,Error,659,"Putting something like this in TCling and calling it in the TCling ctor should do:. ```cpp. static bool IsSymbolVisibilityHidden() {. static const std::string libClingLocation = FindLibraryName(&IsFromRootCling());. auto ObjF = llvm::object::ObjectFile::createObjectFile(ROOT::TMetaUtils::GetRealPath(libClingLocation));. if (!ObjF) {. Warn(""TCling__IsSymbolVisibilityHidden"",. ""Failed to read object file %s"", libClingLocation.c_str());. return false;. }. llvm::object::ObjectFile *BinObjFile = ObjF.get().getBinary();. for (const auto &S : BinObjFile->symbols()) {. #ifdef NDEBUG. if (S.getFlags() & llvm::object::SymbolRef::SF_Hidden). return true;. else. Error(""TCling__IsSymbolVisibilityHidden"",. ""Symbol %s is exported. Please compile LLVM with -fvisibility=hidden!\n"", S.getName().data() );. return false;. #else // debug. // In debug mode we make sure all symbols are hidden. if (!(S.getFlags() & llvm::object::SymbolRef::SF_Hidden)) {. Error(""TCling__IsSymbolVisibilityHidden"",. ""Symbol %s is exported. Please compile LLVM with -fvisibility=hidden!\n"", S.getName().data() );. return false;. }. #endif // NDEBUG. }. return true;. }. ```. Needless to say that I did not compile this code. It may need some adjustments... :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:945,performance,Error,Error,945,"Putting something like this in TCling and calling it in the TCling ctor should do:. ```cpp. static bool IsSymbolVisibilityHidden() {. static const std::string libClingLocation = FindLibraryName(&IsFromRootCling());. auto ObjF = llvm::object::ObjectFile::createObjectFile(ROOT::TMetaUtils::GetRealPath(libClingLocation));. if (!ObjF) {. Warn(""TCling__IsSymbolVisibilityHidden"",. ""Failed to read object file %s"", libClingLocation.c_str());. return false;. }. llvm::object::ObjectFile *BinObjFile = ObjF.get().getBinary();. for (const auto &S : BinObjFile->symbols()) {. #ifdef NDEBUG. if (S.getFlags() & llvm::object::SymbolRef::SF_Hidden). return true;. else. Error(""TCling__IsSymbolVisibilityHidden"",. ""Symbol %s is exported. Please compile LLVM with -fvisibility=hidden!\n"", S.getName().data() );. return false;. #else // debug. // In debug mode we make sure all symbols are hidden. if (!(S.getFlags() & llvm::object::SymbolRef::SF_Hidden)) {. Error(""TCling__IsSymbolVisibilityHidden"",. ""Symbol %s is exported. Please compile LLVM with -fvisibility=hidden!\n"", S.getName().data() );. return false;. }. #endif // NDEBUG. }. return true;. }. ```. Needless to say that I did not compile this code. It may need some adjustments... :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:379,reliability,Fail,Failed,379,"Putting something like this in TCling and calling it in the TCling ctor should do:. ```cpp. static bool IsSymbolVisibilityHidden() {. static const std::string libClingLocation = FindLibraryName(&IsFromRootCling());. auto ObjF = llvm::object::ObjectFile::createObjectFile(ROOT::TMetaUtils::GetRealPath(libClingLocation));. if (!ObjF) {. Warn(""TCling__IsSymbolVisibilityHidden"",. ""Failed to read object file %s"", libClingLocation.c_str());. return false;. }. llvm::object::ObjectFile *BinObjFile = ObjF.get().getBinary();. for (const auto &S : BinObjFile->symbols()) {. #ifdef NDEBUG. if (S.getFlags() & llvm::object::SymbolRef::SF_Hidden). return true;. else. Error(""TCling__IsSymbolVisibilityHidden"",. ""Symbol %s is exported. Please compile LLVM with -fvisibility=hidden!\n"", S.getName().data() );. return false;. #else // debug. // In debug mode we make sure all symbols are hidden. if (!(S.getFlags() & llvm::object::SymbolRef::SF_Hidden)) {. Error(""TCling__IsSymbolVisibilityHidden"",. ""Symbol %s is exported. Please compile LLVM with -fvisibility=hidden!\n"", S.getName().data() );. return false;. }. #endif // NDEBUG. }. return true;. }. ```. Needless to say that I did not compile this code. It may need some adjustments... :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:659,safety,Error,Error,659,"Putting something like this in TCling and calling it in the TCling ctor should do:. ```cpp. static bool IsSymbolVisibilityHidden() {. static const std::string libClingLocation = FindLibraryName(&IsFromRootCling());. auto ObjF = llvm::object::ObjectFile::createObjectFile(ROOT::TMetaUtils::GetRealPath(libClingLocation));. if (!ObjF) {. Warn(""TCling__IsSymbolVisibilityHidden"",. ""Failed to read object file %s"", libClingLocation.c_str());. return false;. }. llvm::object::ObjectFile *BinObjFile = ObjF.get().getBinary();. for (const auto &S : BinObjFile->symbols()) {. #ifdef NDEBUG. if (S.getFlags() & llvm::object::SymbolRef::SF_Hidden). return true;. else. Error(""TCling__IsSymbolVisibilityHidden"",. ""Symbol %s is exported. Please compile LLVM with -fvisibility=hidden!\n"", S.getName().data() );. return false;. #else // debug. // In debug mode we make sure all symbols are hidden. if (!(S.getFlags() & llvm::object::SymbolRef::SF_Hidden)) {. Error(""TCling__IsSymbolVisibilityHidden"",. ""Symbol %s is exported. Please compile LLVM with -fvisibility=hidden!\n"", S.getName().data() );. return false;. }. #endif // NDEBUG. }. return true;. }. ```. Needless to say that I did not compile this code. It may need some adjustments... :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:945,safety,Error,Error,945,"Putting something like this in TCling and calling it in the TCling ctor should do:. ```cpp. static bool IsSymbolVisibilityHidden() {. static const std::string libClingLocation = FindLibraryName(&IsFromRootCling());. auto ObjF = llvm::object::ObjectFile::createObjectFile(ROOT::TMetaUtils::GetRealPath(libClingLocation));. if (!ObjF) {. Warn(""TCling__IsSymbolVisibilityHidden"",. ""Failed to read object file %s"", libClingLocation.c_str());. return false;. }. llvm::object::ObjectFile *BinObjFile = ObjF.get().getBinary();. for (const auto &S : BinObjFile->symbols()) {. #ifdef NDEBUG. if (S.getFlags() & llvm::object::SymbolRef::SF_Hidden). return true;. else. Error(""TCling__IsSymbolVisibilityHidden"",. ""Symbol %s is exported. Please compile LLVM with -fvisibility=hidden!\n"", S.getName().data() );. return false;. #else // debug. // In debug mode we make sure all symbols are hidden. if (!(S.getFlags() & llvm::object::SymbolRef::SF_Hidden)) {. Error(""TCling__IsSymbolVisibilityHidden"",. ""Symbol %s is exported. Please compile LLVM with -fvisibility=hidden!\n"", S.getName().data() );. return false;. }. #endif // NDEBUG. }. return true;. }. ```. Needless to say that I did not compile this code. It may need some adjustments... :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:659,usability,Error,Error,659,"Putting something like this in TCling and calling it in the TCling ctor should do:. ```cpp. static bool IsSymbolVisibilityHidden() {. static const std::string libClingLocation = FindLibraryName(&IsFromRootCling());. auto ObjF = llvm::object::ObjectFile::createObjectFile(ROOT::TMetaUtils::GetRealPath(libClingLocation));. if (!ObjF) {. Warn(""TCling__IsSymbolVisibilityHidden"",. ""Failed to read object file %s"", libClingLocation.c_str());. return false;. }. llvm::object::ObjectFile *BinObjFile = ObjF.get().getBinary();. for (const auto &S : BinObjFile->symbols()) {. #ifdef NDEBUG. if (S.getFlags() & llvm::object::SymbolRef::SF_Hidden). return true;. else. Error(""TCling__IsSymbolVisibilityHidden"",. ""Symbol %s is exported. Please compile LLVM with -fvisibility=hidden!\n"", S.getName().data() );. return false;. #else // debug. // In debug mode we make sure all symbols are hidden. if (!(S.getFlags() & llvm::object::SymbolRef::SF_Hidden)) {. Error(""TCling__IsSymbolVisibilityHidden"",. ""Symbol %s is exported. Please compile LLVM with -fvisibility=hidden!\n"", S.getName().data() );. return false;. }. #endif // NDEBUG. }. return true;. }. ```. Needless to say that I did not compile this code. It may need some adjustments... :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:945,usability,Error,Error,945,"Putting something like this in TCling and calling it in the TCling ctor should do:. ```cpp. static bool IsSymbolVisibilityHidden() {. static const std::string libClingLocation = FindLibraryName(&IsFromRootCling());. auto ObjF = llvm::object::ObjectFile::createObjectFile(ROOT::TMetaUtils::GetRealPath(libClingLocation));. if (!ObjF) {. Warn(""TCling__IsSymbolVisibilityHidden"",. ""Failed to read object file %s"", libClingLocation.c_str());. return false;. }. llvm::object::ObjectFile *BinObjFile = ObjF.get().getBinary();. for (const auto &S : BinObjFile->symbols()) {. #ifdef NDEBUG. if (S.getFlags() & llvm::object::SymbolRef::SF_Hidden). return true;. else. Error(""TCling__IsSymbolVisibilityHidden"",. ""Symbol %s is exported. Please compile LLVM with -fvisibility=hidden!\n"", S.getName().data() );. return false;. #else // debug. // In debug mode we make sure all symbols are hidden. if (!(S.getFlags() & llvm::object::SymbolRef::SF_Hidden)) {. Error(""TCling__IsSymbolVisibilityHidden"",. ""Symbol %s is exported. Please compile LLVM with -fvisibility=hidden!\n"", S.getName().data() );. return false;. }. #endif // NDEBUG. }. return true;. }. ```. Needless to say that I did not compile this code. It may need some adjustments... :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:364,modifiability,maintain,maintainers,364,There's nothing inherently wrong with linking libCling against an llvm with visible symbols. If it's broken (you reported privately that a gtest is broken by this) then we should fix / redesign the test instead of requiring symbols to be hidden. The reason builtin-llvm hides its symbols is to allow frameworks to link against ROOT *and* their own llvm. Framework maintainers are experts enough to figure that that providing an external llvm *and* a *different* llvm is calling for trouble.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:198,safety,test,test,198,There's nothing inherently wrong with linking libCling against an llvm with visible symbols. If it's broken (you reported privately that a gtest is broken by this) then we should fix / redesign the test instead of requiring symbols to be hidden. The reason builtin-llvm hides its symbols is to allow frameworks to link against ROOT *and* their own llvm. Framework maintainers are experts enough to figure that that providing an external llvm *and* a *different* llvm is calling for trouble.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:364,safety,maintain,maintainers,364,There's nothing inherently wrong with linking libCling against an llvm with visible symbols. If it's broken (you reported privately that a gtest is broken by this) then we should fix / redesign the test instead of requiring symbols to be hidden. The reason builtin-llvm hides its symbols is to allow frameworks to link against ROOT *and* their own llvm. Framework maintainers are experts enough to figure that that providing an external llvm *and* a *different* llvm is calling for trouble.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:198,testability,test,test,198,There's nothing inherently wrong with linking libCling against an llvm with visible symbols. If it's broken (you reported privately that a gtest is broken by this) then we should fix / redesign the test instead of requiring symbols to be hidden. The reason builtin-llvm hides its symbols is to allow frameworks to link against ROOT *and* their own llvm. Framework maintainers are experts enough to figure that that providing an external llvm *and* a *different* llvm is calling for trouble.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:262,deployability,log,log,262,Note also that the test removed by this PR does *not* test whether the external llvm has visible symbols: it tests whether the process had loaded an llvm with visible symbols before dlopening libCling - and that's not an issue anymore as explained in the commit log. So any discussion about that feature is independent of this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:139,energy efficiency,load,loaded,139,Note also that the test removed by this PR does *not* test whether the external llvm has visible symbols: it tests whether the process had loaded an llvm with visible symbols before dlopening libCling - and that's not an issue anymore as explained in the commit log. So any discussion about that feature is independent of this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:139,performance,load,loaded,139,Note also that the test removed by this PR does *not* test whether the external llvm has visible symbols: it tests whether the process had loaded an llvm with visible symbols before dlopening libCling - and that's not an issue anymore as explained in the commit log. So any discussion about that feature is independent of this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:43,reliability,doe,does,43,Note also that the test removed by this PR does *not* test whether the external llvm has visible symbols: it tests whether the process had loaded an llvm with visible symbols before dlopening libCling - and that's not an issue anymore as explained in the commit log. So any discussion about that feature is independent of this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:19,safety,test,test,19,Note also that the test removed by this PR does *not* test whether the external llvm has visible symbols: it tests whether the process had loaded an llvm with visible symbols before dlopening libCling - and that's not an issue anymore as explained in the commit log. So any discussion about that feature is independent of this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:54,safety,test,test,54,Note also that the test removed by this PR does *not* test whether the external llvm has visible symbols: it tests whether the process had loaded an llvm with visible symbols before dlopening libCling - and that's not an issue anymore as explained in the commit log. So any discussion about that feature is independent of this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:109,safety,test,tests,109,Note also that the test removed by this PR does *not* test whether the external llvm has visible symbols: it tests whether the process had loaded an llvm with visible symbols before dlopening libCling - and that's not an issue anymore as explained in the commit log. So any discussion about that feature is independent of this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:262,safety,log,log,262,Note also that the test removed by this PR does *not* test whether the external llvm has visible symbols: it tests whether the process had loaded an llvm with visible symbols before dlopening libCling - and that's not an issue anymore as explained in the commit log. So any discussion about that feature is independent of this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:262,security,log,log,262,Note also that the test removed by this PR does *not* test whether the external llvm has visible symbols: it tests whether the process had loaded an llvm with visible symbols before dlopening libCling - and that's not an issue anymore as explained in the commit log. So any discussion about that feature is independent of this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:19,testability,test,test,19,Note also that the test removed by this PR does *not* test whether the external llvm has visible symbols: it tests whether the process had loaded an llvm with visible symbols before dlopening libCling - and that's not an issue anymore as explained in the commit log. So any discussion about that feature is independent of this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:54,testability,test,test,54,Note also that the test removed by this PR does *not* test whether the external llvm has visible symbols: it tests whether the process had loaded an llvm with visible symbols before dlopening libCling - and that's not an issue anymore as explained in the commit log. So any discussion about that feature is independent of this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:109,testability,test,tests,109,Note also that the test removed by this PR does *not* test whether the external llvm has visible symbols: it tests whether the process had loaded an llvm with visible symbols before dlopening libCling - and that's not an issue anymore as explained in the commit log. So any discussion about that feature is independent of this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:262,testability,log,log,262,Note also that the test removed by this PR does *not* test whether the external llvm has visible symbols: it tests whether the process had loaded an llvm with visible symbols before dlopening libCling - and that's not an issue anymore as explained in the commit log. So any discussion about that feature is independent of this PR.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:103,performance,time,time,103,The external llvm should be built exactly in the same way as internal llvm to avoid troubles and waste time of the experts who do not really care. I'd prefer to conservatively require it and relax the requirement when there is a valid use case for having ROOT working with llvm with exported symbols... This diagnostic is a practical request by 2 expert users of external_llvm (which probably makes it around 99% of the users of that feature) :),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:308,reliability,diagno,diagnostic,308,The external llvm should be built exactly in the same way as internal llvm to avoid troubles and waste time of the experts who do not really care. I'd prefer to conservatively require it and relax the requirement when there is a valid use case for having ROOT working with llvm with exported symbols... This diagnostic is a practical request by 2 expert users of external_llvm (which probably makes it around 99% of the users of that feature) :),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:324,reliability,pra,practical,324,The external llvm should be built exactly in the same way as internal llvm to avoid troubles and waste time of the experts who do not really care. I'd prefer to conservatively require it and relax the requirement when there is a valid use case for having ROOT working with llvm with exported symbols... This diagnostic is a practical request by 2 expert users of external_llvm (which probably makes it around 99% of the users of that feature) :),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:78,safety,avoid,avoid,78,The external llvm should be built exactly in the same way as internal llvm to avoid troubles and waste time of the experts who do not really care. I'd prefer to conservatively require it and relax the requirement when there is a valid use case for having ROOT working with llvm with exported symbols... This diagnostic is a practical request by 2 expert users of external_llvm (which probably makes it around 99% of the users of that feature) :),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:229,safety,valid,valid,229,The external llvm should be built exactly in the same way as internal llvm to avoid troubles and waste time of the experts who do not really care. I'd prefer to conservatively require it and relax the requirement when there is a valid use case for having ROOT working with llvm with exported symbols... This diagnostic is a practical request by 2 expert users of external_llvm (which probably makes it around 99% of the users of that feature) :),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:308,testability,diagno,diagnostic,308,The external llvm should be built exactly in the same way as internal llvm to avoid troubles and waste time of the experts who do not really care. I'd prefer to conservatively require it and relax the requirement when there is a valid use case for having ROOT working with llvm with exported symbols... This diagnostic is a practical request by 2 expert users of external_llvm (which probably makes it around 99% of the users of that feature) :),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:151,usability,prefer,prefer,151,The external llvm should be built exactly in the same way as internal llvm to avoid troubles and waste time of the experts who do not really care. I'd prefer to conservatively require it and relax the requirement when there is a valid use case for having ROOT working with llvm with exported symbols... This diagnostic is a practical request by 2 expert users of external_llvm (which probably makes it around 99% of the users of that feature) :),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:354,usability,user,users,354,The external llvm should be built exactly in the same way as internal llvm to avoid troubles and waste time of the experts who do not really care. I'd prefer to conservatively require it and relax the requirement when there is a valid use case for having ROOT working with llvm with exported symbols... This diagnostic is a practical request by 2 expert users of external_llvm (which probably makes it around 99% of the users of that feature) :),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:420,usability,user,users,420,The external llvm should be built exactly in the same way as internal llvm to avoid troubles and waste time of the experts who do not really care. I'd prefer to conservatively require it and relax the requirement when there is a valid use case for having ROOT working with llvm with exported symbols... This diagnostic is a practical request by 2 expert users of external_llvm (which probably makes it around 99% of the users of that feature) :),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:445,availability,failur,failure,445,"> troubles and waste time of the experts who do not really care. You are indeed re-iterating your opinion without providing new arguments. Let me repeat:. We don't see an issue with exported symbols anymore. I thus don't see a reason to provide a check. And even if I were wrong (totally possible), the check I remove in this PR is independent of what you discuss, so please propose your new check in a separate PR, with an explanation of which failure it avoids. Thanks!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:445,deployability,fail,failure,445,"> troubles and waste time of the experts who do not really care. You are indeed re-iterating your opinion without providing new arguments. Let me repeat:. We don't see an issue with exported symbols anymore. I thus don't see a reason to provide a check. And even if I were wrong (totally possible), the check I remove in this PR is independent of what you discuss, so please propose your new check in a separate PR, with an explanation of which failure it avoids. Thanks!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:21,performance,time,time,21,"> troubles and waste time of the experts who do not really care. You are indeed re-iterating your opinion without providing new arguments. Let me repeat:. We don't see an issue with exported symbols anymore. I thus don't see a reason to provide a check. And even if I were wrong (totally possible), the check I remove in this PR is independent of what you discuss, so please propose your new check in a separate PR, with an explanation of which failure it avoids. Thanks!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:445,performance,failur,failure,445,"> troubles and waste time of the experts who do not really care. You are indeed re-iterating your opinion without providing new arguments. Let me repeat:. We don't see an issue with exported symbols anymore. I thus don't see a reason to provide a check. And even if I were wrong (totally possible), the check I remove in this PR is independent of what you discuss, so please propose your new check in a separate PR, with an explanation of which failure it avoids. Thanks!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:445,reliability,fail,failure,445,"> troubles and waste time of the experts who do not really care. You are indeed re-iterating your opinion without providing new arguments. Let me repeat:. We don't see an issue with exported symbols anymore. I thus don't see a reason to provide a check. And even if I were wrong (totally possible), the check I remove in this PR is independent of what you discuss, so please propose your new check in a separate PR, with an explanation of which failure it avoids. Thanks!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:456,safety,avoid,avoids,456,"> troubles and waste time of the experts who do not really care. You are indeed re-iterating your opinion without providing new arguments. Let me repeat:. We don't see an issue with exported symbols anymore. I thus don't see a reason to provide a check. And even if I were wrong (totally possible), the check I remove in this PR is independent of what you discuss, so please propose your new check in a separate PR, with an explanation of which failure it avoids. Thanks!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:29,availability,failur,failure,29,mac1014/cxx17 was a checkout failure; all tests pass.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:29,deployability,fail,failure,29,mac1014/cxx17 was a checkout failure; all tests pass.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:29,performance,failur,failure,29,mac1014/cxx17 was a checkout failure; all tests pass.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:29,reliability,fail,failure,29,mac1014/cxx17 was a checkout failure; all tests pass.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:42,safety,test,tests,42,mac1014/cxx17 was a checkout failure; all tests pass.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:42,testability,test,tests,42,mac1014/cxx17 was a checkout failure; all tests pass.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:139,deployability,build,build,139,"If I may comment one last time: The correct check that we would actually want is to verify that in case -Dbuiltin_llvm=Off, ROOT checks at build time whether the external LLVM is built with symbols hidden. I don't know if this is easily possible. If it is not possible, I'd just leave the old check, and hide it with an `#ifdef EXTERNAL_LLVM` or similar. I agree it's a rare corner case, but still, since we know about the problem, it would be nice to leave a warning somewhere just in case someone else comes across it.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:26,performance,time,time,26,"If I may comment one last time: The correct check that we would actually want is to verify that in case -Dbuiltin_llvm=Off, ROOT checks at build time whether the external LLVM is built with symbols hidden. I don't know if this is easily possible. If it is not possible, I'd just leave the old check, and hide it with an `#ifdef EXTERNAL_LLVM` or similar. I agree it's a rare corner case, but still, since we know about the problem, it would be nice to leave a warning somewhere just in case someone else comes across it.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:145,performance,time,time,145,"If I may comment one last time: The correct check that we would actually want is to verify that in case -Dbuiltin_llvm=Off, ROOT checks at build time whether the external LLVM is built with symbols hidden. I don't know if this is easily possible. If it is not possible, I'd just leave the old check, and hide it with an `#ifdef EXTERNAL_LLVM` or similar. I agree it's a rare corner case, but still, since we know about the problem, it would be nice to leave a warning somewhere just in case someone else comes across it.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:84,testability,verif,verify,84,"If I may comment one last time: The correct check that we would actually want is to verify that in case -Dbuiltin_llvm=Off, ROOT checks at build time whether the external LLVM is built with symbols hidden. I don't know if this is easily possible. If it is not possible, I'd just leave the old check, and hide it with an `#ifdef EXTERNAL_LLVM` or similar. I agree it's a rare corner case, but still, since we know about the problem, it would be nice to leave a warning somewhere just in case someone else comes across it.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:155,energy efficiency,current,currently,155,@davidrohr the test that this PR removes does *not* test whether the llvm used by libCling has symbols visible or hidden. That's a different tests that we currently don't have (and that I don't believe we need but I might be wrong).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:41,reliability,doe,does,41,@davidrohr the test that this PR removes does *not* test whether the llvm used by libCling has symbols visible or hidden. That's a different tests that we currently don't have (and that I don't believe we need but I might be wrong).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:15,safety,test,test,15,@davidrohr the test that this PR removes does *not* test whether the llvm used by libCling has symbols visible or hidden. That's a different tests that we currently don't have (and that I don't believe we need but I might be wrong).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:52,safety,test,test,52,@davidrohr the test that this PR removes does *not* test whether the llvm used by libCling has symbols visible or hidden. That's a different tests that we currently don't have (and that I don't believe we need but I might be wrong).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:141,safety,test,tests,141,@davidrohr the test that this PR removes does *not* test whether the llvm used by libCling has symbols visible or hidden. That's a different tests that we currently don't have (and that I don't believe we need but I might be wrong).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:15,testability,test,test,15,@davidrohr the test that this PR removes does *not* test whether the llvm used by libCling has symbols visible or hidden. That's a different tests that we currently don't have (and that I don't believe we need but I might be wrong).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:52,testability,test,test,52,@davidrohr the test that this PR removes does *not* test whether the llvm used by libCling has symbols visible or hidden. That's a different tests that we currently don't have (and that I don't believe we need but I might be wrong).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:141,testability,test,tests,141,@davidrohr the test that this PR removes does *not* test whether the llvm used by libCling has symbols visible or hidden. That's a different tests that we currently don't have (and that I don't believe we need but I might be wrong).,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:114,deployability,build,build,114,"I know, but it would at least give you a warning to be careful with external LLVM. The correct check is indeed at build time whether the external LLVM was built right. Anyhow, let's conclude that we don't agree. For myself, I know what to take care of.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:120,performance,time,time,120,"I know, but it would at least give you a warning to be careful with external LLVM. The correct check is indeed at build time whether the external LLVM was built right. Anyhow, let's conclude that we don't agree. For myself, I know what to take care of.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:146,energy efficiency,load,loads,146,"> it would at least give you a warning to be careful with external LLVM. I don't see how it would! It:. - check for a visible llvm symbol. - then loads libCling. If the external llvm was built with visible symbols then the check would be happy. If you have a tool that you link yourself against llvm then it would barf if that your-llvm had exported symbols. But now: so what, not an issue. Summary: I understand that you believe that there is something to check, but I don't see how it relates to *this* check? David - what's the *second* llvm that you are dealing with? There's that of libCling, but there must be a second one that was linked against your binary or else you'd not see the warning. You did you link against libCling?!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:146,performance,load,loads,146,"> it would at least give you a warning to be careful with external LLVM. I don't see how it would! It:. - check for a visible llvm symbol. - then loads libCling. If the external llvm was built with visible symbols then the check would be happy. If you have a tool that you link yourself against llvm then it would barf if that your-llvm had exported symbols. But now: so what, not an issue. Summary: I understand that you believe that there is something to check, but I don't see how it relates to *this* check? David - what's the *second* llvm that you are dealing with? There's that of libCling, but there must be a second one that was linked against your binary or else you'd not see the warning. You did you link against libCling?!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:402,testability,understand,understand,402,"> it would at least give you a warning to be careful with external LLVM. I don't see how it would! It:. - check for a visible llvm symbol. - then loads libCling. If the external llvm was built with visible symbols then the check would be happy. If you have a tool that you link yourself against llvm then it would barf if that your-llvm had exported symbols. But now: so what, not an issue. Summary: I understand that you believe that there is something to check, but I don't see how it relates to *this* check? David - what's the *second* llvm that you are dealing with? There's that of libCling, but there must be a second one that was linked against your binary or else you'd not see the warning. You did you link against libCling?!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:259,usability,tool,tool,259,"> it would at least give you a warning to be careful with external LLVM. I don't see how it would! It:. - check for a visible llvm symbol. - then loads libCling. If the external llvm was built with visible symbols then the check would be happy. If you have a tool that you link yourself against llvm then it would barf if that your-llvm had exported symbols. But now: so what, not an issue. Summary: I understand that you believe that there is something to check, but I don't see how it relates to *this* check? David - what's the *second* llvm that you are dealing with? There's that of libCling, but there must be a second one that was linked against your binary or else you'd not see the warning. You did you link against libCling?!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:567,deployability,build,build,567,"> David - what's the _second_ llvm that you are dealing with? There's that of libCling, but there must be a second one that was linked against your binary or else you'd not see the warning. You did you link against libCling?! My ROOT was linked to an external LLVM 5, but then I also linked to arrow, which is itself linked to an LLVM 7 (and that LLVM7 doesn't have hidden symbols). That caused the collision. My point with keeping the warning in case of an external LLVM is:. - #4689 is basically ineffective for an external LLVM, since it changes the internal LLVM build files, which are not used. - By default, people with an external LLVM will not hide the symbols in the external LLVM, so they will end up in the same situation as before #4689 . - Hence we could either:. - Check if an external LLVM was build with hidden symbols like in #4689, then we would be safe. Otherwise we could reject this external LLVM as improperly built. - Or, disable the warning in this PR only for builtin_llvm. Then, the warning is gone in the default case. And when people use an external LLVM, they will get the same warning as before, as they are threatened by the same problem as before.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:809,deployability,build,build,809,"> David - what's the _second_ llvm that you are dealing with? There's that of libCling, but there must be a second one that was linked against your binary or else you'd not see the warning. You did you link against libCling?! My ROOT was linked to an external LLVM 5, but then I also linked to arrow, which is itself linked to an LLVM 7 (and that LLVM7 doesn't have hidden symbols). That caused the collision. My point with keeping the warning in case of an external LLVM is:. - #4689 is basically ineffective for an external LLVM, since it changes the internal LLVM build files, which are not used. - By default, people with an external LLVM will not hide the symbols in the external LLVM, so they will end up in the same situation as before #4689 . - Hence we could either:. - Check if an external LLVM was build with hidden symbols like in #4689, then we would be safe. Otherwise we could reject this external LLVM as improperly built. - Or, disable the warning in this PR only for builtin_llvm. Then, the warning is gone in the default case. And when people use an external LLVM, they will get the same warning as before, as they are threatened by the same problem as before.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:353,reliability,doe,doesn,353,"> David - what's the _second_ llvm that you are dealing with? There's that of libCling, but there must be a second one that was linked against your binary or else you'd not see the warning. You did you link against libCling?! My ROOT was linked to an external LLVM 5, but then I also linked to arrow, which is itself linked to an LLVM 7 (and that LLVM7 doesn't have hidden symbols). That caused the collision. My point with keeping the warning in case of an external LLVM is:. - #4689 is basically ineffective for an external LLVM, since it changes the internal LLVM build files, which are not used. - By default, people with an external LLVM will not hide the symbols in the external LLVM, so they will end up in the same situation as before #4689 . - Hence we could either:. - Check if an external LLVM was build with hidden symbols like in #4689, then we would be safe. Otherwise we could reject this external LLVM as improperly built. - Or, disable the warning in this PR only for builtin_llvm. Then, the warning is gone in the default case. And when people use an external LLVM, they will get the same warning as before, as they are threatened by the same problem as before.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:867,safety,safe,safe,867,"> David - what's the _second_ llvm that you are dealing with? There's that of libCling, but there must be a second one that was linked against your binary or else you'd not see the warning. You did you link against libCling?! My ROOT was linked to an external LLVM 5, but then I also linked to arrow, which is itself linked to an LLVM 7 (and that LLVM7 doesn't have hidden symbols). That caused the collision. My point with keeping the warning in case of an external LLVM is:. - #4689 is basically ineffective for an external LLVM, since it changes the internal LLVM build files, which are not used. - By default, people with an external LLVM will not hide the symbols in the external LLVM, so they will end up in the same situation as before #4689 . - Hence we could either:. - Check if an external LLVM was build with hidden symbols like in #4689, then we would be safe. Otherwise we could reject this external LLVM as improperly built. - Or, disable the warning in this PR only for builtin_llvm. Then, the warning is gone in the default case. And when people use an external LLVM, they will get the same warning as before, as they are threatened by the same problem as before.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:1138,security,threat,threatened,1138,"> David - what's the _second_ llvm that you are dealing with? There's that of libCling, but there must be a second one that was linked against your binary or else you'd not see the warning. You did you link against libCling?! My ROOT was linked to an external LLVM 5, but then I also linked to arrow, which is itself linked to an LLVM 7 (and that LLVM7 doesn't have hidden symbols). That caused the collision. My point with keeping the warning in case of an external LLVM is:. - #4689 is basically ineffective for an external LLVM, since it changes the internal LLVM build files, which are not used. - By default, people with an external LLVM will not hide the symbols in the external LLVM, so they will end up in the same situation as before #4689 . - Hence we could either:. - Check if an external LLVM was build with hidden symbols like in #4689, then we would be safe. Otherwise we could reject this external LLVM as improperly built. - Or, disable the warning in this PR only for builtin_llvm. Then, the warning is gone in the default case. And when people use an external LLVM, they will get the same warning as before, as they are threatened by the same problem as before.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:115,safety,test,test,115,OK thanks. But then the right check is *not just* to see whether the process has exported LLVM symbols (that's the test removed in this PR) because that isn't an issue if libCling's llvm is built correctly. But to check whether libCling's symbols are exposed *and* there are llvm symbols in the process. Again - just don't do that if it hurts :-),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:251,security,expos,exposed,251,OK thanks. But then the right check is *not just* to see whether the process has exported LLVM symbols (that's the test removed in this PR) because that isn't an issue if libCling's llvm is built correctly. But to check whether libCling's symbols are exposed *and* there are llvm symbols in the process. Again - just don't do that if it hurts :-),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:115,testability,test,test,115,OK thanks. But then the right check is *not just* to see whether the process has exported LLVM symbols (that's the test removed in this PR) because that isn't an issue if libCling's llvm is built correctly. But to check whether libCling's symbols are exposed *and* there are llvm symbols in the process. Again - just don't do that if it hurts :-),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:96,deployability,updat,update,96,"So since there is no progress, should we merge this as is, and when we implement a better check update it. At least right now we are getting false warnings.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:96,safety,updat,update,96,"So since there is no progress, should we merge this as is, and when we implement a better check update it. At least right now we are getting false warnings.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:96,security,updat,update,96,"So since there is no progress, should we merge this as is, and when we implement a better check update it. At least right now we are getting false warnings.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:21,usability,progress,progress,21,"So since there is no progress, should we merge this as is, and when we implement a better check update it. At least right now we are getting false warnings.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4736:11,deployability,build,build,11,@phsft-bot build just on ROOT-ubuntu18.04-i386/cxx14,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4736
https://github.com/root-project/root/pull/4737:11,deployability,build,build,11,@phsft-bot build with -Dpyroot_experimental=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4737
https://github.com/root-project/root/pull/4737:11,deployability,build,build,11,@phsft-bot build with -Dpyroot_experimental=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4737
https://github.com/root-project/root/pull/4738:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4738
https://github.com/root-project/root/pull/4738:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4738
https://github.com/root-project/root/pull/4738:11,deployability,build,build,11,@phsft-bot build just on mac1014/cxx17 with flags -Druntime_cxxmodules=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4738
https://github.com/root-project/root/pull/4738:30,deployability,fail,fails,30,Do we know why the MacOS test fails so much?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4738
https://github.com/root-project/root/pull/4738:30,reliability,fail,fails,30,Do we know why the MacOS test fails so much?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4738
https://github.com/root-project/root/pull/4738:25,safety,test,test,25,Do we know why the MacOS test fails so much?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4738
https://github.com/root-project/root/pull/4738:25,testability,test,test,25,Do we know why the MacOS test fails so much?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4738
https://github.com/root-project/root/pull/4738:91,availability,failur,failures,91,"C++ modules on Mac OS X is still experimental, but Vassil today managed to reduce from 400 failures to 24 :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4738
https://github.com/root-project/root/pull/4738:4,deployability,modul,modules,4,"C++ modules on Mac OS X is still experimental, but Vassil today managed to reduce from 400 failures to 24 :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4738
https://github.com/root-project/root/pull/4738:64,deployability,manag,managed,64,"C++ modules on Mac OS X is still experimental, but Vassil today managed to reduce from 400 failures to 24 :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4738
https://github.com/root-project/root/pull/4738:91,deployability,fail,failures,91,"C++ modules on Mac OS X is still experimental, but Vassil today managed to reduce from 400 failures to 24 :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4738
https://github.com/root-project/root/pull/4738:64,energy efficiency,manag,managed,64,"C++ modules on Mac OS X is still experimental, but Vassil today managed to reduce from 400 failures to 24 :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4738
https://github.com/root-project/root/pull/4738:75,energy efficiency,reduc,reduce,75,"C++ modules on Mac OS X is still experimental, but Vassil today managed to reduce from 400 failures to 24 :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4738
https://github.com/root-project/root/pull/4738:4,modifiability,modul,modules,4,"C++ modules on Mac OS X is still experimental, but Vassil today managed to reduce from 400 failures to 24 :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4738
https://github.com/root-project/root/pull/4738:91,performance,failur,failures,91,"C++ modules on Mac OS X is still experimental, but Vassil today managed to reduce from 400 failures to 24 :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4738
https://github.com/root-project/root/pull/4738:91,reliability,fail,failures,91,"C++ modules on Mac OS X is still experimental, but Vassil today managed to reduce from 400 failures to 24 :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4738
https://github.com/root-project/root/pull/4738:4,safety,modul,modules,4,"C++ modules on Mac OS X is still experimental, but Vassil today managed to reduce from 400 failures to 24 :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4738
https://github.com/root-project/root/pull/4738:64,safety,manag,managed,64,"C++ modules on Mac OS X is still experimental, but Vassil today managed to reduce from 400 failures to 24 :)",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4738
https://github.com/root-project/root/pull/4742:11,deployability,build,build,11,@phsft-bot build just on mac1014/cxx17 with flags -Druntime_cxxmodules=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4742
https://github.com/root-project/root/pull/4742:11,deployability,build,build,11,"@phsft-bot build on ROOT-performance-centos7-multicore/default, ROOT-fedora27/noimt, ROOT-fedora29/python3, ROOT-fedora30/cxx14, ROOT-ubuntu16/nortcxxmod, ROOT-ubuntu18.04-i386/cxx14, mac1014/cxx17, windows10/cxx14",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4742
https://github.com/root-project/root/pull/4742:25,performance,perform,performance-,25,"@phsft-bot build on ROOT-performance-centos7-multicore/default, ROOT-fedora27/noimt, ROOT-fedora29/python3, ROOT-fedora30/cxx14, ROOT-ubuntu16/nortcxxmod, ROOT-ubuntu18.04-i386/cxx14, mac1014/cxx17, windows10/cxx14",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4742
https://github.com/root-project/root/pull/4742:25,usability,perform,performance-,25,"@phsft-bot build on ROOT-performance-centos7-multicore/default, ROOT-fedora27/noimt, ROOT-fedora29/python3, ROOT-fedora30/cxx14, ROOT-ubuntu16/nortcxxmod, ROOT-ubuntu18.04-i386/cxx14, mac1014/cxx17, windows10/cxx14",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4742
https://github.com/root-project/root/pull/4743:11,deployability,build,build,11,@phsft-bot build just on mac1014/cxx17 with flags -Druntime_cxxmodules=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4743
https://github.com/root-project/root/pull/4743:4,availability,failur,failure,4,The failure is due to a flaky test TGraphMultiErrorsTests,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4743
https://github.com/root-project/root/pull/4743:4,deployability,fail,failure,4,The failure is due to a flaky test TGraphMultiErrorsTests,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4743
https://github.com/root-project/root/pull/4743:4,performance,failur,failure,4,The failure is due to a flaky test TGraphMultiErrorsTests,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4743
https://github.com/root-project/root/pull/4743:4,reliability,fail,failure,4,The failure is due to a flaky test TGraphMultiErrorsTests,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4743
https://github.com/root-project/root/pull/4743:30,safety,test,test,30,The failure is due to a flaky test TGraphMultiErrorsTests,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4743
https://github.com/root-project/root/pull/4743:30,testability,test,test,30,The failure is due to a flaky test TGraphMultiErrorsTests,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4743
https://github.com/root-project/root/pull/4749:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4749
https://github.com/root-project/root/pull/4749:32,usability,support,supporting,32,Closing as there is a consensus supporting #4750 instead.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4749
https://github.com/root-project/root/pull/4749:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4749
https://github.com/root-project/root/pull/4750:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:168,deployability,build,build,168,> I am in favor of this PR but it will require more thorough testing...@vgvassilev was asking if it works with -Dclingtest=ON. I agree that this one is cleaned and the build works with `clingtest=ON`. (I didn't try running anything beyond my usual test commands.),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:61,safety,test,testing,61,> I am in favor of this PR but it will require more thorough testing...@vgvassilev was asking if it works with -Dclingtest=ON. I agree that this one is cleaned and the build works with `clingtest=ON`. (I didn't try running anything beyond my usual test commands.),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:248,safety,test,test,248,> I am in favor of this PR but it will require more thorough testing...@vgvassilev was asking if it works with -Dclingtest=ON. I agree that this one is cleaned and the build works with `clingtest=ON`. (I didn't try running anything beyond my usual test commands.),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:61,testability,test,testing,61,> I am in favor of this PR but it will require more thorough testing...@vgvassilev was asking if it works with -Dclingtest=ON. I agree that this one is cleaned and the build works with `clingtest=ON`. (I didn't try running anything beyond my usual test commands.),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:248,testability,test,test,248,> I am in favor of this PR but it will require more thorough testing...@vgvassilev was asking if it works with -Dclingtest=ON. I agree that this one is cleaned and the build works with `clingtest=ON`. (I didn't try running anything beyond my usual test commands.),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:253,usability,command,commands,253,> I am in favor of this PR but it will require more thorough testing...@vgvassilev was asking if it works with -Dclingtest=ON. I agree that this one is cleaned and the build works with `clingtest=ON`. (I didn't try running anything beyond my usual test commands.),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:11,deployability,build,build,11,@phsft-bot build with flags -Dclingtest=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:4,availability,failur,failures,4,The failures actually mean this PR is ok. The changes introduced by this PR should have had impact on how we configure. The failing tests show that we went past this phase and fail in the testing phase which is something that we probably broke long ago. LGTM!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:4,deployability,fail,failures,4,The failures actually mean this PR is ok. The changes introduced by this PR should have had impact on how we configure. The failing tests show that we went past this phase and fail in the testing phase which is something that we probably broke long ago. LGTM!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:124,deployability,fail,failing,124,The failures actually mean this PR is ok. The changes introduced by this PR should have had impact on how we configure. The failing tests show that we went past this phase and fail in the testing phase which is something that we probably broke long ago. LGTM!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:176,deployability,fail,fail,176,The failures actually mean this PR is ok. The changes introduced by this PR should have had impact on how we configure. The failing tests show that we went past this phase and fail in the testing phase which is something that we probably broke long ago. LGTM!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:109,integrability,configur,configure,109,The failures actually mean this PR is ok. The changes introduced by this PR should have had impact on how we configure. The failing tests show that we went past this phase and fail in the testing phase which is something that we probably broke long ago. LGTM!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:109,modifiability,configur,configure,109,The failures actually mean this PR is ok. The changes introduced by this PR should have had impact on how we configure. The failing tests show that we went past this phase and fail in the testing phase which is something that we probably broke long ago. LGTM!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:4,performance,failur,failures,4,The failures actually mean this PR is ok. The changes introduced by this PR should have had impact on how we configure. The failing tests show that we went past this phase and fail in the testing phase which is something that we probably broke long ago. LGTM!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:4,reliability,fail,failures,4,The failures actually mean this PR is ok. The changes introduced by this PR should have had impact on how we configure. The failing tests show that we went past this phase and fail in the testing phase which is something that we probably broke long ago. LGTM!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:124,reliability,fail,failing,124,The failures actually mean this PR is ok. The changes introduced by this PR should have had impact on how we configure. The failing tests show that we went past this phase and fail in the testing phase which is something that we probably broke long ago. LGTM!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:176,reliability,fail,fail,176,The failures actually mean this PR is ok. The changes introduced by this PR should have had impact on how we configure. The failing tests show that we went past this phase and fail in the testing phase which is something that we probably broke long ago. LGTM!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:132,safety,test,tests,132,The failures actually mean this PR is ok. The changes introduced by this PR should have had impact on how we configure. The failing tests show that we went past this phase and fail in the testing phase which is something that we probably broke long ago. LGTM!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:188,safety,test,testing,188,The failures actually mean this PR is ok. The changes introduced by this PR should have had impact on how we configure. The failing tests show that we went past this phase and fail in the testing phase which is something that we probably broke long ago. LGTM!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:109,security,configur,configure,109,The failures actually mean this PR is ok. The changes introduced by this PR should have had impact on how we configure. The failing tests show that we went past this phase and fail in the testing phase which is something that we probably broke long ago. LGTM!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:132,testability,test,tests,132,The failures actually mean this PR is ok. The changes introduced by this PR should have had impact on how we configure. The failing tests show that we went past this phase and fail in the testing phase which is something that we probably broke long ago. LGTM!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:188,testability,test,testing,188,The failures actually mean this PR is ok. The changes introduced by this PR should have had impact on how we configure. The failing tests show that we went past this phase and fail in the testing phase which is something that we probably broke long ago. LGTM!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:33,availability,failur,failure,33,"LGTM, as well! I checked Windows failure (unrelated TBB failure), so @Axel-Naumann what do you think? Can we merge it?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:56,availability,failur,failure,56,"LGTM, as well! I checked Windows failure (unrelated TBB failure), so @Axel-Naumann what do you think? Can we merge it?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:33,deployability,fail,failure,33,"LGTM, as well! I checked Windows failure (unrelated TBB failure), so @Axel-Naumann what do you think? Can we merge it?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:56,deployability,fail,failure,56,"LGTM, as well! I checked Windows failure (unrelated TBB failure), so @Axel-Naumann what do you think? Can we merge it?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:33,performance,failur,failure,33,"LGTM, as well! I checked Windows failure (unrelated TBB failure), so @Axel-Naumann what do you think? Can we merge it?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:56,performance,failur,failure,56,"LGTM, as well! I checked Windows failure (unrelated TBB failure), so @Axel-Naumann what do you think? Can we merge it?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:33,reliability,fail,failure,33,"LGTM, as well! I checked Windows failure (unrelated TBB failure), so @Axel-Naumann what do you think? Can we merge it?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:56,reliability,fail,failure,56,"LGTM, as well! I checked Windows failure (unrelated TBB failure), so @Axel-Naumann what do you think? Can we merge it?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:201,deployability,upgrad,upgrade,201,"@Axel-Naumann I think it will be better, considering comment of @amadio in https://sft.its.cern.ch/jira/browse/ROOT-10472 to use instead of this PR, the PR #4749 (I reopened it). @chrisburr After LLVM upgrade, I will be happy to try your patch again!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:238,deployability,patch,patch,238,"@Axel-Naumann I think it will be better, considering comment of @amadio in https://sft.its.cern.ch/jira/browse/ROOT-10472 to use instead of this PR, the PR #4749 (I reopened it). @chrisburr After LLVM upgrade, I will be happy to try your patch again!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:201,modifiability,upgrad,upgrade,201,"@Axel-Naumann I think it will be better, considering comment of @amadio in https://sft.its.cern.ch/jira/browse/ROOT-10472 to use instead of this PR, the PR #4749 (I reopened it). @chrisburr After LLVM upgrade, I will be happy to try your patch again!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:238,safety,patch,patch,238,"@Axel-Naumann I think it will be better, considering comment of @amadio in https://sft.its.cern.ch/jira/browse/ROOT-10472 to use instead of this PR, the PR #4749 (I reopened it). @chrisburr After LLVM upgrade, I will be happy to try your patch again!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:238,security,patch,patch,238,"@Axel-Naumann I think it will be better, considering comment of @amadio in https://sft.its.cern.ch/jira/browse/ROOT-10472 to use instead of this PR, the PR #4749 (I reopened it). @chrisburr After LLVM upgrade, I will be happy to try your patch again!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:124,availability,failur,failures,124,"I see no argument why the cling tests are preexisting? Could someone please verify, eg. using the PR builds testing PR? The failures look suspiciously connected to a change of the build system in how we link llvm into cling.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:101,deployability,build,builds,101,"I see no argument why the cling tests are preexisting? Could someone please verify, eg. using the PR builds testing PR? The failures look suspiciously connected to a change of the build system in how we link llvm into cling.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:124,deployability,fail,failures,124,"I see no argument why the cling tests are preexisting? Could someone please verify, eg. using the PR builds testing PR? The failures look suspiciously connected to a change of the build system in how we link llvm into cling.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:180,deployability,build,build,180,"I see no argument why the cling tests are preexisting? Could someone please verify, eg. using the PR builds testing PR? The failures look suspiciously connected to a change of the build system in how we link llvm into cling.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:124,performance,failur,failures,124,"I see no argument why the cling tests are preexisting? Could someone please verify, eg. using the PR builds testing PR? The failures look suspiciously connected to a change of the build system in how we link llvm into cling.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:124,reliability,fail,failures,124,"I see no argument why the cling tests are preexisting? Could someone please verify, eg. using the PR builds testing PR? The failures look suspiciously connected to a change of the build system in how we link llvm into cling.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:32,safety,test,tests,32,"I see no argument why the cling tests are preexisting? Could someone please verify, eg. using the PR builds testing PR? The failures look suspiciously connected to a change of the build system in how we link llvm into cling.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:108,safety,test,testing,108,"I see no argument why the cling tests are preexisting? Could someone please verify, eg. using the PR builds testing PR? The failures look suspiciously connected to a change of the build system in how we link llvm into cling.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:32,testability,test,tests,32,"I see no argument why the cling tests are preexisting? Could someone please verify, eg. using the PR builds testing PR? The failures look suspiciously connected to a change of the build system in how we link llvm into cling.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:76,testability,verif,verify,76,"I see no argument why the cling tests are preexisting? Could someone please verify, eg. using the PR builds testing PR? The failures look suspiciously connected to a change of the build system in how we link llvm into cling.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:108,testability,test,testing,108,"I see no argument why the cling tests are preexisting? Could someone please verify, eg. using the PR builds testing PR? The failures look suspiciously connected to a change of the build system in how we link llvm into cling.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:57,deployability,Updat,Update,57,I opened https://github.com/root-project/root/pull/4843. Update: tests are failing in master as well.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:75,deployability,fail,failing,75,I opened https://github.com/root-project/root/pull/4843. Update: tests are failing in master as well.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:75,reliability,fail,failing,75,I opened https://github.com/root-project/root/pull/4843. Update: tests are failing in master as well.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:57,safety,Updat,Update,57,I opened https://github.com/root-project/root/pull/4843. Update: tests are failing in master as well.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:65,safety,test,tests,65,I opened https://github.com/root-project/root/pull/4843. Update: tests are failing in master as well.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:57,security,Updat,Update,57,I opened https://github.com/root-project/root/pull/4843. Update: tests are failing in master as well.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4750:65,testability,test,tests,65,I opened https://github.com/root-project/root/pull/4843. Update: tests are failing in master as well.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4750
https://github.com/root-project/root/pull/4751:56,deployability,instal,installing,56,"Hey, can you return back the line because *_.rdicts are installing somewhere else following two commit messages https://github.com/root-project/root/commit/5cad428dc71929b9f4c202fadfe5934513cd978a and https://github.com/root-project/root/commit/8afa8841936b35167515789f40934d660c6455ab",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4751
https://github.com/root-project/root/pull/4751:103,integrability,messag,messages,103,"Hey, can you return back the line because *_.rdicts are installing somewhere else following two commit messages https://github.com/root-project/root/commit/5cad428dc71929b9f4c202fadfe5934513cd978a and https://github.com/root-project/root/commit/8afa8841936b35167515789f40934d660c6455ab",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4751
https://github.com/root-project/root/pull/4751:103,interoperability,messag,messages,103,"Hey, can you return back the line because *_.rdicts are installing somewhere else following two commit messages https://github.com/root-project/root/commit/5cad428dc71929b9f4c202fadfe5934513cd978a and https://github.com/root-project/root/commit/8afa8841936b35167515789f40934d660c6455ab",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4751
https://github.com/root-project/root/pull/4751:58,deployability,instal,installing,58,"> Hey, can you return back the line because *_.rdicts are installing somewhere else following two commit messages [5cad428](https://github.com/root-project/root/commit/5cad428dc71929b9f4c202fadfe5934513cd978a) and [8afa884](https://github.com/root-project/root/commit/8afa8841936b35167515789f40934d660c6455ab). I build ROOT with R modules with and without the line, and it is really doesn't allow to install _rdicts (e.g. for R). Please go ahead with merging like it is now! Thanks for patience!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4751
https://github.com/root-project/root/pull/4751:313,deployability,build,build,313,"> Hey, can you return back the line because *_.rdicts are installing somewhere else following two commit messages [5cad428](https://github.com/root-project/root/commit/5cad428dc71929b9f4c202fadfe5934513cd978a) and [8afa884](https://github.com/root-project/root/commit/8afa8841936b35167515789f40934d660c6455ab). I build ROOT with R modules with and without the line, and it is really doesn't allow to install _rdicts (e.g. for R). Please go ahead with merging like it is now! Thanks for patience!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4751
https://github.com/root-project/root/pull/4751:331,deployability,modul,modules,331,"> Hey, can you return back the line because *_.rdicts are installing somewhere else following two commit messages [5cad428](https://github.com/root-project/root/commit/5cad428dc71929b9f4c202fadfe5934513cd978a) and [8afa884](https://github.com/root-project/root/commit/8afa8841936b35167515789f40934d660c6455ab). I build ROOT with R modules with and without the line, and it is really doesn't allow to install _rdicts (e.g. for R). Please go ahead with merging like it is now! Thanks for patience!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4751
https://github.com/root-project/root/pull/4751:400,deployability,instal,install,400,"> Hey, can you return back the line because *_.rdicts are installing somewhere else following two commit messages [5cad428](https://github.com/root-project/root/commit/5cad428dc71929b9f4c202fadfe5934513cd978a) and [8afa884](https://github.com/root-project/root/commit/8afa8841936b35167515789f40934d660c6455ab). I build ROOT with R modules with and without the line, and it is really doesn't allow to install _rdicts (e.g. for R). Please go ahead with merging like it is now! Thanks for patience!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4751
https://github.com/root-project/root/pull/4751:105,integrability,messag,messages,105,"> Hey, can you return back the line because *_.rdicts are installing somewhere else following two commit messages [5cad428](https://github.com/root-project/root/commit/5cad428dc71929b9f4c202fadfe5934513cd978a) and [8afa884](https://github.com/root-project/root/commit/8afa8841936b35167515789f40934d660c6455ab). I build ROOT with R modules with and without the line, and it is really doesn't allow to install _rdicts (e.g. for R). Please go ahead with merging like it is now! Thanks for patience!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4751
https://github.com/root-project/root/pull/4751:105,interoperability,messag,messages,105,"> Hey, can you return back the line because *_.rdicts are installing somewhere else following two commit messages [5cad428](https://github.com/root-project/root/commit/5cad428dc71929b9f4c202fadfe5934513cd978a) and [8afa884](https://github.com/root-project/root/commit/8afa8841936b35167515789f40934d660c6455ab). I build ROOT with R modules with and without the line, and it is really doesn't allow to install _rdicts (e.g. for R). Please go ahead with merging like it is now! Thanks for patience!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4751
https://github.com/root-project/root/pull/4751:331,modifiability,modul,modules,331,"> Hey, can you return back the line because *_.rdicts are installing somewhere else following two commit messages [5cad428](https://github.com/root-project/root/commit/5cad428dc71929b9f4c202fadfe5934513cd978a) and [8afa884](https://github.com/root-project/root/commit/8afa8841936b35167515789f40934d660c6455ab). I build ROOT with R modules with and without the line, and it is really doesn't allow to install _rdicts (e.g. for R). Please go ahead with merging like it is now! Thanks for patience!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4751
https://github.com/root-project/root/pull/4751:383,reliability,doe,doesn,383,"> Hey, can you return back the line because *_.rdicts are installing somewhere else following two commit messages [5cad428](https://github.com/root-project/root/commit/5cad428dc71929b9f4c202fadfe5934513cd978a) and [8afa884](https://github.com/root-project/root/commit/8afa8841936b35167515789f40934d660c6455ab). I build ROOT with R modules with and without the line, and it is really doesn't allow to install _rdicts (e.g. for R). Please go ahead with merging like it is now! Thanks for patience!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4751
https://github.com/root-project/root/pull/4751:331,safety,modul,modules,331,"> Hey, can you return back the line because *_.rdicts are installing somewhere else following two commit messages [5cad428](https://github.com/root-project/root/commit/5cad428dc71929b9f4c202fadfe5934513cd978a) and [8afa884](https://github.com/root-project/root/commit/8afa8841936b35167515789f40934d660c6455ab). I build ROOT with R modules with and without the line, and it is really doesn't allow to install _rdicts (e.g. for R). Please go ahead with merging like it is now! Thanks for patience!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4751
https://github.com/root-project/root/pull/4751:51,deployability,updat,update,51,...it would have been helpful for the future us to update the commit log to explain why that exclusion can be dropped. Next time! Axel.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4751
https://github.com/root-project/root/pull/4751:69,deployability,log,log,69,...it would have been helpful for the future us to update the commit log to explain why that exclusion can be dropped. Next time! Axel.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4751
https://github.com/root-project/root/pull/4751:124,performance,time,time,124,...it would have been helpful for the future us to update the commit log to explain why that exclusion can be dropped. Next time! Axel.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4751
https://github.com/root-project/root/pull/4751:51,safety,updat,update,51,...it would have been helpful for the future us to update the commit log to explain why that exclusion can be dropped. Next time! Axel.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4751
https://github.com/root-project/root/pull/4751:69,safety,log,log,69,...it would have been helpful for the future us to update the commit log to explain why that exclusion can be dropped. Next time! Axel.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4751
https://github.com/root-project/root/pull/4751:51,security,updat,update,51,...it would have been helpful for the future us to update the commit log to explain why that exclusion can be dropped. Next time! Axel.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4751
https://github.com/root-project/root/pull/4751:69,security,log,log,69,...it would have been helpful for the future us to update the commit log to explain why that exclusion can be dropped. Next time! Axel.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4751
https://github.com/root-project/root/pull/4751:69,testability,log,log,69,...it would have been helpful for the future us to update the commit log to explain why that exclusion can be dropped. Next time! Axel.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4751
https://github.com/root-project/root/pull/4751:22,usability,help,helpful,22,...it would have been helpful for the future us to update the commit log to explain why that exclusion can be dropped. Next time! Axel.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4751
https://github.com/root-project/root/pull/4752:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4752
https://github.com/root-project/root/pull/4753:11,deployability,build,build,11,@phsft-bot build with-flags -Dpyroot_experimental=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4753
https://github.com/root-project/root/pull/4753:11,deployability,build,build,11,@phsft-bot build with flags -Dpyroot_experimental=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4753
https://github.com/root-project/root/pull/4754:252,deployability,patch,patch,252,I will just add that this pythonization (and the other using-related ones for `plotOn`) will no longer be necessary in the new PyROOT when this PR is in its final shape and is merged:. https://github.com/root-project/root/pull/3640. which comes from a patch in the mini-ROOT of Cppyy:. https://bitbucket.org/wlav/cppyy-backend/src/master/cling/patches/using_decls.diff .,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4754
https://github.com/root-project/root/pull/4754:344,deployability,patch,patches,344,I will just add that this pythonization (and the other using-related ones for `plotOn`) will no longer be necessary in the new PyROOT when this PR is in its final shape and is merged:. https://github.com/root-project/root/pull/3640. which comes from a patch in the mini-ROOT of Cppyy:. https://bitbucket.org/wlav/cppyy-backend/src/master/cling/patches/using_decls.diff .,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4754
https://github.com/root-project/root/pull/4754:252,safety,patch,patch,252,I will just add that this pythonization (and the other using-related ones for `plotOn`) will no longer be necessary in the new PyROOT when this PR is in its final shape and is merged:. https://github.com/root-project/root/pull/3640. which comes from a patch in the mini-ROOT of Cppyy:. https://bitbucket.org/wlav/cppyy-backend/src/master/cling/patches/using_decls.diff .,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4754
https://github.com/root-project/root/pull/4754:344,safety,patch,patches,344,I will just add that this pythonization (and the other using-related ones for `plotOn`) will no longer be necessary in the new PyROOT when this PR is in its final shape and is merged:. https://github.com/root-project/root/pull/3640. which comes from a patch in the mini-ROOT of Cppyy:. https://bitbucket.org/wlav/cppyy-backend/src/master/cling/patches/using_decls.diff .,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4754
https://github.com/root-project/root/pull/4754:252,security,patch,patch,252,I will just add that this pythonization (and the other using-related ones for `plotOn`) will no longer be necessary in the new PyROOT when this PR is in its final shape and is merged:. https://github.com/root-project/root/pull/3640. which comes from a patch in the mini-ROOT of Cppyy:. https://bitbucket.org/wlav/cppyy-backend/src/master/cling/patches/using_decls.diff .,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4754
https://github.com/root-project/root/pull/4754:344,security,patch,patches,344,I will just add that this pythonization (and the other using-related ones for `plotOn`) will no longer be necessary in the new PyROOT when this PR is in its final shape and is merged:. https://github.com/root-project/root/pull/3640. which comes from a patch in the mini-ROOT of Cppyy:. https://bitbucket.org/wlav/cppyy-backend/src/master/cling/patches/using_decls.diff .,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4754
https://github.com/root-project/root/pull/4755:16,deployability,patch,patch,16,I'll apply this patch. Thanks to have fixed this problem.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4755
https://github.com/root-project/root/pull/4755:16,safety,patch,patch,16,I'll apply this patch. Thanks to have fixed this problem.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4755
https://github.com/root-project/root/pull/4755:16,security,patch,patch,16,I'll apply this patch. Thanks to have fixed this problem.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4755
https://github.com/root-project/root/pull/4756:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4756
https://github.com/root-project/root/pull/4756:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4756
https://github.com/root-project/root/pull/4756:198,deployability,patch,patch,198,"@agheata, yes, it would be good to have it in 6.20 and the next 6.18.x, too, if possible. We have also another PR (https://github.com/root-project/root/pull/4459) which we would like to have in the patch 6.18.x tag.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4756
https://github.com/root-project/root/pull/4756:198,safety,patch,patch,198,"@agheata, yes, it would be good to have it in 6.20 and the next 6.18.x, too, if possible. We have also another PR (https://github.com/root-project/root/pull/4459) which we would like to have in the patch 6.18.x tag.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4756
https://github.com/root-project/root/pull/4756:198,security,patch,patch,198,"@agheata, yes, it would be good to have it in 6.20 and the next 6.18.x, too, if possible. We have also another PR (https://github.com/root-project/root/pull/4459) which we would like to have in the patch 6.18.x tag.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4756
https://github.com/root-project/root/pull/4756:30,energy efficiency,green,green,30,I think we need @Axel-Naumann green light to put these PR's in 6.20.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4756
https://github.com/root-project/root/pull/4757:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4757
https://github.com/root-project/root/pull/4758:11,deployability,build,build,11,@phsft-bot build just on mac1014/cxx17 with flags -Druntime_cxxmodules=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4758
https://github.com/root-project/root/pull/4758:11,deployability,build,build,11,@phsft-bot build just on mac1014/cxx17 with flags -Druntime_cxxmodules=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4758
https://github.com/root-project/root/pull/4758:11,deployability,build,build,11,@phsft-bot build just on mac1014/cxx17 with flags -Druntime_cxxmodules=On -Dsoversion=Off,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4758
https://github.com/root-project/root/pull/4758:11,deployability,build,build,11,@phsft-bot build just on mac1014/cxx17 with flags -Druntime_cxxmodules=On -Dsoversion=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4758
https://github.com/root-project/root/pull/4758:11,safety,test,tests,11,"> LGTM! 13 tests were fixed (from 37 to 24), but why -Dsoversion=Off should be off? I was just playing around. No particular need.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4758
https://github.com/root-project/root/pull/4758:11,testability,test,tests,11,"> LGTM! 13 tests were fixed (from 37 to 24), but why -Dsoversion=Off should be off? I was just playing around. No particular need.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4758
https://github.com/root-project/root/pull/4758:11,deployability,build,build,11,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4758
https://github.com/root-project/root/pull/4758:11,deployability,build,build,11,@phsft-bot build just on mac1014/cxx17 with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4758
https://github.com/root-project/root/pull/4758:11,deployability,build,build,11,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4758
https://github.com/root-project/root/pull/4758:48,integrability,messag,message,48,The push just has wording changes in the commit message.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4758
https://github.com/root-project/root/pull/4758:48,interoperability,messag,message,48,The push just has wording changes in the commit message.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4758
https://github.com/root-project/root/pull/4761:79,performance,time,time,79,"@Axel-Naumann, @vgvassilev, we checked and for me, it improved from 0.4s (wall time) to 0.3s for tutorials/matrix/invertMatrix.C",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4761
https://github.com/root-project/root/pull/4762:30,deployability,build,build,30,Could an admin please start a build of this PR to check whether all tests are passing?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4762
https://github.com/root-project/root/pull/4762:68,safety,test,tests,68,Could an admin please start a build of this PR to check whether all tests are passing?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4762
https://github.com/root-project/root/pull/4762:68,testability,test,tests,68,Could an admin please start a build of this PR to check whether all tests are passing?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4762
https://github.com/root-project/root/pull/4763:84,availability,error,error,84,The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:175,deployability,releas,release,175,The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:322,deployability,releas,release,322,The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:132,integrability,rout,routine,132,The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:84,performance,error,error,84,The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:27,safety,hot,hotspot,27,The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:68,safety,risk,risk,68,The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:84,safety,error,error,84,The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:114,safety,compl,complexity,114,The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:153,safety,risk,risk,153,The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:68,security,risk,risk,68,The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:114,security,compl,complexity,114,The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:153,security,risk,risk,153,The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:84,usability,error,error,84,The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:86,availability,error,error,86,"> The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch. @vgvassilev . As long as @etejedor agrees, for me it's fine reverting a couple of commits and go back to 4ce57e, even if empty directories are installed. . But I don't think this can stay as it is forever. As I partially pointed out in the description, there are two main cons:. - 80 pcms out of 90 are installed twice;. - install(DIRECTORY ...) has the default behavior of copying empty skeletons of all the subdirectories found in the directory; it was only by chance that we found it with the introduction of multiple Python versions, but this doesn't mean that we're not going to be stuck in the same situation once again in the future.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:177,deployability,releas,release,177,"> The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch. @vgvassilev . As long as @etejedor agrees, for me it's fine reverting a couple of commits and go back to 4ce57e, even if empty directories are installed. . But I don't think this can stay as it is forever. As I partially pointed out in the description, there are two main cons:. - 80 pcms out of 90 are installed twice;. - install(DIRECTORY ...) has the default behavior of copying empty skeletons of all the subdirectories found in the directory; it was only by chance that we found it with the introduction of multiple Python versions, but this doesn't mean that we're not going to be stuck in the same situation once again in the future.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:324,deployability,releas,release,324,"> The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch. @vgvassilev . As long as @etejedor agrees, for me it's fine reverting a couple of commits and go back to 4ce57e, even if empty directories are installed. . But I don't think this can stay as it is forever. As I partially pointed out in the description, there are two main cons:. - 80 pcms out of 90 are installed twice;. - install(DIRECTORY ...) has the default behavior of copying empty skeletons of all the subdirectories found in the directory; it was only by chance that we found it with the introduction of multiple Python versions, but this doesn't mean that we're not going to be stuck in the same situation once again in the future.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:483,deployability,instal,installed,483,"> The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch. @vgvassilev . As long as @etejedor agrees, for me it's fine reverting a couple of commits and go back to 4ce57e, even if empty directories are installed. . But I don't think this can stay as it is forever. As I partially pointed out in the description, there are two main cons:. - 80 pcms out of 90 are installed twice;. - install(DIRECTORY ...) has the default behavior of copying empty skeletons of all the subdirectories found in the directory; it was only by chance that we found it with the introduction of multiple Python versions, but this doesn't mean that we're not going to be stuck in the same situation once again in the future.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:643,deployability,instal,installed,643,"> The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch. @vgvassilev . As long as @etejedor agrees, for me it's fine reverting a couple of commits and go back to 4ce57e, even if empty directories are installed. . But I don't think this can stay as it is forever. As I partially pointed out in the description, there are two main cons:. - 80 pcms out of 90 are installed twice;. - install(DIRECTORY ...) has the default behavior of copying empty skeletons of all the subdirectories found in the directory; it was only by chance that we found it with the introduction of multiple Python versions, but this doesn't mean that we're not going to be stuck in the same situation once again in the future.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:663,deployability,instal,install,663,"> The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch. @vgvassilev . As long as @etejedor agrees, for me it's fine reverting a couple of commits and go back to 4ce57e, even if empty directories are installed. . But I don't think this can stay as it is forever. As I partially pointed out in the description, there are two main cons:. - 80 pcms out of 90 are installed twice;. - install(DIRECTORY ...) has the default behavior of copying empty skeletons of all the subdirectories found in the directory; it was only by chance that we found it with the introduction of multiple Python versions, but this doesn't mean that we're not going to be stuck in the same situation once again in the future.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:868,deployability,version,versions,868,"> The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch. @vgvassilev . As long as @etejedor agrees, for me it's fine reverting a couple of commits and go back to 4ce57e, even if empty directories are installed. . But I don't think this can stay as it is forever. As I partially pointed out in the description, there are two main cons:. - 80 pcms out of 90 are installed twice;. - install(DIRECTORY ...) has the default behavior of copying empty skeletons of all the subdirectories found in the directory; it was only by chance that we found it with the introduction of multiple Python versions, but this doesn't mean that we're not going to be stuck in the same situation once again in the future.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:134,integrability,rout,routine,134,"> The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch. @vgvassilev . As long as @etejedor agrees, for me it's fine reverting a couple of commits and go back to 4ce57e, even if empty directories are installed. . But I don't think this can stay as it is forever. As I partially pointed out in the description, there are two main cons:. - 80 pcms out of 90 are installed twice;. - install(DIRECTORY ...) has the default behavior of copying empty skeletons of all the subdirectories found in the directory; it was only by chance that we found it with the introduction of multiple Python versions, but this doesn't mean that we're not going to be stuck in the same situation once again in the future.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:412,integrability,coupl,couple,412,"> The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch. @vgvassilev . As long as @etejedor agrees, for me it's fine reverting a couple of commits and go back to 4ce57e, even if empty directories are installed. . But I don't think this can stay as it is forever. As I partially pointed out in the description, there are two main cons:. - 80 pcms out of 90 are installed twice;. - install(DIRECTORY ...) has the default behavior of copying empty skeletons of all the subdirectories found in the directory; it was only by chance that we found it with the introduction of multiple Python versions, but this doesn't mean that we're not going to be stuck in the same situation once again in the future.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:749,integrability,sub,subdirectories,749,"> The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch. @vgvassilev . As long as @etejedor agrees, for me it's fine reverting a couple of commits and go back to 4ce57e, even if empty directories are installed. . But I don't think this can stay as it is forever. As I partially pointed out in the description, there are two main cons:. - 80 pcms out of 90 are installed twice;. - install(DIRECTORY ...) has the default behavior of copying empty skeletons of all the subdirectories found in the directory; it was only by chance that we found it with the introduction of multiple Python versions, but this doesn't mean that we're not going to be stuck in the same situation once again in the future.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:868,integrability,version,versions,868,"> The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch. @vgvassilev . As long as @etejedor agrees, for me it's fine reverting a couple of commits and go back to 4ce57e, even if empty directories are installed. . But I don't think this can stay as it is forever. As I partially pointed out in the description, there are two main cons:. - 80 pcms out of 90 are installed twice;. - install(DIRECTORY ...) has the default behavior of copying empty skeletons of all the subdirectories found in the directory; it was only by chance that we found it with the introduction of multiple Python versions, but this doesn't mean that we're not going to be stuck in the same situation once again in the future.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:728,interoperability,skeleton,skeletons,728,"> The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch. @vgvassilev . As long as @etejedor agrees, for me it's fine reverting a couple of commits and go back to 4ce57e, even if empty directories are installed. . But I don't think this can stay as it is forever. As I partially pointed out in the description, there are two main cons:. - 80 pcms out of 90 are installed twice;. - install(DIRECTORY ...) has the default behavior of copying empty skeletons of all the subdirectories found in the directory; it was only by chance that we found it with the introduction of multiple Python versions, but this doesn't mean that we're not going to be stuck in the same situation once again in the future.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:412,modifiability,coupl,couple,412,"> The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch. @vgvassilev . As long as @etejedor agrees, for me it's fine reverting a couple of commits and go back to 4ce57e, even if empty directories are installed. . But I don't think this can stay as it is forever. As I partially pointed out in the description, there are two main cons:. - 80 pcms out of 90 are installed twice;. - install(DIRECTORY ...) has the default behavior of copying empty skeletons of all the subdirectories found in the directory; it was only by chance that we found it with the introduction of multiple Python versions, but this doesn't mean that we're not going to be stuck in the same situation once again in the future.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:868,modifiability,version,versions,868,"> The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch. @vgvassilev . As long as @etejedor agrees, for me it's fine reverting a couple of commits and go back to 4ce57e, even if empty directories are installed. . But I don't think this can stay as it is forever. As I partially pointed out in the description, there are two main cons:. - 80 pcms out of 90 are installed twice;. - install(DIRECTORY ...) has the default behavior of copying empty skeletons of all the subdirectories found in the directory; it was only by chance that we found it with the introduction of multiple Python versions, but this doesn't mean that we're not going to be stuck in the same situation once again in the future.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:86,performance,error,error,86,"> The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch. @vgvassilev . As long as @etejedor agrees, for me it's fine reverting a couple of commits and go back to 4ce57e, even if empty directories are installed. . But I don't think this can stay as it is forever. As I partially pointed out in the description, there are two main cons:. - 80 pcms out of 90 are installed twice;. - install(DIRECTORY ...) has the default behavior of copying empty skeletons of all the subdirectories found in the directory; it was only by chance that we found it with the introduction of multiple Python versions, but this doesn't mean that we're not going to be stuck in the same situation once again in the future.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:887,reliability,doe,doesn,887,"> The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch. @vgvassilev . As long as @etejedor agrees, for me it's fine reverting a couple of commits and go back to 4ce57e, even if empty directories are installed. . But I don't think this can stay as it is forever. As I partially pointed out in the description, there are two main cons:. - 80 pcms out of 90 are installed twice;. - install(DIRECTORY ...) has the default behavior of copying empty skeletons of all the subdirectories found in the directory; it was only by chance that we found it with the introduction of multiple Python versions, but this doesn't mean that we're not going to be stuck in the same situation once again in the future.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:29,safety,hot,hotspot,29,"> The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch. @vgvassilev . As long as @etejedor agrees, for me it's fine reverting a couple of commits and go back to 4ce57e, even if empty directories are installed. . But I don't think this can stay as it is forever. As I partially pointed out in the description, there are two main cons:. - 80 pcms out of 90 are installed twice;. - install(DIRECTORY ...) has the default behavior of copying empty skeletons of all the subdirectories found in the directory; it was only by chance that we found it with the introduction of multiple Python versions, but this doesn't mean that we're not going to be stuck in the same situation once again in the future.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:70,safety,risk,risk,70,"> The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch. @vgvassilev . As long as @etejedor agrees, for me it's fine reverting a couple of commits and go back to 4ce57e, even if empty directories are installed. . But I don't think this can stay as it is forever. As I partially pointed out in the description, there are two main cons:. - 80 pcms out of 90 are installed twice;. - install(DIRECTORY ...) has the default behavior of copying empty skeletons of all the subdirectories found in the directory; it was only by chance that we found it with the introduction of multiple Python versions, but this doesn't mean that we're not going to be stuck in the same situation once again in the future.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:86,safety,error,error,86,"> The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch. @vgvassilev . As long as @etejedor agrees, for me it's fine reverting a couple of commits and go back to 4ce57e, even if empty directories are installed. . But I don't think this can stay as it is forever. As I partially pointed out in the description, there are two main cons:. - 80 pcms out of 90 are installed twice;. - install(DIRECTORY ...) has the default behavior of copying empty skeletons of all the subdirectories found in the directory; it was only by chance that we found it with the introduction of multiple Python versions, but this doesn't mean that we're not going to be stuck in the same situation once again in the future.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:116,safety,compl,complexity,116,"> The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch. @vgvassilev . As long as @etejedor agrees, for me it's fine reverting a couple of commits and go back to 4ce57e, even if empty directories are installed. . But I don't think this can stay as it is forever. As I partially pointed out in the description, there are two main cons:. - 80 pcms out of 90 are installed twice;. - install(DIRECTORY ...) has the default behavior of copying empty skeletons of all the subdirectories found in the directory; it was only by chance that we found it with the introduction of multiple Python versions, but this doesn't mean that we're not going to be stuck in the same situation once again in the future.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:155,safety,risk,risk,155,"> The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch. @vgvassilev . As long as @etejedor agrees, for me it's fine reverting a couple of commits and go back to 4ce57e, even if empty directories are installed. . But I don't think this can stay as it is forever. As I partially pointed out in the description, there are two main cons:. - 80 pcms out of 90 are installed twice;. - install(DIRECTORY ...) has the default behavior of copying empty skeletons of all the subdirectories found in the directory; it was only by chance that we found it with the introduction of multiple Python versions, but this doesn't mean that we're not going to be stuck in the same situation once again in the future.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:70,security,risk,risk,70,"> The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch. @vgvassilev . As long as @etejedor agrees, for me it's fine reverting a couple of commits and go back to 4ce57e, even if empty directories are installed. . But I don't think this can stay as it is forever. As I partially pointed out in the description, there are two main cons:. - 80 pcms out of 90 are installed twice;. - install(DIRECTORY ...) has the default behavior of copying empty skeletons of all the subdirectories found in the directory; it was only by chance that we found it with the introduction of multiple Python versions, but this doesn't mean that we're not going to be stuck in the same situation once again in the future.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:116,security,compl,complexity,116,"> The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch. @vgvassilev . As long as @etejedor agrees, for me it's fine reverting a couple of commits and go back to 4ce57e, even if empty directories are installed. . But I don't think this can stay as it is forever. As I partially pointed out in the description, there are two main cons:. - 80 pcms out of 90 are installed twice;. - install(DIRECTORY ...) has the default behavior of copying empty skeletons of all the subdirectories found in the directory; it was only by chance that we found it with the introduction of multiple Python versions, but this doesn't mean that we're not going to be stuck in the same situation once again in the future.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:155,security,risk,risk,155,"> The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch. @vgvassilev . As long as @etejedor agrees, for me it's fine reverting a couple of commits and go back to 4ce57e, even if empty directories are installed. . But I don't think this can stay as it is forever. As I partially pointed out in the description, there are two main cons:. - 80 pcms out of 90 are installed twice;. - install(DIRECTORY ...) has the default behavior of copying empty skeletons of all the subdirectories found in the directory; it was only by chance that we found it with the introduction of multiple Python versions, but this doesn't mean that we're not going to be stuck in the same situation once again in the future.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:412,testability,coupl,couple,412,"> The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch. @vgvassilev . As long as @etejedor agrees, for me it's fine reverting a couple of commits and go back to 4ce57e, even if empty directories are installed. . But I don't think this can stay as it is forever. As I partially pointed out in the description, there are two main cons:. - 80 pcms out of 90 are installed twice;. - install(DIRECTORY ...) has the default behavior of copying empty skeletons of all the subdirectories found in the directory; it was only by chance that we found it with the introduction of multiple Python versions, but this doesn't mean that we're not going to be stuck in the same situation once again in the future.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:86,usability,error,error,86,"> The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch. @vgvassilev . As long as @etejedor agrees, for me it's fine reverting a couple of commits and go back to 4ce57e, even if empty directories are installed. . But I don't think this can stay as it is forever. As I partially pointed out in the description, there are two main cons:. - 80 pcms out of 90 are installed twice;. - install(DIRECTORY ...) has the default behavior of copying empty skeletons of all the subdirectories found in the directory; it was only by chance that we found it with the introduction of multiple Python versions, but this doesn't mean that we're not going to be stuck in the same situation once again in the future.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:702,usability,behavi,behavior,702,"> The change is on the cmake hotspot used by virtually everybody. The risk to make an error here is high due to the complexity of the routine. Taking such risk weeks before the release should be very well weighted with the actual gain. It seems to me that the gain is not big enough to justify taking this direction for the release branch. @vgvassilev . As long as @etejedor agrees, for me it's fine reverting a couple of commits and go back to 4ce57e, even if empty directories are installed. . But I don't think this can stay as it is forever. As I partially pointed out in the description, there are two main cons:. - 80 pcms out of 90 are installed twice;. - install(DIRECTORY ...) has the default behavior of copying empty skeletons of all the subdirectories found in the directory; it was only by chance that we found it with the introduction of multiple Python versions, but this doesn't mean that we're not going to be stuck in the same situation once again in the future.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:59,deployability,releas,release,59,"@vgvassilev what is the solution you would propose for the release? Is it going back to:. https://github.com/root-project/root/blob/v6-18-00-patches/CMakeLists.txt#L409-L414. ? The problem is that such INSTALL command not only copies the missing ~10 PCMs, but also (empty) PyROOT experimental folders that should not be present in the installation directory.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:141,deployability,patch,patches,141,"@vgvassilev what is the solution you would propose for the release? Is it going back to:. https://github.com/root-project/root/blob/v6-18-00-patches/CMakeLists.txt#L409-L414. ? The problem is that such INSTALL command not only copies the missing ~10 PCMs, but also (empty) PyROOT experimental folders that should not be present in the installation directory.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:202,deployability,INSTAL,INSTALL,202,"@vgvassilev what is the solution you would propose for the release? Is it going back to:. https://github.com/root-project/root/blob/v6-18-00-patches/CMakeLists.txt#L409-L414. ? The problem is that such INSTALL command not only copies the missing ~10 PCMs, but also (empty) PyROOT experimental folders that should not be present in the installation directory.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:335,deployability,instal,installation,335,"@vgvassilev what is the solution you would propose for the release? Is it going back to:. https://github.com/root-project/root/blob/v6-18-00-patches/CMakeLists.txt#L409-L414. ? The problem is that such INSTALL command not only copies the missing ~10 PCMs, but also (empty) PyROOT experimental folders that should not be present in the installation directory.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:141,safety,patch,patches,141,"@vgvassilev what is the solution you would propose for the release? Is it going back to:. https://github.com/root-project/root/blob/v6-18-00-patches/CMakeLists.txt#L409-L414. ? The problem is that such INSTALL command not only copies the missing ~10 PCMs, but also (empty) PyROOT experimental folders that should not be present in the installation directory.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:141,security,patch,patches,141,"@vgvassilev what is the solution you would propose for the release? Is it going back to:. https://github.com/root-project/root/blob/v6-18-00-patches/CMakeLists.txt#L409-L414. ? The problem is that such INSTALL command not only copies the missing ~10 PCMs, but also (empty) PyROOT experimental folders that should not be present in the installation directory.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:210,usability,command,command,210,"@vgvassilev what is the solution you would propose for the release? Is it going back to:. https://github.com/root-project/root/blob/v6-18-00-patches/CMakeLists.txt#L409-L414. ? The problem is that such INSTALL command not only copies the missing ~10 PCMs, but also (empty) PyROOT experimental folders that should not be present in the installation directory.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:35,deployability,build,building,35,@etejedor I propose to enable back building experiments https://github.com/root-project/root/pull/4775 and then decide together what to do.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:48,modifiability,refact,refactor,48,"@maxgalli, yes I agree with you that we need to refactor this code in future. We should not reinstall things twice. @etejedor, I would like to play safe and would be in favor of @oshadura's solution in #4775.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:48,performance,refactor,refactor,48,"@maxgalli, yes I agree with you that we need to refactor this code in future. We should not reinstall things twice. @etejedor, I would like to play safe and would be in favor of @oshadura's solution in #4775.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:148,safety,safe,safe,148,"@maxgalli, yes I agree with you that we need to refactor this code in future. We should not reinstall things twice. @etejedor, I would like to play safe and would be in favor of @oshadura's solution in #4775.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:169,deployability,instal,install,169,"@oshadura @vgvassilev I am in favour of merging now a solution that solves the problem of the missing pcms, so ok for #4775 which is basically bringing back the initial install command that was there before:. https://github.com/root-project/root/blob/v6-18-00-patches/CMakeLists.txt#L409-L414. But I would like to insist that **we need another (better) fix for this release**, since that solution, as pointed out by @maxgalli, copies empty directories into the installation directory, not only the missing pcms.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:260,deployability,patch,patches,260,"@oshadura @vgvassilev I am in favour of merging now a solution that solves the problem of the missing pcms, so ok for #4775 which is basically bringing back the initial install command that was there before:. https://github.com/root-project/root/blob/v6-18-00-patches/CMakeLists.txt#L409-L414. But I would like to insist that **we need another (better) fix for this release**, since that solution, as pointed out by @maxgalli, copies empty directories into the installation directory, not only the missing pcms.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:366,deployability,releas,release,366,"@oshadura @vgvassilev I am in favour of merging now a solution that solves the problem of the missing pcms, so ok for #4775 which is basically bringing back the initial install command that was there before:. https://github.com/root-project/root/blob/v6-18-00-patches/CMakeLists.txt#L409-L414. But I would like to insist that **we need another (better) fix for this release**, since that solution, as pointed out by @maxgalli, copies empty directories into the installation directory, not only the missing pcms.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:461,deployability,instal,installation,461,"@oshadura @vgvassilev I am in favour of merging now a solution that solves the problem of the missing pcms, so ok for #4775 which is basically bringing back the initial install command that was there before:. https://github.com/root-project/root/blob/v6-18-00-patches/CMakeLists.txt#L409-L414. But I would like to insist that **we need another (better) fix for this release**, since that solution, as pointed out by @maxgalli, copies empty directories into the installation directory, not only the missing pcms.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:260,safety,patch,patches,260,"@oshadura @vgvassilev I am in favour of merging now a solution that solves the problem of the missing pcms, so ok for #4775 which is basically bringing back the initial install command that was there before:. https://github.com/root-project/root/blob/v6-18-00-patches/CMakeLists.txt#L409-L414. But I would like to insist that **we need another (better) fix for this release**, since that solution, as pointed out by @maxgalli, copies empty directories into the installation directory, not only the missing pcms.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:260,security,patch,patches,260,"@oshadura @vgvassilev I am in favour of merging now a solution that solves the problem of the missing pcms, so ok for #4775 which is basically bringing back the initial install command that was there before:. https://github.com/root-project/root/blob/v6-18-00-patches/CMakeLists.txt#L409-L414. But I would like to insist that **we need another (better) fix for this release**, since that solution, as pointed out by @maxgalli, copies empty directories into the installation directory, not only the missing pcms.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:177,usability,command,command,177,"@oshadura @vgvassilev I am in favour of merging now a solution that solves the problem of the missing pcms, so ok for #4775 which is basically bringing back the initial install command that was there before:. https://github.com/root-project/root/blob/v6-18-00-patches/CMakeLists.txt#L409-L414. But I would like to insist that **we need another (better) fix for this release**, since that solution, as pointed out by @maxgalli, copies empty directories into the installation directory, not only the missing pcms.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:307,integrability,sub,subfolders,307,"@etejedor, I do not see another way of implementing the desired behavior without touching `ROOT_GENERATE_DICTIONARY` which is very risky task as I mentioned in the previous comment. I am open to any other non-intrusive idea you guys have. Just for my personal clarification: I do not understand why we have subfolders in ROOTSYS/lib (eg things like cmake) in first place. Are the empty directories causing any problems or it just the folder structure looks bad?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:131,safety,risk,risky,131,"@etejedor, I do not see another way of implementing the desired behavior without touching `ROOT_GENERATE_DICTIONARY` which is very risky task as I mentioned in the previous comment. I am open to any other non-intrusive idea you guys have. Just for my personal clarification: I do not understand why we have subfolders in ROOTSYS/lib (eg things like cmake) in first place. Are the empty directories causing any problems or it just the folder structure looks bad?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:131,security,risk,risky,131,"@etejedor, I do not see another way of implementing the desired behavior without touching `ROOT_GENERATE_DICTIONARY` which is very risky task as I mentioned in the previous comment. I am open to any other non-intrusive idea you guys have. Just for my personal clarification: I do not understand why we have subfolders in ROOTSYS/lib (eg things like cmake) in first place. Are the empty directories causing any problems or it just the folder structure looks bad?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:209,security,intrus,intrusive,209,"@etejedor, I do not see another way of implementing the desired behavior without touching `ROOT_GENERATE_DICTIONARY` which is very risky task as I mentioned in the previous comment. I am open to any other non-intrusive idea you guys have. Just for my personal clarification: I do not understand why we have subfolders in ROOTSYS/lib (eg things like cmake) in first place. Are the empty directories causing any problems or it just the folder structure looks bad?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:284,testability,understand,understand,284,"@etejedor, I do not see another way of implementing the desired behavior without touching `ROOT_GENERATE_DICTIONARY` which is very risky task as I mentioned in the previous comment. I am open to any other non-intrusive idea you guys have. Just for my personal clarification: I do not understand why we have subfolders in ROOTSYS/lib (eg things like cmake) in first place. Are the empty directories causing any problems or it just the folder structure looks bad?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:64,usability,behavi,behavior,64,"@etejedor, I do not see another way of implementing the desired behavior without touching `ROOT_GENERATE_DICTIONARY` which is very risky task as I mentioned in the previous comment. I am open to any other non-intrusive idea you guys have. Just for my personal clarification: I do not understand why we have subfolders in ROOTSYS/lib (eg things like cmake) in first place. Are the empty directories causing any problems or it just the folder structure looks bad?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:251,usability,person,personal,251,"@etejedor, I do not see another way of implementing the desired behavior without touching `ROOT_GENERATE_DICTIONARY` which is very risky task as I mentioned in the previous comment. I am open to any other non-intrusive idea you guys have. Just for my personal clarification: I do not understand why we have subfolders in ROOTSYS/lib (eg things like cmake) in first place. Are the empty directories causing any problems or it just the folder structure looks bad?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:64,deployability,build,build,64,"@vgvassilev we have subfolders in the $BUILD_DIR/lib because we build now for multiple Python versions, each version having its subdirectory. Since the install command you have for the extra pcms does not discriminate, it also copies empty subdirectories into the installation directory. I think we agree that is not the way to go and it can't be left like that. Could you explain why exactly the solution proposed by @oshadura of modifying `ROOT_GENERATE_DICTIONARY` is risky? https://github.com/root-project/root/pull/4763/commits/2dd3f463cf843e6014162830047ba7dab4fb093f. From what I can see, she is just hardcoding the installation of those extra pcms in an analogous way to this code:. https://github.com/root-project/root/blob/master/core/dictgen/src/rootcling_impl.cxx#L4237-L4253. I understand the best solution would be that those pcms are fully controlled by the build system, but that would probably be a more time-consuming solution and require more changes. So the solution proposed by @oshadura looks good to me.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:94,deployability,version,versions,94,"@vgvassilev we have subfolders in the $BUILD_DIR/lib because we build now for multiple Python versions, each version having its subdirectory. Since the install command you have for the extra pcms does not discriminate, it also copies empty subdirectories into the installation directory. I think we agree that is not the way to go and it can't be left like that. Could you explain why exactly the solution proposed by @oshadura of modifying `ROOT_GENERATE_DICTIONARY` is risky? https://github.com/root-project/root/pull/4763/commits/2dd3f463cf843e6014162830047ba7dab4fb093f. From what I can see, she is just hardcoding the installation of those extra pcms in an analogous way to this code:. https://github.com/root-project/root/blob/master/core/dictgen/src/rootcling_impl.cxx#L4237-L4253. I understand the best solution would be that those pcms are fully controlled by the build system, but that would probably be a more time-consuming solution and require more changes. So the solution proposed by @oshadura looks good to me.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:109,deployability,version,version,109,"@vgvassilev we have subfolders in the $BUILD_DIR/lib because we build now for multiple Python versions, each version having its subdirectory. Since the install command you have for the extra pcms does not discriminate, it also copies empty subdirectories into the installation directory. I think we agree that is not the way to go and it can't be left like that. Could you explain why exactly the solution proposed by @oshadura of modifying `ROOT_GENERATE_DICTIONARY` is risky? https://github.com/root-project/root/pull/4763/commits/2dd3f463cf843e6014162830047ba7dab4fb093f. From what I can see, she is just hardcoding the installation of those extra pcms in an analogous way to this code:. https://github.com/root-project/root/blob/master/core/dictgen/src/rootcling_impl.cxx#L4237-L4253. I understand the best solution would be that those pcms are fully controlled by the build system, but that would probably be a more time-consuming solution and require more changes. So the solution proposed by @oshadura looks good to me.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:152,deployability,instal,install,152,"@vgvassilev we have subfolders in the $BUILD_DIR/lib because we build now for multiple Python versions, each version having its subdirectory. Since the install command you have for the extra pcms does not discriminate, it also copies empty subdirectories into the installation directory. I think we agree that is not the way to go and it can't be left like that. Could you explain why exactly the solution proposed by @oshadura of modifying `ROOT_GENERATE_DICTIONARY` is risky? https://github.com/root-project/root/pull/4763/commits/2dd3f463cf843e6014162830047ba7dab4fb093f. From what I can see, she is just hardcoding the installation of those extra pcms in an analogous way to this code:. https://github.com/root-project/root/blob/master/core/dictgen/src/rootcling_impl.cxx#L4237-L4253. I understand the best solution would be that those pcms are fully controlled by the build system, but that would probably be a more time-consuming solution and require more changes. So the solution proposed by @oshadura looks good to me.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:264,deployability,instal,installation,264,"@vgvassilev we have subfolders in the $BUILD_DIR/lib because we build now for multiple Python versions, each version having its subdirectory. Since the install command you have for the extra pcms does not discriminate, it also copies empty subdirectories into the installation directory. I think we agree that is not the way to go and it can't be left like that. Could you explain why exactly the solution proposed by @oshadura of modifying `ROOT_GENERATE_DICTIONARY` is risky? https://github.com/root-project/root/pull/4763/commits/2dd3f463cf843e6014162830047ba7dab4fb093f. From what I can see, she is just hardcoding the installation of those extra pcms in an analogous way to this code:. https://github.com/root-project/root/blob/master/core/dictgen/src/rootcling_impl.cxx#L4237-L4253. I understand the best solution would be that those pcms are fully controlled by the build system, but that would probably be a more time-consuming solution and require more changes. So the solution proposed by @oshadura looks good to me.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:623,deployability,instal,installation,623,"@vgvassilev we have subfolders in the $BUILD_DIR/lib because we build now for multiple Python versions, each version having its subdirectory. Since the install command you have for the extra pcms does not discriminate, it also copies empty subdirectories into the installation directory. I think we agree that is not the way to go and it can't be left like that. Could you explain why exactly the solution proposed by @oshadura of modifying `ROOT_GENERATE_DICTIONARY` is risky? https://github.com/root-project/root/pull/4763/commits/2dd3f463cf843e6014162830047ba7dab4fb093f. From what I can see, she is just hardcoding the installation of those extra pcms in an analogous way to this code:. https://github.com/root-project/root/blob/master/core/dictgen/src/rootcling_impl.cxx#L4237-L4253. I understand the best solution would be that those pcms are fully controlled by the build system, but that would probably be a more time-consuming solution and require more changes. So the solution proposed by @oshadura looks good to me.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:873,deployability,build,build,873,"@vgvassilev we have subfolders in the $BUILD_DIR/lib because we build now for multiple Python versions, each version having its subdirectory. Since the install command you have for the extra pcms does not discriminate, it also copies empty subdirectories into the installation directory. I think we agree that is not the way to go and it can't be left like that. Could you explain why exactly the solution proposed by @oshadura of modifying `ROOT_GENERATE_DICTIONARY` is risky? https://github.com/root-project/root/pull/4763/commits/2dd3f463cf843e6014162830047ba7dab4fb093f. From what I can see, she is just hardcoding the installation of those extra pcms in an analogous way to this code:. https://github.com/root-project/root/blob/master/core/dictgen/src/rootcling_impl.cxx#L4237-L4253. I understand the best solution would be that those pcms are fully controlled by the build system, but that would probably be a more time-consuming solution and require more changes. So the solution proposed by @oshadura looks good to me.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:740,energy efficiency,core,core,740,"@vgvassilev we have subfolders in the $BUILD_DIR/lib because we build now for multiple Python versions, each version having its subdirectory. Since the install command you have for the extra pcms does not discriminate, it also copies empty subdirectories into the installation directory. I think we agree that is not the way to go and it can't be left like that. Could you explain why exactly the solution proposed by @oshadura of modifying `ROOT_GENERATE_DICTIONARY` is risky? https://github.com/root-project/root/pull/4763/commits/2dd3f463cf843e6014162830047ba7dab4fb093f. From what I can see, she is just hardcoding the installation of those extra pcms in an analogous way to this code:. https://github.com/root-project/root/blob/master/core/dictgen/src/rootcling_impl.cxx#L4237-L4253. I understand the best solution would be that those pcms are fully controlled by the build system, but that would probably be a more time-consuming solution and require more changes. So the solution proposed by @oshadura looks good to me.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:20,integrability,sub,subfolders,20,"@vgvassilev we have subfolders in the $BUILD_DIR/lib because we build now for multiple Python versions, each version having its subdirectory. Since the install command you have for the extra pcms does not discriminate, it also copies empty subdirectories into the installation directory. I think we agree that is not the way to go and it can't be left like that. Could you explain why exactly the solution proposed by @oshadura of modifying `ROOT_GENERATE_DICTIONARY` is risky? https://github.com/root-project/root/pull/4763/commits/2dd3f463cf843e6014162830047ba7dab4fb093f. From what I can see, she is just hardcoding the installation of those extra pcms in an analogous way to this code:. https://github.com/root-project/root/blob/master/core/dictgen/src/rootcling_impl.cxx#L4237-L4253. I understand the best solution would be that those pcms are fully controlled by the build system, but that would probably be a more time-consuming solution and require more changes. So the solution proposed by @oshadura looks good to me.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:94,integrability,version,versions,94,"@vgvassilev we have subfolders in the $BUILD_DIR/lib because we build now for multiple Python versions, each version having its subdirectory. Since the install command you have for the extra pcms does not discriminate, it also copies empty subdirectories into the installation directory. I think we agree that is not the way to go and it can't be left like that. Could you explain why exactly the solution proposed by @oshadura of modifying `ROOT_GENERATE_DICTIONARY` is risky? https://github.com/root-project/root/pull/4763/commits/2dd3f463cf843e6014162830047ba7dab4fb093f. From what I can see, she is just hardcoding the installation of those extra pcms in an analogous way to this code:. https://github.com/root-project/root/blob/master/core/dictgen/src/rootcling_impl.cxx#L4237-L4253. I understand the best solution would be that those pcms are fully controlled by the build system, but that would probably be a more time-consuming solution and require more changes. So the solution proposed by @oshadura looks good to me.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:109,integrability,version,version,109,"@vgvassilev we have subfolders in the $BUILD_DIR/lib because we build now for multiple Python versions, each version having its subdirectory. Since the install command you have for the extra pcms does not discriminate, it also copies empty subdirectories into the installation directory. I think we agree that is not the way to go and it can't be left like that. Could you explain why exactly the solution proposed by @oshadura of modifying `ROOT_GENERATE_DICTIONARY` is risky? https://github.com/root-project/root/pull/4763/commits/2dd3f463cf843e6014162830047ba7dab4fb093f. From what I can see, she is just hardcoding the installation of those extra pcms in an analogous way to this code:. https://github.com/root-project/root/blob/master/core/dictgen/src/rootcling_impl.cxx#L4237-L4253. I understand the best solution would be that those pcms are fully controlled by the build system, but that would probably be a more time-consuming solution and require more changes. So the solution proposed by @oshadura looks good to me.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:128,integrability,sub,subdirectory,128,"@vgvassilev we have subfolders in the $BUILD_DIR/lib because we build now for multiple Python versions, each version having its subdirectory. Since the install command you have for the extra pcms does not discriminate, it also copies empty subdirectories into the installation directory. I think we agree that is not the way to go and it can't be left like that. Could you explain why exactly the solution proposed by @oshadura of modifying `ROOT_GENERATE_DICTIONARY` is risky? https://github.com/root-project/root/pull/4763/commits/2dd3f463cf843e6014162830047ba7dab4fb093f. From what I can see, she is just hardcoding the installation of those extra pcms in an analogous way to this code:. https://github.com/root-project/root/blob/master/core/dictgen/src/rootcling_impl.cxx#L4237-L4253. I understand the best solution would be that those pcms are fully controlled by the build system, but that would probably be a more time-consuming solution and require more changes. So the solution proposed by @oshadura looks good to me.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:240,integrability,sub,subdirectories,240,"@vgvassilev we have subfolders in the $BUILD_DIR/lib because we build now for multiple Python versions, each version having its subdirectory. Since the install command you have for the extra pcms does not discriminate, it also copies empty subdirectories into the installation directory. I think we agree that is not the way to go and it can't be left like that. Could you explain why exactly the solution proposed by @oshadura of modifying `ROOT_GENERATE_DICTIONARY` is risky? https://github.com/root-project/root/pull/4763/commits/2dd3f463cf843e6014162830047ba7dab4fb093f. From what I can see, she is just hardcoding the installation of those extra pcms in an analogous way to this code:. https://github.com/root-project/root/blob/master/core/dictgen/src/rootcling_impl.cxx#L4237-L4253. I understand the best solution would be that those pcms are fully controlled by the build system, but that would probably be a more time-consuming solution and require more changes. So the solution proposed by @oshadura looks good to me.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:94,modifiability,version,versions,94,"@vgvassilev we have subfolders in the $BUILD_DIR/lib because we build now for multiple Python versions, each version having its subdirectory. Since the install command you have for the extra pcms does not discriminate, it also copies empty subdirectories into the installation directory. I think we agree that is not the way to go and it can't be left like that. Could you explain why exactly the solution proposed by @oshadura of modifying `ROOT_GENERATE_DICTIONARY` is risky? https://github.com/root-project/root/pull/4763/commits/2dd3f463cf843e6014162830047ba7dab4fb093f. From what I can see, she is just hardcoding the installation of those extra pcms in an analogous way to this code:. https://github.com/root-project/root/blob/master/core/dictgen/src/rootcling_impl.cxx#L4237-L4253. I understand the best solution would be that those pcms are fully controlled by the build system, but that would probably be a more time-consuming solution and require more changes. So the solution proposed by @oshadura looks good to me.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:109,modifiability,version,version,109,"@vgvassilev we have subfolders in the $BUILD_DIR/lib because we build now for multiple Python versions, each version having its subdirectory. Since the install command you have for the extra pcms does not discriminate, it also copies empty subdirectories into the installation directory. I think we agree that is not the way to go and it can't be left like that. Could you explain why exactly the solution proposed by @oshadura of modifying `ROOT_GENERATE_DICTIONARY` is risky? https://github.com/root-project/root/pull/4763/commits/2dd3f463cf843e6014162830047ba7dab4fb093f. From what I can see, she is just hardcoding the installation of those extra pcms in an analogous way to this code:. https://github.com/root-project/root/blob/master/core/dictgen/src/rootcling_impl.cxx#L4237-L4253. I understand the best solution would be that those pcms are fully controlled by the build system, but that would probably be a more time-consuming solution and require more changes. So the solution proposed by @oshadura looks good to me.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:921,performance,time,time-consuming,921,"@vgvassilev we have subfolders in the $BUILD_DIR/lib because we build now for multiple Python versions, each version having its subdirectory. Since the install command you have for the extra pcms does not discriminate, it also copies empty subdirectories into the installation directory. I think we agree that is not the way to go and it can't be left like that. Could you explain why exactly the solution proposed by @oshadura of modifying `ROOT_GENERATE_DICTIONARY` is risky? https://github.com/root-project/root/pull/4763/commits/2dd3f463cf843e6014162830047ba7dab4fb093f. From what I can see, she is just hardcoding the installation of those extra pcms in an analogous way to this code:. https://github.com/root-project/root/blob/master/core/dictgen/src/rootcling_impl.cxx#L4237-L4253. I understand the best solution would be that those pcms are fully controlled by the build system, but that would probably be a more time-consuming solution and require more changes. So the solution proposed by @oshadura looks good to me.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:196,reliability,doe,does,196,"@vgvassilev we have subfolders in the $BUILD_DIR/lib because we build now for multiple Python versions, each version having its subdirectory. Since the install command you have for the extra pcms does not discriminate, it also copies empty subdirectories into the installation directory. I think we agree that is not the way to go and it can't be left like that. Could you explain why exactly the solution proposed by @oshadura of modifying `ROOT_GENERATE_DICTIONARY` is risky? https://github.com/root-project/root/pull/4763/commits/2dd3f463cf843e6014162830047ba7dab4fb093f. From what I can see, she is just hardcoding the installation of those extra pcms in an analogous way to this code:. https://github.com/root-project/root/blob/master/core/dictgen/src/rootcling_impl.cxx#L4237-L4253. I understand the best solution would be that those pcms are fully controlled by the build system, but that would probably be a more time-consuming solution and require more changes. So the solution proposed by @oshadura looks good to me.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:471,safety,risk,risky,471,"@vgvassilev we have subfolders in the $BUILD_DIR/lib because we build now for multiple Python versions, each version having its subdirectory. Since the install command you have for the extra pcms does not discriminate, it also copies empty subdirectories into the installation directory. I think we agree that is not the way to go and it can't be left like that. Could you explain why exactly the solution proposed by @oshadura of modifying `ROOT_GENERATE_DICTIONARY` is risky? https://github.com/root-project/root/pull/4763/commits/2dd3f463cf843e6014162830047ba7dab4fb093f. From what I can see, she is just hardcoding the installation of those extra pcms in an analogous way to this code:. https://github.com/root-project/root/blob/master/core/dictgen/src/rootcling_impl.cxx#L4237-L4253. I understand the best solution would be that those pcms are fully controlled by the build system, but that would probably be a more time-consuming solution and require more changes. So the solution proposed by @oshadura looks good to me.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:431,security,modif,modifying,431,"@vgvassilev we have subfolders in the $BUILD_DIR/lib because we build now for multiple Python versions, each version having its subdirectory. Since the install command you have for the extra pcms does not discriminate, it also copies empty subdirectories into the installation directory. I think we agree that is not the way to go and it can't be left like that. Could you explain why exactly the solution proposed by @oshadura of modifying `ROOT_GENERATE_DICTIONARY` is risky? https://github.com/root-project/root/pull/4763/commits/2dd3f463cf843e6014162830047ba7dab4fb093f. From what I can see, she is just hardcoding the installation of those extra pcms in an analogous way to this code:. https://github.com/root-project/root/blob/master/core/dictgen/src/rootcling_impl.cxx#L4237-L4253. I understand the best solution would be that those pcms are fully controlled by the build system, but that would probably be a more time-consuming solution and require more changes. So the solution proposed by @oshadura looks good to me.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:471,security,risk,risky,471,"@vgvassilev we have subfolders in the $BUILD_DIR/lib because we build now for multiple Python versions, each version having its subdirectory. Since the install command you have for the extra pcms does not discriminate, it also copies empty subdirectories into the installation directory. I think we agree that is not the way to go and it can't be left like that. Could you explain why exactly the solution proposed by @oshadura of modifying `ROOT_GENERATE_DICTIONARY` is risky? https://github.com/root-project/root/pull/4763/commits/2dd3f463cf843e6014162830047ba7dab4fb093f. From what I can see, she is just hardcoding the installation of those extra pcms in an analogous way to this code:. https://github.com/root-project/root/blob/master/core/dictgen/src/rootcling_impl.cxx#L4237-L4253. I understand the best solution would be that those pcms are fully controlled by the build system, but that would probably be a more time-consuming solution and require more changes. So the solution proposed by @oshadura looks good to me.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:608,security,hardcod,hardcoding,608,"@vgvassilev we have subfolders in the $BUILD_DIR/lib because we build now for multiple Python versions, each version having its subdirectory. Since the install command you have for the extra pcms does not discriminate, it also copies empty subdirectories into the installation directory. I think we agree that is not the way to go and it can't be left like that. Could you explain why exactly the solution proposed by @oshadura of modifying `ROOT_GENERATE_DICTIONARY` is risky? https://github.com/root-project/root/pull/4763/commits/2dd3f463cf843e6014162830047ba7dab4fb093f. From what I can see, she is just hardcoding the installation of those extra pcms in an analogous way to this code:. https://github.com/root-project/root/blob/master/core/dictgen/src/rootcling_impl.cxx#L4237-L4253. I understand the best solution would be that those pcms are fully controlled by the build system, but that would probably be a more time-consuming solution and require more changes. So the solution proposed by @oshadura looks good to me.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:855,security,control,controlled,855,"@vgvassilev we have subfolders in the $BUILD_DIR/lib because we build now for multiple Python versions, each version having its subdirectory. Since the install command you have for the extra pcms does not discriminate, it also copies empty subdirectories into the installation directory. I think we agree that is not the way to go and it can't be left like that. Could you explain why exactly the solution proposed by @oshadura of modifying `ROOT_GENERATE_DICTIONARY` is risky? https://github.com/root-project/root/pull/4763/commits/2dd3f463cf843e6014162830047ba7dab4fb093f. From what I can see, she is just hardcoding the installation of those extra pcms in an analogous way to this code:. https://github.com/root-project/root/blob/master/core/dictgen/src/rootcling_impl.cxx#L4237-L4253. I understand the best solution would be that those pcms are fully controlled by the build system, but that would probably be a more time-consuming solution and require more changes. So the solution proposed by @oshadura looks good to me.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:791,testability,understand,understand,791,"@vgvassilev we have subfolders in the $BUILD_DIR/lib because we build now for multiple Python versions, each version having its subdirectory. Since the install command you have for the extra pcms does not discriminate, it also copies empty subdirectories into the installation directory. I think we agree that is not the way to go and it can't be left like that. Could you explain why exactly the solution proposed by @oshadura of modifying `ROOT_GENERATE_DICTIONARY` is risky? https://github.com/root-project/root/pull/4763/commits/2dd3f463cf843e6014162830047ba7dab4fb093f. From what I can see, she is just hardcoding the installation of those extra pcms in an analogous way to this code:. https://github.com/root-project/root/blob/master/core/dictgen/src/rootcling_impl.cxx#L4237-L4253. I understand the best solution would be that those pcms are fully controlled by the build system, but that would probably be a more time-consuming solution and require more changes. So the solution proposed by @oshadura looks good to me.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:855,testability,control,controlled,855,"@vgvassilev we have subfolders in the $BUILD_DIR/lib because we build now for multiple Python versions, each version having its subdirectory. Since the install command you have for the extra pcms does not discriminate, it also copies empty subdirectories into the installation directory. I think we agree that is not the way to go and it can't be left like that. Could you explain why exactly the solution proposed by @oshadura of modifying `ROOT_GENERATE_DICTIONARY` is risky? https://github.com/root-project/root/pull/4763/commits/2dd3f463cf843e6014162830047ba7dab4fb093f. From what I can see, she is just hardcoding the installation of those extra pcms in an analogous way to this code:. https://github.com/root-project/root/blob/master/core/dictgen/src/rootcling_impl.cxx#L4237-L4253. I understand the best solution would be that those pcms are fully controlled by the build system, but that would probably be a more time-consuming solution and require more changes. So the solution proposed by @oshadura looks good to me.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:160,usability,command,command,160,"@vgvassilev we have subfolders in the $BUILD_DIR/lib because we build now for multiple Python versions, each version having its subdirectory. Since the install command you have for the extra pcms does not discriminate, it also copies empty subdirectories into the installation directory. I think we agree that is not the way to go and it can't be left like that. Could you explain why exactly the solution proposed by @oshadura of modifying `ROOT_GENERATE_DICTIONARY` is risky? https://github.com/root-project/root/pull/4763/commits/2dd3f463cf843e6014162830047ba7dab4fb093f. From what I can see, she is just hardcoding the installation of those extra pcms in an analogous way to this code:. https://github.com/root-project/root/blob/master/core/dictgen/src/rootcling_impl.cxx#L4237-L4253. I understand the best solution would be that those pcms are fully controlled by the build system, but that would probably be a more time-consuming solution and require more changes. So the solution proposed by @oshadura looks good to me.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4763:80,integrability,sub,subfolder,80,I will reply in length tomorrow but what’s the reason you chose to put a python subfolder in lib and not elsewhere is what I meant to ask.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4763
https://github.com/root-project/root/pull/4765:30,deployability,build,build,30,Could an admin please start a build of this PR to check whether all tests are passing?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4765
https://github.com/root-project/root/pull/4765:68,safety,test,tests,68,Could an admin please start a build of this PR to check whether all tests are passing?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4765
https://github.com/root-project/root/pull/4765:68,testability,test,tests,68,Could an admin please start a build of this PR to check whether all tests are passing?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4765
https://github.com/root-project/root/pull/4765:11,deployability,build,build,11,@phsft-bot build.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4765
https://github.com/root-project/root/pull/4766:11,deployability,build,build,11,@phsft-bot build with flags -Dpyroot_experimental=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4766
https://github.com/root-project/root/pull/4766:14,availability,error,errors,14,"The remaining errors on mac1014/cxx17 :. https://github.com/root-project/root/pull/4766#issuecomment-573734088. are due to the the fact that some Python2.7 headers (e.g. https://github.com/python/cpython/blob/2.7/Include/unicodeobject.h#L534) still use the `register` keyword, which is not supported anymore in cxx17. Since Python2 is not maintained anymore, those headers will not be updated to support cxx17. Therefore, users of Python2.7 should either not compile with cxx17 or migrate to Python3.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4766
https://github.com/root-project/root/pull/4766:385,deployability,updat,updated,385,"The remaining errors on mac1014/cxx17 :. https://github.com/root-project/root/pull/4766#issuecomment-573734088. are due to the the fact that some Python2.7 headers (e.g. https://github.com/python/cpython/blob/2.7/Include/unicodeobject.h#L534) still use the `register` keyword, which is not supported anymore in cxx17. Since Python2 is not maintained anymore, those headers will not be updated to support cxx17. Therefore, users of Python2.7 should either not compile with cxx17 or migrate to Python3.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4766
https://github.com/root-project/root/pull/4766:339,modifiability,maintain,maintained,339,"The remaining errors on mac1014/cxx17 :. https://github.com/root-project/root/pull/4766#issuecomment-573734088. are due to the the fact that some Python2.7 headers (e.g. https://github.com/python/cpython/blob/2.7/Include/unicodeobject.h#L534) still use the `register` keyword, which is not supported anymore in cxx17. Since Python2 is not maintained anymore, those headers will not be updated to support cxx17. Therefore, users of Python2.7 should either not compile with cxx17 or migrate to Python3.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4766
https://github.com/root-project/root/pull/4766:14,performance,error,errors,14,"The remaining errors on mac1014/cxx17 :. https://github.com/root-project/root/pull/4766#issuecomment-573734088. are due to the the fact that some Python2.7 headers (e.g. https://github.com/python/cpython/blob/2.7/Include/unicodeobject.h#L534) still use the `register` keyword, which is not supported anymore in cxx17. Since Python2 is not maintained anymore, those headers will not be updated to support cxx17. Therefore, users of Python2.7 should either not compile with cxx17 or migrate to Python3.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4766
https://github.com/root-project/root/pull/4766:14,safety,error,errors,14,"The remaining errors on mac1014/cxx17 :. https://github.com/root-project/root/pull/4766#issuecomment-573734088. are due to the the fact that some Python2.7 headers (e.g. https://github.com/python/cpython/blob/2.7/Include/unicodeobject.h#L534) still use the `register` keyword, which is not supported anymore in cxx17. Since Python2 is not maintained anymore, those headers will not be updated to support cxx17. Therefore, users of Python2.7 should either not compile with cxx17 or migrate to Python3.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4766
https://github.com/root-project/root/pull/4766:339,safety,maintain,maintained,339,"The remaining errors on mac1014/cxx17 :. https://github.com/root-project/root/pull/4766#issuecomment-573734088. are due to the the fact that some Python2.7 headers (e.g. https://github.com/python/cpython/blob/2.7/Include/unicodeobject.h#L534) still use the `register` keyword, which is not supported anymore in cxx17. Since Python2 is not maintained anymore, those headers will not be updated to support cxx17. Therefore, users of Python2.7 should either not compile with cxx17 or migrate to Python3.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4766
https://github.com/root-project/root/pull/4766:385,safety,updat,updated,385,"The remaining errors on mac1014/cxx17 :. https://github.com/root-project/root/pull/4766#issuecomment-573734088. are due to the the fact that some Python2.7 headers (e.g. https://github.com/python/cpython/blob/2.7/Include/unicodeobject.h#L534) still use the `register` keyword, which is not supported anymore in cxx17. Since Python2 is not maintained anymore, those headers will not be updated to support cxx17. Therefore, users of Python2.7 should either not compile with cxx17 or migrate to Python3.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4766
https://github.com/root-project/root/pull/4766:385,security,updat,updated,385,"The remaining errors on mac1014/cxx17 :. https://github.com/root-project/root/pull/4766#issuecomment-573734088. are due to the the fact that some Python2.7 headers (e.g. https://github.com/python/cpython/blob/2.7/Include/unicodeobject.h#L534) still use the `register` keyword, which is not supported anymore in cxx17. Since Python2 is not maintained anymore, those headers will not be updated to support cxx17. Therefore, users of Python2.7 should either not compile with cxx17 or migrate to Python3.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4766
https://github.com/root-project/root/pull/4766:14,usability,error,errors,14,"The remaining errors on mac1014/cxx17 :. https://github.com/root-project/root/pull/4766#issuecomment-573734088. are due to the the fact that some Python2.7 headers (e.g. https://github.com/python/cpython/blob/2.7/Include/unicodeobject.h#L534) still use the `register` keyword, which is not supported anymore in cxx17. Since Python2 is not maintained anymore, those headers will not be updated to support cxx17. Therefore, users of Python2.7 should either not compile with cxx17 or migrate to Python3.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4766
https://github.com/root-project/root/pull/4766:290,usability,support,supported,290,"The remaining errors on mac1014/cxx17 :. https://github.com/root-project/root/pull/4766#issuecomment-573734088. are due to the the fact that some Python2.7 headers (e.g. https://github.com/python/cpython/blob/2.7/Include/unicodeobject.h#L534) still use the `register` keyword, which is not supported anymore in cxx17. Since Python2 is not maintained anymore, those headers will not be updated to support cxx17. Therefore, users of Python2.7 should either not compile with cxx17 or migrate to Python3.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4766
https://github.com/root-project/root/pull/4766:396,usability,support,support,396,"The remaining errors on mac1014/cxx17 :. https://github.com/root-project/root/pull/4766#issuecomment-573734088. are due to the the fact that some Python2.7 headers (e.g. https://github.com/python/cpython/blob/2.7/Include/unicodeobject.h#L534) still use the `register` keyword, which is not supported anymore in cxx17. Since Python2 is not maintained anymore, those headers will not be updated to support cxx17. Therefore, users of Python2.7 should either not compile with cxx17 or migrate to Python3.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4766
https://github.com/root-project/root/pull/4766:422,usability,user,users,422,"The remaining errors on mac1014/cxx17 :. https://github.com/root-project/root/pull/4766#issuecomment-573734088. are due to the the fact that some Python2.7 headers (e.g. https://github.com/python/cpython/blob/2.7/Include/unicodeobject.h#L534) still use the `register` keyword, which is not supported anymore in cxx17. Since Python2 is not maintained anymore, those headers will not be updated to support cxx17. Therefore, users of Python2.7 should either not compile with cxx17 or migrate to Python3.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4766
https://github.com/root-project/root/pull/4767:25,energy efficiency,load,loading,25,Here is hard-corded libs loading:. https://github.com/root-project/root/pull/4767/files#diff-ec80b78da8b78ffdfb70dd12d74ebdeeR182-R189. One needs more flexible solution - can be provided in following PRs,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4767
https://github.com/root-project/root/pull/4767:25,performance,load,loading,25,Here is hard-corded libs loading:. https://github.com/root-project/root/pull/4767/files#diff-ec80b78da8b78ffdfb70dd12d74ebdeeR182-R189. One needs more flexible solution - can be provided in following PRs,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4767
https://github.com/root-project/root/pull/4768:11,reliability,doe,does,11,"The commit does not mention 'why' the "" -include:_G__cpp_set.."" have become obsolete. Thanks.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4768
https://github.com/root-project/root/pull/4772:30,deployability,build,build,30,Could an admin please start a build of this PR to check whether it compiles and all tests pass?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4772
https://github.com/root-project/root/pull/4772:84,safety,test,tests,84,Could an admin please start a build of this PR to check whether it compiles and all tests pass?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4772
https://github.com/root-project/root/pull/4772:84,testability,test,tests,84,Could an admin please start a build of this PR to check whether it compiles and all tests pass?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4772
https://github.com/root-project/root/pull/4772:10,deployability,automat,automatically,10,It starts automatically,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4772
https://github.com/root-project/root/pull/4772:10,testability,automat,automatically,10,It starts automatically,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4772
https://github.com/root-project/root/pull/4772:12,deployability,automat,automatically,12,"> It starts automatically. I was refering to the Jenkins build, not the Travis-CI. As far as I know it has to be started manually with ""@phsft-bot build"" but I don't have the permissions for it. P.S.: I sent you my E-Mail adress.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4772
https://github.com/root-project/root/pull/4772:57,deployability,build,build,57,"> It starts automatically. I was refering to the Jenkins build, not the Travis-CI. As far as I know it has to be started manually with ""@phsft-bot build"" but I don't have the permissions for it. P.S.: I sent you my E-Mail adress.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4772
https://github.com/root-project/root/pull/4772:147,deployability,build,build,147,"> It starts automatically. I was refering to the Jenkins build, not the Travis-CI. As far as I know it has to be started manually with ""@phsft-bot build"" but I don't have the permissions for it. P.S.: I sent you my E-Mail adress.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4772
https://github.com/root-project/root/pull/4772:175,safety,permiss,permissions,175,"> It starts automatically. I was refering to the Jenkins build, not the Travis-CI. As far as I know it has to be started manually with ""@phsft-bot build"" but I don't have the permissions for it. P.S.: I sent you my E-Mail adress.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4772
https://github.com/root-project/root/pull/4772:12,testability,automat,automatically,12,"> It starts automatically. I was refering to the Jenkins build, not the Travis-CI. As far as I know it has to be started manually with ""@phsft-bot build"" but I don't have the permissions for it. P.S.: I sent you my E-Mail adress.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4772
https://github.com/root-project/root/pull/4772:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4772
https://github.com/root-project/root/pull/4772:20,interoperability,conflict,conflicts,20,I just resolved the conflicts caused by the merge of #4762,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4772
https://github.com/root-project/root/pull/4774:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4774
https://github.com/root-project/root/pull/4777:14,deployability,fail,failing,14,There is some failing check. May be we can commit anyway ?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4777
https://github.com/root-project/root/pull/4777:14,reliability,fail,failing,14,There is some failing check. May be we can commit anyway ?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4777
https://github.com/root-project/root/pull/4777:16,deployability,fail,failing,16,"> There is some failing check. May be we can commit anyway ? This warning was for an extremly unlikely case where there would have been a memory leak. However, since it was easy to fix, I just fixed it.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4777
https://github.com/root-project/root/pull/4777:138,performance,memor,memory,138,"> There is some failing check. May be we can commit anyway ? This warning was for an extremly unlikely case where there would have been a memory leak. However, since it was easy to fix, I just fixed it.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4777
https://github.com/root-project/root/pull/4777:16,reliability,fail,failing,16,"> There is some failing check. May be we can commit anyway ? This warning was for an extremly unlikely case where there would have been a memory leak. However, since it was easy to fix, I just fixed it.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4777
https://github.com/root-project/root/pull/4777:138,usability,memor,memory,138,"> There is some failing check. May be we can commit anyway ? This warning was for an extremly unlikely case where there would have been a memory leak. However, since it was easy to fix, I just fixed it.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4777
https://github.com/root-project/root/pull/4778:0,availability,Failur,Failure,0,Failure has nothing to do with PR - merging,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4778
https://github.com/root-project/root/pull/4778:0,deployability,Fail,Failure,0,Failure has nothing to do with PR - merging,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4778
https://github.com/root-project/root/pull/4778:0,performance,Failur,Failure,0,Failure has nothing to do with PR - merging,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4778
https://github.com/root-project/root/pull/4778:0,reliability,Fail,Failure,0,Failure has nothing to do with PR - merging,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4778
https://github.com/root-project/root/pull/4779:213,integrability,sub,subscribed,213,"Stop. On Thu, Jan 16, 2020, 12:22 AM Enric Tejedor <notifications@github.com>. wrote:. > Merged #4779 <https://github.com/root-project/root/pull/4779> into master. >. > —. > You are receiving this because you are subscribed to this thread. > Reply to this email directly, view it on GitHub. > <https://github.com/root-project/root/pull/4779?email_source=notifications&email_token=ANBRRSXTTSMDV7P4RHQCVPDQ6AKNXA5CNFSM4KHAKRYKYY3PNVWWK3TUL52HS4DFWZEXG43VMVCXMZLOORHG65DJMZUWGYLUNFXW5KTDN5WW2ZLOORPWSZGOWAGDGTA#event-2953589580>,. > or unsubscribe. > <https://github.com/notifications/unsubscribe-auth/ANBRRSRCWVKQDHL62OAAK73Q6AKNXANCNFSM4KHAKRYA>. > . >.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4779
https://github.com/root-project/root/pull/4779:508,integrability,event,event-,508,"Stop. On Thu, Jan 16, 2020, 12:22 AM Enric Tejedor <notifications@github.com>. wrote:. > Merged #4779 <https://github.com/root-project/root/pull/4779> into master. >. > —. > You are receiving this because you are subscribed to this thread. > Reply to this email directly, view it on GitHub. > <https://github.com/root-project/root/pull/4779?email_source=notifications&email_token=ANBRRSXTTSMDV7P4RHQCVPDQ6AKNXA5CNFSM4KHAKRYKYY3PNVWWK3TUL52HS4DFWZEXG43VMVCXMZLOORHG65DJMZUWGYLUNFXW5KTDN5WW2ZLOORPWSZGOWAGDGTA#event-2953589580>,. > or unsubscribe. > <https://github.com/notifications/unsubscribe-auth/ANBRRSRCWVKQDHL62OAAK73Q6AKNXANCNFSM4KHAKRYA>. > . >.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4779
https://github.com/root-project/root/pull/4779:594,security,auth,auth,594,"Stop. On Thu, Jan 16, 2020, 12:22 AM Enric Tejedor <notifications@github.com>. wrote:. > Merged #4779 <https://github.com/root-project/root/pull/4779> into master. >. > —. > You are receiving this because you are subscribed to this thread. > Reply to this email directly, view it on GitHub. > <https://github.com/root-project/root/pull/4779?email_source=notifications&email_token=ANBRRSXTTSMDV7P4RHQCVPDQ6AKNXA5CNFSM4KHAKRYKYY3PNVWWK3TUL52HS4DFWZEXG43VMVCXMZLOORHG65DJMZUWGYLUNFXW5KTDN5WW2ZLOORPWSZGOWAGDGTA#event-2953589580>,. > or unsubscribe. > <https://github.com/notifications/unsubscribe-auth/ANBRRSRCWVKQDHL62OAAK73Q6AKNXANCNFSM4KHAKRYA>. > . >.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4779
https://github.com/root-project/root/pull/4779:0,usability,Stop,Stop,0,"Stop. On Thu, Jan 16, 2020, 12:22 AM Enric Tejedor <notifications@github.com>. wrote:. > Merged #4779 <https://github.com/root-project/root/pull/4779> into master. >. > —. > You are receiving this because you are subscribed to this thread. > Reply to this email directly, view it on GitHub. > <https://github.com/root-project/root/pull/4779?email_source=notifications&email_token=ANBRRSXTTSMDV7P4RHQCVPDQ6AKNXA5CNFSM4KHAKRYKYY3PNVWWK3TUL52HS4DFWZEXG43VMVCXMZLOORHG65DJMZUWGYLUNFXW5KTDN5WW2ZLOORPWSZGOWAGDGTA#event-2953589580>,. > or unsubscribe. > <https://github.com/notifications/unsubscribe-auth/ANBRRSRCWVKQDHL62OAAK73Q6AKNXANCNFSM4KHAKRYA>. > . >.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4779
https://github.com/root-project/root/pull/4786:11,deployability,build,build,11,@phsft-bot build just on mac1014/cxx17 with flags -DKEEP_PR_BUILDS_FOR_A_DAY=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4786
https://github.com/root-project/root/pull/4791:13,reliability,doe,does,13,"Seems to be, does not work. For me was ok",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4791
https://github.com/root-project/root/pull/4795:11,deployability,build,build,11,@phsft-bot build with flags -Dpyroot_experimental=ON,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4795
https://github.com/root-project/root/pull/4796:38,deployability,build,build,38,"Could an admin please run ""@phsft-bot build just on windows10/cxx14"" to be on the safe side?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4796
https://github.com/root-project/root/pull/4796:82,safety,safe,safe,82,"Could an admin please run ""@phsft-bot build just on windows10/cxx14"" to be on the safe side?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4796
https://github.com/root-project/root/pull/4796:11,deployability,build,build,11,@phsft-bot build just on windows10/cxx14,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4796
https://github.com/root-project/root/pull/4799:425,availability,Error,Error,425,"Build failed with:. ```. 11:40:26 make[2]: *** No rule to make target '/home/sftnight/build/workspace/root-pullrequests-build/root/gui/browserv7/inc/ROOT/RBrowsable.hxx', needed by 'include/ROOT/RBrowsable.hxx'. Stop. 11:40:26 CMakeFiles/Makefile2:31460: recipe for target 'gui/browserv7/CMakeFiles/move_header_gui_browserv7.dir/all' failed. 11:40:26 make[1]: *** [gui/browserv7/CMakeFiles/move_header_gui_browserv7.dir/all] Error 2. 11:40:26 make[1]: *** Waiting for unfinished jobs.... ```. This is obviously not related, so I'm merging my changes anyway.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4799
https://github.com/root-project/root/pull/4799:0,deployability,Build,Build,0,"Build failed with:. ```. 11:40:26 make[2]: *** No rule to make target '/home/sftnight/build/workspace/root-pullrequests-build/root/gui/browserv7/inc/ROOT/RBrowsable.hxx', needed by 'include/ROOT/RBrowsable.hxx'. Stop. 11:40:26 CMakeFiles/Makefile2:31460: recipe for target 'gui/browserv7/CMakeFiles/move_header_gui_browserv7.dir/all' failed. 11:40:26 make[1]: *** [gui/browserv7/CMakeFiles/move_header_gui_browserv7.dir/all] Error 2. 11:40:26 make[1]: *** Waiting for unfinished jobs.... ```. This is obviously not related, so I'm merging my changes anyway.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4799
https://github.com/root-project/root/pull/4799:6,deployability,fail,failed,6,"Build failed with:. ```. 11:40:26 make[2]: *** No rule to make target '/home/sftnight/build/workspace/root-pullrequests-build/root/gui/browserv7/inc/ROOT/RBrowsable.hxx', needed by 'include/ROOT/RBrowsable.hxx'. Stop. 11:40:26 CMakeFiles/Makefile2:31460: recipe for target 'gui/browserv7/CMakeFiles/move_header_gui_browserv7.dir/all' failed. 11:40:26 make[1]: *** [gui/browserv7/CMakeFiles/move_header_gui_browserv7.dir/all] Error 2. 11:40:26 make[1]: *** Waiting for unfinished jobs.... ```. This is obviously not related, so I'm merging my changes anyway.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4799
https://github.com/root-project/root/pull/4799:86,deployability,build,build,86,"Build failed with:. ```. 11:40:26 make[2]: *** No rule to make target '/home/sftnight/build/workspace/root-pullrequests-build/root/gui/browserv7/inc/ROOT/RBrowsable.hxx', needed by 'include/ROOT/RBrowsable.hxx'. Stop. 11:40:26 CMakeFiles/Makefile2:31460: recipe for target 'gui/browserv7/CMakeFiles/move_header_gui_browserv7.dir/all' failed. 11:40:26 make[1]: *** [gui/browserv7/CMakeFiles/move_header_gui_browserv7.dir/all] Error 2. 11:40:26 make[1]: *** Waiting for unfinished jobs.... ```. This is obviously not related, so I'm merging my changes anyway.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4799
https://github.com/root-project/root/pull/4799:120,deployability,build,build,120,"Build failed with:. ```. 11:40:26 make[2]: *** No rule to make target '/home/sftnight/build/workspace/root-pullrequests-build/root/gui/browserv7/inc/ROOT/RBrowsable.hxx', needed by 'include/ROOT/RBrowsable.hxx'. Stop. 11:40:26 CMakeFiles/Makefile2:31460: recipe for target 'gui/browserv7/CMakeFiles/move_header_gui_browserv7.dir/all' failed. 11:40:26 make[1]: *** [gui/browserv7/CMakeFiles/move_header_gui_browserv7.dir/all] Error 2. 11:40:26 make[1]: *** Waiting for unfinished jobs.... ```. This is obviously not related, so I'm merging my changes anyway.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4799
https://github.com/root-project/root/pull/4799:334,deployability,fail,failed,334,"Build failed with:. ```. 11:40:26 make[2]: *** No rule to make target '/home/sftnight/build/workspace/root-pullrequests-build/root/gui/browserv7/inc/ROOT/RBrowsable.hxx', needed by 'include/ROOT/RBrowsable.hxx'. Stop. 11:40:26 CMakeFiles/Makefile2:31460: recipe for target 'gui/browserv7/CMakeFiles/move_header_gui_browserv7.dir/all' failed. 11:40:26 make[1]: *** [gui/browserv7/CMakeFiles/move_header_gui_browserv7.dir/all] Error 2. 11:40:26 make[1]: *** Waiting for unfinished jobs.... ```. This is obviously not related, so I'm merging my changes anyway.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4799
https://github.com/root-project/root/pull/4799:425,performance,Error,Error,425,"Build failed with:. ```. 11:40:26 make[2]: *** No rule to make target '/home/sftnight/build/workspace/root-pullrequests-build/root/gui/browserv7/inc/ROOT/RBrowsable.hxx', needed by 'include/ROOT/RBrowsable.hxx'. Stop. 11:40:26 CMakeFiles/Makefile2:31460: recipe for target 'gui/browserv7/CMakeFiles/move_header_gui_browserv7.dir/all' failed. 11:40:26 make[1]: *** [gui/browserv7/CMakeFiles/move_header_gui_browserv7.dir/all] Error 2. 11:40:26 make[1]: *** Waiting for unfinished jobs.... ```. This is obviously not related, so I'm merging my changes anyway.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4799
https://github.com/root-project/root/pull/4799:6,reliability,fail,failed,6,"Build failed with:. ```. 11:40:26 make[2]: *** No rule to make target '/home/sftnight/build/workspace/root-pullrequests-build/root/gui/browserv7/inc/ROOT/RBrowsable.hxx', needed by 'include/ROOT/RBrowsable.hxx'. Stop. 11:40:26 CMakeFiles/Makefile2:31460: recipe for target 'gui/browserv7/CMakeFiles/move_header_gui_browserv7.dir/all' failed. 11:40:26 make[1]: *** [gui/browserv7/CMakeFiles/move_header_gui_browserv7.dir/all] Error 2. 11:40:26 make[1]: *** Waiting for unfinished jobs.... ```. This is obviously not related, so I'm merging my changes anyway.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4799
https://github.com/root-project/root/pull/4799:334,reliability,fail,failed,334,"Build failed with:. ```. 11:40:26 make[2]: *** No rule to make target '/home/sftnight/build/workspace/root-pullrequests-build/root/gui/browserv7/inc/ROOT/RBrowsable.hxx', needed by 'include/ROOT/RBrowsable.hxx'. Stop. 11:40:26 CMakeFiles/Makefile2:31460: recipe for target 'gui/browserv7/CMakeFiles/move_header_gui_browserv7.dir/all' failed. 11:40:26 make[1]: *** [gui/browserv7/CMakeFiles/move_header_gui_browserv7.dir/all] Error 2. 11:40:26 make[1]: *** Waiting for unfinished jobs.... ```. This is obviously not related, so I'm merging my changes anyway.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4799
https://github.com/root-project/root/pull/4799:425,safety,Error,Error,425,"Build failed with:. ```. 11:40:26 make[2]: *** No rule to make target '/home/sftnight/build/workspace/root-pullrequests-build/root/gui/browserv7/inc/ROOT/RBrowsable.hxx', needed by 'include/ROOT/RBrowsable.hxx'. Stop. 11:40:26 CMakeFiles/Makefile2:31460: recipe for target 'gui/browserv7/CMakeFiles/move_header_gui_browserv7.dir/all' failed. 11:40:26 make[1]: *** [gui/browserv7/CMakeFiles/move_header_gui_browserv7.dir/all] Error 2. 11:40:26 make[1]: *** Waiting for unfinished jobs.... ```. This is obviously not related, so I'm merging my changes anyway.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4799
https://github.com/root-project/root/pull/4799:212,usability,Stop,Stop,212,"Build failed with:. ```. 11:40:26 make[2]: *** No rule to make target '/home/sftnight/build/workspace/root-pullrequests-build/root/gui/browserv7/inc/ROOT/RBrowsable.hxx', needed by 'include/ROOT/RBrowsable.hxx'. Stop. 11:40:26 CMakeFiles/Makefile2:31460: recipe for target 'gui/browserv7/CMakeFiles/move_header_gui_browserv7.dir/all' failed. 11:40:26 make[1]: *** [gui/browserv7/CMakeFiles/move_header_gui_browserv7.dir/all] Error 2. 11:40:26 make[1]: *** Waiting for unfinished jobs.... ```. This is obviously not related, so I'm merging my changes anyway.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4799
https://github.com/root-project/root/pull/4799:425,usability,Error,Error,425,"Build failed with:. ```. 11:40:26 make[2]: *** No rule to make target '/home/sftnight/build/workspace/root-pullrequests-build/root/gui/browserv7/inc/ROOT/RBrowsable.hxx', needed by 'include/ROOT/RBrowsable.hxx'. Stop. 11:40:26 CMakeFiles/Makefile2:31460: recipe for target 'gui/browserv7/CMakeFiles/move_header_gui_browserv7.dir/all' failed. 11:40:26 make[1]: *** [gui/browserv7/CMakeFiles/move_header_gui_browserv7.dir/all] Error 2. 11:40:26 make[1]: *** Waiting for unfinished jobs.... ```. This is obviously not related, so I'm merging my changes anyway.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4799
https://github.com/root-project/root/pull/4803:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4803
https://github.com/root-project/root/pull/4803:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4803
https://github.com/root-project/root/pull/4805:335,availability,error,errors,335,"> Would be good to have a marker `-DENABLE_BROKEN_WINDOWS_TESTS=On` (with accompanying `CXXFLAGS+=-DENABLE_BROKEN_WINDOWS_TESTS=1` in GNU-make speak) to tag places we should revisit. Otherwise: LGTM, congrats! Thanks! Done. But as explained in the last commit, I had to keep some part of the code commented out, to prevent compilation errors",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4805
https://github.com/root-project/root/pull/4805:335,performance,error,errors,335,"> Would be good to have a marker `-DENABLE_BROKEN_WINDOWS_TESTS=On` (with accompanying `CXXFLAGS+=-DENABLE_BROKEN_WINDOWS_TESTS=1` in GNU-make speak) to tag places we should revisit. Otherwise: LGTM, congrats! Thanks! Done. But as explained in the last commit, I had to keep some part of the code commented out, to prevent compilation errors",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4805
https://github.com/root-project/root/pull/4805:315,safety,prevent,prevent,315,"> Would be good to have a marker `-DENABLE_BROKEN_WINDOWS_TESTS=On` (with accompanying `CXXFLAGS+=-DENABLE_BROKEN_WINDOWS_TESTS=1` in GNU-make speak) to tag places we should revisit. Otherwise: LGTM, congrats! Thanks! Done. But as explained in the last commit, I had to keep some part of the code commented out, to prevent compilation errors",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4805
https://github.com/root-project/root/pull/4805:335,safety,error,errors,335,"> Would be good to have a marker `-DENABLE_BROKEN_WINDOWS_TESTS=On` (with accompanying `CXXFLAGS+=-DENABLE_BROKEN_WINDOWS_TESTS=1` in GNU-make speak) to tag places we should revisit. Otherwise: LGTM, congrats! Thanks! Done. But as explained in the last commit, I had to keep some part of the code commented out, to prevent compilation errors",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4805
https://github.com/root-project/root/pull/4805:315,security,preven,prevent,315,"> Would be good to have a marker `-DENABLE_BROKEN_WINDOWS_TESTS=On` (with accompanying `CXXFLAGS+=-DENABLE_BROKEN_WINDOWS_TESTS=1` in GNU-make speak) to tag places we should revisit. Otherwise: LGTM, congrats! Thanks! Done. But as explained in the last commit, I had to keep some part of the code commented out, to prevent compilation errors",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4805
https://github.com/root-project/root/pull/4805:335,usability,error,errors,335,"> Would be good to have a marker `-DENABLE_BROKEN_WINDOWS_TESTS=On` (with accompanying `CXXFLAGS+=-DENABLE_BROKEN_WINDOWS_TESTS=1` in GNU-make speak) to tag places we should revisit. Otherwise: LGTM, congrats! Thanks! Done. But as explained in the last commit, I had to keep some part of the code commented out, to prevent compilation errors",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4805
https://github.com/root-project/root/pull/4806:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4806
https://github.com/root-project/root/pull/4806:11,deployability,build,build,11,@phsft-bot build! LGTM!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4806
https://github.com/root-project/root/pull/4806:33,deployability,build,build,33,@henryiii do you know why travis build (minuit2-standalone) didn't catch this issue?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4806
https://github.com/root-project/root/pull/4806:35,deployability,build,build,35,"> @henryiii do you know why travis build (minuit2-standalone) didn't catch this issue? Yes. It was failing to build but due to missing bash exit mode, was ""passing"". Fixed. :flushed:",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4806
https://github.com/root-project/root/pull/4806:99,deployability,fail,failing,99,"> @henryiii do you know why travis build (minuit2-standalone) didn't catch this issue? Yes. It was failing to build but due to missing bash exit mode, was ""passing"". Fixed. :flushed:",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4806
https://github.com/root-project/root/pull/4806:110,deployability,build,build,110,"> @henryiii do you know why travis build (minuit2-standalone) didn't catch this issue? Yes. It was failing to build but due to missing bash exit mode, was ""passing"". Fixed. :flushed:",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4806
https://github.com/root-project/root/pull/4806:99,reliability,fail,failing,99,"> @henryiii do you know why travis build (minuit2-standalone) didn't catch this issue? Yes. It was failing to build but due to missing bash exit mode, was ""passing"". Fixed. :flushed:",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4806
https://github.com/root-project/root/pull/4806:97,deployability,patch,patches,97,"Yup! As soon as PR will be green, I will merge it and please backport changes to branch v6-20-00-patches!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4806
https://github.com/root-project/root/pull/4806:27,energy efficiency,green,green,27,"Yup! As soon as PR will be green, I will merge it and please backport changes to branch v6-20-00-patches!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4806
https://github.com/root-project/root/pull/4806:97,safety,patch,patches,97,"Yup! As soon as PR will be green, I will merge it and please backport changes to branch v6-20-00-patches!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4806
https://github.com/root-project/root/pull/4806:97,security,patch,patches,97,"Yup! As soon as PR will be green, I will merge it and please backport changes to branch v6-20-00-patches!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4806
https://github.com/root-project/root/pull/4806:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4806
https://github.com/root-project/root/pull/4811:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4811
https://github.com/root-project/root/pull/4812:11,deployability,build,build,11,@phsft-bot build just on mac1014/cxx17 with flags -Druntime_cxxmodules=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4812
https://github.com/root-project/root/pull/4812:131,deployability,build,build,131,"> We should make sure we don't break -Dcxxmodules=On. @oshadura, what was the voodoo magic to trigger this check? I think we can't build cxxmodules in PRs...",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4812
https://github.com/root-project/root/pull/4818:30,interoperability,format,format,30,It's impossible to see what's format changes and what's functional ones. Can you just cherry-pick the relevant commits from master? (I'm hoping that *they* distinguish format from functional.),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4818
https://github.com/root-project/root/pull/4818:168,interoperability,format,format,168,It's impossible to see what's format changes and what's functional ones. Can you just cherry-pick the relevant commits from master? (I'm hoping that *they* distinguish format from functional.),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4818
https://github.com/root-project/root/pull/4818:152,availability,error,error,152,There is 2 PR to cherry pick. I did on my local 620-patches branch. But then I cannot push:. Pushing to ssh://github.com/root-project/root.git. remote: error: GH006: Protected branch update failed for refs/heads/v6-20-00-patches. .,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4818
https://github.com/root-project/root/pull/4818:52,deployability,patch,patches,52,There is 2 PR to cherry pick. I did on my local 620-patches branch. But then I cannot push:. Pushing to ssh://github.com/root-project/root.git. remote: error: GH006: Protected branch update failed for refs/heads/v6-20-00-patches. .,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4818
https://github.com/root-project/root/pull/4818:183,deployability,updat,update,183,There is 2 PR to cherry pick. I did on my local 620-patches branch. But then I cannot push:. Pushing to ssh://github.com/root-project/root.git. remote: error: GH006: Protected branch update failed for refs/heads/v6-20-00-patches. .,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4818
https://github.com/root-project/root/pull/4818:190,deployability,fail,failed,190,There is 2 PR to cherry pick. I did on my local 620-patches branch. But then I cannot push:. Pushing to ssh://github.com/root-project/root.git. remote: error: GH006: Protected branch update failed for refs/heads/v6-20-00-patches. .,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4818
https://github.com/root-project/root/pull/4818:221,deployability,patch,patches,221,There is 2 PR to cherry pick. I did on my local 620-patches branch. But then I cannot push:. Pushing to ssh://github.com/root-project/root.git. remote: error: GH006: Protected branch update failed for refs/heads/v6-20-00-patches. .,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4818
https://github.com/root-project/root/pull/4818:152,performance,error,error,152,There is 2 PR to cherry pick. I did on my local 620-patches branch. But then I cannot push:. Pushing to ssh://github.com/root-project/root.git. remote: error: GH006: Protected branch update failed for refs/heads/v6-20-00-patches. .,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4818
https://github.com/root-project/root/pull/4818:190,reliability,fail,failed,190,There is 2 PR to cherry pick. I did on my local 620-patches branch. But then I cannot push:. Pushing to ssh://github.com/root-project/root.git. remote: error: GH006: Protected branch update failed for refs/heads/v6-20-00-patches. .,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4818
https://github.com/root-project/root/pull/4818:52,safety,patch,patches,52,There is 2 PR to cherry pick. I did on my local 620-patches branch. But then I cannot push:. Pushing to ssh://github.com/root-project/root.git. remote: error: GH006: Protected branch update failed for refs/heads/v6-20-00-patches. .,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4818
https://github.com/root-project/root/pull/4818:152,safety,error,error,152,There is 2 PR to cherry pick. I did on my local 620-patches branch. But then I cannot push:. Pushing to ssh://github.com/root-project/root.git. remote: error: GH006: Protected branch update failed for refs/heads/v6-20-00-patches. .,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4818
https://github.com/root-project/root/pull/4818:183,safety,updat,update,183,There is 2 PR to cherry pick. I did on my local 620-patches branch. But then I cannot push:. Pushing to ssh://github.com/root-project/root.git. remote: error: GH006: Protected branch update failed for refs/heads/v6-20-00-patches. .,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4818
https://github.com/root-project/root/pull/4818:221,safety,patch,patches,221,There is 2 PR to cherry pick. I did on my local 620-patches branch. But then I cannot push:. Pushing to ssh://github.com/root-project/root.git. remote: error: GH006: Protected branch update failed for refs/heads/v6-20-00-patches. .,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4818
https://github.com/root-project/root/pull/4818:52,security,patch,patches,52,There is 2 PR to cherry pick. I did on my local 620-patches branch. But then I cannot push:. Pushing to ssh://github.com/root-project/root.git. remote: error: GH006: Protected branch update failed for refs/heads/v6-20-00-patches. .,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4818
https://github.com/root-project/root/pull/4818:104,security,ssh,ssh,104,There is 2 PR to cherry pick. I did on my local 620-patches branch. But then I cannot push:. Pushing to ssh://github.com/root-project/root.git. remote: error: GH006: Protected branch update failed for refs/heads/v6-20-00-patches. .,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4818
https://github.com/root-project/root/pull/4818:183,security,updat,update,183,There is 2 PR to cherry pick. I did on my local 620-patches branch. But then I cannot push:. Pushing to ssh://github.com/root-project/root.git. remote: error: GH006: Protected branch update failed for refs/heads/v6-20-00-patches. .,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4818
https://github.com/root-project/root/pull/4818:221,security,patch,patches,221,There is 2 PR to cherry pick. I did on my local 620-patches branch. But then I cannot push:. Pushing to ssh://github.com/root-project/root.git. remote: error: GH006: Protected branch update failed for refs/heads/v6-20-00-patches. .,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4818
https://github.com/root-project/root/pull/4818:152,usability,error,error,152,There is 2 PR to cherry pick. I did on my local 620-patches branch. But then I cannot push:. Pushing to ssh://github.com/root-project/root.git. remote: error: GH006: Protected branch update failed for refs/heads/v6-20-00-patches. .,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4818
https://github.com/root-project/root/pull/4822:71,deployability,build,build,71,"Change has only effect when calling cmake, therefore not waiting until build is finished",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4822
https://github.com/root-project/root/pull/4827:11,deployability,build,build,11,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4827
https://github.com/root-project/root/pull/4827:11,deployability,build,build,11,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4827
https://github.com/root-project/root/pull/4827:25,deployability,version,version,25,"I *really* like the last version. That's not what I read from the original code, so at least to me this would be very helpful.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4827
https://github.com/root-project/root/pull/4827:25,integrability,version,version,25,"I *really* like the last version. That's not what I read from the original code, so at least to me this would be very helpful.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4827
https://github.com/root-project/root/pull/4827:25,modifiability,version,version,25,"I *really* like the last version. That's not what I read from the original code, so at least to me this would be very helpful.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4827
https://github.com/root-project/root/pull/4827:118,usability,help,helpful,118,"I *really* like the last version. That's not what I read from the original code, so at least to me this would be very helpful.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4827
https://github.com/root-project/root/pull/4829:11,deployability,build,build,11,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4829
https://github.com/root-project/root/pull/4829:223,availability,failur,failures,223,"Hi,. is there any chance to get this merged soon? We are getting code migrated from `const std::string&` to `std::string_view`, which is more efficient when dealing with string literals. Because of that we are getting many failures in our tests against ROOT v6.20-patches, for code that works nicely with ROOT 6.18/04. Thanks. Marco",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4829
https://github.com/root-project/root/pull/4829:223,deployability,fail,failures,223,"Hi,. is there any chance to get this merged soon? We are getting code migrated from `const std::string&` to `std::string_view`, which is more efficient when dealing with string literals. Because of that we are getting many failures in our tests against ROOT v6.20-patches, for code that works nicely with ROOT 6.18/04. Thanks. Marco",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4829
https://github.com/root-project/root/pull/4829:264,deployability,patch,patches,264,"Hi,. is there any chance to get this merged soon? We are getting code migrated from `const std::string&` to `std::string_view`, which is more efficient when dealing with string literals. Because of that we are getting many failures in our tests against ROOT v6.20-patches, for code that works nicely with ROOT 6.18/04. Thanks. Marco",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4829
https://github.com/root-project/root/pull/4829:223,performance,failur,failures,223,"Hi,. is there any chance to get this merged soon? We are getting code migrated from `const std::string&` to `std::string_view`, which is more efficient when dealing with string literals. Because of that we are getting many failures in our tests against ROOT v6.20-patches, for code that works nicely with ROOT 6.18/04. Thanks. Marco",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4829
https://github.com/root-project/root/pull/4829:223,reliability,fail,failures,223,"Hi,. is there any chance to get this merged soon? We are getting code migrated from `const std::string&` to `std::string_view`, which is more efficient when dealing with string literals. Because of that we are getting many failures in our tests against ROOT v6.20-patches, for code that works nicely with ROOT 6.18/04. Thanks. Marco",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4829
https://github.com/root-project/root/pull/4829:239,safety,test,tests,239,"Hi,. is there any chance to get this merged soon? We are getting code migrated from `const std::string&` to `std::string_view`, which is more efficient when dealing with string literals. Because of that we are getting many failures in our tests against ROOT v6.20-patches, for code that works nicely with ROOT 6.18/04. Thanks. Marco",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4829
https://github.com/root-project/root/pull/4829:264,safety,patch,patches,264,"Hi,. is there any chance to get this merged soon? We are getting code migrated from `const std::string&` to `std::string_view`, which is more efficient when dealing with string literals. Because of that we are getting many failures in our tests against ROOT v6.20-patches, for code that works nicely with ROOT 6.18/04. Thanks. Marco",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4829
https://github.com/root-project/root/pull/4829:264,security,patch,patches,264,"Hi,. is there any chance to get this merged soon? We are getting code migrated from `const std::string&` to `std::string_view`, which is more efficient when dealing with string literals. Because of that we are getting many failures in our tests against ROOT v6.20-patches, for code that works nicely with ROOT 6.18/04. Thanks. Marco",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4829
https://github.com/root-project/root/pull/4829:239,testability,test,tests,239,"Hi,. is there any chance to get this merged soon? We are getting code migrated from `const std::string&` to `std::string_view`, which is more efficient when dealing with string literals. Because of that we are getting many failures in our tests against ROOT v6.20-patches, for code that works nicely with ROOT 6.18/04. Thanks. Marco",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4829
https://github.com/root-project/root/pull/4829:142,usability,efficien,efficient,142,"Hi,. is there any chance to get this merged soon? We are getting code migrated from `const std::string&` to `std::string_view`, which is more efficient when dealing with string literals. Because of that we are getting many failures in our tests against ROOT v6.20-patches, for code that works nicely with ROOT 6.18/04. Thanks. Marco",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4829
https://github.com/root-project/root/pull/4829:68,deployability,updat,updates,68,Yes. It should be merged this week-end or Monday. (after additional updates),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4829
https://github.com/root-project/root/pull/4829:68,safety,updat,updates,68,Yes. It should be merged this week-end or Monday. (after additional updates),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4829
https://github.com/root-project/root/pull/4829:68,security,updat,updates,68,Yes. It should be merged this week-end or Monday. (after additional updates),MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4829
https://github.com/root-project/root/pull/4830:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4830
https://github.com/root-project/root/pull/4830:78,deployability,updat,updated,78,I suspect if 2 macros have the different content this means that the user has updated/fixed the code between the 2 run producing the files ... whether the change is semantically consequent (i.e the files are compatible or not is a decision the user has to take) ... So it would make sense to only merge the TMacro that are all the same ....,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4830
https://github.com/root-project/root/pull/4830:165,interoperability,semant,semantically,165,I suspect if 2 macros have the different content this means that the user has updated/fixed the code between the 2 run producing the files ... whether the change is semantically consequent (i.e the files are compatible or not is a decision the user has to take) ... So it would make sense to only merge the TMacro that are all the same ....,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4830
https://github.com/root-project/root/pull/4830:208,interoperability,compatib,compatible,208,I suspect if 2 macros have the different content this means that the user has updated/fixed the code between the 2 run producing the files ... whether the change is semantically consequent (i.e the files are compatible or not is a decision the user has to take) ... So it would make sense to only merge the TMacro that are all the same ....,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4830
https://github.com/root-project/root/pull/4830:41,performance,content,content,41,I suspect if 2 macros have the different content this means that the user has updated/fixed the code between the 2 run producing the files ... whether the change is semantically consequent (i.e the files are compatible or not is a decision the user has to take) ... So it would make sense to only merge the TMacro that are all the same ....,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4830
https://github.com/root-project/root/pull/4830:78,safety,updat,updated,78,I suspect if 2 macros have the different content this means that the user has updated/fixed the code between the 2 run producing the files ... whether the change is semantically consequent (i.e the files are compatible or not is a decision the user has to take) ... So it would make sense to only merge the TMacro that are all the same ....,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4830
https://github.com/root-project/root/pull/4830:78,security,updat,updated,78,I suspect if 2 macros have the different content this means that the user has updated/fixed the code between the 2 run producing the files ... whether the change is semantically consequent (i.e the files are compatible or not is a decision the user has to take) ... So it would make sense to only merge the TMacro that are all the same ....,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4830
https://github.com/root-project/root/pull/4830:69,usability,user,user,69,I suspect if 2 macros have the different content this means that the user has updated/fixed the code between the 2 run producing the files ... whether the change is semantically consequent (i.e the files are compatible or not is a decision the user has to take) ... So it would make sense to only merge the TMacro that are all the same ....,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4830
https://github.com/root-project/root/pull/4830:244,usability,user,user,244,I suspect if 2 macros have the different content this means that the user has updated/fixed the code between the 2 run producing the files ... whether the change is semantically consequent (i.e the files are compatible or not is a decision the user has to take) ... So it would make sense to only merge the TMacro that are all the same ....,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4830
https://github.com/root-project/root/pull/4830:80,deployability,updat,updated,80,"> I suspect if 2 macros have the different content this means that the user has updated/fixed the code between the 2 run producing the files ... whether the change is semantically consequent (i.e the files are compatible or not is a decision the user has to take) ... So it would make sense to only merge the TMacro that are all the same .... I understand your concerns, but I don't know whether its possible to implement it like that. At least I don't know how. However, I would consider merging the results of two different versions of the same macro extremly dangerous and would only use that for quick and dirty tests. At least in my case the macros are so complex that I would rerun it after all changes for safety.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4830
https://github.com/root-project/root/pull/4830:526,deployability,version,versions,526,"> I suspect if 2 macros have the different content this means that the user has updated/fixed the code between the 2 run producing the files ... whether the change is semantically consequent (i.e the files are compatible or not is a decision the user has to take) ... So it would make sense to only merge the TMacro that are all the same .... I understand your concerns, but I don't know whether its possible to implement it like that. At least I don't know how. However, I would consider merging the results of two different versions of the same macro extremly dangerous and would only use that for quick and dirty tests. At least in my case the macros are so complex that I would rerun it after all changes for safety.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4830
https://github.com/root-project/root/pull/4830:526,integrability,version,versions,526,"> I suspect if 2 macros have the different content this means that the user has updated/fixed the code between the 2 run producing the files ... whether the change is semantically consequent (i.e the files are compatible or not is a decision the user has to take) ... So it would make sense to only merge the TMacro that are all the same .... I understand your concerns, but I don't know whether its possible to implement it like that. At least I don't know how. However, I would consider merging the results of two different versions of the same macro extremly dangerous and would only use that for quick and dirty tests. At least in my case the macros are so complex that I would rerun it after all changes for safety.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4830
https://github.com/root-project/root/pull/4830:167,interoperability,semant,semantically,167,"> I suspect if 2 macros have the different content this means that the user has updated/fixed the code between the 2 run producing the files ... whether the change is semantically consequent (i.e the files are compatible or not is a decision the user has to take) ... So it would make sense to only merge the TMacro that are all the same .... I understand your concerns, but I don't know whether its possible to implement it like that. At least I don't know how. However, I would consider merging the results of two different versions of the same macro extremly dangerous and would only use that for quick and dirty tests. At least in my case the macros are so complex that I would rerun it after all changes for safety.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4830
https://github.com/root-project/root/pull/4830:210,interoperability,compatib,compatible,210,"> I suspect if 2 macros have the different content this means that the user has updated/fixed the code between the 2 run producing the files ... whether the change is semantically consequent (i.e the files are compatible or not is a decision the user has to take) ... So it would make sense to only merge the TMacro that are all the same .... I understand your concerns, but I don't know whether its possible to implement it like that. At least I don't know how. However, I would consider merging the results of two different versions of the same macro extremly dangerous and would only use that for quick and dirty tests. At least in my case the macros are so complex that I would rerun it after all changes for safety.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4830
https://github.com/root-project/root/pull/4830:361,modifiability,concern,concerns,361,"> I suspect if 2 macros have the different content this means that the user has updated/fixed the code between the 2 run producing the files ... whether the change is semantically consequent (i.e the files are compatible or not is a decision the user has to take) ... So it would make sense to only merge the TMacro that are all the same .... I understand your concerns, but I don't know whether its possible to implement it like that. At least I don't know how. However, I would consider merging the results of two different versions of the same macro extremly dangerous and would only use that for quick and dirty tests. At least in my case the macros are so complex that I would rerun it after all changes for safety.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4830
https://github.com/root-project/root/pull/4830:526,modifiability,version,versions,526,"> I suspect if 2 macros have the different content this means that the user has updated/fixed the code between the 2 run producing the files ... whether the change is semantically consequent (i.e the files are compatible or not is a decision the user has to take) ... So it would make sense to only merge the TMacro that are all the same .... I understand your concerns, but I don't know whether its possible to implement it like that. At least I don't know how. However, I would consider merging the results of two different versions of the same macro extremly dangerous and would only use that for quick and dirty tests. At least in my case the macros are so complex that I would rerun it after all changes for safety.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4830
https://github.com/root-project/root/pull/4830:43,performance,content,content,43,"> I suspect if 2 macros have the different content this means that the user has updated/fixed the code between the 2 run producing the files ... whether the change is semantically consequent (i.e the files are compatible or not is a decision the user has to take) ... So it would make sense to only merge the TMacro that are all the same .... I understand your concerns, but I don't know whether its possible to implement it like that. At least I don't know how. However, I would consider merging the results of two different versions of the same macro extremly dangerous and would only use that for quick and dirty tests. At least in my case the macros are so complex that I would rerun it after all changes for safety.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4830
https://github.com/root-project/root/pull/4830:80,safety,updat,updated,80,"> I suspect if 2 macros have the different content this means that the user has updated/fixed the code between the 2 run producing the files ... whether the change is semantically consequent (i.e the files are compatible or not is a decision the user has to take) ... So it would make sense to only merge the TMacro that are all the same .... I understand your concerns, but I don't know whether its possible to implement it like that. At least I don't know how. However, I would consider merging the results of two different versions of the same macro extremly dangerous and would only use that for quick and dirty tests. At least in my case the macros are so complex that I would rerun it after all changes for safety.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4830
https://github.com/root-project/root/pull/4830:616,safety,test,tests,616,"> I suspect if 2 macros have the different content this means that the user has updated/fixed the code between the 2 run producing the files ... whether the change is semantically consequent (i.e the files are compatible or not is a decision the user has to take) ... So it would make sense to only merge the TMacro that are all the same .... I understand your concerns, but I don't know whether its possible to implement it like that. At least I don't know how. However, I would consider merging the results of two different versions of the same macro extremly dangerous and would only use that for quick and dirty tests. At least in my case the macros are so complex that I would rerun it after all changes for safety.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4830
https://github.com/root-project/root/pull/4830:661,safety,compl,complex,661,"> I suspect if 2 macros have the different content this means that the user has updated/fixed the code between the 2 run producing the files ... whether the change is semantically consequent (i.e the files are compatible or not is a decision the user has to take) ... So it would make sense to only merge the TMacro that are all the same .... I understand your concerns, but I don't know whether its possible to implement it like that. At least I don't know how. However, I would consider merging the results of two different versions of the same macro extremly dangerous and would only use that for quick and dirty tests. At least in my case the macros are so complex that I would rerun it after all changes for safety.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4830
https://github.com/root-project/root/pull/4830:713,safety,safe,safety,713,"> I suspect if 2 macros have the different content this means that the user has updated/fixed the code between the 2 run producing the files ... whether the change is semantically consequent (i.e the files are compatible or not is a decision the user has to take) ... So it would make sense to only merge the TMacro that are all the same .... I understand your concerns, but I don't know whether its possible to implement it like that. At least I don't know how. However, I would consider merging the results of two different versions of the same macro extremly dangerous and would only use that for quick and dirty tests. At least in my case the macros are so complex that I would rerun it after all changes for safety.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4830
https://github.com/root-project/root/pull/4830:80,security,updat,updated,80,"> I suspect if 2 macros have the different content this means that the user has updated/fixed the code between the 2 run producing the files ... whether the change is semantically consequent (i.e the files are compatible or not is a decision the user has to take) ... So it would make sense to only merge the TMacro that are all the same .... I understand your concerns, but I don't know whether its possible to implement it like that. At least I don't know how. However, I would consider merging the results of two different versions of the same macro extremly dangerous and would only use that for quick and dirty tests. At least in my case the macros are so complex that I would rerun it after all changes for safety.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4830
https://github.com/root-project/root/pull/4830:661,security,compl,complex,661,"> I suspect if 2 macros have the different content this means that the user has updated/fixed the code between the 2 run producing the files ... whether the change is semantically consequent (i.e the files are compatible or not is a decision the user has to take) ... So it would make sense to only merge the TMacro that are all the same .... I understand your concerns, but I don't know whether its possible to implement it like that. At least I don't know how. However, I would consider merging the results of two different versions of the same macro extremly dangerous and would only use that for quick and dirty tests. At least in my case the macros are so complex that I would rerun it after all changes for safety.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4830
https://github.com/root-project/root/pull/4830:345,testability,understand,understand,345,"> I suspect if 2 macros have the different content this means that the user has updated/fixed the code between the 2 run producing the files ... whether the change is semantically consequent (i.e the files are compatible or not is a decision the user has to take) ... So it would make sense to only merge the TMacro that are all the same .... I understand your concerns, but I don't know whether its possible to implement it like that. At least I don't know how. However, I would consider merging the results of two different versions of the same macro extremly dangerous and would only use that for quick and dirty tests. At least in my case the macros are so complex that I would rerun it after all changes for safety.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4830
https://github.com/root-project/root/pull/4830:361,testability,concern,concerns,361,"> I suspect if 2 macros have the different content this means that the user has updated/fixed the code between the 2 run producing the files ... whether the change is semantically consequent (i.e the files are compatible or not is a decision the user has to take) ... So it would make sense to only merge the TMacro that are all the same .... I understand your concerns, but I don't know whether its possible to implement it like that. At least I don't know how. However, I would consider merging the results of two different versions of the same macro extremly dangerous and would only use that for quick and dirty tests. At least in my case the macros are so complex that I would rerun it after all changes for safety.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4830
https://github.com/root-project/root/pull/4830:616,testability,test,tests,616,"> I suspect if 2 macros have the different content this means that the user has updated/fixed the code between the 2 run producing the files ... whether the change is semantically consequent (i.e the files are compatible or not is a decision the user has to take) ... So it would make sense to only merge the TMacro that are all the same .... I understand your concerns, but I don't know whether its possible to implement it like that. At least I don't know how. However, I would consider merging the results of two different versions of the same macro extremly dangerous and would only use that for quick and dirty tests. At least in my case the macros are so complex that I would rerun it after all changes for safety.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4830
https://github.com/root-project/root/pull/4830:71,usability,user,user,71,"> I suspect if 2 macros have the different content this means that the user has updated/fixed the code between the 2 run producing the files ... whether the change is semantically consequent (i.e the files are compatible or not is a decision the user has to take) ... So it would make sense to only merge the TMacro that are all the same .... I understand your concerns, but I don't know whether its possible to implement it like that. At least I don't know how. However, I would consider merging the results of two different versions of the same macro extremly dangerous and would only use that for quick and dirty tests. At least in my case the macros are so complex that I would rerun it after all changes for safety.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4830
https://github.com/root-project/root/pull/4830:246,usability,user,user,246,"> I suspect if 2 macros have the different content this means that the user has updated/fixed the code between the 2 run producing the files ... whether the change is semantically consequent (i.e the files are compatible or not is a decision the user has to take) ... So it would make sense to only merge the TMacro that are all the same .... I understand your concerns, but I don't know whether its possible to implement it like that. At least I don't know how. However, I would consider merging the results of two different versions of the same macro extremly dangerous and would only use that for quick and dirty tests. At least in my case the macros are so complex that I would rerun it after all changes for safety.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4830
https://github.com/root-project/root/pull/4832:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4832
https://github.com/root-project/root/pull/4832:225,deployability,upgrad,upgrade,225,"About #4750 considering comment of @amadio in https://sft.its.cern.ch/jira/browse/ROOT-10472 I will propose return back to idea to use instead the PR https://github.com/root-project/root/pull/4749 (I reopened it). After LLVM upgrade, I will be happy to try your patch again! About #4757 Can you pleeeease backport to 6.20?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4832
https://github.com/root-project/root/pull/4832:262,deployability,patch,patch,262,"About #4750 considering comment of @amadio in https://sft.its.cern.ch/jira/browse/ROOT-10472 I will propose return back to idea to use instead the PR https://github.com/root-project/root/pull/4749 (I reopened it). After LLVM upgrade, I will be happy to try your patch again! About #4757 Can you pleeeease backport to 6.20?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4832
https://github.com/root-project/root/pull/4832:225,modifiability,upgrad,upgrade,225,"About #4750 considering comment of @amadio in https://sft.its.cern.ch/jira/browse/ROOT-10472 I will propose return back to idea to use instead the PR https://github.com/root-project/root/pull/4749 (I reopened it). After LLVM upgrade, I will be happy to try your patch again! About #4757 Can you pleeeease backport to 6.20?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4832
https://github.com/root-project/root/pull/4832:262,safety,patch,patch,262,"About #4750 considering comment of @amadio in https://sft.its.cern.ch/jira/browse/ROOT-10472 I will propose return back to idea to use instead the PR https://github.com/root-project/root/pull/4749 (I reopened it). After LLVM upgrade, I will be happy to try your patch again! About #4757 Can you pleeeease backport to 6.20?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4832
https://github.com/root-project/root/pull/4832:262,security,patch,patch,262,"About #4750 considering comment of @amadio in https://sft.its.cern.ch/jira/browse/ROOT-10472 I will propose return back to idea to use instead the PR https://github.com/root-project/root/pull/4749 (I reopened it). After LLVM upgrade, I will be happy to try your patch again! About #4757 Can you pleeeease backport to 6.20?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4832
https://github.com/root-project/root/pull/4832:116,deployability,version,versions,116,"It seems that we don't really need to use both `FindPython2` and `FindPython3` until the moment we want to use both versions at the same time. It might be better to just use `FindPython` instead, at least for now. See https://cmake.org/cmake/help/latest/module/FindPython.html for more information. When a single build of ROOT will build PyROOT for multiple versions of Python, then inside that directory we can use `FindPython2` and `FindPython3`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4832
https://github.com/root-project/root/pull/4832:254,deployability,modul,module,254,"It seems that we don't really need to use both `FindPython2` and `FindPython3` until the moment we want to use both versions at the same time. It might be better to just use `FindPython` instead, at least for now. See https://cmake.org/cmake/help/latest/module/FindPython.html for more information. When a single build of ROOT will build PyROOT for multiple versions of Python, then inside that directory we can use `FindPython2` and `FindPython3`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4832
https://github.com/root-project/root/pull/4832:313,deployability,build,build,313,"It seems that we don't really need to use both `FindPython2` and `FindPython3` until the moment we want to use both versions at the same time. It might be better to just use `FindPython` instead, at least for now. See https://cmake.org/cmake/help/latest/module/FindPython.html for more information. When a single build of ROOT will build PyROOT for multiple versions of Python, then inside that directory we can use `FindPython2` and `FindPython3`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4832
https://github.com/root-project/root/pull/4832:332,deployability,build,build,332,"It seems that we don't really need to use both `FindPython2` and `FindPython3` until the moment we want to use both versions at the same time. It might be better to just use `FindPython` instead, at least for now. See https://cmake.org/cmake/help/latest/module/FindPython.html for more information. When a single build of ROOT will build PyROOT for multiple versions of Python, then inside that directory we can use `FindPython2` and `FindPython3`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4832
https://github.com/root-project/root/pull/4832:358,deployability,version,versions,358,"It seems that we don't really need to use both `FindPython2` and `FindPython3` until the moment we want to use both versions at the same time. It might be better to just use `FindPython` instead, at least for now. See https://cmake.org/cmake/help/latest/module/FindPython.html for more information. When a single build of ROOT will build PyROOT for multiple versions of Python, then inside that directory we can use `FindPython2` and `FindPython3`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4832
https://github.com/root-project/root/pull/4832:116,integrability,version,versions,116,"It seems that we don't really need to use both `FindPython2` and `FindPython3` until the moment we want to use both versions at the same time. It might be better to just use `FindPython` instead, at least for now. See https://cmake.org/cmake/help/latest/module/FindPython.html for more information. When a single build of ROOT will build PyROOT for multiple versions of Python, then inside that directory we can use `FindPython2` and `FindPython3`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4832
https://github.com/root-project/root/pull/4832:358,integrability,version,versions,358,"It seems that we don't really need to use both `FindPython2` and `FindPython3` until the moment we want to use both versions at the same time. It might be better to just use `FindPython` instead, at least for now. See https://cmake.org/cmake/help/latest/module/FindPython.html for more information. When a single build of ROOT will build PyROOT for multiple versions of Python, then inside that directory we can use `FindPython2` and `FindPython3`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4832
https://github.com/root-project/root/pull/4832:116,modifiability,version,versions,116,"It seems that we don't really need to use both `FindPython2` and `FindPython3` until the moment we want to use both versions at the same time. It might be better to just use `FindPython` instead, at least for now. See https://cmake.org/cmake/help/latest/module/FindPython.html for more information. When a single build of ROOT will build PyROOT for multiple versions of Python, then inside that directory we can use `FindPython2` and `FindPython3`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4832
https://github.com/root-project/root/pull/4832:254,modifiability,modul,module,254,"It seems that we don't really need to use both `FindPython2` and `FindPython3` until the moment we want to use both versions at the same time. It might be better to just use `FindPython` instead, at least for now. See https://cmake.org/cmake/help/latest/module/FindPython.html for more information. When a single build of ROOT will build PyROOT for multiple versions of Python, then inside that directory we can use `FindPython2` and `FindPython3`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4832
https://github.com/root-project/root/pull/4832:358,modifiability,version,versions,358,"It seems that we don't really need to use both `FindPython2` and `FindPython3` until the moment we want to use both versions at the same time. It might be better to just use `FindPython` instead, at least for now. See https://cmake.org/cmake/help/latest/module/FindPython.html for more information. When a single build of ROOT will build PyROOT for multiple versions of Python, then inside that directory we can use `FindPython2` and `FindPython3`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4832
https://github.com/root-project/root/pull/4832:137,performance,time,time,137,"It seems that we don't really need to use both `FindPython2` and `FindPython3` until the moment we want to use both versions at the same time. It might be better to just use `FindPython` instead, at least for now. See https://cmake.org/cmake/help/latest/module/FindPython.html for more information. When a single build of ROOT will build PyROOT for multiple versions of Python, then inside that directory we can use `FindPython2` and `FindPython3`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4832
https://github.com/root-project/root/pull/4832:254,safety,modul,module,254,"It seems that we don't really need to use both `FindPython2` and `FindPython3` until the moment we want to use both versions at the same time. It might be better to just use `FindPython` instead, at least for now. See https://cmake.org/cmake/help/latest/module/FindPython.html for more information. When a single build of ROOT will build PyROOT for multiple versions of Python, then inside that directory we can use `FindPython2` and `FindPython3`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4832
https://github.com/root-project/root/pull/4832:242,usability,help,help,242,"It seems that we don't really need to use both `FindPython2` and `FindPython3` until the moment we want to use both versions at the same time. It might be better to just use `FindPython` instead, at least for now. See https://cmake.org/cmake/help/latest/module/FindPython.html for more information. When a single build of ROOT will build PyROOT for multiple versions of Python, then inside that directory we can use `FindPython2` and `FindPython3`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4832
https://github.com/root-project/root/pull/4832:95,deployability,version,versions,95,@chrisburr can you check please with @maxgalli that it will work with both PyROOT for multiple versions of Python?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4832
https://github.com/root-project/root/pull/4832:95,integrability,version,versions,95,@chrisburr can you check please with @maxgalli that it will work with both PyROOT for multiple versions of Python?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4832
https://github.com/root-project/root/pull/4832:95,modifiability,version,versions,95,@chrisburr can you check please with @maxgalli that it will work with both PyROOT for multiple versions of Python?,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4832
https://github.com/root-project/root/pull/4832:97,deployability,version,versions,97,"> @chrisburr can you check please with @maxgalli that it will work with both PyROOT for multiple versions of Python? I've tried to build two different versions (2.7 and 3.6) with also this commit and I can' t see anything different, so I guess it works fine",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4832
https://github.com/root-project/root/pull/4832:131,deployability,build,build,131,"> @chrisburr can you check please with @maxgalli that it will work with both PyROOT for multiple versions of Python? I've tried to build two different versions (2.7 and 3.6) with also this commit and I can' t see anything different, so I guess it works fine",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4832
https://github.com/root-project/root/pull/4832:151,deployability,version,versions,151,"> @chrisburr can you check please with @maxgalli that it will work with both PyROOT for multiple versions of Python? I've tried to build two different versions (2.7 and 3.6) with also this commit and I can' t see anything different, so I guess it works fine",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4832
https://github.com/root-project/root/pull/4832:97,integrability,version,versions,97,"> @chrisburr can you check please with @maxgalli that it will work with both PyROOT for multiple versions of Python? I've tried to build two different versions (2.7 and 3.6) with also this commit and I can' t see anything different, so I guess it works fine",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4832
https://github.com/root-project/root/pull/4832:151,integrability,version,versions,151,"> @chrisburr can you check please with @maxgalli that it will work with both PyROOT for multiple versions of Python? I've tried to build two different versions (2.7 and 3.6) with also this commit and I can' t see anything different, so I guess it works fine",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4832
https://github.com/root-project/root/pull/4832:97,modifiability,version,versions,97,"> @chrisburr can you check please with @maxgalli that it will work with both PyROOT for multiple versions of Python? I've tried to build two different versions (2.7 and 3.6) with also this commit and I can' t see anything different, so I guess it works fine",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4832
https://github.com/root-project/root/pull/4832:151,modifiability,version,versions,151,"> @chrisburr can you check please with @maxgalli that it will work with both PyROOT for multiple versions of Python? I've tried to build two different versions (2.7 and 3.6) with also this commit and I can' t see anything different, so I guess it works fine",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4832
https://github.com/root-project/root/pull/4833:24,usability,confirm,confirm,24,"Thank you, @agheata , I confirm.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4833
https://github.com/root-project/root/pull/4834:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4834
https://github.com/root-project/root/pull/4835:37,usability,confirm,confirm,37,"Thank you, @agheata . I checked, and confirm.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4835
https://github.com/root-project/root/pull/4835:4,deployability,build,build,4,"The build on ROOT-fedora30/cxx14 fails for no reason, all test have passed but the build is declared UNSTABLE for some unknown reason. @Axel-Naumann any idea? I've seen this message on other builds in the past.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4835
https://github.com/root-project/root/pull/4835:33,deployability,fail,fails,33,"The build on ROOT-fedora30/cxx14 fails for no reason, all test have passed but the build is declared UNSTABLE for some unknown reason. @Axel-Naumann any idea? I've seen this message on other builds in the past.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4835
https://github.com/root-project/root/pull/4835:83,deployability,build,build,83,"The build on ROOT-fedora30/cxx14 fails for no reason, all test have passed but the build is declared UNSTABLE for some unknown reason. @Axel-Naumann any idea? I've seen this message on other builds in the past.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4835
https://github.com/root-project/root/pull/4835:191,deployability,build,builds,191,"The build on ROOT-fedora30/cxx14 fails for no reason, all test have passed but the build is declared UNSTABLE for some unknown reason. @Axel-Naumann any idea? I've seen this message on other builds in the past.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4835
https://github.com/root-project/root/pull/4835:174,integrability,messag,message,174,"The build on ROOT-fedora30/cxx14 fails for no reason, all test have passed but the build is declared UNSTABLE for some unknown reason. @Axel-Naumann any idea? I've seen this message on other builds in the past.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4835
https://github.com/root-project/root/pull/4835:174,interoperability,messag,message,174,"The build on ROOT-fedora30/cxx14 fails for no reason, all test have passed but the build is declared UNSTABLE for some unknown reason. @Axel-Naumann any idea? I've seen this message on other builds in the past.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4835
https://github.com/root-project/root/pull/4835:33,reliability,fail,fails,33,"The build on ROOT-fedora30/cxx14 fails for no reason, all test have passed but the build is declared UNSTABLE for some unknown reason. @Axel-Naumann any idea? I've seen this message on other builds in the past.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4835
https://github.com/root-project/root/pull/4835:58,safety,test,test,58,"The build on ROOT-fedora30/cxx14 fails for no reason, all test have passed but the build is declared UNSTABLE for some unknown reason. @Axel-Naumann any idea? I've seen this message on other builds in the past.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4835
https://github.com/root-project/root/pull/4835:58,testability,test,test,58,"The build on ROOT-fedora30/cxx14 fails for no reason, all test have passed but the build is declared UNSTABLE for some unknown reason. @Axel-Naumann any idea? I've seen this message on other builds in the past.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4835
https://github.com/root-project/root/pull/4835:18,availability,failur,failure,18,"All test passing, failure is due to UNSTABLE. @Axel-Naumann this is ready to merge",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4835
https://github.com/root-project/root/pull/4835:18,deployability,fail,failure,18,"All test passing, failure is due to UNSTABLE. @Axel-Naumann this is ready to merge",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4835
https://github.com/root-project/root/pull/4835:18,performance,failur,failure,18,"All test passing, failure is due to UNSTABLE. @Axel-Naumann this is ready to merge",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4835
https://github.com/root-project/root/pull/4835:18,reliability,fail,failure,18,"All test passing, failure is due to UNSTABLE. @Axel-Naumann this is ready to merge",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4835
https://github.com/root-project/root/pull/4835:4,safety,test,test,4,"All test passing, failure is due to UNSTABLE. @Axel-Naumann this is ready to merge",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4835
https://github.com/root-project/root/pull/4835:4,testability,test,test,4,"All test passing, failure is due to UNSTABLE. @Axel-Naumann this is ready to merge",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4835
https://github.com/root-project/root/pull/4836:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4836
https://github.com/root-project/root/pull/4837:11,deployability,build,build,11,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4837
https://github.com/root-project/root/pull/4837:11,deployability,build,build,11,@phsft-bot build with flags -DCTEST_TEST_EXCLUDE_NONE=On.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4837
https://github.com/root-project/root/pull/4837:28,deployability,fail,failed,28,"Tests went ok, Jenkins just failed to update the status.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4837
https://github.com/root-project/root/pull/4837:38,deployability,updat,update,38,"Tests went ok, Jenkins just failed to update the status.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4837
https://github.com/root-project/root/pull/4837:28,reliability,fail,failed,28,"Tests went ok, Jenkins just failed to update the status.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4837
https://github.com/root-project/root/pull/4837:0,safety,Test,Tests,0,"Tests went ok, Jenkins just failed to update the status.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4837
https://github.com/root-project/root/pull/4837:38,safety,updat,update,38,"Tests went ok, Jenkins just failed to update the status.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4837
https://github.com/root-project/root/pull/4837:38,security,updat,update,38,"Tests went ok, Jenkins just failed to update the status.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4837
https://github.com/root-project/root/pull/4837:0,testability,Test,Tests,0,"Tests went ok, Jenkins just failed to update the status.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4837
https://github.com/root-project/root/pull/4837:49,usability,statu,status,49,"Tests went ok, Jenkins just failed to update the status.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4837
https://github.com/root-project/root/pull/4838:11,deployability,build,build,11,@phsft-bot build!,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4838
https://github.com/root-project/root/pull/4839:95,deployability,log,log,95,"In addition this changes the value kUseCompiledDefault, could that be documented in the commit log?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4839
https://github.com/root-project/root/pull/4839:95,safety,log,log,95,"In addition this changes the value kUseCompiledDefault, could that be documented in the commit log?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4839
https://github.com/root-project/root/pull/4839:95,security,log,log,95,"In addition this changes the value kUseCompiledDefault, could that be documented in the commit log?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4839
https://github.com/root-project/root/pull/4839:95,testability,log,log,95,"In addition this changes the value kUseCompiledDefault, could that be documented in the commit log?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4839
https://github.com/root-project/root/pull/4839:70,usability,document,documented,70,"In addition this changes the value kUseCompiledDefault, could that be documented in the commit log?",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4839
https://github.com/root-project/root/pull/4839:97,deployability,log,log,97,"> In addition this changes the value kUseCompiledDefault, could that be documented in the commit log? Done!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4839
https://github.com/root-project/root/pull/4839:97,safety,log,log,97,"> In addition this changes the value kUseCompiledDefault, could that be documented in the commit log? Done!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4839
https://github.com/root-project/root/pull/4839:97,security,log,log,97,"> In addition this changes the value kUseCompiledDefault, could that be documented in the commit log? Done!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4839
https://github.com/root-project/root/pull/4839:97,testability,log,log,97,"> In addition this changes the value kUseCompiledDefault, could that be documented in the commit log? Done!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4839
https://github.com/root-project/root/pull/4839:72,usability,document,documented,72,"> In addition this changes the value kUseCompiledDefault, could that be documented in the commit log? Done!",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4839
https://github.com/root-project/root/pull/4839:126,deployability,log,logs,126,Actually my apologies ... changing the default seems to warrant its own commit so that it is clearly marked/seen in short git logs.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4839
https://github.com/root-project/root/pull/4839:126,safety,log,logs,126,Actually my apologies ... changing the default seems to warrant its own commit so that it is clearly marked/seen in short git logs.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4839
https://github.com/root-project/root/pull/4839:126,security,log,logs,126,Actually my apologies ... changing the default seems to warrant its own commit so that it is clearly marked/seen in short git logs.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4839
https://github.com/root-project/root/pull/4839:126,testability,log,logs,126,Actually my apologies ... changing the default seems to warrant its own commit so that it is clearly marked/seen in short git logs.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4839
https://github.com/root-project/root/pull/4839:93,usability,clear,clearly,93,Actually my apologies ... changing the default seems to warrant its own commit so that it is clearly marked/seen in short git logs.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4839
https://github.com/root-project/root/pull/4843:11,deployability,build,build,11,@phsft-bot build with flags -Dclingtest=On,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4843
https://github.com/root-project/root/pull/4847:1072,safety,test,test,1072,"@pcanal For instance. ```json. {. ""vpx"": [0.208788, -1.70924, 0.955477, 0.162738, 1.77392, -0.243316, -0.857411, 0.714772, 1.05418, -0.153219, -0.366184]. }. ```. ```json. {. ""B_FlightDistance"": 14.4299,. ""B_VertexChi2"": 10.295,. ""H1_PX"": -318.158,. ""H1_PY"": -6407.68,. ""H1_PZ"": 152900,. ""H1_ProbK"": 0.0667207,. ""H1_ProbPi"": 0.685733,. ""H1_Charge"": 1,. ""H1_IPChi2"": 21.3981,. ""H1_isMuon"": 0,. ""H2_PX"": 382.38,. ""H2_PY"": 114.052,. ""H2_PZ"": 6374.15,. ""H2_ProbK"": 0.142381,. ""H2_ProbPi"": 0.906743,. ""H2_Charge"": -1,. ""H2_IPChi2"": 351.338,. ""H2_isMuon"": 0,. ""H3_PX"": -1151.69,. ""H3_PY"": -2406.64,. ""H3_PZ"": 33660.3,. ""H3_ProbK"": 0.946793,. ""H3_ProbPi"": 0.0687876,. ""H3_Charge"": -1,. ""H3_IPChi2"": 587.399,. ""H3_isMuon"": 0. }. ```. ```json. {. ""Muon_pt"": [3.59005, 4.19566],. ""Muon_eta"": [-2.13241, -2.19689],. ""Muon_phi"": [-2.98745, 0.425593],. ""Muon_mass"": [0.105658, 0.105658],. ""Muon_charge"": [-1, -1],. ""nMuon"": 2,. ""run"": 167674,. ""luminosityBlock"": 209. }. ```. There are more examples in `ntpl001_staff.C` and `ntpl002_vector.C` tutorials and in the `ntuple_print` unit test.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4847
https://github.com/root-project/root/pull/4847:1067,testability,unit,unit,1067,"@pcanal For instance. ```json. {. ""vpx"": [0.208788, -1.70924, 0.955477, 0.162738, 1.77392, -0.243316, -0.857411, 0.714772, 1.05418, -0.153219, -0.366184]. }. ```. ```json. {. ""B_FlightDistance"": 14.4299,. ""B_VertexChi2"": 10.295,. ""H1_PX"": -318.158,. ""H1_PY"": -6407.68,. ""H1_PZ"": 152900,. ""H1_ProbK"": 0.0667207,. ""H1_ProbPi"": 0.685733,. ""H1_Charge"": 1,. ""H1_IPChi2"": 21.3981,. ""H1_isMuon"": 0,. ""H2_PX"": 382.38,. ""H2_PY"": 114.052,. ""H2_PZ"": 6374.15,. ""H2_ProbK"": 0.142381,. ""H2_ProbPi"": 0.906743,. ""H2_Charge"": -1,. ""H2_IPChi2"": 351.338,. ""H2_isMuon"": 0,. ""H3_PX"": -1151.69,. ""H3_PY"": -2406.64,. ""H3_PZ"": 33660.3,. ""H3_ProbK"": 0.946793,. ""H3_ProbPi"": 0.0687876,. ""H3_Charge"": -1,. ""H3_IPChi2"": 587.399,. ""H3_isMuon"": 0. }. ```. ```json. {. ""Muon_pt"": [3.59005, 4.19566],. ""Muon_eta"": [-2.13241, -2.19689],. ""Muon_phi"": [-2.98745, 0.425593],. ""Muon_mass"": [0.105658, 0.105658],. ""Muon_charge"": [-1, -1],. ""nMuon"": 2,. ""run"": 167674,. ""luminosityBlock"": 209. }. ```. There are more examples in `ntpl001_staff.C` and `ntpl002_vector.C` tutorials and in the `ntuple_print` unit test.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4847
https://github.com/root-project/root/pull/4847:1072,testability,test,test,1072,"@pcanal For instance. ```json. {. ""vpx"": [0.208788, -1.70924, 0.955477, 0.162738, 1.77392, -0.243316, -0.857411, 0.714772, 1.05418, -0.153219, -0.366184]. }. ```. ```json. {. ""B_FlightDistance"": 14.4299,. ""B_VertexChi2"": 10.295,. ""H1_PX"": -318.158,. ""H1_PY"": -6407.68,. ""H1_PZ"": 152900,. ""H1_ProbK"": 0.0667207,. ""H1_ProbPi"": 0.685733,. ""H1_Charge"": 1,. ""H1_IPChi2"": 21.3981,. ""H1_isMuon"": 0,. ""H2_PX"": 382.38,. ""H2_PY"": 114.052,. ""H2_PZ"": 6374.15,. ""H2_ProbK"": 0.142381,. ""H2_ProbPi"": 0.906743,. ""H2_Charge"": -1,. ""H2_IPChi2"": 351.338,. ""H2_isMuon"": 0,. ""H3_PX"": -1151.69,. ""H3_PY"": -2406.64,. ""H3_PZ"": 33660.3,. ""H3_ProbK"": 0.946793,. ""H3_ProbPi"": 0.0687876,. ""H3_Charge"": -1,. ""H3_IPChi2"": 587.399,. ""H3_isMuon"": 0. }. ```. ```json. {. ""Muon_pt"": [3.59005, 4.19566],. ""Muon_eta"": [-2.13241, -2.19689],. ""Muon_phi"": [-2.98745, 0.425593],. ""Muon_mass"": [0.105658, 0.105658],. ""Muon_charge"": [-1, -1],. ""nMuon"": 2,. ""run"": 167674,. ""luminosityBlock"": 209. }. ```. There are more examples in `ntpl001_staff.C` and `ntpl002_vector.C` tutorials and in the `ntuple_print` unit test.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4847
https://github.com/root-project/root/pull/4850:23,safety,test,test,23,Put the fix before the test so that we don't have a broken commit on master.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4850
https://github.com/root-project/root/pull/4850:23,testability,test,test,23,Put the fix before the test so that we don't have a broken commit on master.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4850
https://github.com/root-project/root/pull/4850:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4850
https://github.com/root-project/root/pull/4850:11,deployability,build,build,11,@phsft-bot build,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4850
https://github.com/root-project/root/pull/4850:23,safety,input,input,23,@bluehood @pcanal Your input is requested on jira ;) -> https://sft.its.cern.ch/jira/browse/ROOT-10527,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4850
https://github.com/root-project/root/pull/4850:23,usability,input,input,23,@bluehood @pcanal Your input is requested on jira ;) -> https://sft.its.cern.ch/jira/browse/ROOT-10527,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4850
https://github.com/root-project/root/pull/4850:45,availability,error,error,45,OOM on fed29 and the pcanal-v6-18-00-patches error should be fixed,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4850
https://github.com/root-project/root/pull/4850:37,deployability,patch,patches,37,OOM on fed29 and the pcanal-v6-18-00-patches error should be fixed,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4850
https://github.com/root-project/root/pull/4850:45,performance,error,error,45,OOM on fed29 and the pcanal-v6-18-00-patches error should be fixed,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4850
https://github.com/root-project/root/pull/4850:37,safety,patch,patches,37,OOM on fed29 and the pcanal-v6-18-00-patches error should be fixed,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4850
https://github.com/root-project/root/pull/4850:45,safety,error,error,45,OOM on fed29 and the pcanal-v6-18-00-patches error should be fixed,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4850
https://github.com/root-project/root/pull/4850:37,security,patch,patches,37,OOM on fed29 and the pcanal-v6-18-00-patches error should be fixed,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4850
https://github.com/root-project/root/pull/4850:45,usability,error,error,45,OOM on fed29 and the pcanal-v6-18-00-patches error should be fixed,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4850
https://github.com/root-project/root/pull/4850:36,deployability,log,logic,36,"The issue is that with changing the logic of `IsContainer` excluding `std::string`, the `FillHelper` of `RDataFrame::Histo1D` does not support `std::string` anymore.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4850
https://github.com/root-project/root/pull/4850:126,reliability,doe,does,126,"The issue is that with changing the logic of `IsContainer` excluding `std::string`, the `FillHelper` of `RDataFrame::Histo1D` does not support `std::string` anymore.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4850
https://github.com/root-project/root/pull/4850:36,safety,log,logic,36,"The issue is that with changing the logic of `IsContainer` excluding `std::string`, the `FillHelper` of `RDataFrame::Histo1D` does not support `std::string` anymore.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4850
https://github.com/root-project/root/pull/4850:36,security,log,logic,36,"The issue is that with changing the logic of `IsContainer` excluding `std::string`, the `FillHelper` of `RDataFrame::Histo1D` does not support `std::string` anymore.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4850
https://github.com/root-project/root/pull/4850:36,testability,log,logic,36,"The issue is that with changing the logic of `IsContainer` excluding `std::string`, the `FillHelper` of `RDataFrame::Histo1D` does not support `std::string` anymore.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4850
https://github.com/root-project/root/pull/4850:135,usability,support,support,135,"The issue is that with changing the logic of `IsContainer` excluding `std::string`, the `FillHelper` of `RDataFrame::Histo1D` does not support `std::string` anymore.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4850
https://github.com/root-project/root/pull/4850:84,deployability,log,logic,84,So we could specialize on the level of the `FillHelper` or retain the `IsContainer` logic in addition to the `IsDataContainer` trait.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4850
https://github.com/root-project/root/pull/4850:84,safety,log,logic,84,So we could specialize on the level of the `FillHelper` or retain the `IsContainer` logic in addition to the `IsDataContainer` trait.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4850
https://github.com/root-project/root/pull/4850:84,security,log,logic,84,So we could specialize on the level of the `FillHelper` or retain the `IsContainer` logic in addition to the `IsDataContainer` trait.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4850
https://github.com/root-project/root/pull/4850:84,testability,log,logic,84,So we could specialize on the level of the `FillHelper` or retain the `IsContainer` logic in addition to the `IsDataContainer` trait.,MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4850
https://github.com/root-project/root/pull/4850:133,availability,error,error,133,"@bluehood Do we want to support filling a histogram with the characters of a `std::string`? I could also just make some compile time error, that we don't support filling histograms from `std::string`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4850
https://github.com/root-project/root/pull/4850:128,performance,time,time,128,"@bluehood Do we want to support filling a histogram with the characters of a `std::string`? I could also just make some compile time error, that we don't support filling histograms from `std::string`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4850
https://github.com/root-project/root/pull/4850:133,performance,error,error,133,"@bluehood Do we want to support filling a histogram with the characters of a `std::string`? I could also just make some compile time error, that we don't support filling histograms from `std::string`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4850
https://github.com/root-project/root/pull/4850:133,safety,error,error,133,"@bluehood Do we want to support filling a histogram with the characters of a `std::string`? I could also just make some compile time error, that we don't support filling histograms from `std::string`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4850
https://github.com/root-project/root/pull/4850:24,usability,support,support,24,"@bluehood Do we want to support filling a histogram with the characters of a `std::string`? I could also just make some compile time error, that we don't support filling histograms from `std::string`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4850
https://github.com/root-project/root/pull/4850:133,usability,error,error,133,"@bluehood Do we want to support filling a histogram with the characters of a `std::string`? I could also just make some compile time error, that we don't support filling histograms from `std::string`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4850
https://github.com/root-project/root/pull/4850:154,usability,support,support,154,"@bluehood Do we want to support filling a histogram with the characters of a `std::string`? I could also just make some compile time error, that we don't support filling histograms from `std::string`.",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4850
https://github.com/root-project/root/pull/4850:148,deployability,version,version,148,"The question is rather whether we want to _stop_ supporting it. I realize that it's not a very useful feature, but why change the behavior from one version to the other if we don't have to? > then it looks uglier than before. It's just an extra `||`. Even if we want to disable filling histograms with std::strings, that will require extra code (e.g. an extra template specialization). With this said, I would accept either solution. Let's try to fix the original bug without expanding the scope of this PR further though :D",MatchSource.ISSUE_COMMENT,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/4850
